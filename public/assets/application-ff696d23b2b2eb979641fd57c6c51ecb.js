(function(definition){if(typeof define=="function"){define(definition)}else if(typeof YUI=="function"){YUI.add("es5",definition)}else{definition()}})(function(){function Empty(){}if(!Function.prototype.bind){Function.prototype.bind=function bind(that){var target=this;if(typeof target!="function"){throw new TypeError("Function.prototype.bind called on incompatible "+target)}var args=_Array_slice_.call(arguments,1);var bound=function(){if(this instanceof bound){var result=target.apply(this,args.concat(_Array_slice_.call(arguments)));if(Object(result)===result){return result}return this}else{return target.apply(that,args.concat(_Array_slice_.call(arguments)))}};if(target.prototype){Empty.prototype=target.prototype;bound.prototype=new Empty;Empty.prototype=null}return bound}}var call=Function.prototype.call;var prototypeOfArray=Array.prototype;var prototypeOfObject=Object.prototype;var _Array_slice_=prototypeOfArray.slice;var _toString=call.bind(prototypeOfObject.toString);var owns=call.bind(prototypeOfObject.hasOwnProperty);var defineGetter;var defineSetter;var lookupGetter;var lookupSetter;var supportsAccessors;if(supportsAccessors=owns(prototypeOfObject,"__defineGetter__")){defineGetter=call.bind(prototypeOfObject.__defineGetter__);defineSetter=call.bind(prototypeOfObject.__defineSetter__);lookupGetter=call.bind(prototypeOfObject.__lookupGetter__);lookupSetter=call.bind(prototypeOfObject.__lookupSetter__)}if([1,2].splice(0).length!=2){var array_splice=Array.prototype.splice;if(function(){function makeArray(l){var a=[];while(l--){a.unshift(l)}return a}var array=[],lengthBefore;array.splice.bind(array,0,0).apply(null,makeArray(20));array.splice.bind(array,0,0).apply(null,makeArray(26));lengthBefore=array.length;array.splice(5,0,"XXX");if(lengthBefore+1==array.length){return true}}()){Array.prototype.splice=function(start,deleteCount){if(!arguments.length){return[]}else{return array_splice.apply(this,[start===void 0?0:start,deleteCount===void 0?this.length-start:deleteCount].concat(_Array_slice_.call(arguments,2)))}}}else{Array.prototype.splice=function(start,deleteCount){var result,args=_Array_slice_.call(arguments,2),addElementsCount=args.length;if(!arguments.length){return[]}if(start===void 0){start=0}if(deleteCount===void 0){deleteCount=this.length-start}if(addElementsCount>0){if(deleteCount<=0){if(start==this.length){this.push.apply(this,args);return[]}if(start==0){this.unshift.apply(this,args);return[]}}result=_Array_slice_.call(this,start,start+deleteCount);args.push.apply(args,_Array_slice_.call(this,start+deleteCount,this.length));args.unshift.apply(args,_Array_slice_.call(this,0,start));args.unshift(0,this.length);array_splice.apply(this,args);return result}return array_splice.call(this,start,deleteCount)}}}if([].unshift(0)!=1){var array_unshift=Array.prototype.unshift;Array.prototype.unshift=function(){array_unshift.apply(this,arguments);return this.length}}if(!Array.isArray){Array.isArray=function isArray(obj){return _toString(obj)=="[object Array]"}}var boxedString=Object("a"),splitString=boxedString[0]!="a"||!(0 in boxedString);if(!Array.prototype.forEach){Array.prototype.forEach=function forEach(fun){var object=toObject(this),self=splitString&&_toString(this)=="[object String]"?this.split(""):object,thisp=arguments[1],i=-1,length=self.length>>>0;if(_toString(fun)!="[object Function]"){throw new TypeError}while(++i<length){if(i in self){fun.call(thisp,self[i],i,object)}}}}if(!Array.prototype.map){Array.prototype.map=function map(fun){var object=toObject(this),self=splitString&&_toString(this)=="[object String]"?this.split(""):object,length=self.length>>>0,result=Array(length),thisp=arguments[1];if(_toString(fun)!="[object Function]"){throw new TypeError(fun+" is not a function")}for(var i=0;i<length;i++){if(i in self)result[i]=fun.call(thisp,self[i],i,object)}return result}}if(!Array.prototype.filter){Array.prototype.filter=function filter(fun){var object=toObject(this),self=splitString&&_toString(this)=="[object String]"?this.split(""):object,length=self.length>>>0,result=[],value,thisp=arguments[1];if(_toString(fun)!="[object Function]"){throw new TypeError(fun+" is not a function")}for(var i=0;i<length;i++){if(i in self){value=self[i];if(fun.call(thisp,value,i,object)){result.push(value)}}}return result}}if(!Array.prototype.every){Array.prototype.every=function every(fun){var object=toObject(this),self=splitString&&_toString(this)=="[object String]"?this.split(""):object,length=self.length>>>0,thisp=arguments[1];if(_toString(fun)!="[object Function]"){throw new TypeError(fun+" is not a function")}for(var i=0;i<length;i++){if(i in self&&!fun.call(thisp,self[i],i,object)){return false}}return true}}if(!Array.prototype.some){Array.prototype.some=function some(fun){var object=toObject(this),self=splitString&&_toString(this)=="[object String]"?this.split(""):object,length=self.length>>>0,thisp=arguments[1];if(_toString(fun)!="[object Function]"){throw new TypeError(fun+" is not a function")}for(var i=0;i<length;i++){if(i in self&&fun.call(thisp,self[i],i,object)){return true}}return false}}if(!Array.prototype.reduce){Array.prototype.reduce=function reduce(fun){var object=toObject(this),self=splitString&&_toString(this)=="[object String]"?this.split(""):object,length=self.length>>>0;if(_toString(fun)!="[object Function]"){throw new TypeError(fun+" is not a function")}if(!length&&arguments.length==1){throw new TypeError("reduce of empty array with no initial value")}var i=0;var result;if(arguments.length>=2){result=arguments[1]}else{do{if(i in self){result=self[i++];break}if(++i>=length){throw new TypeError("reduce of empty array with no initial value")}}while(true)}for(;i<length;i++){if(i in self){result=fun.call(void 0,result,self[i],i,object)}}return result}}if(!Array.prototype.reduceRight){Array.prototype.reduceRight=function reduceRight(fun){var object=toObject(this),self=splitString&&_toString(this)=="[object String]"?this.split(""):object,length=self.length>>>0;if(_toString(fun)!="[object Function]"){throw new TypeError(fun+" is not a function")}if(!length&&arguments.length==1){throw new TypeError("reduceRight of empty array with no initial value")}var result,i=length-1;if(arguments.length>=2){result=arguments[1]}else{do{if(i in self){result=self[i--];break}if(--i<0){throw new TypeError("reduceRight of empty array with no initial value")}}while(true)}if(i<0){return result}do{if(i in this){result=fun.call(void 0,result,self[i],i,object)}}while(i--);return result}}if(!Array.prototype.indexOf||[0,1].indexOf(1,2)!=-1){Array.prototype.indexOf=function indexOf(sought){var self=splitString&&_toString(this)=="[object String]"?this.split(""):toObject(this),length=self.length>>>0;if(!length){return-1}var i=0;if(arguments.length>1){i=toInteger(arguments[1])}i=i>=0?i:Math.max(0,length+i);for(;i<length;i++){if(i in self&&self[i]===sought){return i}}return-1}}if(!Array.prototype.lastIndexOf||[0,1].lastIndexOf(0,-3)!=-1){Array.prototype.lastIndexOf=function lastIndexOf(sought){var self=splitString&&_toString(this)=="[object String]"?this.split(""):toObject(this),length=self.length>>>0;if(!length){return-1}var i=length-1;if(arguments.length>1){i=Math.min(i,toInteger(arguments[1]))}i=i>=0?i:length-Math.abs(i);for(;i>=0;i--){if(i in self&&sought===self[i]){return i}}return-1}}if(!Object.keys){var hasDontEnumBug=true,dontEnums=["toString","toLocaleString","valueOf","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","constructor"],dontEnumsLength=dontEnums.length;for(var key in{toString:null}){hasDontEnumBug=false}Object.keys=function keys(object){if(typeof object!="object"&&typeof object!="function"||object===null){throw new TypeError("Object.keys called on a non-object")}var keys=[];for(var name in object){if(owns(object,name)){keys.push(name)}}if(hasDontEnumBug){for(var i=0,ii=dontEnumsLength;i<ii;i++){var dontEnum=dontEnums[i];if(owns(object,dontEnum)){keys.push(dontEnum)}}}return keys}}var negativeDate=-621987552e5,negativeYearString="-000001";if(!Date.prototype.toISOString||new Date(negativeDate).toISOString().indexOf(negativeYearString)===-1){Date.prototype.toISOString=function toISOString(){var result,length,value,year,month;if(!isFinite(this)){throw new RangeError("Date.prototype.toISOString called on non-finite value.")}year=this.getUTCFullYear();month=this.getUTCMonth();year+=Math.floor(month/12);month=(month%12+12)%12;result=[month+1,this.getUTCDate(),this.getUTCHours(),this.getUTCMinutes(),this.getUTCSeconds()];year=(year<0?"-":year>9999?"+":"")+("00000"+Math.abs(year)).slice(0<=year&&year<=9999?-4:-6);length=result.length;while(length--){value=result[length];if(value<10){result[length]="0"+value}}return year+"-"+result.slice(0,2).join("-")+"T"+result.slice(2).join(":")+"."+("000"+this.getUTCMilliseconds()).slice(-3)+"Z"}}var dateToJSONIsSupported=false;try{dateToJSONIsSupported=Date.prototype.toJSON&&new Date(NaN).toJSON()===null&&new Date(negativeDate).toJSON().indexOf(negativeYearString)!==-1&&Date.prototype.toJSON.call({toISOString:function(){return true}})}catch(e){}if(!dateToJSONIsSupported){Date.prototype.toJSON=function toJSON(key){var o=Object(this),tv=toPrimitive(o),toISO;if(typeof tv==="number"&&!isFinite(tv)){return null}toISO=o.toISOString;if(typeof toISO!="function"){throw new TypeError("toISOString property is not callable")}return toISO.call(o)}}if(!Date.parse||"Date.parse is buggy"){Date=function(NativeDate){function Date(Y,M,D,h,m,s,ms){var length=arguments.length;if(this instanceof NativeDate){var date=length==1&&String(Y)===Y?new NativeDate(Date.parse(Y)):length>=7?new NativeDate(Y,M,D,h,m,s,ms):length>=6?new NativeDate(Y,M,D,h,m,s):length>=5?new NativeDate(Y,M,D,h,m):length>=4?new NativeDate(Y,M,D,h):length>=3?new NativeDate(Y,M,D):length>=2?new NativeDate(Y,M):length>=1?new NativeDate(Y):new NativeDate;date.constructor=Date;return date}return NativeDate.apply(this,arguments)}var isoDateExpression=new RegExp("^"+"(\\d{4}|[+-]\\d{6})"+"(?:-(\\d{2})"+"(?:-(\\d{2})"+"(?:"+"T(\\d{2})"+":(\\d{2})"+"(?:"+":(\\d{2})"+"(?:(\\.\\d{1,}))?"+")?"+"("+"Z|"+"(?:"+"([-+])"+"(\\d{2})"+":(\\d{2})"+")"+")?)?)?)?"+"$");var months=[0,31,59,90,120,151,181,212,243,273,304,334,365];function dayFromMonth(year,month){var t=month>1?1:0;return months[month]+Math.floor((year-1969+t)/4)-Math.floor((year-1901+t)/100)+Math.floor((year-1601+t)/400)+365*(year-1970)}for(var key in NativeDate){Date[key]=NativeDate[key]}Date.now=NativeDate.now;Date.UTC=NativeDate.UTC;Date.prototype=NativeDate.prototype;Date.prototype.constructor=Date;Date.parse=function parse(string){var match=isoDateExpression.exec(string);if(match){var year=Number(match[1]),month=Number(match[2]||1)-1,day=Number(match[3]||1)-1,hour=Number(match[4]||0),minute=Number(match[5]||0),second=Number(match[6]||0),millisecond=Math.floor(Number(match[7]||0)*1e3),offset=!match[4]||match[8]?0:Number(new NativeDate(1970,0)),signOffset=match[9]==="-"?1:-1,hourOffset=Number(match[10]||0),minuteOffset=Number(match[11]||0),result;if(hour<(minute>0||second>0||millisecond>0?24:25)&&minute<60&&second<60&&millisecond<1e3&&month>-1&&month<12&&hourOffset<24&&minuteOffset<60&&day>-1&&day<dayFromMonth(year,month+1)-dayFromMonth(year,month)){result=((dayFromMonth(year,month)+day)*24+hour+hourOffset*signOffset)*60;result=((result+minute+minuteOffset*signOffset)*60+second)*1e3+millisecond+offset;if(-864e13<=result&&result<=864e13){return result}}return NaN}return NativeDate.parse.apply(this,arguments)};return Date}(Date)}if(!Date.now){Date.now=function now(){return(new Date).getTime()}}if(!Number.prototype.toFixed||8e-5.toFixed(3)!=="0.000"||.9.toFixed(0)==="0"||1.255.toFixed(2)!=="1.25"||0xde0b6b3a7640080.toFixed(0)!=="1000000000000000128"){(function(){var base,size,data,i;base=1e7;size=6;data=[0,0,0,0,0,0];function multiply(n,c){var i=-1;while(++i<size){c+=n*data[i];data[i]=c%base;c=Math.floor(c/base)}}function divide(n){var i=size,c=0;while(--i>=0){c+=data[i];data[i]=Math.floor(c/n);c=c%n*base}}function toString(){var i=size;var s="";while(--i>=0){if(s!==""||i===0||data[i]!==0){var t=String(data[i]);if(s===""){s=t}else{s+="0000000".slice(0,7-t.length)+t}}}return s}function pow(x,n,acc){return n===0?acc:n%2===1?pow(x,n-1,acc*x):pow(x*x,n/2,acc)}function log(x){var n=0;while(x>=4096){n+=12;x/=4096}while(x>=2){n+=1;x/=2}return n}Number.prototype.toFixed=function(fractionDigits){var f,x,s,m,e,z,j,k;f=Number(fractionDigits);f=f!==f?0:Math.floor(f);if(f<0||f>20){throw new RangeError("Number.toFixed called with invalid number of decimals")}x=Number(this);if(x!==x){return"NaN"}if(x<=-1e21||x>=1e21){return String(x)}s="";if(x<0){s="-";x=-x}m="0";if(x>1e-21){e=log(x*pow(2,69,1))-69;z=e<0?x*pow(2,-e,1):x/pow(2,e,1);z*=4503599627370496;e=52-e;if(e>0){multiply(0,z);j=f;while(j>=7){multiply(1e7,0);j-=7}multiply(pow(10,j,1),0);j=e-1;while(j>=23){divide(1<<23);j-=23}divide(1<<j);multiply(1,1);divide(2);m=toString()}else{multiply(0,z);multiply(1<<-e,0);m=toString()+"0.00000000000000000000".slice(2,2+f)}}if(f>0){k=m.length;if(k<=f){m=s+"0.0000000000000000000".slice(0,f-k+2)+m}else{m=s+m.slice(0,k-f)+"."+m.slice(k-f)}}else{m=s+m}return m}})()}var string_split=String.prototype.split;if("ab".split(/(?:ab)*/).length!==2||".".split(/(.?)(.?)/).length!==4||"tesst".split(/(s)*/)[1]==="t"||"".split(/.?/).length===0||".".split(/()()/).length>1){(function(){var compliantExecNpcg=/()??/.exec("")[1]===void 0;String.prototype.split=function(separator,limit){var string=this;if(separator===void 0&&limit===0)return[];if(Object.prototype.toString.call(separator)!=="[object RegExp]"){return string_split.apply(this,arguments)}var output=[],flags=(separator.ignoreCase?"i":"")+(separator.multiline?"m":"")+(separator.extended?"x":"")+(separator.sticky?"y":""),lastLastIndex=0,separator=new RegExp(separator.source,flags+"g"),separator2,match,lastIndex,lastLength;string+="";if(!compliantExecNpcg){separator2=new RegExp("^"+separator.source+"$(?!\\s)",flags)}limit=limit===void 0?-1>>>0:limit>>>0;while(match=separator.exec(string)){lastIndex=match.index+match[0].length;if(lastIndex>lastLastIndex){output.push(string.slice(lastLastIndex,match.index));if(!compliantExecNpcg&&match.length>1){match[0].replace(separator2,function(){for(var i=1;i<arguments.length-2;i++){if(arguments[i]===void 0){match[i]=void 0}}})}if(match.length>1&&match.index<string.length){Array.prototype.push.apply(output,match.slice(1))}lastLength=match[0].length;lastLastIndex=lastIndex;if(output.length>=limit){break}}if(separator.lastIndex===match.index){separator.lastIndex++}}if(lastLastIndex===string.length){if(lastLength||!separator.test("")){output.push("")}}else{output.push(string.slice(lastLastIndex))}return output.length>limit?output.slice(0,limit):output}})()}else if("0".split(void 0,0).length){String.prototype.split=function(separator,limit){if(separator===void 0&&limit===0)return[];return string_split.apply(this,arguments)}}if("".substr&&"0b".substr(-1)!=="b"){var string_substr=String.prototype.substr;String.prototype.substr=function(start,length){return string_substr.call(this,start<0?(start=this.length+start)<0?0:start:start,length)}}var ws="	\n\f\r \xa0\u1680\u180e\u2000\u2001\u2002\u2003"+"\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028"+"\u2029\ufeff";if(!String.prototype.trim||ws.trim()){ws="["+ws+"]";var trimBeginRegexp=new RegExp("^"+ws+ws+"*"),trimEndRegexp=new RegExp(ws+ws+"*$");String.prototype.trim=function trim(){if(this===void 0||this===null){throw new TypeError("can't convert "+this+" to object")}return String(this).replace(trimBeginRegexp,"").replace(trimEndRegexp,"")}}function toInteger(n){n=+n;if(n!==n){n=0}else if(n!==0&&n!==1/0&&n!==-(1/0)){n=(n>0||-1)*Math.floor(Math.abs(n))}return n}function isPrimitive(input){var type=typeof input;return input===null||type==="undefined"||type==="boolean"||type==="number"||type==="string"}function toPrimitive(input){var val,valueOf,toString;if(isPrimitive(input)){return input}valueOf=input.valueOf;if(typeof valueOf==="function"){val=valueOf.call(input);if(isPrimitive(val)){return val}}toString=input.toString;if(typeof toString==="function"){val=toString.call(input);if(isPrimitive(val)){return val}}throw new TypeError}var toObject=function(o){if(o==null){throw new TypeError("can't convert "+o+" to object")}return Object(o)}});
(function(definition){if(typeof define=="function"){define(definition)}else if(typeof YUI=="function"){YUI.add("es5-sham",definition)}else{definition()}})(function(){var call=Function.prototype.call;var prototypeOfObject=Object.prototype;var owns=call.bind(prototypeOfObject.hasOwnProperty);var defineGetter;var defineSetter;var lookupGetter;var lookupSetter;var supportsAccessors;if(supportsAccessors=owns(prototypeOfObject,"__defineGetter__")){defineGetter=call.bind(prototypeOfObject.__defineGetter__);defineSetter=call.bind(prototypeOfObject.__defineSetter__);lookupGetter=call.bind(prototypeOfObject.__lookupGetter__);lookupSetter=call.bind(prototypeOfObject.__lookupSetter__)}if(!Object.getPrototypeOf){Object.getPrototypeOf=function getPrototypeOf(object){return object.__proto__||(object.constructor?object.constructor.prototype:prototypeOfObject)}}function doesGetOwnPropertyDescriptorWork(object){try{object.sentinel=0;return Object.getOwnPropertyDescriptor(object,"sentinel").value===0}catch(exception){}}if(Object.defineProperty){var getOwnPropertyDescriptorWorksOnObject=doesGetOwnPropertyDescriptorWork({});var getOwnPropertyDescriptorWorksOnDom=typeof document=="undefined"||doesGetOwnPropertyDescriptorWork(document.createElement("div"));if(!getOwnPropertyDescriptorWorksOnDom||!getOwnPropertyDescriptorWorksOnObject){var getOwnPropertyDescriptorFallback=Object.getOwnPropertyDescriptor}}if(!Object.getOwnPropertyDescriptor||getOwnPropertyDescriptorFallback){var ERR_NON_OBJECT="Object.getOwnPropertyDescriptor called on a non-object: ";Object.getOwnPropertyDescriptor=function getOwnPropertyDescriptor(object,property){if(typeof object!="object"&&typeof object!="function"||object===null){throw new TypeError(ERR_NON_OBJECT+object)}if(getOwnPropertyDescriptorFallback){try{return getOwnPropertyDescriptorFallback.call(Object,object,property)}catch(exception){}}if(!owns(object,property)){return}var descriptor={enumerable:true,configurable:true};if(supportsAccessors){var prototype=object.__proto__;object.__proto__=prototypeOfObject;var getter=lookupGetter(object,property);var setter=lookupSetter(object,property);object.__proto__=prototype;if(getter||setter){if(getter){descriptor.get=getter}if(setter){descriptor.set=setter}return descriptor}}descriptor.value=object[property];descriptor.writable=true;return descriptor}}if(!Object.getOwnPropertyNames){Object.getOwnPropertyNames=function getOwnPropertyNames(object){return Object.keys(object)}}if(!Object.create){var createEmpty;var supportsProto=Object.prototype.__proto__===null;if(supportsProto||typeof document=="undefined"){createEmpty=function(){return{__proto__:null}}}else{createEmpty=function(){var iframe=document.createElement("iframe");var parent=document.body||document.documentElement;iframe.style.display="none";parent.appendChild(iframe);iframe.src="javascript:";var empty=iframe.contentWindow.Object.prototype;parent.removeChild(iframe);iframe=null;delete empty.constructor;delete empty.hasOwnProperty;delete empty.propertyIsEnumerable;delete empty.isPrototypeOf;delete empty.toLocaleString;delete empty.toString;delete empty.valueOf;empty.__proto__=null;function Empty(){}Empty.prototype=empty;createEmpty=function(){return new Empty};return new Empty}}Object.create=function create(prototype,properties){var object;function Type(){}if(prototype===null){object=createEmpty()}else{if(typeof prototype!=="object"&&typeof prototype!=="function"){throw new TypeError("Object prototype may only be an Object or null")}Type.prototype=prototype;object=new Type;object.__proto__=prototype}if(properties!==void 0){Object.defineProperties(object,properties)}return object}}function doesDefinePropertyWork(object){try{Object.defineProperty(object,"sentinel",{});return"sentinel"in object}catch(exception){}}if(Object.defineProperty){var definePropertyWorksOnObject=doesDefinePropertyWork({});var definePropertyWorksOnDom=typeof document=="undefined"||doesDefinePropertyWork(document.createElement("div"));if(!definePropertyWorksOnObject||!definePropertyWorksOnDom){var definePropertyFallback=Object.defineProperty,definePropertiesFallback=Object.defineProperties}}if(!Object.defineProperty||definePropertyFallback){var ERR_NON_OBJECT_DESCRIPTOR="Property description must be an object: ";var ERR_NON_OBJECT_TARGET="Object.defineProperty called on non-object: ";var ERR_ACCESSORS_NOT_SUPPORTED="getters & setters can not be defined "+"on this javascript engine";Object.defineProperty=function defineProperty(object,property,descriptor){if(typeof object!="object"&&typeof object!="function"||object===null){throw new TypeError(ERR_NON_OBJECT_TARGET+object)}if(typeof descriptor!="object"&&typeof descriptor!="function"||descriptor===null){throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR+descriptor)}if(definePropertyFallback){try{return definePropertyFallback.call(Object,object,property,descriptor)}catch(exception){}}if(owns(descriptor,"value")){if(supportsAccessors&&(lookupGetter(object,property)||lookupSetter(object,property))){var prototype=object.__proto__;object.__proto__=prototypeOfObject;delete object[property];object[property]=descriptor.value;object.__proto__=prototype}else{object[property]=descriptor.value}}else{if(!supportsAccessors){throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED)}if(owns(descriptor,"get")){defineGetter(object,property,descriptor.get)}if(owns(descriptor,"set")){defineSetter(object,property,descriptor.set)}}return object}}if(!Object.defineProperties||definePropertiesFallback){Object.defineProperties=function defineProperties(object,properties){if(definePropertiesFallback){try{return definePropertiesFallback.call(Object,object,properties)}catch(exception){}}for(var property in properties){if(owns(properties,property)&&property!="__proto__"){Object.defineProperty(object,property,properties[property])}}return object}}if(!Object.seal){Object.seal=function seal(object){return object}}if(!Object.freeze){Object.freeze=function freeze(object){return object}}try{Object.freeze(function(){})}catch(exception){Object.freeze=function freeze(freezeObject){return function freeze(object){if(typeof object=="function"){return object}else{return freezeObject(object)}}}(Object.freeze)}if(!Object.preventExtensions){Object.preventExtensions=function preventExtensions(object){return object}}if(!Object.isSealed){Object.isSealed=function isSealed(object){return false}}if(!Object.isFrozen){Object.isFrozen=function isFrozen(object){return false}}if(!Object.isExtensible){Object.isExtensible=function isExtensible(object){if(Object(object)!==object){throw new TypeError}var name="";while(owns(object,name)){name+="?"}object[name]=true;var returnValue=owns(object,name);delete object[name];return returnValue}}});
/*!
 * jQuery JavaScript Library v1.11.0
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-01-23T21:02Z
 */


(function( global, factory ) {

	if ( typeof module === "object" && typeof module.exports === "object" ) {
		// For CommonJS and CommonJS-like environments where a proper window is present,
		// execute the factory and get jQuery
		// For environments that do not inherently posses a window with a document
		// (such as Node.js), expose a jQuery-making factory as module.exports
		// This accentuates the need for the creation of a real window
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Can't do this because several apps including ASP.NET trace
// the stack via arguments.caller.callee and Firefox dies if
// you try to trace through "use strict" call chains. (#13335)
// Support: Firefox 18+
//

var deletedIds = [];

var slice = deletedIds.slice;

var concat = deletedIds.concat;

var push = deletedIds.push;

var indexOf = deletedIds.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var trim = "".trim;

var support = {};



var
	version = "1.11.0",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Make sure we trim BOM and NBSP (here's looking at you, Safari 5.0 and IE)
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([\da-z])/gi,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	};

jQuery.fn = jQuery.prototype = {
	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// Start with an empty selector
	selector: "",

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num != null ?

			// Return a 'clean' array
			( num < 0 ? this[ num + this.length ] : this[ num ] ) :

			// Return just the object
			slice.call( this );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;
		ret.context = this.context;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.)
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
			return callback.call( elem, i, elem );
		}));
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor(null);
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: deletedIds.sort,
	splice: deletedIds.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var src, copyIsArray, copy, name, options, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
		target = {};
	}

	// extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray(src) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend({
	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	// See test/unit/core.js for details concerning isFunction.
	// Since version 1.3, DOM methods and functions like alert
	// aren't supported. They return false on IE (#2968).
	isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
	},

	isArray: Array.isArray || function( obj ) {
		return jQuery.type(obj) === "array";
	},

	isWindow: function( obj ) {
		/* jshint eqeqeq: false */
		return obj != null && obj == obj.window;
	},

	isNumeric: function( obj ) {
		// parseFloat NaNs numeric-cast false positives (null|true|false|"")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		return obj - parseFloat( obj ) >= 0;
	},

	isEmptyObject: function( obj ) {
		var name;
		for ( name in obj ) {
			return false;
		}
		return true;
	},

	isPlainObject: function( obj ) {
		var key;

		// Must be an Object.
		// Because of IE, we also have to check the presence of the constructor property.
		// Make sure that DOM nodes and window objects don't pass through, as well
		if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		try {
			// Not own constructor property must be Object
			if ( obj.constructor &&
				!hasOwn.call(obj, "constructor") &&
				!hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
				return false;
			}
		} catch ( e ) {
			// IE8,9 Will throw exceptions on certain host objects #9897
			return false;
		}

		// Support: IE<9
		// Handle iteration over inherited properties before own properties.
		if ( support.ownLast ) {
			for ( key in obj ) {
				return hasOwn.call( obj, key );
			}
		}

		// Own properties are enumerated firstly, so to speed up,
		// if last one is own, then all properties are own.
		for ( key in obj ) {}

		return key === undefined || hasOwn.call( obj, key );
	},

	type: function( obj ) {
		if ( obj == null ) {
			return obj + "";
		}
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ toString.call(obj) ] || "object" :
			typeof obj;
	},

	// Evaluates a script in a global context
	// Workarounds based on findings by Jim Driscoll
	// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
	globalEval: function( data ) {
		if ( data && jQuery.trim( data ) ) {
			// We use execScript on Internet Explorer
			// We use an anonymous function so that context is window
			// rather than jQuery in Firefox
			( window.execScript || function( data ) {
				window[ "eval" ].call( window, data );
			} )( data );
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	},

	// args is for internal usage only
	each: function( obj, callback, args ) {
		var value,
			i = 0,
			length = obj.length,
			isArray = isArraylike( obj );

		if ( args ) {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			}

		// A special, fast, case for the most common use of each
		} else {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			}
		}

		return obj;
	},

	// Use native String.trim function wherever possible
	trim: trim && !trim.call("\uFEFF\xA0") ?
		function( text ) {
			return text == null ?
				"" :
				trim.call( text );
		} :

		// Otherwise use our own trimming functionality
		function( text ) {
			return text == null ?
				"" :
				( text + "" ).replace( rtrim, "" );
		},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArraylike( Object(arr) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		var len;

		if ( arr ) {
			if ( indexOf ) {
				return indexOf.call( arr, elem, i );
			}

			len = arr.length;
			i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;

			for ( ; i < len; i++ ) {
				// Skip accessing in sparse arrays
				if ( i in arr && arr[ i ] === elem ) {
					return i;
				}
			}
		}

		return -1;
	},

	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		while ( j < len ) {
			first[ i++ ] = second[ j++ ];
		}

		// Support: IE<9
		// Workaround casting of .length to NaN on otherwise arraylike objects (e.g., NodeLists)
		if ( len !== len ) {
			while ( second[j] !== undefined ) {
				first[ i++ ] = second[ j++ ];
			}
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var value,
			i = 0,
			length = elems.length,
			isArray = isArraylike( elems ),
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArray ) {
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var args, proxy, tmp;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	now: function() {
		return +( new Date() );
	},

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
});

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

function isArraylike( obj ) {
	var length = obj.length,
		type = jQuery.type( obj );

	if ( type === "function" || jQuery.isWindow( obj ) ) {
		return false;
	}

	if ( obj.nodeType === 1 && length ) {
		return true;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v1.10.16
 * http://sizzlejs.com/
 *
 * Copyright 2013 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-01-13
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	compile,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + -(new Date()),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// General-purpose constants
	strundefined = typeof undefined,
	MAX_NEGATIVE = 1 << 31,

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf if we can't use a native one
	indexOf = arr.indexOf || function( elem ) {
		var i = 0,
			len = this.length;
		for ( ; i < len; i++ ) {
			if ( this[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",
	// http://www.w3.org/TR/css3-syntax/#characters
	characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

	// Loosely modeled on CSS identifier characters
	// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
	// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = characterEncoding.replace( "w", "w#" ),

	// Acceptable operators http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + characterEncoding + ")" + whitespace +
		"*(?:([*^$|!~]?=)" + whitespace + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + identifier + ")|)|)" + whitespace + "*\\]",

	// Prefer arguments quoted,
	//   then not containing pseudos/brackets,
	//   then attribute selectors/non-parenthetical expressions,
	//   then anything else
	// These preferences are here to reduce the number of selectors
	//   needing tokenize in the PSEUDO preFilter
	pseudos = ":(" + characterEncoding + ")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|" + attributes.replace( 3, 8 ) + ")*)|.*)\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + characterEncoding + ")" ),
		"CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
		"TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,
	rescape = /'|\\/g,

	// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	};

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var match, elem, m, nodeType,
		// QSA vars
		i, groups, old, nid, newContext, newSelector;

	if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
		setDocument( context );
	}

	context = context || document;
	results = results || [];

	if ( !selector || typeof selector !== "string" ) {
		return results;
	}

	if ( (nodeType = context.nodeType) !== 1 && nodeType !== 9 ) {
		return [];
	}

	if ( documentIsHTML && !seed ) {

		// Shortcuts
		if ( (match = rquickExpr.exec( selector )) ) {
			// Speed-up: Sizzle("#ID")
			if ( (m = match[1]) ) {
				if ( nodeType === 9 ) {
					elem = context.getElementById( m );
					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document (jQuery #6963)
					if ( elem && elem.parentNode ) {
						// Handle the case where IE, Opera, and Webkit return items
						// by name instead of ID
						if ( elem.id === m ) {
							results.push( elem );
							return results;
						}
					} else {
						return results;
					}
				} else {
					// Context is not a document
					if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
						contains( context, elem ) && elem.id === m ) {
						results.push( elem );
						return results;
					}
				}

			// Speed-up: Sizzle("TAG")
			} else if ( match[2] ) {
				push.apply( results, context.getElementsByTagName( selector ) );
				return results;

			// Speed-up: Sizzle(".CLASS")
			} else if ( (m = match[3]) && support.getElementsByClassName && context.getElementsByClassName ) {
				push.apply( results, context.getElementsByClassName( m ) );
				return results;
			}
		}

		// QSA path
		if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
			nid = old = expando;
			newContext = context;
			newSelector = nodeType === 9 && selector;

			// qSA works strangely on Element-rooted queries
			// We can work around this by specifying an extra ID on the root
			// and working up from there (Thanks to Andrew Dupont for the technique)
			// IE 8 doesn't work on object elements
			if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
				groups = tokenize( selector );

				if ( (old = context.getAttribute("id")) ) {
					nid = old.replace( rescape, "\\$&" );
				} else {
					context.setAttribute( "id", nid );
				}
				nid = "[id='" + nid + "'] ";

				i = groups.length;
				while ( i-- ) {
					groups[i] = nid + toSelector( groups[i] );
				}
				newContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;
				newSelector = groups.join(",");
			}

			if ( newSelector ) {
				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch(qsaError) {
				} finally {
					if ( !old ) {
						context.removeAttribute("id");
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created div and expects a boolean result
 */
function assert( fn ) {
	var div = document.createElement("div");

	try {
		return !!fn( div );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( div.parentNode ) {
			div.parentNode.removeChild( div );
		}
		// release memory in IE
		div = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = attrs.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			( ~b.sourceIndex || MAX_NEGATIVE ) -
			( ~a.sourceIndex || MAX_NEGATIVE );

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== strundefined && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare,
		doc = node ? node.ownerDocument || node : preferredDoc,
		parent = doc.defaultView;

	// If no document and documentElement is available, return
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Set our document
	document = doc;
	docElem = doc.documentElement;

	// Support tests
	documentIsHTML = !isXML( doc );

	// Support: IE>8
	// If iframe document is assigned to "document" variable and if iframe has been reloaded,
	// IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
	// IE6-8 do not support the defaultView property so parent will be undefined
	if ( parent && parent !== parent.top ) {
		// IE11 does not have attachEvent, so all must suffer
		if ( parent.addEventListener ) {
			parent.addEventListener( "unload", function() {
				setDocument();
			}, false );
		} else if ( parent.attachEvent ) {
			parent.attachEvent( "onunload", function() {
				setDocument();
			});
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties (excepting IE8 booleans)
	support.attributes = assert(function( div ) {
		div.className = "i";
		return !div.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( div ) {
		div.appendChild( doc.createComment("") );
		return !div.getElementsByTagName("*").length;
	});

	// Check if getElementsByClassName can be trusted
	support.getElementsByClassName = rnative.test( doc.getElementsByClassName ) && assert(function( div ) {
		div.innerHTML = "<div class='a'></div><div class='a i'></div>";

		// Support: Safari<4
		// Catch class over-caching
		div.firstChild.className = "i";
		// Support: Opera<10
		// Catch gEBCN failure to find non-leading classes
		return div.getElementsByClassName("i").length === 2;
	});

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( div ) {
		docElem.appendChild( div ).id = expando;
		return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
	});

	// ID find and filter
	if ( support.getById ) {
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== strundefined && documentIsHTML ) {
				var m = context.getElementById( id );
				// Check parentNode to catch when Blackberry 4.6 returns
				// nodes that are no longer in the document #6963
				return m && m.parentNode ? [m] : [];
			}
		};
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
	} else {
		// Support: IE6/7
		// getElementById is not reliable as a find shortcut
		delete Expr.find["ID"];

		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== strundefined ) {
				return context.getElementsByTagName( tag );
			}
		} :
		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== strundefined && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See http://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( div ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// http://bugs.jquery.com/ticket/12359
			div.innerHTML = "<select t=''><option selected=''></option></select>";

			// Support: IE8, Opera 10-12
			// Nothing should be selected when empty strings follow ^= or $= or *=
			if ( div.querySelectorAll("[t^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !div.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}
		});

		assert(function( div ) {
			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = doc.createElement("input");
			input.setAttribute( "type", "hidden" );
			div.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( div.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":enabled").length ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			div.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( div ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( div, "div" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( div, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully does not implement inclusive descendent
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === doc ? -1 :
				b === doc ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return doc;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch(e) {}
	}

	return Sizzle( expr, document, null, [elem] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[5] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] && match[4] !== undefined ) {
				match[2] = match[4];

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, outerCache, node, diff, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {
							// Seek `elem` from a previously-cached index
							outerCache = parent[ expando ] || (parent[ expando ] = {});
							cache = outerCache[ type ] || [];
							nodeIndex = cache[0] === dirruns && cache[1];
							diff = cache[0] === dirruns && cache[2];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									outerCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						// Use previously-cached element index if available
						} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
							diff = cache[1];

						// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
						} else {
							// Use the same loop as above to seek `elem` from the start
							while ( (node = ++nodeIndex && node && node[ dir ] ||
								(diff = nodeIndex = 0) || start.pop()) ) {

								if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
									// Cache the index of each encountered element
									if ( useCache ) {
										(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
									}

									if ( node === elem ) {
										break;
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf.call( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": function( elem ) {
			return elem.disabled === false;
		},

		"disabled": function( elem ) {
			return elem.disabled === true;
		},

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

function tokenize( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
}

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		checkNonElements = base && dir === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});
						if ( (oldCache = outerCache[ dir ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							outerCache[ dir ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf.call( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf.call( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			return ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context !== document && context;
			}

			// Add elements passing elementMatchers directly to results
			// Keep `i` a string if there are no elements so `matchedCount` will be "00" below
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context, xml ) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// Apply set filters to unmatched elements
			matchedCount += i;
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, group /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !group ) {
			group = tokenize( selector );
		}
		i = group.length;
		while ( i-- ) {
			cached = matcherFromTokens( group[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );
	}
	return cached;
};

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function select( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		match = tokenize( selector );

	if ( !seed ) {
		// Try to minimize operations if there is only one group
		if ( match.length === 1 ) {

			// Take a shortcut and set the context if the root selector is an ID
			tokens = match[0] = match[0].slice( 0 );
			if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
					support.getById && context.nodeType === 9 && documentIsHTML &&
					Expr.relative[ tokens[1].type ] ) {

				context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
				if ( !context ) {
					return results;
				}
				selector = selector.slice( tokens.shift().value.length );
			}

			// Fetch a seed set for right-to-left matching
			i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
			while ( i-- ) {
				token = tokens[i];

				// Abort if we hit a combinator
				if ( Expr.relative[ (type = token.type) ] ) {
					break;
				}
				if ( (find = Expr.find[ type ]) ) {
					// Search, expanding context for leading sibling combinators
					if ( (seed = find(
						token.matches[0].replace( runescape, funescape ),
						rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
					)) ) {

						// If seed is empty or no tokens remain, we can return early
						tokens.splice( i, 1 );
						selector = seed.length && toSelector( tokens );
						if ( !selector ) {
							push.apply( results, seed );
							return results;
						}

						break;
					}
				}
			}
		}
	}

	// Compile and execute a filtering function
	// Provide `match` to avoid retokenization if we modified the selector above
	compile( selector, match )(
		seed,
		context,
		!documentIsHTML,
		results,
		rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
}

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome<14
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( div1 ) {
	// Should return 1, but returns 4 (following)
	return div1.compareDocumentPosition( document.createElement("div") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( div ) {
	div.innerHTML = "<a href='#'></a>";
	return div.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( div ) {
	div.innerHTML = "<input/>";
	div.firstChild.setAttribute( "value", "" );
	return div.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( div ) {
	return div.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.pseudos;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;



var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);



var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			/* jshint -W018 */
			return !!qualifier.call( elem, i, elem ) !== not;
		});

	}

	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		});

	}

	if ( typeof qualifier === "string" ) {
		if ( risSimple.test( qualifier ) ) {
			return jQuery.filter( qualifier, elements, not );
		}

		qualifier = jQuery.filter( qualifier, elements );
	}

	return jQuery.grep( elements, function( elem ) {
		return ( jQuery.inArray( elem, qualifier ) >= 0 ) !== not;
	});
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	return elems.length === 1 && elem.nodeType === 1 ?
		jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
		jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
			return elem.nodeType === 1;
		}));
};

jQuery.fn.extend({
	find: function( selector ) {
		var i,
			ret = [],
			self = this,
			len = self.length;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter(function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			}) );
		}

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		// Needed because $( selector, context ) becomes $( context ).find( selector )
		ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
		ret.selector = this.selector ? this.selector + " " + selector : selector;
		return ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow(this, selector || [], false) );
	},
	not: function( selector ) {
		return this.pushStack( winnow(this, selector || [], true) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
});


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// Use the correct document accordingly with window argument (sandbox)
	document = window.document,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

	init = jQuery.fn.init = function( selector, context ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {
				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && (match[1] || !context) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[1] ) {
					context = context instanceof jQuery ? context[0] : context;

					// scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[1],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {
							// Properties of context are called as methods if possible
							if ( jQuery.isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[2] );

					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					if ( elem && elem.parentNode ) {
						// Handle the case where IE and Opera return items
						// by name instead of ID
						if ( elem.id !== match[2] ) {
							return rootjQuery.find( selector );
						}

						// Otherwise, we inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || rootjQuery ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return typeof rootjQuery.ready !== "undefined" ?
				rootjQuery.ready( selector ) :
				// Execute immediately if ready is not present
				selector( jQuery );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,
	// methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.extend({
	dir: function( elem, dir, until ) {
		var matched = [],
			cur = elem[ dir ];

		while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
			if ( cur.nodeType === 1 ) {
				matched.push( cur );
			}
			cur = cur[dir];
		}
		return matched;
	},

	sibling: function( n, elem ) {
		var r = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				r.push( n );
			}
		}

		return r;
	}
});

jQuery.fn.extend({
	has: function( target ) {
		var i,
			targets = jQuery( target, this ),
			len = targets.length;

		return this.filter(function() {
			for ( i = 0; i < len; i++ ) {
				if ( jQuery.contains( this, targets[i] ) ) {
					return true;
				}
			}
		});
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( ; i < l; i++ ) {
			for ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {
				// Always skip document fragments
				if ( cur.nodeType < 11 && (pos ?
					pos.index(cur) > -1 :

					// Don't pass non-elements to Sizzle
					cur.nodeType === 1 &&
						jQuery.find.matchesSelector(cur, selectors)) ) {

					matched.push( cur );
					break;
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );
	},

	// Determine the position of an element within
	// the matched set of elements
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[0] && this[0].parentNode ) ? this.first().prevAll().length : -1;
		}

		// index in selector
		if ( typeof elem === "string" ) {
			return jQuery.inArray( this[0], jQuery( elem ) );
		}

		// Locate the position of the desired element
		return jQuery.inArray(
			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[0] : elem, this );
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.unique(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter(selector)
		);
	}
});

function sibling( cur, dir ) {
	do {
		cur = cur[ dir ];
	} while ( cur && cur.nodeType !== 1 );

	return cur;
}

jQuery.each({
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return jQuery.dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return jQuery.dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return jQuery.dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return jQuery.sibling( elem.firstChild );
	},
	contents: function( elem ) {
		return jQuery.nodeName( elem, "iframe" ) ?
			elem.contentDocument || elem.contentWindow.document :
			jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var ret = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			ret = jQuery.filter( selector, ret );
		}

		if ( this.length > 1 ) {
			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				ret = jQuery.unique( ret );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				ret = ret.reverse();
			}
		}

		return this.pushStack( ret );
	};
});
var rnotwhite = (/\S+/g);



// String to Object options format cache
var optionsCache = {};

// Convert String-formatted options into Object-formatted ones and store in cache
function createOptions( options ) {
	var object = optionsCache[ options ] = {};
	jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	});
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		( optionsCache[ options ] || createOptions( options ) ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,
		// Last fire value (for non-forgettable lists)
		memory,
		// Flag to know if list was already fired
		fired,
		// End of the loop when firing
		firingLength,
		// Index of currently firing callback (modified by remove if needed)
		firingIndex,
		// First callback to fire (used internally by add and fireWith)
		firingStart,
		// Actual callback list
		list = [],
		// Stack of fire calls for repeatable lists
		stack = !options.once && [],
		// Fire callbacks
		fire = function( data ) {
			memory = options.memory && data;
			fired = true;
			firingIndex = firingStart || 0;
			firingStart = 0;
			firingLength = list.length;
			firing = true;
			for ( ; list && firingIndex < firingLength; firingIndex++ ) {
				if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
					memory = false; // To prevent further calls using add
					break;
				}
			}
			firing = false;
			if ( list ) {
				if ( stack ) {
					if ( stack.length ) {
						fire( stack.shift() );
					}
				} else if ( memory ) {
					list = [];
				} else {
					self.disable();
				}
			}
		},
		// Actual Callbacks object
		self = {
			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {
					// First, we save the current length
					var start = list.length;
					(function add( args ) {
						jQuery.each( args, function( _, arg ) {
							var type = jQuery.type( arg );
							if ( type === "function" ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && type !== "string" ) {
								// Inspect recursively
								add( arg );
							}
						});
					})( arguments );
					// Do we need to add the callbacks to the
					// current firing batch?
					if ( firing ) {
						firingLength = list.length;
					// With memory, if we're not firing then
					// we should call right away
					} else if ( memory ) {
						firingStart = start;
						fire( memory );
					}
				}
				return this;
			},
			// Remove a callback from the list
			remove: function() {
				if ( list ) {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );
							// Handle firing indexes
							if ( firing ) {
								if ( index <= firingLength ) {
									firingLength--;
								}
								if ( index <= firingIndex ) {
									firingIndex--;
								}
							}
						}
					});
				}
				return this;
			},
			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );
			},
			// Remove all callbacks from the list
			empty: function() {
				list = [];
				firingLength = 0;
				return this;
			},
			// Have the list do nothing anymore
			disable: function() {
				list = stack = memory = undefined;
				return this;
			},
			// Is it disabled?
			disabled: function() {
				return !list;
			},
			// Lock the list in its current state
			lock: function() {
				stack = undefined;
				if ( !memory ) {
					self.disable();
				}
				return this;
			},
			// Is it locked?
			locked: function() {
				return !stack;
			},
			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( list && ( !fired || stack ) ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					if ( firing ) {
						stack.push( args );
					} else {
						fire( args );
					}
				}
				return this;
			},
			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},
			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


jQuery.extend({

	Deferred: function( func ) {
		var tuples = [
				// action, add listener, listener list, final state
				[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
				[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
				[ "notify", "progress", jQuery.Callbacks("memory") ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				then: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;
					return jQuery.Deferred(function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {
							var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
							// deferred[ done | fail | progress ] for forwarding actions to newDefer
							deferred[ tuple[1] ](function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.done( newDefer.resolve )
										.fail( newDefer.reject )
										.progress( newDefer.notify );
								} else {
									newDefer[ tuple[ 0 ] + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
								}
							});
						});
						fns = null;
					}).promise();
				},
				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Keep pipe for back-compat
		promise.pipe = promise.then;

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 3 ];

			// promise[ done | fail | progress ] = list.add
			promise[ tuple[1] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(function() {
					// state = [ resolved | rejected ]
					state = stateString;

				// [ reject_list | resolve_list ].disable; progress_list.lock
				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
			}

			// deferred[ resolve | reject | notify ]
			deferred[ tuple[0] ] = function() {
				deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
				return this;
			};
			deferred[ tuple[0] + "With" ] = list.fireWith;
		});

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( subordinate /* , ..., subordinateN */ ) {
		var i = 0,
			resolveValues = slice.call( arguments ),
			length = resolveValues.length,

			// the count of uncompleted subordinates
			remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

			// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

			// Update function for both resolve and progress values
			updateFunc = function( i, contexts, values ) {
				return function( value ) {
					contexts[ i ] = this;
					values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( values === progressValues ) {
						deferred.notifyWith( contexts, values );

					} else if ( !(--remaining) ) {
						deferred.resolveWith( contexts, values );
					}
				};
			},

			progressValues, progressContexts, resolveContexts;

		// add listeners to Deferred subordinates; treat others as resolved
		if ( length > 1 ) {
			progressValues = new Array( length );
			progressContexts = new Array( length );
			resolveContexts = new Array( length );
			for ( ; i < length; i++ ) {
				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
					resolveValues[ i ].promise()
						.done( updateFunc( i, resolveContexts, resolveValues ) )
						.fail( deferred.reject )
						.progress( updateFunc( i, progressContexts, progressValues ) );
				} else {
					--remaining;
				}
			}
		}

		// if we're not waiting on anything, resolve the master
		if ( !remaining ) {
			deferred.resolveWith( resolveContexts, resolveValues );
		}

		return deferred.promise();
	}
});


// The deferred used on DOM ready
var readyList;

jQuery.fn.ready = function( fn ) {
	// Add the callback
	jQuery.ready.promise().done( fn );

	return this;
};

jQuery.extend({
	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
		if ( !document.body ) {
			return setTimeout( jQuery.ready );
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );

		// Trigger any bound ready events
		if ( jQuery.fn.trigger ) {
			jQuery( document ).trigger("ready").off("ready");
		}
	}
});

/**
 * Clean-up method for dom ready events
 */
function detach() {
	if ( document.addEventListener ) {
		document.removeEventListener( "DOMContentLoaded", completed, false );
		window.removeEventListener( "load", completed, false );

	} else {
		document.detachEvent( "onreadystatechange", completed );
		window.detachEvent( "onload", completed );
	}
}

/**
 * The ready event handler and self cleanup method
 */
function completed() {
	// readyState === "complete" is good enough for us to call the dom ready in oldIE
	if ( document.addEventListener || event.type === "load" || document.readyState === "complete" ) {
		detach();
		jQuery.ready();
	}
}

jQuery.ready.promise = function( obj ) {
	if ( !readyList ) {

		readyList = jQuery.Deferred();

		// Catch cases where $(document).ready() is called after the browser event has already occurred.
		// we once tried to use readyState "interactive" here, but it caused issues like the one
		// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
		if ( document.readyState === "complete" ) {
			// Handle it asynchronously to allow scripts the opportunity to delay ready
			setTimeout( jQuery.ready );

		// Standards-based browsers support DOMContentLoaded
		} else if ( document.addEventListener ) {
			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", completed, false );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", completed, false );

		// If IE event model is used
		} else {
			// Ensure firing before onload, maybe late but safe also for iframes
			document.attachEvent( "onreadystatechange", completed );

			// A fallback to window.onload, that will always work
			window.attachEvent( "onload", completed );

			// If IE and not a frame
			// continually check to see if the document is ready
			var top = false;

			try {
				top = window.frameElement == null && document.documentElement;
			} catch(e) {}

			if ( top && top.doScroll ) {
				(function doScrollCheck() {
					if ( !jQuery.isReady ) {

						try {
							// Use the trick by Diego Perini
							// http://javascript.nwbox.com/IEContentLoaded/
							top.doScroll("left");
						} catch(e) {
							return setTimeout( doScrollCheck, 50 );
						}

						// detach all dom ready events
						detach();

						// and execute any waiting functions
						jQuery.ready();
					}
				})();
			}
		}
	}
	return readyList.promise( obj );
};


var strundefined = typeof undefined;



// Support: IE<9
// Iteration over object's inherited properties before its own
var i;
for ( i in jQuery( support ) ) {
	break;
}
support.ownLast = i !== "0";

// Note: most support tests are defined in their respective modules.
// false until the test is run
support.inlineBlockNeedsLayout = false;

jQuery(function() {
	// We need to execute this one support test ASAP because we need to know
	// if body.style.zoom needs to be set.

	var container, div,
		body = document.getElementsByTagName("body")[0];

	if ( !body ) {
		// Return for frameset docs that don't have a body
		return;
	}

	// Setup
	container = document.createElement( "div" );
	container.style.cssText = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px";

	div = document.createElement( "div" );
	body.appendChild( container ).appendChild( div );

	if ( typeof div.style.zoom !== strundefined ) {
		// Support: IE<8
		// Check if natively block-level elements act like inline-block
		// elements when setting their display to 'inline' and giving
		// them layout
		div.style.cssText = "border:0;margin:0;width:1px;padding:1px;display:inline;zoom:1";

		if ( (support.inlineBlockNeedsLayout = ( div.offsetWidth === 3 )) ) {
			// Prevent IE 6 from affecting layout for positioned elements #11048
			// Prevent IE from shrinking the body in IE 7 mode #12869
			// Support: IE<8
			body.style.zoom = 1;
		}
	}

	body.removeChild( container );

	// Null elements to avoid leaks in IE
	container = div = null;
});




(function() {
	var div = document.createElement( "div" );

	// Execute the test only if not already executed in another module.
	if (support.deleteExpando == null) {
		// Support: IE<9
		support.deleteExpando = true;
		try {
			delete div.test;
		} catch( e ) {
			support.deleteExpando = false;
		}
	}

	// Null elements to avoid leaks in IE.
	div = null;
})();


/**
 * Determines whether an object can have data
 */
jQuery.acceptData = function( elem ) {
	var noData = jQuery.noData[ (elem.nodeName + " ").toLowerCase() ],
		nodeType = +elem.nodeType || 1;

	// Do not set data on non-element DOM nodes because it will not be cleared (#8335).
	return nodeType !== 1 && nodeType !== 9 ?
		false :

		// Nodes accept data unless otherwise specified; rejection can be conditional
		!noData || noData !== true && elem.getAttribute("classid") === noData;
};


var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /([A-Z])/g;

function dataAttr( elem, key, data ) {
	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {

		var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();

		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
					data === "false" ? false :
					data === "null" ? null :
					// Only convert to a number if it doesn't change the string
					+data + "" === data ? +data :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch( e ) {}

			// Make sure we set the data so it isn't changed later
			jQuery.data( elem, key, data );

		} else {
			data = undefined;
		}
	}

	return data;
}

// checks a cache object for emptiness
function isEmptyDataObject( obj ) {
	var name;
	for ( name in obj ) {

		// if the public data object is empty, the private is still empty
		if ( name === "data" && jQuery.isEmptyObject( obj[name] ) ) {
			continue;
		}
		if ( name !== "toJSON" ) {
			return false;
		}
	}

	return true;
}

function internalData( elem, name, data, pvt /* Internal Use Only */ ) {
	if ( !jQuery.acceptData( elem ) ) {
		return;
	}

	var ret, thisCache,
		internalKey = jQuery.expando,

		// We have to handle DOM nodes and JS objects differently because IE6-7
		// can't GC object references properly across the DOM-JS boundary
		isNode = elem.nodeType,

		// Only DOM nodes need the global jQuery cache; JS object data is
		// attached directly to the object so GC can occur automatically
		cache = isNode ? jQuery.cache : elem,

		// Only defining an ID for JS objects if its cache already exists allows
		// the code to shortcut on the same path as a DOM node with no cache
		id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey;

	// Avoid doing any more work than we need to when trying to get data on an
	// object that has no data at all
	if ( (!id || !cache[id] || (!pvt && !cache[id].data)) && data === undefined && typeof name === "string" ) {
		return;
	}

	if ( !id ) {
		// Only DOM nodes need a new unique ID for each element since their data
		// ends up in the global cache
		if ( isNode ) {
			id = elem[ internalKey ] = deletedIds.pop() || jQuery.guid++;
		} else {
			id = internalKey;
		}
	}

	if ( !cache[ id ] ) {
		// Avoid exposing jQuery metadata on plain JS objects when the object
		// is serialized using JSON.stringify
		cache[ id ] = isNode ? {} : { toJSON: jQuery.noop };
	}

	// An object can be passed to jQuery.data instead of a key/value pair; this gets
	// shallow copied over onto the existing cache
	if ( typeof name === "object" || typeof name === "function" ) {
		if ( pvt ) {
			cache[ id ] = jQuery.extend( cache[ id ], name );
		} else {
			cache[ id ].data = jQuery.extend( cache[ id ].data, name );
		}
	}

	thisCache = cache[ id ];

	// jQuery data() is stored in a separate object inside the object's internal data
	// cache in order to avoid key collisions between internal data and user-defined
	// data.
	if ( !pvt ) {
		if ( !thisCache.data ) {
			thisCache.data = {};
		}

		thisCache = thisCache.data;
	}

	if ( data !== undefined ) {
		thisCache[ jQuery.camelCase( name ) ] = data;
	}

	// Check for both converted-to-camel and non-converted data property names
	// If a data property was specified
	if ( typeof name === "string" ) {

		// First Try to find as-is property data
		ret = thisCache[ name ];

		// Test for null|undefined property data
		if ( ret == null ) {

			// Try to find the camelCased property
			ret = thisCache[ jQuery.camelCase( name ) ];
		}
	} else {
		ret = thisCache;
	}

	return ret;
}

function internalRemoveData( elem, name, pvt ) {
	if ( !jQuery.acceptData( elem ) ) {
		return;
	}

	var thisCache, i,
		isNode = elem.nodeType,

		// See jQuery.data for more information
		cache = isNode ? jQuery.cache : elem,
		id = isNode ? elem[ jQuery.expando ] : jQuery.expando;

	// If there is already no cache entry for this object, there is no
	// purpose in continuing
	if ( !cache[ id ] ) {
		return;
	}

	if ( name ) {

		thisCache = pvt ? cache[ id ] : cache[ id ].data;

		if ( thisCache ) {

			// Support array or space separated string names for data keys
			if ( !jQuery.isArray( name ) ) {

				// try the string as a key before any manipulation
				if ( name in thisCache ) {
					name = [ name ];
				} else {

					// split the camel cased version by spaces unless a key with the spaces exists
					name = jQuery.camelCase( name );
					if ( name in thisCache ) {
						name = [ name ];
					} else {
						name = name.split(" ");
					}
				}
			} else {
				// If "name" is an array of keys...
				// When data is initially created, via ("key", "val") signature,
				// keys will be converted to camelCase.
				// Since there is no way to tell _how_ a key was added, remove
				// both plain key and camelCase key. #12786
				// This will only penalize the array argument path.
				name = name.concat( jQuery.map( name, jQuery.camelCase ) );
			}

			i = name.length;
			while ( i-- ) {
				delete thisCache[ name[i] ];
			}

			// If there is no data left in the cache, we want to continue
			// and let the cache object itself get destroyed
			if ( pvt ? !isEmptyDataObject(thisCache) : !jQuery.isEmptyObject(thisCache) ) {
				return;
			}
		}
	}

	// See jQuery.data for more information
	if ( !pvt ) {
		delete cache[ id ].data;

		// Don't destroy the parent cache unless the internal data object
		// had been the only thing left in it
		if ( !isEmptyDataObject( cache[ id ] ) ) {
			return;
		}
	}

	// Destroy the cache
	if ( isNode ) {
		jQuery.cleanData( [ elem ], true );

	// Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)
	/* jshint eqeqeq: false */
	} else if ( support.deleteExpando || cache != cache.window ) {
		/* jshint eqeqeq: true */
		delete cache[ id ];

	// When all else fails, null
	} else {
		cache[ id ] = null;
	}
}

jQuery.extend({
	cache: {},

	// The following elements (space-suffixed to avoid Object.prototype collisions)
	// throw uncatchable exceptions if you attempt to set expando properties
	noData: {
		"applet ": true,
		"embed ": true,
		// ...but Flash objects (which have this classid) *can* handle expandos
		"object ": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"
	},

	hasData: function( elem ) {
		elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];
		return !!elem && !isEmptyDataObject( elem );
	},

	data: function( elem, name, data ) {
		return internalData( elem, name, data );
	},

	removeData: function( elem, name ) {
		return internalRemoveData( elem, name );
	},

	// For internal use only.
	_data: function( elem, name, data ) {
		return internalData( elem, name, data, true );
	},

	_removeData: function( elem, name ) {
		return internalRemoveData( elem, name, true );
	}
});

jQuery.fn.extend({
	data: function( key, value ) {
		var i, name, data,
			elem = this[0],
			attrs = elem && elem.attributes;

		// Special expections of .data basically thwart jQuery.access,
		// so implement the relevant behavior ourselves

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = jQuery.data( elem );

				if ( elem.nodeType === 1 && !jQuery._data( elem, "parsedAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {
						name = attrs[i].name;

						if ( name.indexOf("data-") === 0 ) {
							name = jQuery.camelCase( name.slice(5) );

							dataAttr( elem, name, data[ name ] );
						}
					}
					jQuery._data( elem, "parsedAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each(function() {
				jQuery.data( this, key );
			});
		}

		return arguments.length > 1 ?

			// Sets one value
			this.each(function() {
				jQuery.data( this, key, value );
			}) :

			// Gets one value
			// Try to fetch any internally stored data first
			elem ? dataAttr( elem, key, jQuery.data( elem, key ) ) : undefined;
	},

	removeData: function( key ) {
		return this.each(function() {
			jQuery.removeData( this, key );
		});
	}
});


jQuery.extend({
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = jQuery._data( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || jQuery.isArray(data) ) {
					queue = jQuery._data( elem, type, jQuery.makeArray(data) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// not intended for public consumption - generates a queueHooks object, or returns the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return jQuery._data( elem, key ) || jQuery._data( elem, key, {
			empty: jQuery.Callbacks("once memory").add(function() {
				jQuery._removeData( elem, type + "queue" );
				jQuery._removeData( elem, key );
			})
		});
	}
});

jQuery.fn.extend({
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[0], type );
		}

		return data === undefined ?
			this :
			this.each(function() {
				var queue = jQuery.queue( this, type, data );

				// ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[0] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			});
	},
	dequeue: function( type ) {
		return this.each(function() {
			jQuery.dequeue( this, type );
		});
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},
	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = jQuery._data( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
});
var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;

var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHidden = function( elem, el ) {
		// isHidden might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;
		return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
	};



// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		length = elems.length,
		bulk = key == null;

	// Sets many values
	if ( jQuery.type( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !jQuery.isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {
			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < length; i++ ) {
				fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
			}
		}
	}

	return chainable ?
		elems :

		// Gets
		bulk ?
			fn.call( elems ) :
			length ? fn( elems[0], key ) : emptyGet;
};
var rcheckableType = (/^(?:checkbox|radio)$/i);



(function() {
	var fragment = document.createDocumentFragment(),
		div = document.createElement("div"),
		input = document.createElement("input");

	// Setup
	div.setAttribute( "className", "t" );
	div.innerHTML = "  <link/><table></table><a href='/a'>a</a>";

	// IE strips leading whitespace when .innerHTML is used
	support.leadingWhitespace = div.firstChild.nodeType === 3;

	// Make sure that tbody elements aren't automatically inserted
	// IE will insert them into empty tables
	support.tbody = !div.getElementsByTagName( "tbody" ).length;

	// Make sure that link elements get serialized correctly by innerHTML
	// This requires a wrapper element in IE
	support.htmlSerialize = !!div.getElementsByTagName( "link" ).length;

	// Makes sure cloning an html5 element does not cause problems
	// Where outerHTML is undefined, this still works
	support.html5Clone =
		document.createElement( "nav" ).cloneNode( true ).outerHTML !== "<:nav></:nav>";

	// Check if a disconnected checkbox will retain its checked
	// value of true after appended to the DOM (IE6/7)
	input.type = "checkbox";
	input.checked = true;
	fragment.appendChild( input );
	support.appendChecked = input.checked;

	// Make sure textarea (and checkbox) defaultValue is properly cloned
	// Support: IE6-IE11+
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;

	// #11217 - WebKit loses check when the name is after the checked attribute
	fragment.appendChild( div );
	div.innerHTML = "<input type='radio' checked='checked' name='t'/>";

	// Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3
	// old WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE<9
	// Opera does not clone events (and typeof div.attachEvent === undefined).
	// IE9-10 clones events bound via attachEvent, but they don't trigger with .click()
	support.noCloneEvent = true;
	if ( div.attachEvent ) {
		div.attachEvent( "onclick", function() {
			support.noCloneEvent = false;
		});

		div.cloneNode( true ).click();
	}

	// Execute the test only if not already executed in another module.
	if (support.deleteExpando == null) {
		// Support: IE<9
		support.deleteExpando = true;
		try {
			delete div.test;
		} catch( e ) {
			support.deleteExpando = false;
		}
	}

	// Null elements to avoid leaks in IE.
	fragment = div = input = null;
})();


(function() {
	var i, eventName,
		div = document.createElement( "div" );

	// Support: IE<9 (lack submit/change bubble), Firefox 23+ (lack focusin event)
	for ( i in { submit: true, change: true, focusin: true }) {
		eventName = "on" + i;

		if ( !(support[ i + "Bubbles" ] = eventName in window) ) {
			// Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP)
			div.setAttribute( eventName, "t" );
			support[ i + "Bubbles" ] = div.attributes[ eventName ].expando === false;
		}
	}

	// Null elements to avoid leaks in IE.
	div = null;
})();


var rformElems = /^(?:input|select|textarea)$/i,
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|contextmenu)|click/,
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {
		var tmp, events, t, handleObjIn,
			special, eventHandle, handleObj,
			handlers, type, namespaces, origType,
			elemData = jQuery._data( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !(events = elemData.events) ) {
			events = elemData.events = {};
		}
		if ( !(eventHandle = elemData.handle) ) {
			eventHandle = elemData.handle = function( e ) {
				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== strundefined && (!e || jQuery.event.triggered !== e.type) ?
					jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
					undefined;
			};
			// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
			eventHandle.elem = elem;
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend({
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join(".")
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !(handlers = events[ type ]) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener/attachEvent if the special events handler returns false
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					// Bind the global event handler to the element
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );

					} else if ( elem.attachEvent ) {
						elem.attachEvent( "on" + type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

		// Nullify elem to prevent memory leaks in IE
		elem = null;
	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {
		var j, handleObj, tmp,
			origCount, t, events,
			special, handlers, type,
			namespaces, origType,
			elemData = jQuery.hasData( elem ) && jQuery._data( elem );

		if ( !elemData || !(events = elemData.events) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			delete elemData.handle;

			// removeData also checks for emptiness and clears the expando if empty
			// so use it instead of delete
			jQuery._removeData( elem, "events" );
		}
	},

	trigger: function( event, data, elem, onlyHandlers ) {
		var handle, ontype, cur,
			bubbleType, special, tmp, i,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];

		cur = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf(".") >= 0 ) {
			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split(".");
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf(":") < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join(".");
		event.namespace_re = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === (elem.ownerDocument || document) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {

			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] && jQuery._data( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && jQuery.acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&
				jQuery.acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Can't use an .isFunction() check here because IE6/7 fails that test.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && elem[ type ] && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					try {
						elem[ type ]();
					} catch ( e ) {
						// IE<9 dies on focus/blur to hidden element (#1486,#12518)
						// only reproducible on winXP IE8 native, not IE9 in IE8 mode
					}
					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event );

		var i, ret, handleObj, matched, j,
			handlerQueue = [],
			args = slice.call( arguments ),
			handlers = ( jQuery._data( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[0] = event;
		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or
				// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
							.apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( (event.result = ret) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var sel, handleObj, matches, i,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		// Black-hole SVG <use> instance trees (#13180)
		// Avoid non-left-click bubbling in Firefox (#3861)
		if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {

			/* jshint eqeqeq: false */
			for ( ; cur != this; cur = cur.parentNode || this ) {
				/* jshint eqeqeq: true */

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && (cur.disabled !== true || event.type !== "click") ) {
					matches = [];
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matches[ sel ] === undefined ) {
							matches[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) >= 0 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matches[ sel ] ) {
							matches.push( handleObj );
						}
					}
					if ( matches.length ) {
						handlerQueue.push({ elem: cur, handlers: matches });
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( delegateCount < handlers.length ) {
			handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
		}

		return handlerQueue;
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop, copy,
			type = event.type,
			originalEvent = event,
			fixHook = this.fixHooks[ type ];

		if ( !fixHook ) {
			this.fixHooks[ type ] = fixHook =
				rmouseEvent.test( type ) ? this.mouseHooks :
				rkeyEvent.test( type ) ? this.keyHooks :
				{};
		}
		copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = new jQuery.Event( originalEvent );

		i = copy.length;
		while ( i-- ) {
			prop = copy[ i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Support: IE<9
		// Fix target property (#1925)
		if ( !event.target ) {
			event.target = originalEvent.srcElement || document;
		}

		// Support: Chrome 23+, Safari?
		// Target should not be a text node (#504, #13143)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		// Support: IE<9
		// For mouse/key events, metaKey==false if it's undefined (#3368, #11328)
		event.metaKey = !!event.metaKey;

		return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split(" "),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
		filter: function( event, original ) {
			var body, eventDoc, doc,
				button = original.button,
				fromElement = original.fromElement;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			// Add relatedTarget, if necessary
			if ( !event.relatedTarget && fromElement ) {
				event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	special: {
		load: {
			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {
			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					try {
						this.focus();
						return false;
					} catch ( e ) {
						// Support: IE<9
						// If we error on focus to hidden element (#1486, #12518),
						// let .trigger() run the handlers
					}
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {
			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( jQuery.nodeName( this, "input" ) && this.type === "checkbox" && this.click ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return jQuery.nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Even when returnValue equals to undefined Firefox will still show alert
				if ( event.result !== undefined ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	},

	simulate: function( type, elem, event, bubble ) {
		// Piggyback on a donor event to simulate a different one.
		// Fake originalEvent to avoid donor's stopPropagation, but if the
		// simulated event prevents default then we do the same on the donor.
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true,
				originalEvent: {}
			}
		);
		if ( bubble ) {
			jQuery.event.trigger( e, null, elem );
		} else {
			jQuery.event.dispatch.call( elem, e );
		}
		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}
};

jQuery.removeEvent = document.removeEventListener ?
	function( elem, type, handle ) {
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle, false );
		}
	} :
	function( elem, type, handle ) {
		var name = "on" + type;

		if ( elem.detachEvent ) {

			// #8545, #7054, preventing memory leaks for custom events in IE6-8
			// detachEvent needed property on element, by name of that event, to properly expose it to GC
			if ( typeof elem[ name ] === strundefined ) {
				elem[ name ] = null;
			}

			elem.detachEvent( name, handle );
		}
	};

jQuery.Event = function( src, props ) {
	// Allow instantiation without the 'new' keyword
	if ( !(this instanceof jQuery.Event) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined && (
				// Support: IE < 9
				src.returnValue === false ||
				// Support: Android < 4.0
				src.getPreventDefault && src.getPreventDefault() ) ?
			returnTrue :
			returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;
		if ( !e ) {
			return;
		}

		// If preventDefault exists, run it on the original event
		if ( e.preventDefault ) {
			e.preventDefault();

		// Support: IE
		// Otherwise set the returnValue property of the original event to false
		} else {
			e.returnValue = false;
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;
		if ( !e ) {
			return;
		}
		// If stopPropagation exists, run it on the original event
		if ( e.stopPropagation ) {
			e.stopPropagation();
		}

		// Support: IE
		// Set the cancelBubble property of the original event to true
		e.cancelBubble = true;
	},
	stopImmediatePropagation: function() {
		this.isImmediatePropagationStopped = returnTrue;
		this.stopPropagation();
	}
};

// Create mouseenter/leave events using mouseover/out and event-time checks
jQuery.each({
	mouseenter: "mouseover",
	mouseleave: "mouseout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mousenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
});

// IE submit delegation
if ( !support.submitBubbles ) {

	jQuery.event.special.submit = {
		setup: function() {
			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			// Lazy-add a submit handler when a descendant form may potentially be submitted
			jQuery.event.add( this, "click._submit keypress._submit", function( e ) {
				// Node name check avoids a VML-related crash in IE (#9807)
				var elem = e.target,
					form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ? elem.form : undefined;
				if ( form && !jQuery._data( form, "submitBubbles" ) ) {
					jQuery.event.add( form, "submit._submit", function( event ) {
						event._submit_bubble = true;
					});
					jQuery._data( form, "submitBubbles", true );
				}
			});
			// return undefined since we don't need an event listener
		},

		postDispatch: function( event ) {
			// If form was submitted by the user, bubble the event up the tree
			if ( event._submit_bubble ) {
				delete event._submit_bubble;
				if ( this.parentNode && !event.isTrigger ) {
					jQuery.event.simulate( "submit", this.parentNode, event, true );
				}
			}
		},

		teardown: function() {
			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			// Remove delegated handlers; cleanData eventually reaps submit handlers attached above
			jQuery.event.remove( this, "._submit" );
		}
	};
}

// IE change delegation and checkbox/radio fix
if ( !support.changeBubbles ) {

	jQuery.event.special.change = {

		setup: function() {

			if ( rformElems.test( this.nodeName ) ) {
				// IE doesn't fire change on a check/radio until blur; trigger it on click
				// after a propertychange. Eat the blur-change in special.change.handle.
				// This still fires onchange a second time for check/radio after blur.
				if ( this.type === "checkbox" || this.type === "radio" ) {
					jQuery.event.add( this, "propertychange._change", function( event ) {
						if ( event.originalEvent.propertyName === "checked" ) {
							this._just_changed = true;
						}
					});
					jQuery.event.add( this, "click._change", function( event ) {
						if ( this._just_changed && !event.isTrigger ) {
							this._just_changed = false;
						}
						// Allow triggered, simulated change events (#11500)
						jQuery.event.simulate( "change", this, event, true );
					});
				}
				return false;
			}
			// Delegated event; lazy-add a change handler on descendant inputs
			jQuery.event.add( this, "beforeactivate._change", function( e ) {
				var elem = e.target;

				if ( rformElems.test( elem.nodeName ) && !jQuery._data( elem, "changeBubbles" ) ) {
					jQuery.event.add( elem, "change._change", function( event ) {
						if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {
							jQuery.event.simulate( "change", this.parentNode, event, true );
						}
					});
					jQuery._data( elem, "changeBubbles", true );
				}
			});
		},

		handle: function( event ) {
			var elem = event.target;

			// Swallow native change events from checkbox/radio, we already triggered them above
			if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox") ) {
				return event.handleObj.handler.apply( this, arguments );
			}
		},

		teardown: function() {
			jQuery.event.remove( this, "._change" );

			return !rformElems.test( this.nodeName );
		}
	};
}

// Create "bubbling" focus and blur events
if ( !support.focusinBubbles ) {
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
			};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = jQuery._data( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				jQuery._data( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = jQuery._data( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					jQuery._removeData( doc, fix );
				} else {
					jQuery._data( doc, fix, attaches );
				}
			}
		};
	});
}

jQuery.fn.extend({

	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
		var type, origFn;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {
				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				this.on( type, selector, data, types[ type ], one );
			}
			return this;
		}

		if ( data == null && fn == null ) {
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return this;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return this.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		});
	},
	one: function( types, selector, data, fn ) {
		return this.on( types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {
			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {
			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {
			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each(function() {
			jQuery.event.remove( this, types, fn, selector );
		});
	},

	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},
	triggerHandler: function( type, data ) {
		var elem = this[0];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
});


function createSafeFragment( document ) {
	var list = nodeNames.split( "|" ),
		safeFrag = document.createDocumentFragment();

	if ( safeFrag.createElement ) {
		while ( list.length ) {
			safeFrag.createElement(
				list.pop()
			);
		}
	}
	return safeFrag;
}

var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|" +
		"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
	rinlinejQuery = / jQuery\d+="(?:null|\d+)"/g,
	rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"),
	rleadingWhitespace = /^\s+/,
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
	rtagName = /<([\w:]+)/,
	rtbody = /<tbody/i,
	rhtml = /<|&#?\w+;/,
	rnoInnerhtml = /<(?:script|style|link)/i,
	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /^$|\/(?:java|ecma)script/i,
	rscriptTypeMasked = /^true\/(.*)/,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,

	// We have to close these tags to support XHTML (#13200)
	wrapMap = {
		option: [ 1, "<select multiple='multiple'>", "</select>" ],
		legend: [ 1, "<fieldset>", "</fieldset>" ],
		area: [ 1, "<map>", "</map>" ],
		param: [ 1, "<object>", "</object>" ],
		thead: [ 1, "<table>", "</table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

		// IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,
		// unless wrapped in a div with non-breaking characters in front of it.
		_default: support.htmlSerialize ? [ 0, "", "" ] : [ 1, "X<div>", "</div>"  ]
	},
	safeFragment = createSafeFragment( document ),
	fragmentDiv = safeFragment.appendChild( document.createElement("div") );

wrapMap.optgroup = wrapMap.option;
wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

function getAll( context, tag ) {
	var elems, elem,
		i = 0,
		found = typeof context.getElementsByTagName !== strundefined ? context.getElementsByTagName( tag || "*" ) :
			typeof context.querySelectorAll !== strundefined ? context.querySelectorAll( tag || "*" ) :
			undefined;

	if ( !found ) {
		for ( found = [], elems = context.childNodes || context; (elem = elems[i]) != null; i++ ) {
			if ( !tag || jQuery.nodeName( elem, tag ) ) {
				found.push( elem );
			} else {
				jQuery.merge( found, getAll( elem, tag ) );
			}
		}
	}

	return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
		jQuery.merge( [ context ], found ) :
		found;
}

// Used in buildFragment, fixes the defaultChecked property
function fixDefaultChecked( elem ) {
	if ( rcheckableType.test( elem.type ) ) {
		elem.defaultChecked = elem.checked;
	}
}

// Support: IE<8
// Manipulating tables requires a tbody
function manipulationTarget( elem, content ) {
	return jQuery.nodeName( elem, "table" ) &&
		jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?

		elem.getElementsByTagName("tbody")[0] ||
			elem.appendChild( elem.ownerDocument.createElement("tbody") ) :
		elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = (jQuery.find.attr( elem, "type" ) !== null) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	var match = rscriptTypeMasked.exec( elem.type );
	if ( match ) {
		elem.type = match[1];
	} else {
		elem.removeAttribute("type");
	}
	return elem;
}

// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var elem,
		i = 0;
	for ( ; (elem = elems[i]) != null; i++ ) {
		jQuery._data( elem, "globalEval", !refElements || jQuery._data( refElements[i], "globalEval" ) );
	}
}

function cloneCopyEvent( src, dest ) {

	if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
		return;
	}

	var type, i, l,
		oldData = jQuery._data( src ),
		curData = jQuery._data( dest, oldData ),
		events = oldData.events;

	if ( events ) {
		delete curData.handle;
		curData.events = {};

		for ( type in events ) {
			for ( i = 0, l = events[ type ].length; i < l; i++ ) {
				jQuery.event.add( dest, type, events[ type ][ i ] );
			}
		}
	}

	// make the cloned public data object a copy from the original
	if ( curData.data ) {
		curData.data = jQuery.extend( {}, curData.data );
	}
}

function fixCloneNodeIssues( src, dest ) {
	var nodeName, e, data;

	// We do not need to do anything for non-Elements
	if ( dest.nodeType !== 1 ) {
		return;
	}

	nodeName = dest.nodeName.toLowerCase();

	// IE6-8 copies events bound via attachEvent when using cloneNode.
	if ( !support.noCloneEvent && dest[ jQuery.expando ] ) {
		data = jQuery._data( dest );

		for ( e in data.events ) {
			jQuery.removeEvent( dest, e, data.handle );
		}

		// Event data gets referenced instead of copied if the expando gets copied too
		dest.removeAttribute( jQuery.expando );
	}

	// IE blanks contents when cloning scripts, and tries to evaluate newly-set text
	if ( nodeName === "script" && dest.text !== src.text ) {
		disableScript( dest ).text = src.text;
		restoreScript( dest );

	// IE6-10 improperly clones children of object elements using classid.
	// IE10 throws NoModificationAllowedError if parent is null, #12132.
	} else if ( nodeName === "object" ) {
		if ( dest.parentNode ) {
			dest.outerHTML = src.outerHTML;
		}

		// This path appears unavoidable for IE9. When cloning an object
		// element in IE9, the outerHTML strategy above is not sufficient.
		// If the src has innerHTML and the destination does not,
		// copy the src.innerHTML into the dest.innerHTML. #10324
		if ( support.html5Clone && ( src.innerHTML && !jQuery.trim(dest.innerHTML) ) ) {
			dest.innerHTML = src.innerHTML;
		}

	} else if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		// IE6-8 fails to persist the checked state of a cloned checkbox
		// or radio button. Worse, IE6-7 fail to give the cloned element
		// a checked appearance if the defaultChecked value isn't also set

		dest.defaultChecked = dest.checked = src.checked;

		// IE6-7 get confused and end up setting the value of a cloned
		// checkbox/radio button to an empty string instead of "on"
		if ( dest.value !== src.value ) {
			dest.value = src.value;
		}

	// IE6-8 fails to return the selected option to the default selected
	// state when cloning options
	} else if ( nodeName === "option" ) {
		dest.defaultSelected = dest.selected = src.defaultSelected;

	// IE6-8 fails to set the defaultValue to the correct value when
	// cloning other types of input fields
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

jQuery.extend({
	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var destElements, node, clone, i, srcElements,
			inPage = jQuery.contains( elem.ownerDocument, elem );

		if ( support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test( "<" + elem.nodeName + ">" ) ) {
			clone = elem.cloneNode( true );

		// IE<=8 does not properly clone detached, unknown element nodes
		} else {
			fragmentDiv.innerHTML = elem.outerHTML;
			fragmentDiv.removeChild( clone = fragmentDiv.firstChild );
		}

		if ( (!support.noCloneEvent || !support.noCloneChecked) &&
				(elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {

			// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			// Fix all IE cloning issues
			for ( i = 0; (node = srcElements[i]) != null; ++i ) {
				// Ensure that the destination node is not null; Fixes #9587
				if ( destElements[i] ) {
					fixCloneNodeIssues( node, destElements[i] );
				}
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0; (node = srcElements[i]) != null; i++ ) {
					cloneCopyEvent( node, destElements[i] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		destElements = srcElements = node = null;

		// Return the cloned set
		return clone;
	},

	buildFragment: function( elems, context, scripts, selection ) {
		var j, elem, contains,
			tmp, tag, tbody, wrap,
			l = elems.length,

			// Ensure a safe fragment
			safe = createSafeFragment( context ),

			nodes = [],
			i = 0;

		for ( ; i < l; i++ ) {
			elem = elems[ i ];

			if ( elem || elem === 0 ) {

				// Add nodes directly
				if ( jQuery.type( elem ) === "object" ) {
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );

				// Convert html into DOM nodes
				} else {
					tmp = tmp || safe.appendChild( context.createElement("div") );

					// Deserialize a standard representation
					tag = (rtagName.exec( elem ) || [ "", "" ])[ 1 ].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;

					tmp.innerHTML = wrap[1] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[2];

					// Descend through wrappers to the right content
					j = wrap[0];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}

					// Manually add leading whitespace removed by IE
					if ( !support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
						nodes.push( context.createTextNode( rleadingWhitespace.exec( elem )[0] ) );
					}

					// Remove IE's autoinserted <tbody> from table fragments
					if ( !support.tbody ) {

						// String was a <table>, *may* have spurious <tbody>
						elem = tag === "table" && !rtbody.test( elem ) ?
							tmp.firstChild :

							// String was a bare <thead> or <tfoot>
							wrap[1] === "<table>" && !rtbody.test( elem ) ?
								tmp :
								0;

						j = elem && elem.childNodes.length;
						while ( j-- ) {
							if ( jQuery.nodeName( (tbody = elem.childNodes[j]), "tbody" ) && !tbody.childNodes.length ) {
								elem.removeChild( tbody );
							}
						}
					}

					jQuery.merge( nodes, tmp.childNodes );

					// Fix #12392 for WebKit and IE > 9
					tmp.textContent = "";

					// Fix #12392 for oldIE
					while ( tmp.firstChild ) {
						tmp.removeChild( tmp.firstChild );
					}

					// Remember the top-level container for proper cleanup
					tmp = safe.lastChild;
				}
			}
		}

		// Fix #11356: Clear elements from fragment
		if ( tmp ) {
			safe.removeChild( tmp );
		}

		// Reset defaultChecked for any radios and checkboxes
		// about to be appended to the DOM in IE 6/7 (#8060)
		if ( !support.appendChecked ) {
			jQuery.grep( getAll( nodes, "input" ), fixDefaultChecked );
		}

		i = 0;
		while ( (elem = nodes[ i++ ]) ) {

			// #4087 - If origin and destination elements are the same, and this is
			// that element, do not do anything
			if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {
				continue;
			}

			contains = jQuery.contains( elem.ownerDocument, elem );

			// Append to fragment
			tmp = getAll( safe.appendChild( elem ), "script" );

			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}

			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( (elem = tmp[ j++ ]) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}

		tmp = null;

		return safe;
	},

	cleanData: function( elems, /* internal */ acceptData ) {
		var elem, type, id, data,
			i = 0,
			internalKey = jQuery.expando,
			cache = jQuery.cache,
			deleteExpando = support.deleteExpando,
			special = jQuery.event.special;

		for ( ; (elem = elems[i]) != null; i++ ) {
			if ( acceptData || jQuery.acceptData( elem ) ) {

				id = elem[ internalKey ];
				data = id && cache[ id ];

				if ( data ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Remove cache only if it was not already removed by jQuery.event.remove
					if ( cache[ id ] ) {

						delete cache[ id ];

						// IE does not allow us to delete expando properties from nodes,
						// nor does it have a removeAttribute function on Document nodes;
						// we must handle all of these cases
						if ( deleteExpando ) {
							delete elem[ internalKey ];

						} else if ( typeof elem.removeAttribute !== strundefined ) {
							elem.removeAttribute( internalKey );

						} else {
							elem[ internalKey ] = null;
						}

						deletedIds.push( id );
					}
				}
			}
		}
	}
});

jQuery.fn.extend({
	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().append( ( this[0] && this[0].ownerDocument || document ).createTextNode( value ) );
		}, null, value, arguments.length );
	},

	append: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		});
	},

	prepend: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		});
	},

	before: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		});
	},

	after: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		});
	},

	remove: function( selector, keepData /* Internal Use Only */ ) {
		var elem,
			elems = selector ? jQuery.filter( selector, this ) : this,
			i = 0;

		for ( ; (elem = elems[i]) != null; i++ ) {

			if ( !keepData && elem.nodeType === 1 ) {
				jQuery.cleanData( getAll( elem ) );
			}

			if ( elem.parentNode ) {
				if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {
					setGlobalEval( getAll( elem, "script" ) );
				}
				elem.parentNode.removeChild( elem );
			}
		}

		return this;
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; (elem = this[i]) != null; i++ ) {
			// Remove element nodes and prevent memory leaks
			if ( elem.nodeType === 1 ) {
				jQuery.cleanData( getAll( elem, false ) );
			}

			// Remove any remaining nodes
			while ( elem.firstChild ) {
				elem.removeChild( elem.firstChild );
			}

			// If this is a select, ensure that it displays empty (#12336)
			// Support: IE<9
			if ( elem.options && jQuery.nodeName( elem, "select" ) ) {
				elem.options.length = 0;
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map(function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		});
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined ) {
				return elem.nodeType === 1 ?
					elem.innerHTML.replace( rinlinejQuery, "" ) :
					undefined;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				( support.htmlSerialize || !rnoshimcache.test( value )  ) &&
				( support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&
				!wrapMap[ (rtagName.exec( value ) || [ "", "" ])[ 1 ].toLowerCase() ] ) {

				value = value.replace( rxhtmlTag, "<$1></$2>" );

				try {
					for (; i < l; i++ ) {
						// Remove element nodes and prevent memory leaks
						elem = this[i] || {};
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch(e) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var arg = arguments[ 0 ];

		// Make the changes, replacing each context element with the new content
		this.domManip( arguments, function( elem ) {
			arg = this.parentNode;

			jQuery.cleanData( getAll( this ) );

			if ( arg ) {
				arg.replaceChild( elem, this );
			}
		});

		// Force removal if there was no new content (e.g., from empty arguments)
		return arg && (arg.length || arg.nodeType) ? this : this.remove();
	},

	detach: function( selector ) {
		return this.remove( selector, true );
	},

	domManip: function( args, callback ) {

		// Flatten any nested arrays
		args = concat.apply( [], args );

		var first, node, hasScripts,
			scripts, doc, fragment,
			i = 0,
			l = this.length,
			set = this,
			iNoClone = l - 1,
			value = args[0],
			isFunction = jQuery.isFunction( value );

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( isFunction ||
				( l > 1 && typeof value === "string" &&
					!support.checkClone && rchecked.test( value ) ) ) {
			return this.each(function( index ) {
				var self = set.eq( index );
				if ( isFunction ) {
					args[0] = value.call( this, index, self.html() );
				}
				self.domManip( args, callback );
			});
		}

		if ( l ) {
			fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			if ( first ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;

				// Use the original fragment for the last item instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;

					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );

						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}

					callback.call( this[i], node, i );
				}

				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;

					// Reenable scripts
					jQuery.map( scripts, restoreScript );

					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!jQuery._data( node, "globalEval" ) && jQuery.contains( doc, node ) ) {

							if ( node.src ) {
								// Optional AJAX dependency, but won't run scripts if not present
								if ( jQuery._evalUrl ) {
									jQuery._evalUrl( node.src );
								}
							} else {
								jQuery.globalEval( ( node.text || node.textContent || node.innerHTML || "" ).replace( rcleanScript, "" ) );
							}
						}
					}
				}

				// Fix #11809: Avoid leaking memory
				fragment = first = null;
			}
		}

		return this;
	}
});

jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			i = 0,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone(true);
			jQuery( insert[i] )[ original ]( elems );

			// Modern browsers can apply jQuery collections as arrays, but oldIE needs a .get()
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
});


var iframe,
	elemdisplay = {};

/**
 * Retrieve the actual display of a element
 * @param {String} name nodeName of the element
 * @param {Object} doc Document object
 */
// Called only from within defaultDisplay
function actualDisplay( name, doc ) {
	var elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

		// getDefaultComputedStyle might be reliably used only on attached element
		display = window.getDefaultComputedStyle ?

			// Use of this method is a temporary fix (more like optmization) until something better comes along,
			// since it was removed from specification and supported only in FF
			window.getDefaultComputedStyle( elem[ 0 ] ).display : jQuery.css( elem[ 0 ], "display" );

	// We don't have any data stored on the element,
	// so use "detach" method as fast way to get rid of the element
	elem.detach();

	return display;
}

/**
 * Try to determine the default display value of an element
 * @param {String} nodeName
 */
function defaultDisplay( nodeName ) {
	var doc = document,
		display = elemdisplay[ nodeName ];

	if ( !display ) {
		display = actualDisplay( nodeName, doc );

		// If the simple way fails, read from inside an iframe
		if ( display === "none" || !display ) {

			// Use the already-created iframe if possible
			iframe = (iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" )).appendTo( doc.documentElement );

			// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
			doc = ( iframe[ 0 ].contentWindow || iframe[ 0 ].contentDocument ).document;

			// Support: IE
			doc.write();
			doc.close();

			display = actualDisplay( nodeName, doc );
			iframe.detach();
		}

		// Store the correct default display
		elemdisplay[ nodeName ] = display;
	}

	return display;
}


(function() {
	var a, shrinkWrapBlocksVal,
		div = document.createElement( "div" ),
		divReset =
			"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;" +
			"display:block;padding:0;margin:0;border:0";

	// Setup
	div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";
	a = div.getElementsByTagName( "a" )[ 0 ];

	a.style.cssText = "float:left;opacity:.5";

	// Make sure that element opacity exists
	// (IE uses filter instead)
	// Use a regex to work around a WebKit issue. See #5145
	support.opacity = /^0.5/.test( a.style.opacity );

	// Verify style float existence
	// (IE uses styleFloat instead of cssFloat)
	support.cssFloat = !!a.style.cssFloat;

	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	// Null elements to avoid leaks in IE.
	a = div = null;

	support.shrinkWrapBlocks = function() {
		var body, container, div, containerStyles;

		if ( shrinkWrapBlocksVal == null ) {
			body = document.getElementsByTagName( "body" )[ 0 ];
			if ( !body ) {
				// Test fired too early or in an unsupported environment, exit.
				return;
			}

			containerStyles = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px";
			container = document.createElement( "div" );
			div = document.createElement( "div" );

			body.appendChild( container ).appendChild( div );

			// Will be changed later if needed.
			shrinkWrapBlocksVal = false;

			if ( typeof div.style.zoom !== strundefined ) {
				// Support: IE6
				// Check if elements with layout shrink-wrap their children
				div.style.cssText = divReset + ";width:1px;padding:1px;zoom:1";
				div.innerHTML = "<div></div>";
				div.firstChild.style.width = "5px";
				shrinkWrapBlocksVal = div.offsetWidth !== 3;
			}

			body.removeChild( container );

			// Null elements to avoid leaks in IE.
			body = container = div = null;
		}

		return shrinkWrapBlocksVal;
	};

})();
var rmargin = (/^margin/);

var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );



var getStyles, curCSS,
	rposition = /^(top|right|bottom|left)$/;

if ( window.getComputedStyle ) {
	getStyles = function( elem ) {
		return elem.ownerDocument.defaultView.getComputedStyle( elem, null );
	};

	curCSS = function( elem, name, computed ) {
		var width, minWidth, maxWidth, ret,
			style = elem.style;

		computed = computed || getStyles( elem );

		// getPropertyValue is only needed for .css('filter') in IE9, see #12537
		ret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined;

		if ( computed ) {

			if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
				ret = jQuery.style( elem, name );
			}

			// A tribute to the "awesome hack by Dean Edwards"
			// Chrome < 17 and Safari 5.0 uses "computed value" instead of "used value" for margin-right
			// Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
			// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
			if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {

				// Remember the original values
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;

				// Put in the new values to get a computed value out
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;

				// Revert the changed values
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}

		// Support: IE
		// IE returns zIndex value as an integer.
		return ret === undefined ?
			ret :
			ret + "";
	};
} else if ( document.documentElement.currentStyle ) {
	getStyles = function( elem ) {
		return elem.currentStyle;
	};

	curCSS = function( elem, name, computed ) {
		var left, rs, rsLeft, ret,
			style = elem.style;

		computed = computed || getStyles( elem );
		ret = computed ? computed[ name ] : undefined;

		// Avoid setting ret to empty string here
		// so we don't default to auto
		if ( ret == null && style && style[ name ] ) {
			ret = style[ name ];
		}

		// From the awesome hack by Dean Edwards
		// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

		// If we're not dealing with a regular pixel number
		// but a number that has a weird ending, we need to convert it to pixels
		// but not position css attributes, as those are proportional to the parent element instead
		// and we can't measure the parent instead because it might trigger a "stacking dolls" problem
		if ( rnumnonpx.test( ret ) && !rposition.test( name ) ) {

			// Remember the original values
			left = style.left;
			rs = elem.runtimeStyle;
			rsLeft = rs && rs.left;

			// Put in the new values to get a computed value out
			if ( rsLeft ) {
				rs.left = elem.currentStyle.left;
			}
			style.left = name === "fontSize" ? "1em" : ret;
			ret = style.pixelLeft + "px";

			// Revert the changed values
			style.left = left;
			if ( rsLeft ) {
				rs.left = rsLeft;
			}
		}

		// Support: IE
		// IE returns zIndex value as an integer.
		return ret === undefined ?
			ret :
			ret + "" || "auto";
	};
}




function addGetHookIf( conditionFn, hookFn ) {
	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			var condition = conditionFn();

			if ( condition == null ) {
				// The test was not ready at this point; screw the hook this time
				// but check again when needed next time.
				return;
			}

			if ( condition ) {
				// Hook not needed (or it's not possible to use it due to missing dependency),
				// remove it.
				// Since there are no other hooks for marginRight, remove the whole object.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.

			return (this.get = hookFn).apply( this, arguments );
		}
	};
}


(function() {
	var a, reliableHiddenOffsetsVal, boxSizingVal, boxSizingReliableVal,
		pixelPositionVal, reliableMarginRightVal,
		div = document.createElement( "div" ),
		containerStyles = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px",
		divReset =
			"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;" +
			"display:block;padding:0;margin:0;border:0";

	// Setup
	div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";
	a = div.getElementsByTagName( "a" )[ 0 ];

	a.style.cssText = "float:left;opacity:.5";

	// Make sure that element opacity exists
	// (IE uses filter instead)
	// Use a regex to work around a WebKit issue. See #5145
	support.opacity = /^0.5/.test( a.style.opacity );

	// Verify style float existence
	// (IE uses styleFloat instead of cssFloat)
	support.cssFloat = !!a.style.cssFloat;

	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	// Null elements to avoid leaks in IE.
	a = div = null;

	jQuery.extend(support, {
		reliableHiddenOffsets: function() {
			if ( reliableHiddenOffsetsVal != null ) {
				return reliableHiddenOffsetsVal;
			}

			var container, tds, isSupported,
				div = document.createElement( "div" ),
				body = document.getElementsByTagName( "body" )[ 0 ];

			if ( !body ) {
				// Return for frameset docs that don't have a body
				return;
			}

			// Setup
			div.setAttribute( "className", "t" );
			div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";

			container = document.createElement( "div" );
			container.style.cssText = containerStyles;

			body.appendChild( container ).appendChild( div );

			// Support: IE8
			// Check if table cells still have offsetWidth/Height when they are set
			// to display:none and there are still other visible table cells in a
			// table row; if so, offsetWidth/Height are not reliable for use when
			// determining if an element has been hidden directly using
			// display:none (it is still safe to use offsets if a parent element is
			// hidden; don safety goggles and see bug #4512 for more information).
			div.innerHTML = "<table><tr><td></td><td>t</td></tr></table>";
			tds = div.getElementsByTagName( "td" );
			tds[ 0 ].style.cssText = "padding:0;margin:0;border:0;display:none";
			isSupported = ( tds[ 0 ].offsetHeight === 0 );

			tds[ 0 ].style.display = "";
			tds[ 1 ].style.display = "none";

			// Support: IE8
			// Check if empty table cells still have offsetWidth/Height
			reliableHiddenOffsetsVal = isSupported && ( tds[ 0 ].offsetHeight === 0 );

			body.removeChild( container );

			// Null elements to avoid leaks in IE.
			div = body = null;

			return reliableHiddenOffsetsVal;
		},

		boxSizing: function() {
			if ( boxSizingVal == null ) {
				computeStyleTests();
			}
			return boxSizingVal;
		},

		boxSizingReliable: function() {
			if ( boxSizingReliableVal == null ) {
				computeStyleTests();
			}
			return boxSizingReliableVal;
		},

		pixelPosition: function() {
			if ( pixelPositionVal == null ) {
				computeStyleTests();
			}
			return pixelPositionVal;
		},

		reliableMarginRight: function() {
			var body, container, div, marginDiv;

			// Use window.getComputedStyle because jsdom on node.js will break without it.
			if ( reliableMarginRightVal == null && window.getComputedStyle ) {
				body = document.getElementsByTagName( "body" )[ 0 ];
				if ( !body ) {
					// Test fired too early or in an unsupported environment, exit.
					return;
				}

				container = document.createElement( "div" );
				div = document.createElement( "div" );
				container.style.cssText = containerStyles;

				body.appendChild( container ).appendChild( div );

				// Check if div with explicit width and no margin-right incorrectly
				// gets computed margin-right based on width of container. (#3333)
				// Fails in WebKit before Feb 2011 nightlies
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				marginDiv = div.appendChild( document.createElement( "div" ) );
				marginDiv.style.cssText = div.style.cssText = divReset;
				marginDiv.style.marginRight = marginDiv.style.width = "0";
				div.style.width = "1px";

				reliableMarginRightVal =
					!parseFloat( ( window.getComputedStyle( marginDiv, null ) || {} ).marginRight );

				body.removeChild( container );
			}

			return reliableMarginRightVal;
		}
	});

	function computeStyleTests() {
		var container, div,
			body = document.getElementsByTagName( "body" )[ 0 ];

		if ( !body ) {
			// Test fired too early or in an unsupported environment, exit.
			return;
		}

		container = document.createElement( "div" );
		div = document.createElement( "div" );
		container.style.cssText = containerStyles;

		body.appendChild( container ).appendChild( div );

		div.style.cssText =
			"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;" +
				"position:absolute;display:block;padding:1px;border:1px;width:4px;" +
				"margin-top:1%;top:1%";

		// Workaround failing boxSizing test due to offsetWidth returning wrong value
		// with some non-1 values of body zoom, ticket #13543
		jQuery.swap( body, body.style.zoom != null ? { zoom: 1 } : {}, function() {
			boxSizingVal = div.offsetWidth === 4;
		});

		// Will be changed later if needed.
		boxSizingReliableVal = true;
		pixelPositionVal = false;
		reliableMarginRightVal = true;

		// Use window.getComputedStyle because jsdom on node.js will break without it.
		if ( window.getComputedStyle ) {
			pixelPositionVal = ( window.getComputedStyle( div, null ) || {} ).top !== "1%";
			boxSizingReliableVal =
				( window.getComputedStyle( div, null ) || { width: "4px" } ).width === "4px";
		}

		body.removeChild( container );

		// Null elements to avoid leaks in IE.
		div = body = null;
	}

})();


// A method for quickly swapping in/out CSS properties to get correct calculations.
jQuery.swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var
		ralpha = /alpha\([^)]*\)/i,
	ropacity = /opacity\s*=\s*([^)]*)/,

	// swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
	// see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rnumsplit = new RegExp( "^(" + pnum + ")(.*)$", "i" ),
	rrelNum = new RegExp( "^([+-])=(" + pnum + ")", "i" ),

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: 0,
		fontWeight: 400
	},

	cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];


// return a css property mapped to a potentially vendor prefixed property
function vendorPropName( style, name ) {

	// shortcut for names that are not vendor prefixed
	if ( name in style ) {
		return name;
	}

	// check for vendor prefixed names
	var capName = name.charAt(0).toUpperCase() + name.slice(1),
		origName = name,
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in style ) {
			return name;
		}
	}

	return origName;
}

function showHide( elements, show ) {
	var display, elem, hidden,
		values = [],
		index = 0,
		length = elements.length;

	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		values[ index ] = jQuery._data( elem, "olddisplay" );
		display = elem.style.display;
		if ( show ) {
			// Reset the inline display of this element to learn if it is
			// being hidden by cascaded rules or not
			if ( !values[ index ] && display === "none" ) {
				elem.style.display = "";
			}

			// Set elements which have been overridden with display: none
			// in a stylesheet to whatever the default browser style is
			// for such an element
			if ( elem.style.display === "" && isHidden( elem ) ) {
				values[ index ] = jQuery._data( elem, "olddisplay", defaultDisplay(elem.nodeName) );
			}
		} else {

			if ( !values[ index ] ) {
				hidden = isHidden( elem );

				if ( display && display !== "none" || !hidden ) {
					jQuery._data( elem, "olddisplay", hidden ? display : jQuery.css( elem, "display" ) );
				}
			}
		}
	}

	// Set the display of most of the elements in a second loop
	// to avoid the constant reflow
	for ( index = 0; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}
		if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
			elem.style.display = show ? values[ index ] || "" : "none";
		}
	}

	return elements;
}

function setPositiveNumber( elem, value, subtract ) {
	var matches = rnumsplit.exec( value );
	return matches ?
		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
		value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
	var i = extra === ( isBorderBox ? "border" : "content" ) ?
		// If we already have the right measurement, avoid augmentation
		4 :
		// Otherwise initialize for horizontal or vertical properties
		name === "width" ? 1 : 0,

		val = 0;

	for ( ; i < 4; i += 2 ) {
		// both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
		}

		if ( isBorderBox ) {
			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// at this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		} else {
			// at this point, extra isn't content, so add padding
			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// at this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property, which is equivalent to the border-box value
	var valueIsBorderBox = true,
		val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		styles = getStyles( elem ),
		isBorderBox = support.boxSizing() && jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

	// some non-html elements return undefined for offsetWidth, so check for null/undefined
	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
	if ( val <= 0 || val == null ) {
		// Fall back to computed then uncomputed css if necessary
		val = curCSS( elem, name, styles );
		if ( val < 0 || val == null ) {
			val = elem.style[ name ];
		}

		// Computed unit is not pixels. Stop here and return.
		if ( rnumnonpx.test(val) ) {
			return val;
		}

		// we need the check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = isBorderBox && ( support.boxSizingReliable() || val === elem.style[ name ] );

		// Normalize "", auto, and prepare for extra
		val = parseFloat( val ) || 0;
	}

	// use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles
		)
	) + "px";
}

jQuery.extend({
	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {
					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"columnCount": true,
		"fillOpacity": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		// normalize float css property
		"float": support.cssFloat ? "cssFloat" : "styleFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {
		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			style = elem.style;

		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

		// gets hook for the prefixed version
		// followed by the unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// convert relative number strings (+= or -=) to relative numbers. #7345
			if ( type === "string" && (ret = rrelNum.exec( value )) ) {
				value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set. See: #7116
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add 'px' to the (except for certain CSS properties)
			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
				value += "px";
			}

			// Fixes #8908, it can be done more correctly by specifing setters in cssHooks,
			// but it would mean to define eight (for every problematic property) identical functions
			if ( !support.clearCloneStyle && value === "" && name.indexOf("background") === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {

				// Support: IE
				// Swallow errors from 'invalid' CSS values (#5509)
				try {
					// Support: Chrome, Safari
					// Setting style to blank string required to delete "style: x !important;"
					style[ name ] = "";
					style[ name ] = value;
				} catch(e) {}
			}

		} else {
			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var num, val, hooks,
			origName = jQuery.camelCase( name );

		// Make sure that we're working with the right name
		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

		// gets hook for the prefixed version
		// followed by the unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		//convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Return, converting to number if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
		}
		return val;
	}
});

jQuery.each([ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {
				// certain elements can have dimension info if we invisibly show them
				// however, it must have a current display style that would benefit from this
				return elem.offsetWidth === 0 && rdisplayswap.test( jQuery.css( elem, "display" ) ) ?
					jQuery.swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, name, extra );
					}) :
					getWidthOrHeight( elem, name, extra );
			}
		},

		set: function( elem, value, extra ) {
			var styles = extra && getStyles( elem );
			return setPositiveNumber( elem, value, extra ?
				augmentWidthOrHeight(
					elem,
					name,
					extra,
					support.boxSizing() && jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					styles
				) : 0
			);
		}
	};
});

if ( !support.opacity ) {
	jQuery.cssHooks.opacity = {
		get: function( elem, computed ) {
			// IE uses filters for opacity
			return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "" ) ?
				( 0.01 * parseFloat( RegExp.$1 ) ) + "" :
				computed ? "1" : "";
		},

		set: function( elem, value ) {
			var style = elem.style,
				currentStyle = elem.currentStyle,
				opacity = jQuery.isNumeric( value ) ? "alpha(opacity=" + value * 100 + ")" : "",
				filter = currentStyle && currentStyle.filter || style.filter || "";

			// IE has trouble with opacity if it does not have layout
			// Force it by setting the zoom level
			style.zoom = 1;

			// if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
			// if value === "", then remove inline opacity #12685
			if ( ( value >= 1 || value === "" ) &&
					jQuery.trim( filter.replace( ralpha, "" ) ) === "" &&
					style.removeAttribute ) {

				// Setting style.filter to null, "" & " " still leave "filter:" in the cssText
				// if "filter:" is present at all, clearType is disabled, we want to avoid this
				// style.removeAttribute is IE Only, but so apparently is this code path...
				style.removeAttribute( "filter" );

				// if there is no filter style applied in a css rule or unset inline opacity, we are done
				if ( value === "" || currentStyle && !currentStyle.filter ) {
					return;
				}
			}

			// otherwise, set new filter values
			style.filter = ralpha.test( filter ) ?
				filter.replace( ralpha, opacity ) :
				filter + " " + opacity;
		}
	};
}

jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
	function( elem, computed ) {
		if ( computed ) {
			// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
			// Work around by temporarily setting element display to inline-block
			return jQuery.swap( elem, { "display": "inline-block" },
				curCSS, [ elem, "marginRight" ] );
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each({
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// assumes a single number if not a string
				parts = typeof value === "string" ? value.split(" ") : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
});

jQuery.fn.extend({
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( jQuery.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	},
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each(function() {
			if ( isHidden( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		});
	}
});


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || "swing";
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			if ( tween.elem[ tween.prop ] != null &&
				(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
				return tween.elem[ tween.prop ];
			}

			// passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails
			// so, simple values such as "10px" are parsed to Float.
			// complex values such as "rotate(1rad)" are returned as is.
			result = jQuery.css( tween.elem, tween.prop, "" );
			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {
			// use step hook for back compat - use cssHook if its there - use .style if its
			// available and use plain properties where available
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9
// Panic based approach to setting things on disconnected nodes

Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	}
};

jQuery.fx = Tween.prototype.init;

// Back Compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, timerId,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" ),
	rrun = /queueHooks$/,
	animationPrefilters = [ defaultPrefilter ],
	tweeners = {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value ),
				target = tween.cur(),
				parts = rfxnum.exec( value ),
				unit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

				// Starting value computation is required for potential unit mismatches
				start = ( jQuery.cssNumber[ prop ] || unit !== "px" && +target ) &&
					rfxnum.exec( jQuery.css( tween.elem, prop ) ),
				scale = 1,
				maxIterations = 20;

			if ( start && start[ 3 ] !== unit ) {
				// Trust units reported by jQuery.css
				unit = unit || start[ 3 ];

				// Make sure we update the tween properties later on
				parts = parts || [];

				// Iteratively approximate from a nonzero starting point
				start = +target || 1;

				do {
					// If previous iteration zeroed out, double until we get *something*
					// Use a string for doubling factor so we don't accidentally see scale as unchanged below
					scale = scale || ".5";

					// Adjust and apply
					start = start / scale;
					jQuery.style( tween.elem, prop, start + unit );

				// Update scale, tolerating zero or NaN from tween.cur()
				// And breaking the loop if scale is unchanged or perfect, or if we've just had enough
				} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
			}

			// Update tween properties
			if ( parts ) {
				start = tween.start = +start || +target || 0;
				tween.unit = unit;
				// If a +=/-= token was provided, we're doing a relative animation
				tween.end = parts[ 1 ] ?
					start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :
					+parts[ 2 ];
			}

			return tween;
		} ]
	};

// Animations created synchronously will run synchronously
function createFxNow() {
	setTimeout(function() {
		fxNow = undefined;
	});
	return ( fxNow = jQuery.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		attrs = { height: type },
		i = 0;

	// if we include width, step value is 1 to do all cssExpand values,
	// if we don't include width, step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4 ; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( (tween = collection[ index ].call( animation, prop, value )) ) {

			// we're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	/* jshint validthis: true */
	var prop, value, toggle, tween, hooks, oldfire, display, dDisplay,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHidden( elem ),
		dataShow = jQuery._data( elem, "fxshow" );

	// handle queue: false promises
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always(function() {
			// doing this makes sure that the complete handler will be called
			// before this completes
			anim.always(function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			});
		});
	}

	// height/width overflow pass
	if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
		// Make sure that nothing sneaks out
		// Record all 3 overflow attributes because IE does not
		// change the overflow attribute when overflowX and
		// overflowY are set to the same value
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Set display property to inline-block for height/width
		// animations on inline elements that are having width/height animated
		display = jQuery.css( elem, "display" );
		dDisplay = defaultDisplay( elem.nodeName );
		if ( display === "none" ) {
			display = dDisplay;
		}
		if ( display === "inline" &&
				jQuery.css( elem, "float" ) === "none" ) {

			// inline-level elements accept inline-block;
			// block-level elements need to be inline with layout
			if ( !support.inlineBlockNeedsLayout || dDisplay === "inline" ) {
				style.display = "inline-block";
			} else {
				style.zoom = 1;
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		if ( !support.shrinkWrapBlocks() ) {
			anim.always(function() {
				style.overflow = opts.overflow[ 0 ];
				style.overflowX = opts.overflow[ 1 ];
				style.overflowY = opts.overflow[ 2 ];
			});
		}
	}

	// show/hide pass
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.exec( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	if ( !jQuery.isEmptyObject( orig ) ) {
		if ( dataShow ) {
			if ( "hidden" in dataShow ) {
				hidden = dataShow.hidden;
			}
		} else {
			dataShow = jQuery._data( elem, "fxshow", {} );
		}

		// store state if its toggle - enables .stop().toggle() to "reverse"
		if ( toggle ) {
			dataShow.hidden = !hidden;
		}
		if ( hidden ) {
			jQuery( elem ).show();
		} else {
			anim.done(function() {
				jQuery( elem ).hide();
			});
		}
		anim.done(function() {
			var prop;
			jQuery._removeData( elem, "fxshow" );
			for ( prop in orig ) {
				jQuery.style( elem, prop, orig[ prop ] );
			}
		});
		for ( prop in orig ) {
			tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = tween.start;
				if ( hidden ) {
					tween.end = tween.start;
					tween.start = prop === "width" || prop === "height" ? 1 : 0;
				}
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( jQuery.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// not quite $.extend, this wont overwrite keys already present.
			// also - reusing 'index' from above because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = animationPrefilters.length,
		deferred = jQuery.Deferred().always( function() {
			// don't match elem in the :animated selector
			delete tick.elem;
		}),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
				// archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length ; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ]);

			if ( percent < 1 && length ) {
				return remaining;
			} else {
				deferred.resolveWith( elem, [ animation ] );
				return false;
			}
		},
		animation = deferred.promise({
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, { specialEasing: {} }, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,
					// if we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// resolve when we played the last frame
				// otherwise, reject
				if ( gotoEnd ) {
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		}),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length ; index++ ) {
		result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		})
	);

	// attach callbacks from options
	return animation.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );
}

jQuery.Animation = jQuery.extend( Animation, {
	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.split(" ");
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length ; index++ ) {
			prop = props[ index ];
			tweeners[ prop ] = tweeners[ prop ] || [];
			tweeners[ prop ].unshift( callback );
		}
	},

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			animationPrefilters.unshift( callback );
		} else {
			animationPrefilters.push( callback );
		}
	}
});

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
		opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

	// normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend({
	fadeTo: function( speed, to, easing, callback ) {

		// show any hidden elements after setting opacity to 0
		return this.filter( isHidden ).css( "opacity", 0 ).show()

			// animate to the value specified
			.end().animate({ opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {
				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || jQuery._data( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each(function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = jQuery._data( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// start the next in the queue if the last step wasn't forced
			// timers currently will call their complete callbacks, which will dequeue
			// but only if they were gotoEnd
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		});
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each(function() {
			var index,
				data = jQuery._data( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// enable finishing flag on private data
			data.finish = true;

			// empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// turn off finishing flag
			delete data.finish;
		});
	}
});

jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
});

// Generate shortcuts for custom animations
jQuery.each({
	slideDown: genFx("show"),
	slideUp: genFx("hide"),
	slideToggle: genFx("toggle"),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
});

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		timers = jQuery.timers,
		i = 0;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];
		// Checks the timer has not already been removed
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	if ( timer() ) {
		jQuery.fx.start();
	} else {
		jQuery.timers.pop();
	}
};

jQuery.fx.interval = 13;

jQuery.fx.start = function() {
	if ( !timerId ) {
		timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
	}
};

jQuery.fx.stop = function() {
	clearInterval( timerId );
	timerId = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,
	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = setTimeout( next, time );
		hooks.stop = function() {
			clearTimeout( timeout );
		};
	});
};


(function() {
	var a, input, select, opt,
		div = document.createElement("div" );

	// Setup
	div.setAttribute( "className", "t" );
	div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";
	a = div.getElementsByTagName("a")[ 0 ];

	// First batch of tests.
	select = document.createElement("select");
	opt = select.appendChild( document.createElement("option") );
	input = div.getElementsByTagName("input")[ 0 ];

	a.style.cssText = "top:1px";

	// Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
	support.getSetAttribute = div.className !== "t";

	// Get the style information from getAttribute
	// (IE uses .cssText instead)
	support.style = /top/.test( a.getAttribute("style") );

	// Make sure that URLs aren't manipulated
	// (IE normalizes it by default)
	support.hrefNormalized = a.getAttribute("href") === "/a";

	// Check the default checkbox/radio value ("" on WebKit; "on" elsewhere)
	support.checkOn = !!input.value;

	// Make sure that a selected-by-default option has a working selected property.
	// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
	support.optSelected = opt.selected;

	// Tests for enctype support on a form (#6743)
	support.enctype = !!document.createElement("form").enctype;

	// Make sure that the options inside disabled selects aren't marked as disabled
	// (WebKit marks them as disabled)
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Support: IE8 only
	// Check if we can trust getAttribute("value")
	input = document.createElement( "input" );
	input.setAttribute( "value", "" );
	support.input = input.getAttribute( "value" ) === "";

	// Check if an input maintains its value after becoming a radio
	input.value = "t";
	input.setAttribute( "type", "radio" );
	support.radioValue = input.value === "t";

	// Null elements to avoid leaks in IE.
	a = input = select = opt = div = null;
})();


var rreturn = /\r/g;

jQuery.fn.extend({
	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[0];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?
					// handle most common string cases
					ret.replace(rreturn, "") :
					// handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each(function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";
			} else if ( typeof val === "number" ) {
				val += "";
			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				});
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		});
	}
});

jQuery.extend({
	valHooks: {
		option: {
			get: function( elem ) {
				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :
					jQuery.text( elem );
			}
		},
		select: {
			get: function( elem ) {
				var value, option,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one" || index < 0,
					values = one ? null : [],
					max = one ? index + 1 : options.length,
					i = index < 0 ?
						max :
						one ? index : 0;

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// oldIE doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&
							// Don't return options that are disabled or in a disabled optgroup
							( support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null ) &&
							( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					if ( jQuery.inArray( jQuery.valHooks.option.get( option ), values ) >= 0 ) {

						// Support: IE6
						// When new option element is added to select box we need to
						// force reflow of newly added node in order to workaround delay
						// of initialization properties
						try {
							option.selected = optionSet = true;

						} catch ( _ ) {

							// Will be executed only in IE6
							option.scrollHeight;
						}

					} else {
						option.selected = false;
					}
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}

				return options;
			}
		}
	}
});

// Radios and checkboxes getter/setter
jQuery.each([ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			// Support: Webkit
			// "" is returned instead of "on" if a value isn't specified
			return elem.getAttribute("value") === null ? "on" : elem.value;
		};
	}
});




var nodeHook, boolHook,
	attrHandle = jQuery.expr.attrHandle,
	ruseDefault = /^(?:checked|selected)$/i,
	getSetAttribute = support.getSetAttribute,
	getSetInput = support.input;

jQuery.fn.extend({
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each(function() {
			jQuery.removeAttr( this, name );
		});
	}
});

jQuery.extend({
	attr: function( elem, name, value ) {
		var hooks, ret,
			nType = elem.nodeType;

		// don't get/set attributes on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === strundefined ) {
			return jQuery.prop( elem, name, value );
		}

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
		}

		if ( value !== undefined ) {

			if ( value === null ) {
				jQuery.removeAttr( elem, name );

			} else if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				elem.setAttribute( name, value + "" );
				return value;
			}

		} else if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
			return ret;

		} else {
			ret = jQuery.find.attr( elem, name );

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ?
				undefined :
				ret;
		}
	},

	removeAttr: function( elem, value ) {
		var name, propName,
			i = 0,
			attrNames = value && value.match( rnotwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( (name = attrNames[i++]) ) {
				propName = jQuery.propFix[ name ] || name;

				// Boolean attributes get special treatment (#10870)
				if ( jQuery.expr.match.bool.test( name ) ) {
					// Set corresponding property to false
					if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {
						elem[ propName ] = false;
					// Support: IE<9
					// Also clear defaultChecked/defaultSelected (if appropriate)
					} else {
						elem[ jQuery.camelCase( "default-" + name ) ] =
							elem[ propName ] = false;
					}

				// See #9699 for explanation of this approach (setting first, then removal)
				} else {
					jQuery.attr( elem, name, "" );
				}

				elem.removeAttribute( getSetAttribute ? name : propName );
			}
		}
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {
					// Setting the type on a radio button after the value resets the value in IE6-9
					// Reset value to default in case type is set after value during creation
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	}
});

// Hook for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {
			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {
			// IE<8 needs the *property* name
			elem.setAttribute( !getSetAttribute && jQuery.propFix[ name ] || name, name );

		// Use defaultChecked and defaultSelected for oldIE
		} else {
			elem[ jQuery.camelCase( "default-" + name ) ] = elem[ name ] = true;
		}

		return name;
	}
};

// Retrieve booleans specially
jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {

	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = getSetInput && getSetAttribute || !ruseDefault.test( name ) ?
		function( elem, name, isXML ) {
			var ret, handle;
			if ( !isXML ) {
				// Avoid an infinite loop by temporarily removing this function from the getter
				handle = attrHandle[ name ];
				attrHandle[ name ] = ret;
				ret = getter( elem, name, isXML ) != null ?
					name.toLowerCase() :
					null;
				attrHandle[ name ] = handle;
			}
			return ret;
		} :
		function( elem, name, isXML ) {
			if ( !isXML ) {
				return elem[ jQuery.camelCase( "default-" + name ) ] ?
					name.toLowerCase() :
					null;
			}
		};
});

// fix oldIE attroperties
if ( !getSetInput || !getSetAttribute ) {
	jQuery.attrHooks.value = {
		set: function( elem, value, name ) {
			if ( jQuery.nodeName( elem, "input" ) ) {
				// Does not return so that setAttribute is also used
				elem.defaultValue = value;
			} else {
				// Use nodeHook if defined (#1954); otherwise setAttribute is fine
				return nodeHook && nodeHook.set( elem, value, name );
			}
		}
	};
}

// IE6/7 do not support getting/setting some attributes with get/setAttribute
if ( !getSetAttribute ) {

	// Use this for any attribute in IE6/7
	// This fixes almost every IE6/7 issue
	nodeHook = {
		set: function( elem, value, name ) {
			// Set the existing or create a new attribute node
			var ret = elem.getAttributeNode( name );
			if ( !ret ) {
				elem.setAttributeNode(
					(ret = elem.ownerDocument.createAttribute( name ))
				);
			}

			ret.value = value += "";

			// Break association with cloned elements by also using setAttribute (#9646)
			if ( name === "value" || value === elem.getAttribute( name ) ) {
				return value;
			}
		}
	};

	// Some attributes are constructed with empty-string values when not defined
	attrHandle.id = attrHandle.name = attrHandle.coords =
		function( elem, name, isXML ) {
			var ret;
			if ( !isXML ) {
				return (ret = elem.getAttributeNode( name )) && ret.value !== "" ?
					ret.value :
					null;
			}
		};

	// Fixing value retrieval on a button requires this module
	jQuery.valHooks.button = {
		get: function( elem, name ) {
			var ret = elem.getAttributeNode( name );
			if ( ret && ret.specified ) {
				return ret.value;
			}
		},
		set: nodeHook.set
	};

	// Set contenteditable to false on removals(#10429)
	// Setting to empty string throws an error as an invalid value
	jQuery.attrHooks.contenteditable = {
		set: function( elem, value, name ) {
			nodeHook.set( elem, value === "" ? false : value, name );
		}
	};

	// Set width and height to auto instead of 0 on empty string( Bug #8150 )
	// This is for removals
	jQuery.each([ "width", "height" ], function( i, name ) {
		jQuery.attrHooks[ name ] = {
			set: function( elem, value ) {
				if ( value === "" ) {
					elem.setAttribute( name, "auto" );
					return value;
				}
			}
		};
	});
}

if ( !support.style ) {
	jQuery.attrHooks.style = {
		get: function( elem ) {
			// Return undefined in the case of empty string
			// Note: IE uppercases css property names, but if we were to .toLowerCase()
			// .cssText, that would destroy case senstitivity in URL's, like in "background"
			return elem.style.cssText || undefined;
		},
		set: function( elem, value ) {
			return ( elem.style.cssText = value + "" );
		}
	};
}




var rfocusable = /^(?:input|select|textarea|button|object)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend({
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		name = jQuery.propFix[ name ] || name;
		return this.each(function() {
			// try/catch handles cases where IE balks (such as removing a property on window)
			try {
				this[ name ] = undefined;
				delete this[ name ];
			} catch( e ) {}
		});
	}
});

jQuery.extend({
	propFix: {
		"for": "htmlFor",
		"class": "className"
	},

	prop: function( elem, name, value ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// don't get/set properties on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		if ( notxml ) {
			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			return hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?
				ret :
				( elem[ name ] = value );

		} else {
			return hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ?
				ret :
				elem[ name ];
		}
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {
				// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
				// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				return tabindex ?
					parseInt( tabindex, 10 ) :
					rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
						0 :
						-1;
			}
		}
	}
});

// Some attributes require a special call on IE
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !support.hrefNormalized ) {
	// href/src property should get the full normalized URL (#10299/#12915)
	jQuery.each([ "href", "src" ], function( i, name ) {
		jQuery.propHooks[ name ] = {
			get: function( elem ) {
				return elem.getAttribute( name, 4 );
			}
		};
	});
}

// Support: Safari, IE9+
// mis-reports the default selected property of an option
// Accessing the parent's selectedIndex property fixes it
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {
			var parent = elem.parentNode;

			if ( parent ) {
				parent.selectedIndex;

				// Make sure that it also works with optgroups, see #5701
				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
			return null;
		}
	};
}

jQuery.each([
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
});

// IE6/7 call enctype encoding
if ( !support.enctype ) {
	jQuery.propFix.enctype = "encoding";
}




var rclass = /[\t\r\n\f]/g;

jQuery.fn.extend({
	addClass: function( value ) {
		var classes, elem, cur, clazz, j, finalValue,
			i = 0,
			len = this.length,
			proceed = typeof value === "string" && value;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).addClass( value.call( this, j, this.className ) );
			});
		}

		if ( proceed ) {
			// The disjunction here is for better compressibility (see removeClass)
			classes = ( value || "" ).match( rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					" "
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// only assign if different to avoid unneeded rendering.
					finalValue = jQuery.trim( cur );
					if ( elem.className !== finalValue ) {
						elem.className = finalValue;
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, clazz, j, finalValue,
			i = 0,
			len = this.length,
			proceed = arguments.length === 0 || typeof value === "string" && value;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).removeClass( value.call( this, j, this.className ) );
			});
		}
		if ( proceed ) {
			classes = ( value || "" ).match( rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					""
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// only assign if different to avoid unneeded rendering.
					finalValue = value ? jQuery.trim( cur ) : "";
					if ( elem.className !== finalValue ) {
						elem.className = finalValue;
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value;

		if ( typeof stateVal === "boolean" && type === "string" ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( i ) {
				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
			});
		}

		return this.each(function() {
			if ( type === "string" ) {
				// toggle individual class names
				var className,
					i = 0,
					self = jQuery( this ),
					classNames = value.match( rnotwhite ) || [];

				while ( (className = classNames[ i++ ]) ) {
					// check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( type === strundefined || type === "boolean" ) {
				if ( this.className ) {
					// store className if set
					jQuery._data( this, "__className__", this.className );
				}

				// If the element has a class name or if we're passed "false",
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";
			}
		});
	},

	hasClass: function( selector ) {
		var className = " " + selector + " ",
			i = 0,
			l = this.length;
		for ( ; i < l; i++ ) {
			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
				return true;
			}
		}

		return false;
	}
});




// Return jQuery for attributes-only inclusion


jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
});

jQuery.fn.extend({
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	},

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {
		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
	}
});


var nonce = jQuery.now();

var rquery = (/\?/);



var rvalidtokens = /(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;

jQuery.parseJSON = function( data ) {
	// Attempt to parse using the native JSON parser first
	if ( window.JSON && window.JSON.parse ) {
		// Support: Android 2.3
		// Workaround failure to string-cast null input
		return window.JSON.parse( data + "" );
	}

	var requireNonComma,
		depth = null,
		str = jQuery.trim( data + "" );

	// Guard against invalid (and possibly dangerous) input by ensuring that nothing remains
	// after removing valid tokens
	return str && !jQuery.trim( str.replace( rvalidtokens, function( token, comma, open, close ) {

		// Force termination if we see a misplaced comma
		if ( requireNonComma && comma ) {
			depth = 0;
		}

		// Perform no more replacements after returning to outermost depth
		if ( depth === 0 ) {
			return token;
		}

		// Commas must not follow "[", "{", or ","
		requireNonComma = open || comma;

		// Determine new depth
		// array/object open ("[" or "{"): depth += true - false (increment)
		// array/object close ("]" or "}"): depth += false - true (decrement)
		// other cases ("," or primitive): depth += true - true (numeric cast)
		depth += !close - !open;

		// Remove this token
		return "";
	}) ) ?
		( Function( "return " + str ) )() :
		jQuery.error( "Invalid JSON: " + data );
};


// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml, tmp;
	if ( !data || typeof data !== "string" ) {
		return null;
	}
	try {
		if ( window.DOMParser ) { // Standard
			tmp = new DOMParser();
			xml = tmp.parseFromString( data, "text/xml" );
		} else { // IE
			xml = new ActiveXObject( "Microsoft.XMLDOM" );
			xml.async = "false";
			xml.loadXML( data );
		}
	} catch( e ) {
		xml = undefined;
	}
	if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	// Document location
	ajaxLocParts,
	ajaxLocation,

	rhash = /#.*$/,
	rts = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat("*");

// #8138, IE may throw an exception when accessing
// a field from window.location if document.domain has been set
try {
	ajaxLocation = location.href;
} catch( e ) {
	// Use the href attribute of an A element
	// since IE will modify it given document.location
	ajaxLocation = document.createElement( "a" );
	ajaxLocation.href = "";
	ajaxLocation = ajaxLocation.href;
}

// Segment location into parts
ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

		if ( jQuery.isFunction( func ) ) {
			// For each dataType in the dataTypeExpression
			while ( (dataType = dataTypes[i++]) ) {
				// Prepend if requested
				if ( dataType.charAt( 0 ) === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					(structure[ dataType ] = structure[ dataType ] || []).unshift( func );

				// Otherwise append
				} else {
					(structure[ dataType ] = structure[ dataType ] || []).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		});
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var deep, key,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {
	var firstDataType, ct, finalDataType, type,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {
		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}
		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},
		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {
								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s[ "throws" ] ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend({

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: ajaxLocation,
		type: "GET",
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /xml/,
			html: /html/,
			json: /json/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var // Cross-domain detection vars
			parts,
			// Loop variable
			i,
			// URL without anti-cache param
			cacheURL,
			// Response headers as string
			responseHeadersString,
			// timeout handle
			timeoutTimer,

			// To know if global events are to be dispatched
			fireGlobals,

			transport,
			// Response headers
			responseHeaders,
			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),
			// Callbacks context
			callbackContext = s.context || s,
			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
				jQuery( callbackContext ) :
				jQuery.event,
			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks("once memory"),
			// Status-dependent callbacks
			statusCode = s.statusCode || {},
			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},
			// The jqXHR state
			state = 0,
			// Default abort message
			strAbort = "canceled",
			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( (match = rheaders.exec( responseHeadersString )) ) {
								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					var lname = name.toLowerCase();
					if ( !state ) {
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( state < 2 ) {
							for ( code in map ) {
								// Lazy-add the new callback in a way that preserves old ones
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						} else {
							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR ).complete = completeDeferred.add;
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

		// A cross-domain request is in order when we have a protocol:host:port mismatch
		if ( s.crossDomain == null ) {
			parts = rurl.exec( s.url.toLowerCase() );
			s.crossDomain = !!( parts &&
				( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==
						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )
			);
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( state === 2 ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		fireGlobals = s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger("ajaxStart");
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		cacheURL = s.url;

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add anti-cache in url if needed
			if ( s.cache === false ) {
				s.url = rts.test( cacheURL ) ?

					// If there is already a '_' parameter, set its value
					cacheURL.replace( rts, "$1_=" + nonce++ ) :

					// Otherwise add one to the end
					cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
			}
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
			// Abort if not done already and return
			return jqXHR.abort();
		}

		// aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}
			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = setTimeout(function() {
					jqXHR.abort("timeout");
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch ( e ) {
				// Propagate exception as error if not done
				if ( state < 2 ) {
					done( -1, e );
				// Simply rethrow otherwise
				} else {
					throw e;
				}
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader("Last-Modified");
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader("etag");
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {
				// We extract error from statusText
				// then normalize statusText and status for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger("ajaxStop");
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
});

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
		// shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		return jQuery.ajax({
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		});
	};
});

// Attach a bunch of functions for handling common AJAX events
jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
});


jQuery._evalUrl = function( url ) {
	return jQuery.ajax({
		url: url,
		type: "GET",
		dataType: "script",
		async: false,
		global: false,
		"throws": true
	});
};


jQuery.fn.extend({
	wrapAll: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapAll( html.call(this, i) );
			});
		}

		if ( this[0] ) {
			// The elements to wrap the target around
			var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);

			if ( this[0].parentNode ) {
				wrap.insertBefore( this[0] );
			}

			wrap.map(function() {
				var elem = this;

				while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
					elem = elem.firstChild;
				}

				return elem;
			}).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapInner( html.call(this, i) );
			});
		}

		return this.each(function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		});
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each(function(i) {
			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
		});
	},

	unwrap: function() {
		return this.parent().each(function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		}).end();
	}
});


jQuery.expr.filters.hidden = function( elem ) {
	// Support: Opera <= 12.12
	// Opera reports offsetWidths and offsetHeights less than zero on some elements
	return elem.offsetWidth <= 0 && elem.offsetHeight <= 0 ||
		(!support.reliableHiddenOffsets() &&
			((elem.style && elem.style.display) || jQuery.css( elem, "display" )) === "none");
};

jQuery.expr.filters.visible = function( elem ) {
	return !jQuery.expr.filters.hidden( elem );
};




var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( jQuery.isArray( obj ) ) {
		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
				// Treat each array item as a scalar.
				add( prefix, v );

			} else {
				// Item is non-scalar (array or object), encode its numeric index.
				buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
			}
		});

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {
		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {
		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, value ) {
			// If value is a function, invoke it and return its value
			value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
			s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
		};

	// Set traditional to true for jQuery <= 1.3.2 behavior.
	if ( traditional === undefined ) {
		traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		});

	} else {
		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" ).replace( r20, "+" );
};

jQuery.fn.extend({
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map(function() {
			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		})
		.filter(function() {
			var type = this.type;
			// Use .is(":disabled") so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		})
		.map(function( i, elem ) {
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val ) {
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					}) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		}).get();
	}
});


// Create the request object
// (This is still attached to ajaxSettings for backward compatibility)
jQuery.ajaxSettings.xhr = window.ActiveXObject !== undefined ?
	// Support: IE6+
	function() {

		// XHR cannot access local files, always use ActiveX for that case
		return !this.isLocal &&

			// Support: IE7-8
			// oldIE XHR does not support non-RFC2616 methods (#13240)
			// See http://msdn.microsoft.com/en-us/library/ie/ms536648(v=vs.85).aspx
			// and http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9
			// Although this check for six methods instead of eight
			// since IE also does not support "trace" and "connect"
			/^(get|post|head|put|delete|options)$/i.test( this.type ) &&

			createStandardXHR() || createActiveXHR();
	} :
	// For all other browsers, use the standard XMLHttpRequest object
	createStandardXHR;

var xhrId = 0,
	xhrCallbacks = {},
	xhrSupported = jQuery.ajaxSettings.xhr();

// Support: IE<10
// Open requests must be manually aborted on unload (#5280)
if ( window.ActiveXObject ) {
	jQuery( window ).on( "unload", function() {
		for ( var key in xhrCallbacks ) {
			xhrCallbacks[ key ]( undefined, true );
		}
	});
}

// Determine support properties
support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
xhrSupported = support.ajax = !!xhrSupported;

// Create transport if the browser can provide an xhr
if ( xhrSupported ) {

	jQuery.ajaxTransport(function( options ) {
		// Cross domain only allowed if supported through XMLHttpRequest
		if ( !options.crossDomain || support.cors ) {

			var callback;

			return {
				send: function( headers, complete ) {
					var i,
						xhr = options.xhr(),
						id = ++xhrId;

					// Open the socket
					xhr.open( options.type, options.url, options.async, options.username, options.password );

					// Apply custom fields if provided
					if ( options.xhrFields ) {
						for ( i in options.xhrFields ) {
							xhr[ i ] = options.xhrFields[ i ];
						}
					}

					// Override mime type if needed
					if ( options.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( options.mimeType );
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !options.crossDomain && !headers["X-Requested-With"] ) {
						headers["X-Requested-With"] = "XMLHttpRequest";
					}

					// Set headers
					for ( i in headers ) {
						// Support: IE<9
						// IE's ActiveXObject throws a 'Type Mismatch' exception when setting
						// request header to a null-value.
						//
						// To keep consistent with other XHR implementations, cast the value
						// to string and ignore `undefined`.
						if ( headers[ i ] !== undefined ) {
							xhr.setRequestHeader( i, headers[ i ] + "" );
						}
					}

					// Do send the request
					// This may raise an exception which is actually
					// handled in jQuery.ajax (so no try/catch here)
					xhr.send( ( options.hasContent && options.data ) || null );

					// Listener
					callback = function( _, isAbort ) {
						var status, statusText, responses;

						// Was never called and is aborted or complete
						if ( callback && ( isAbort || xhr.readyState === 4 ) ) {
							// Clean up
							delete xhrCallbacks[ id ];
							callback = undefined;
							xhr.onreadystatechange = jQuery.noop;

							// Abort manually if needed
							if ( isAbort ) {
								if ( xhr.readyState !== 4 ) {
									xhr.abort();
								}
							} else {
								responses = {};
								status = xhr.status;

								// Support: IE<10
								// Accessing binary-data responseText throws an exception
								// (#11426)
								if ( typeof xhr.responseText === "string" ) {
									responses.text = xhr.responseText;
								}

								// Firefox throws an exception when accessing
								// statusText for faulty cross-domain requests
								try {
									statusText = xhr.statusText;
								} catch( e ) {
									// We normalize with Webkit giving an empty statusText
									statusText = "";
								}

								// Filter status for non standard behaviors

								// If the request is local and we have data: assume a success
								// (success with no data won't get notified, that's the best we
								// can do given current implementations)
								if ( !status && options.isLocal && !options.crossDomain ) {
									status = responses.text ? 200 : 404;
								// IE - #1450: sometimes returns 1223 when it should be 204
								} else if ( status === 1223 ) {
									status = 204;
								}
							}
						}

						// Call complete if needed
						if ( responses ) {
							complete( status, statusText, responses, xhr.getAllResponseHeaders() );
						}
					};

					if ( !options.async ) {
						// if we're in sync mode we fire the callback
						callback();
					} else if ( xhr.readyState === 4 ) {
						// (IE6 & IE7) if it's in cache and has been
						// retrieved directly we need to fire the callback
						setTimeout( callback );
					} else {
						// Add to the list of active xhr callbacks
						xhr.onreadystatechange = xhrCallbacks[ id ] = callback;
					}
				},

				abort: function() {
					if ( callback ) {
						callback( undefined, true );
					}
				}
			};
		}
	});
}

// Functions to create xhrs
function createStandardXHR() {
	try {
		return new window.XMLHttpRequest();
	} catch( e ) {}
}

function createActiveXHR() {
	try {
		return new window.ActiveXObject( "Microsoft.XMLHTTP" );
	} catch( e ) {}
}




// Install script dataType
jQuery.ajaxSetup({
	accepts: {
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /(?:java|ecma)script/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
});

// Handle cache's special case and global
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
		s.global = false;
	}
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function(s) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {

		var script,
			head = document.head || jQuery("head")[0] || document.documentElement;

		return {

			send: function( _, callback ) {

				script = document.createElement("script");

				script.async = true;

				if ( s.scriptCharset ) {
					script.charset = s.scriptCharset;
				}

				script.src = s.url;

				// Attach handlers for all browsers
				script.onload = script.onreadystatechange = function( _, isAbort ) {

					if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {

						// Handle memory leak in IE
						script.onload = script.onreadystatechange = null;

						// Remove the script
						if ( script.parentNode ) {
							script.parentNode.removeChild( script );
						}

						// Dereference the script
						script = null;

						// Callback if not abort
						if ( !isAbort ) {
							callback( 200, "success" );
						}
					}
				};

				// Circumvent IE6 bugs with base elements (#2709 and #4378) by prepending
				// Use native DOM manipulation to avoid our domManip AJAX trickery
				head.insertBefore( script, head.firstChild );
			},

			abort: function() {
				if ( script ) {
					script.onload( undefined, true );
				}
			}
		};
	}
});




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup({
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters["script json"] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always(function() {
			// Restore preexisting value
			window[ callbackName ] = overwritten;

			// Save back as free
			if ( s[ callbackName ] ) {
				// make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		});

		// Delegate to script
		return "script";
	}
});




// data: string of html
// context (optional): If specified, the fragment will be created in this context, defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( !data || typeof data !== "string" ) {
		return null;
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}
	context = context || document;

	var parsed = rsingleTag.exec( data ),
		scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[1] ) ];
	}

	parsed = jQuery.buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


// Keep a copy of the old load method
var _load = jQuery.fn.load;

/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	if ( typeof url !== "string" && _load ) {
		return _load.apply( this, arguments );
	}

	var selector, response, type,
		self = this,
		off = url.indexOf(" ");

	if ( off >= 0 ) {
		selector = url.slice( off, url.length );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax({
			url: url,

			// if "type" variable is undefined, then "GET" method will be used
			type: type,
			dataType: "html",
			data: params
		}).done(function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		}).complete( callback && function( jqXHR, status ) {
			self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
		});
	}

	return this;
};




jQuery.expr.filters.animated = function( elem ) {
	return jQuery.grep(jQuery.timers, function( fn ) {
		return elem === fn.elem;
	}).length;
};





var docElem = window.document.documentElement;

/**
 * Gets a window from an element
 */
function getWindow( elem ) {
	return jQuery.isWindow( elem ) ?
		elem :
		elem.nodeType === 9 ?
			elem.defaultView || elem.parentWindow :
			false;
}

jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			jQuery.inArray("auto", [ curCSSTop, curCSSLeft ] ) > -1;

		// need to be able to calculate position if either top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;
		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {
			options = options.call( elem, i, curOffset );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );
		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend({
	offset: function( options ) {
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each(function( i ) {
					jQuery.offset.setOffset( this, options, i );
				});
		}

		var docElem, win,
			box = { top: 0, left: 0 },
			elem = this[ 0 ],
			doc = elem && elem.ownerDocument;

		if ( !doc ) {
			return;
		}

		docElem = doc.documentElement;

		// Make sure it's not a disconnected DOM node
		if ( !jQuery.contains( docElem, elem ) ) {
			return box;
		}

		// If we don't have gBCR, just use 0,0 rather than error
		// BlackBerry 5, iOS 3 (original iPhone)
		if ( typeof elem.getBoundingClientRect !== strundefined ) {
			box = elem.getBoundingClientRect();
		}
		win = getWindow( doc );
		return {
			top: box.top  + ( win.pageYOffset || docElem.scrollTop )  - ( docElem.clientTop  || 0 ),
			left: box.left + ( win.pageXOffset || docElem.scrollLeft ) - ( docElem.clientLeft || 0 )
		};
	},

	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset,
			parentOffset = { top: 0, left: 0 },
			elem = this[ 0 ];

		// fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
		if ( jQuery.css( elem, "position" ) === "fixed" ) {
			// we assume that getBoundingClientRect is available when computed position is fixed
			offset = elem.getBoundingClientRect();
		} else {
			// Get *real* offsetParent
			offsetParent = this.offsetParent();

			// Get correct offsets
			offset = this.offset();
			if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
				parentOffset = offsetParent.offset();
			}

			// Add offsetParent borders
			parentOffset.top  += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
			parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
		}

		// Subtract parent offsets and element margins
		// note: when an element has margin: auto the offsetLeft and marginLeft
		// are the same in Safari causing offset.left to incorrectly be 0
		return {
			top:  offset.top  - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true)
		};
	},

	offsetParent: function() {
		return this.map(function() {
			var offsetParent = this.offsetParent || docElem;

			while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position" ) === "static" ) ) {
				offsetParent = offsetParent.offsetParent;
			}
			return offsetParent || docElem;
		});
	}
});

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = /Y/.test( prop );

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? (prop in win) ? win[ prop ] :
					win.document.documentElement[ method ] :
					elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : jQuery( win ).scrollLeft(),
					top ? val : jQuery( win ).scrollTop()
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length, null );
	};
});

// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// getComputedStyle returns percent when specified for top/left/bottom/right
// rather than make the css module depend on the offset module, we just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );
				// if curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
});


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
		// margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {
					// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
					// isn't a whole lot we can do. See pull request at this URL for discussion:
					// https://github.com/jquery/jquery/pull/764
					return elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest
					// unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it.
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?
					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable, null );
		};
	});
});


// The number of elements contained in the matched element set
jQuery.fn.size = function() {
	return this.length;
};

jQuery.fn.andSelf = jQuery.fn.addBack;




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.
if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	});
}




var
	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in
// AMD (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( typeof noGlobal === strundefined ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;

}));
(function($, undefined) {

/**
 * Unobtrusive scripting adapter for jQuery
 * https://github.com/rails/jquery-ujs
 *
 * Requires jQuery 1.7.0 or later.
 *
 * Released under the MIT license
 *
 */

  // Cut down on the number of issues from people inadvertently including jquery_ujs twice
  // by detecting and raising an error when it happens.
  if ( $.rails !== undefined ) {
    $.error('jquery-ujs has already been loaded!');
  }

  // Shorthand to make it a little easier to call public rails functions from within rails.js
  var rails;
  var $document = $(document);

  $.rails = rails = {
    // Link elements bound by jquery-ujs
    linkClickSelector: 'a[data-confirm], a[data-method], a[data-remote], a[data-disable-with]',

    // Button elements bound by jquery-ujs
    buttonClickSelector: 'button[data-remote]',

    // Select elements bound by jquery-ujs
    inputChangeSelector: 'select[data-remote], input[data-remote], textarea[data-remote]',

    // Form elements bound by jquery-ujs
    formSubmitSelector: 'form',

    // Form input elements bound by jquery-ujs
    formInputClickSelector: 'form input[type=submit], form input[type=image], form button[type=submit], form button:not([type])',

    // Form input elements disabled during form submission
    disableSelector: 'input[data-disable-with], button[data-disable-with], textarea[data-disable-with]',

    // Form input elements re-enabled after form submission
    enableSelector: 'input[data-disable-with]:disabled, button[data-disable-with]:disabled, textarea[data-disable-with]:disabled',

    // Form required input elements
    requiredInputSelector: 'input[name][required]:not([disabled]),textarea[name][required]:not([disabled])',

    // Form file input elements
    fileInputSelector: 'input[type=file]',

    // Link onClick disable selector with possible reenable after remote submission
    linkDisableSelector: 'a[data-disable-with]',

    // Make sure that every Ajax request sends the CSRF token
    CSRFProtection: function(xhr) {
      var token = $('meta[name="csrf-token"]').attr('content');
      if (token) xhr.setRequestHeader('X-CSRF-Token', token);
    },

    // making sure that all forms have actual up-to-date token(cached forms contain old one)
    refreshCSRFTokens: function(){
      var csrfToken = $('meta[name=csrf-token]').attr('content');
      var csrfParam = $('meta[name=csrf-param]').attr('content');
      $('form input[name="' + csrfParam + '"]').val(csrfToken);
    },

    // Triggers an event on an element and returns false if the event result is false
    fire: function(obj, name, data) {
      var event = $.Event(name);
      obj.trigger(event, data);
      return event.result !== false;
    },

    // Default confirm dialog, may be overridden with custom confirm dialog in $.rails.confirm
    confirm: function(message) {
      return confirm(message);
    },

    // Default ajax function, may be overridden with custom function in $.rails.ajax
    ajax: function(options) {
      return $.ajax(options);
    },

    // Default way to get an element's href. May be overridden at $.rails.href.
    href: function(element) {
      return element.attr('href');
    },

    // Submits "remote" forms and links with ajax
    handleRemote: function(element) {
      var method, url, data, elCrossDomain, crossDomain, withCredentials, dataType, options;

      if (rails.fire(element, 'ajax:before')) {
        elCrossDomain = element.data('cross-domain');
        crossDomain = elCrossDomain === undefined ? null : elCrossDomain;
        withCredentials = element.data('with-credentials') || null;
        dataType = element.data('type') || ($.ajaxSettings && $.ajaxSettings.dataType);

        if (element.is('form')) {
          method = element.attr('method');
          url = element.attr('action');
          data = element.serializeArray();
          // memoized value from clicked submit button
          var button = element.data('ujs:submit-button');
          if (button) {
            data.push(button);
            element.data('ujs:submit-button', null);
          }
        } else if (element.is(rails.inputChangeSelector)) {
          method = element.data('method');
          url = element.data('url');
          data = element.serialize();
          if (element.data('params')) data = data + "&" + element.data('params');
        } else if (element.is(rails.buttonClickSelector)) {
          method = element.data('method') || 'get';
          url = element.data('url');
          data = element.serialize();
          if (element.data('params')) data = data + "&" + element.data('params');
        } else {
          method = element.data('method');
          url = rails.href(element);
          data = element.data('params') || null;
        }

        options = {
          type: method || 'GET', data: data, dataType: dataType,
          // stopping the "ajax:beforeSend" event will cancel the ajax request
          beforeSend: function(xhr, settings) {
            if (settings.dataType === undefined) {
              xhr.setRequestHeader('accept', '*/*;q=0.5, ' + settings.accepts.script);
            }
            return rails.fire(element, 'ajax:beforeSend', [xhr, settings]);
          },
          success: function(data, status, xhr) {
            element.trigger('ajax:success', [data, status, xhr]);
          },
          complete: function(xhr, status) {
            element.trigger('ajax:complete', [xhr, status]);
          },
          error: function(xhr, status, error) {
            element.trigger('ajax:error', [xhr, status, error]);
          },
          crossDomain: crossDomain
        };

        // There is no withCredentials for IE6-8 when
        // "Enable native XMLHTTP support" is disabled
        if (withCredentials) {
          options.xhrFields = {
            withCredentials: withCredentials
          };
        }

        // Only pass url to `ajax` options if not blank
        if (url) { options.url = url; }

        var jqxhr = rails.ajax(options);
        element.trigger('ajax:send', jqxhr);
        return jqxhr;
      } else {
        return false;
      }
    },

    // Handles "data-method" on links such as:
    // <a href="/users/5" data-method="delete" rel="nofollow" data-confirm="Are you sure?">Delete</a>
    handleMethod: function(link) {
      var href = rails.href(link),
        method = link.data('method'),
        target = link.attr('target'),
        csrfToken = $('meta[name=csrf-token]').attr('content'),
        csrfParam = $('meta[name=csrf-param]').attr('content'),
        form = $('<form method="post" action="' + href + '"></form>'),
        metadataInput = '<input name="_method" value="' + method + '" type="hidden" />';

      if (csrfParam !== undefined && csrfToken !== undefined) {
        metadataInput += '<input name="' + csrfParam + '" value="' + csrfToken + '" type="hidden" />';
      }

      if (target) { form.attr('target', target); }

      form.hide().append(metadataInput).appendTo('body');
      form.submit();
    },

    /* Disables form elements:
      - Caches element value in 'ujs:enable-with' data store
      - Replaces element text with value of 'data-disable-with' attribute
      - Sets disabled property to true
    */
    disableFormElements: function(form) {
      form.find(rails.disableSelector).each(function() {
        var element = $(this), method = element.is('button') ? 'html' : 'val';
        element.data('ujs:enable-with', element[method]());
        element[method](element.data('disable-with'));
        element.prop('disabled', true);
      });
    },

    /* Re-enables disabled form elements:
      - Replaces element text with cached value from 'ujs:enable-with' data store (created in `disableFormElements`)
      - Sets disabled property to false
    */
    enableFormElements: function(form) {
      form.find(rails.enableSelector).each(function() {
        var element = $(this), method = element.is('button') ? 'html' : 'val';
        if (element.data('ujs:enable-with')) element[method](element.data('ujs:enable-with'));
        element.prop('disabled', false);
      });
    },

   /* For 'data-confirm' attribute:
      - Fires `confirm` event
      - Shows the confirmation dialog
      - Fires the `confirm:complete` event

      Returns `true` if no function stops the chain and user chose yes; `false` otherwise.
      Attaching a handler to the element's `confirm` event that returns a `falsy` value cancels the confirmation dialog.
      Attaching a handler to the element's `confirm:complete` event that returns a `falsy` value makes this function
      return false. The `confirm:complete` event is fired whether or not the user answered true or false to the dialog.
   */
    allowAction: function(element) {
      var message = element.data('confirm'),
          answer = false, callback;
      if (!message) { return true; }

      if (rails.fire(element, 'confirm')) {
        answer = rails.confirm(message);
        callback = rails.fire(element, 'confirm:complete', [answer]);
      }
      return answer && callback;
    },

    // Helper function which checks for blank inputs in a form that match the specified CSS selector
    blankInputs: function(form, specifiedSelector, nonBlank) {
      var inputs = $(), input, valueToCheck,
          selector = specifiedSelector || 'input,textarea',
          allInputs = form.find(selector);

      allInputs.each(function() {
        input = $(this);
        valueToCheck = input.is('input[type=checkbox],input[type=radio]') ? input.is(':checked') : input.val();
        // If nonBlank and valueToCheck are both truthy, or nonBlank and valueToCheck are both falsey
        if (!valueToCheck === !nonBlank) {

          // Don't count unchecked required radio if other radio with same name is checked
          if (input.is('input[type=radio]') && allInputs.filter('input[type=radio]:checked[name="' + input.attr('name') + '"]').length) {
            return true; // Skip to next input
          }

          inputs = inputs.add(input);
        }
      });
      return inputs.length ? inputs : false;
    },

    // Helper function which checks for non-blank inputs in a form that match the specified CSS selector
    nonBlankInputs: function(form, specifiedSelector) {
      return rails.blankInputs(form, specifiedSelector, true); // true specifies nonBlank
    },

    // Helper function, needed to provide consistent behavior in IE
    stopEverything: function(e) {
      $(e.target).trigger('ujs:everythingStopped');
      e.stopImmediatePropagation();
      return false;
    },

    //  replace element's html with the 'data-disable-with' after storing original html
    //  and prevent clicking on it
    disableElement: function(element) {
      element.data('ujs:enable-with', element.html()); // store enabled state
      element.html(element.data('disable-with')); // set to disabled state
      element.bind('click.railsDisable', function(e) { // prevent further clicking
        return rails.stopEverything(e);
      });
    },

    // restore element to its original state which was disabled by 'disableElement' above
    enableElement: function(element) {
      if (element.data('ujs:enable-with') !== undefined) {
        element.html(element.data('ujs:enable-with')); // set to old enabled state
        element.removeData('ujs:enable-with'); // clean up cache
      }
      element.unbind('click.railsDisable'); // enable element
    }

  };

  if (rails.fire($document, 'rails:attachBindings')) {

    $.ajaxPrefilter(function(options, originalOptions, xhr){ if ( !options.crossDomain ) { rails.CSRFProtection(xhr); }});

    $document.delegate(rails.linkDisableSelector, 'ajax:complete', function() {
        rails.enableElement($(this));
    });

    $document.delegate(rails.linkClickSelector, 'click.rails', function(e) {
      var link = $(this), method = link.data('method'), data = link.data('params'), metaClick = e.metaKey || e.ctrlKey;
      if (!rails.allowAction(link)) return rails.stopEverything(e);

      if (!metaClick && link.is(rails.linkDisableSelector)) rails.disableElement(link);

      if (link.data('remote') !== undefined) {
        if (metaClick && (!method || method === 'GET') && !data) { return true; }

        var handleRemote = rails.handleRemote(link);
        // response from rails.handleRemote() will either be false or a deferred object promise.
        if (handleRemote === false) {
          rails.enableElement(link);
        } else {
          handleRemote.error( function() { rails.enableElement(link); } );
        }
        return false;

      } else if (link.data('method')) {
        rails.handleMethod(link);
        return false;
      }
    });

    $document.delegate(rails.buttonClickSelector, 'click.rails', function(e) {
      var button = $(this);
      if (!rails.allowAction(button)) return rails.stopEverything(e);

      rails.handleRemote(button);
      return false;
    });

    $document.delegate(rails.inputChangeSelector, 'change.rails', function(e) {
      var link = $(this);
      if (!rails.allowAction(link)) return rails.stopEverything(e);

      rails.handleRemote(link);
      return false;
    });

    $document.delegate(rails.formSubmitSelector, 'submit.rails', function(e) {
      var form = $(this),
        remote = form.data('remote') !== undefined,
        blankRequiredInputs = rails.blankInputs(form, rails.requiredInputSelector),
        nonBlankFileInputs = rails.nonBlankInputs(form, rails.fileInputSelector);

      if (!rails.allowAction(form)) return rails.stopEverything(e);

      // skip other logic when required values are missing or file upload is present
      if (blankRequiredInputs && form.attr("novalidate") == undefined && rails.fire(form, 'ajax:aborted:required', [blankRequiredInputs])) {
        return rails.stopEverything(e);
      }

      if (remote) {
        if (nonBlankFileInputs) {
          // slight timeout so that the submit button gets properly serialized
          // (make it easy for event handler to serialize form without disabled values)
          setTimeout(function(){ rails.disableFormElements(form); }, 13);
          var aborted = rails.fire(form, 'ajax:aborted:file', [nonBlankFileInputs]);

          // re-enable form elements if event bindings return false (canceling normal form submission)
          if (!aborted) { setTimeout(function(){ rails.enableFormElements(form); }, 13); }

          return aborted;
        }

        rails.handleRemote(form);
        return false;

      } else {
        // slight timeout so that the submit button gets properly serialized
        setTimeout(function(){ rails.disableFormElements(form); }, 13);
      }
    });

    $document.delegate(rails.formInputClickSelector, 'click.rails', function(event) {
      var button = $(this);

      if (!rails.allowAction(button)) return rails.stopEverything(event);

      // register the pressed submit button
      var name = button.attr('name'),
        data = name ? {name:name, value:button.val()} : null;

      button.closest('form').data('ujs:submit-button', data);
    });

    $document.delegate(rails.formSubmitSelector, 'ajax:beforeSend.rails', function(event) {
      if (this == event.target) rails.disableFormElements($(this));
    });

    $document.delegate(rails.formSubmitSelector, 'ajax:complete.rails', function(event) {
      if (this == event.target) rails.enableFormElements($(this));
    });

    $(function(){
      rails.refreshCSRFTokens();
    });
  }

})( jQuery );
(function(m,j){var d={},e=1,f=m.fn.each,k=m.fn.on||m.fn.bind,n=m.fn.off||m.fn.unbind,l={};function a(p,q){q=m(q);q.prevObject=p;var o=p.length;if(o!==q.length){return q}while(o--){if(p[o]!==q[o]){return q}}return p}function c(o){var p=[],q=o.length;while(q--){p[q]=o[q].g}return p}function h(p,w,t,s){t=t||[];var u={f:p,i:w},q=false,o,x,y;function v(A,B){A.e=false;function z(){A.k=a(A.f,A.k);A.e=true;r()}return typeof B.promise=="function"?B.promise().then(z):B.then(z,true)}function r(A){while(!q){try{q=!q;if(typeof s=="function"){s(m.makeArray(u.k||u.f))}if(u.e==false){break}if(!u.i.j){if(y&&(!t.length||t[0].b)){if(u.f&&typeof u.f.promise=="function"){u.f.promise().then(y.resolve)}else{y.resolveWith(u.f)}y=null}if(!t.length){return u.f}x=t[0].l&&t[0].l(r,u,t);if(!x){break}u=x;continue}o=u.f&&u.f[u.i.j]||l[u.i.j];if(!o){throw'no such method "'+u.i.j+'" on object ('+u.f+")"}if(o.timing&&!u.e){u.e=false;u=o.timing(r,u,t,s)||u}else{if(!o.timing&&!u.e){u.k=u.f[u.i.j].apply(u.f,u.i.c);if(t.length&&u.k&&u.k instanceof g){v(u,u.k);continue}}x={f:u.k,i:u.i.k};u.e=false;if(typeof u.d=="function"){u.d.apply(u.f,c(t))}u=x}}catch(z){q=!q;throw z}finally{q=!q}}return A}if(m.Deferred){r.promise=function(A,B){var z=(y=y||m.Deferred()).promise(B);r();return z}}return r}function g(q,r,p){this[".methods"]=r;this[".callback"]=p;this.length=0;Array.prototype.push.apply(this,m.makeArray(this._=q._=q));for(var o in q){if(!(o in g.prototype)&&typeof q[o]=="function"){this[o]=i(o)}}}if(m.Deferred){g.prototype.promise=function(o,p){if(typeof o=="object"){p=o;o=null}return(this[".callback"]&&typeof this[".callback"].promise=="function")?this[".callback"].promise(o,p):m.Deferred().resolveWith(this).promise(p)}}function i(o){return g.prototype[o]=function(){this[".methods"].j=o;this[".methods"].c=arguments;this[".methods"]=this[".methods"].k={};return this[".callback"]?this[".callback"](this,o,arguments):this}}m.each(["bind","on","one","live","delegate"],function(p,o){if(m.fn[o]){var q=m.fn[o];m.fn[o]=function(){var u,x,w,s,r,t=this;for(u=0;u<arguments.length;u++){if(typeof arguments[u]=="function"||(arguments[u]&&typeof arguments[u]=="object")||arguments[u]===false){if(arguments[u]!==m){if(typeof arguments[u]=="function"&&m.guid){arguments[u].guid=arguments[u].guid||m.guid++}return q.apply(t,arguments)}break}}Array.prototype.splice.call(arguments,u,1,function(){s=h(t.$(this),x,[{g:m.extend(Array.prototype.shift.apply(arguments),arguments),b:true}],function(y){w.length=0;Array.prototype.push.apply(w,y)});if(r){s.promise().then(r.resolve);r=null}return s()});function v(){return s?s(w):w}if(m.Deferred){v.promise=function(y,z){if(typeof y=="object"){z=y;y=null}return(s&&!y)?s.promise(y,z):(r=r||m.Deferred()).promise(z)}}return w=new g(q.apply(t,arguments),x={},v)}}});m.each(["animate","load"],function(p,o){if(m.fn[o]){var q=m.fn[o];m.fn[o]=function(){while(arguments.length&&arguments[arguments.length-1]==null){Array.prototype.pop.apply(arguments)}if(this.length&&arguments.length>1&&arguments[arguments.length-1]===m){var r="_timing"+e++;arguments[arguments.length-1]=function(){m(this).trigger(r)};return this.each().one(r).all(q.apply(this,arguments))}return q.apply(this,arguments)}}});m.each(["wait","repeat","join","then"],function(p,o){m.fn[o]=function(){var r={},q=new g(this,r,h(this,r,[],function(s){q.length=0;Array.prototype.push.apply(q,s)}));return q[o].apply(q,arguments)}});m.fn.join.timing=function(p,r){var q,o,s=r.f.length;if(typeof r.i.c[0]=="string"){q=r.i.c[0];if(typeof r.i.c[1]=="function"){r.d=r.i.c[1]}else{o=r.i.c[1];r.d=r.i.c[2]}}else{if(typeof r.i.c[0]=="function"){r.d=r.i.c[0]}else{o=r.i.c[0];r.d=r.i.c[1]}}r.k=r.f;r.e=!s;if(o){r.f.promise(q==null?"fx":q).then(function(){r.e=true;p()})}else{r.f.queue(q==null?"fx":q,function(t){r.e=!--s;p();t()})}};m.fn.then.timing=function(o,p){p.d=p.i.c[0];p.k=p.f;p.e=true;if(p.i.c[1]){Array.prototype.shift.apply(p.i.c)}};m.fn.wait.timing=function(s,t,u){var r,o,v,p=t.f;r=t.i.c[0];t.d=t.i.c[1];function w(){n.call(o?n.call(p,o,w):p,"unwait",q);t.e=true;t.k=a(t.f,t.k);s()}function q(x,y){n.call(o?n.call(m(this),o,w):m(this),"unwait",q);p=p.not(this);if(!y){t.k=t.k.not(this)}if(!p.length){t.e=t.k.length;t.k=a(t.f,t.k);j.clearTimeout(v);t={f:p}}s()}k.call(p,"unwait",q);t.k=p;if(r==null||r==m){r=p}if(typeof r=="function"){r=r.apply(p,c(u))}if(typeof r=="string"){k.call(p,o=r,w)}else{if(r&&typeof r.promise=="function"){r.promise().then(w)}else{if(r&&typeof r.then=="function"){r.then(w,true)}else{v=j.setTimeout(w,Math.max(0,r))}}}};m.fn.each=function(q){if(!q||q===m){var p={},o=new g(this,p,h(this,p,[],function(r){o.length=0;Array.prototype.push.apply(o,r)}));return o.each(q)}return f.apply(this,arguments)};m.fn.each.timing=function(r,v,w,u){if(v.i.c[0]&&v.i.c[0]!==m){v.e=true;v.k=f.apply(v.f,v.i.c);return}var B=Math.max(v.f.length,1),p=0,y,s,t,A=[],z=[],x=m.extend({},v.f),q=v.i.c[0]===m;if(q){j.setTimeout(function(){t=true;r()},0)}function o(){if(q){if(p<B){(A[p])()}}else{for(var C=0;C<B;C++){(A[C])()}}return x}for(y in g.prototype){x[y]=o}x.length=B;for(y=0;y<B;y++){(function(C){var E=w.slice(),D=v.f.eq(C);z[C]=D.get();E.unshift({g:C,a:function(F){p++;if(p==B){s=F.i.k}r()},h:l.all,l:function(G,F){if(t){p++;if(p==B){s=F.i}r()}}});A[C]=h(D,v.i.k,E,function(G){z[C]=G;x.length=0;for(var F=0;F<B;F++){Array.prototype.push.apply(x,z[F])}if(u){u(m.makeArray(x))}})})(y)}v.k=x;v.e=true;v.l=function(E,D){if(p==B){w.shift();return{f:a(v.f,x),i:s}}var C=p;o();if(p!=C){return D}};v.g=B;w.unshift(v)};l.all=function(o){m.extend(o.i,{k:m.extend({},o.i),j:"all",c:[]});o.e=null};l.all.timing=function(o,q,p){if(!p.length||!p[0].h){throw".all() method must be used after .each() only"}if(!p[0].a){p[0].h(q);return}p[0].a(q)};m.fn.repeat.timing=function(s,v,w){var q,t,u,o,p;if(typeof v.i.c[0]=="function"){v.d=v.i.c[0]}else{if(typeof v.i.c[1]=="function"){q=v.i.c[0];v.d=v.i.c[1]}else{q=v.i.c[0];t=v.i.c[1];v.d=v.i.c[2]}}function x(){v.k=v.k||v.f;v.e=true;s()}function r(){n.call(o?n.call(m(this),o,x):m(this),"unrepeat",r);var y=v.f.not(this);v.k=(v.k==v.f)?y:v.k;v.f=y;v.e=v.f.length&&v.e;q=v.f.length&&q;j.clearInterval(!v.f.length&&p);s()}v.l=function(z,y){if(v.e||u){v.g++;v.k=v.k||v.f;v.e=v.e||(q&&y.f&&y.f.length);return v}};if(q==null){t=q=true;j.setTimeout(function(){u=true;s()},0)}else{if(typeof q=="string"){k.call(v.f,o=q,x)}else{p=j.setInterval(x,Math.max(0,q))}q=false}k.call(v.f,"unrepeat",r);v.k=v.f;v.g=0;v.n=function(y){if(y){r.apply(v.f)}if(q){x()}};v.h=l.until;if(t){x()}w.unshift(v)};l.until=function(o){m.extend(o.i,{k:m.extend({},o.i),j:"until",c:[]});o.e=null};l.until.timing=function(o,r,q){if(!q.length||!q[0].h){throw".until() method must be used after .repeat() only"}if(!q[0].n){q[0].h(r);return}var s=r.i.c[0],p=r.i.c[1];if(s===m){s=null;p=r.i.c.length<=1||p}if(typeof s=="function"){s=s.apply(r.f,c(q))}if(s==null){s=!r.f.size()}if(typeof s=="object"){s=s.toString()}if(typeof s=="number"){s=q[0].g>=s-1}if(s){r.e=true;r.k=r.f;q.shift().n(s)}else{if(p){q[0].k=r.f}r=q[0];r.g++;r.n(s);return r}};new g(l);m.each(["unwait","unrepeat"],function(p,o){m.fn[o]=function(){return this.trigger(o,arguments)}});m.each(["wait","repeat","join","then","unwait","unrepeat"],function(p,o){m[o]=function(){var q=typeof arguments[0]=="string"?Array.prototype.shift.apply(arguments):"";return m.fn[o].apply(d[q]=(d[q]||m("<div>").text(q)),arguments)}});function b(r,u,q){if(typeof r=="string"){q=new Function("x","return ["+r+"\n,x]");r=function(w,v){v=q(w);p.x=v[1];return v[0]}}var o=typeof u=="function",t=typeof r=="function",p=function(v){if(arguments.length==1){p.x=v;if(o){u(v)}}else{return s()}};function s(v){v=o?u():p.x;return t?r(v):v}p.x=0;p._={toString:p.$=p.toString=s.toString=s};p.mod=function(v){return b(function(w){return w%v},p)};p.add=function(v){return b(function(w){return w+v},p)};p.neg=function(){return b("-x",p)};p.$$=p.X=function(v){return b(v,p)};m.each(["a","b","c","d","e","f","g","h","i","j"],function(v,w){p[v]=p[w]=function(){p(arguments[v])}});return p}j.$$=m.$$=m.X=b;m.fn.$=function(){var o=m.apply(j,arguments);o.prevObject=this;return o}})(jQuery,window);
/* ========================================================================
 * Bootstrap: affix.js v3.2.0
 * http://getbootstrap.com/javascript/#affix
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */



+function ($) {
  'use strict';

  // AFFIX CLASS DEFINITION
  // ======================

  var Affix = function (element, options) {
    this.options = $.extend({}, Affix.DEFAULTS, options)

    this.$target = $(this.options.target)
      .on('scroll.bs.affix.data-api', $.proxy(this.checkPosition, this))
      .on('click.bs.affix.data-api',  $.proxy(this.checkPositionWithEventLoop, this))

    this.$element     = $(element)
    this.affixed      =
    this.unpin        =
    this.pinnedOffset = null

    this.checkPosition()
  }

  Affix.VERSION  = '3.2.0'

  Affix.RESET    = 'affix affix-top affix-bottom'

  Affix.DEFAULTS = {
    offset: 0,
    target: window
  }

  Affix.prototype.getPinnedOffset = function () {
    if (this.pinnedOffset) return this.pinnedOffset
    this.$element.removeClass(Affix.RESET).addClass('affix')
    var scrollTop = this.$target.scrollTop()
    var position  = this.$element.offset()
    return (this.pinnedOffset = position.top - scrollTop)
  }

  Affix.prototype.checkPositionWithEventLoop = function () {
    setTimeout($.proxy(this.checkPosition, this), 1)
  }

  Affix.prototype.checkPosition = function () {
    if (!this.$element.is(':visible')) return

    var scrollHeight = $(document).height()
    var scrollTop    = this.$target.scrollTop()
    var position     = this.$element.offset()
    var offset       = this.options.offset
    var offsetTop    = offset.top
    var offsetBottom = offset.bottom

    if (typeof offset != 'object')         offsetBottom = offsetTop = offset
    if (typeof offsetTop == 'function')    offsetTop    = offset.top(this.$element)
    if (typeof offsetBottom == 'function') offsetBottom = offset.bottom(this.$element)

    var affix = this.unpin   != null && (scrollTop + this.unpin <= position.top) ? false :
                offsetBottom != null && (position.top + this.$element.height() >= scrollHeight - offsetBottom) ? 'bottom' :
                offsetTop    != null && (scrollTop <= offsetTop) ? 'top' : false

    if (this.affixed === affix) return
    if (this.unpin != null) this.$element.css('top', '')

    var affixType = 'affix' + (affix ? '-' + affix : '')
    var e         = $.Event(affixType + '.bs.affix')

    this.$element.trigger(e)

    if (e.isDefaultPrevented()) return

    this.affixed = affix
    this.unpin = affix == 'bottom' ? this.getPinnedOffset() : null

    this.$element
      .removeClass(Affix.RESET)
      .addClass(affixType)
      .trigger($.Event(affixType.replace('affix', 'affixed')))

    if (affix == 'bottom') {
      this.$element.offset({
        top: scrollHeight - this.$element.height() - offsetBottom
      })
    }
  }


  // AFFIX PLUGIN DEFINITION
  // =======================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.affix')
      var options = typeof option == 'object' && option

      if (!data) $this.data('bs.affix', (data = new Affix(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.affix

  $.fn.affix             = Plugin
  $.fn.affix.Constructor = Affix


  // AFFIX NO CONFLICT
  // =================

  $.fn.affix.noConflict = function () {
    $.fn.affix = old
    return this
  }


  // AFFIX DATA-API
  // ==============

  $(window).on('load', function () {
    $('[data-spy="affix"]').each(function () {
      var $spy = $(this)
      var data = $spy.data()

      data.offset = data.offset || {}

      if (data.offsetBottom) data.offset.bottom = data.offsetBottom
      if (data.offsetTop)    data.offset.top    = data.offsetTop

      Plugin.call($spy, data)
    })
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: alert.js v3.2.0
 * http://getbootstrap.com/javascript/#alerts
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // ALERT CLASS DEFINITION
  // ======================

  var dismiss = '[data-dismiss="alert"]'
  var Alert   = function (el) {
    $(el).on('click', dismiss, this.close)
  }

  Alert.VERSION = '3.2.0'

  Alert.prototype.close = function (e) {
    var $this    = $(this)
    var selector = $this.attr('data-target')

    if (!selector) {
      selector = $this.attr('href')
      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
    }

    var $parent = $(selector)

    if (e) e.preventDefault()

    if (!$parent.length) {
      $parent = $this.hasClass('alert') ? $this : $this.parent()
    }

    $parent.trigger(e = $.Event('close.bs.alert'))

    if (e.isDefaultPrevented()) return

    $parent.removeClass('in')

    function removeElement() {
      // detach from parent, fire event then clean up data
      $parent.detach().trigger('closed.bs.alert').remove()
    }

    $.support.transition && $parent.hasClass('fade') ?
      $parent
        .one('bsTransitionEnd', removeElement)
        .emulateTransitionEnd(150) :
      removeElement()
  }


  // ALERT PLUGIN DEFINITION
  // =======================

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this)
      var data  = $this.data('bs.alert')

      if (!data) $this.data('bs.alert', (data = new Alert(this)))
      if (typeof option == 'string') data[option].call($this)
    })
  }

  var old = $.fn.alert

  $.fn.alert             = Plugin
  $.fn.alert.Constructor = Alert


  // ALERT NO CONFLICT
  // =================

  $.fn.alert.noConflict = function () {
    $.fn.alert = old
    return this
  }


  // ALERT DATA-API
  // ==============

  $(document).on('click.bs.alert.data-api', dismiss, Alert.prototype.close)

}(jQuery);

/* ========================================================================
 * Bootstrap: button.js v3.2.0
 * http://getbootstrap.com/javascript/#buttons
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // BUTTON PUBLIC CLASS DEFINITION
  // ==============================

  var Button = function (element, options) {
    this.$element  = $(element)
    this.options   = $.extend({}, Button.DEFAULTS, options)
    this.isLoading = false
  }

  Button.VERSION  = '3.2.0'

  Button.DEFAULTS = {
    loadingText: 'loading...'
  }

  Button.prototype.setState = function (state) {
    var d    = 'disabled'
    var $el  = this.$element
    var val  = $el.is('input') ? 'val' : 'html'
    var data = $el.data()

    state = state + 'Text'

    if (data.resetText == null) $el.data('resetText', $el[val]())

    $el[val](data[state] == null ? this.options[state] : data[state])

    // push to event loop to allow forms to submit
    setTimeout($.proxy(function () {
      if (state == 'loadingText') {
        this.isLoading = true
        $el.addClass(d).attr(d, d)
      } else if (this.isLoading) {
        this.isLoading = false
        $el.removeClass(d).removeAttr(d)
      }
    }, this), 0)
  }

  Button.prototype.toggle = function () {
    var changed = true
    var $parent = this.$element.closest('[data-toggle="buttons"]')

    if ($parent.length) {
      var $input = this.$element.find('input')
      if ($input.prop('type') == 'radio') {
        if ($input.prop('checked') && this.$element.hasClass('active')) changed = false
        else $parent.find('.active').removeClass('active')
      }
      if (changed) $input.prop('checked', !this.$element.hasClass('active')).trigger('change')
    }

    if (changed) this.$element.toggleClass('active')
  }


  // BUTTON PLUGIN DEFINITION
  // ========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.button')
      var options = typeof option == 'object' && option

      if (!data) $this.data('bs.button', (data = new Button(this, options)))

      if (option == 'toggle') data.toggle()
      else if (option) data.setState(option)
    })
  }

  var old = $.fn.button

  $.fn.button             = Plugin
  $.fn.button.Constructor = Button


  // BUTTON NO CONFLICT
  // ==================

  $.fn.button.noConflict = function () {
    $.fn.button = old
    return this
  }


  // BUTTON DATA-API
  // ===============

  $(document).on('click.bs.button.data-api', '[data-toggle^="button"]', function (e) {
    var $btn = $(e.target)
    if (!$btn.hasClass('btn')) $btn = $btn.closest('.btn')
    Plugin.call($btn, 'toggle')
    e.preventDefault()
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: carousel.js v3.2.0
 * http://getbootstrap.com/javascript/#carousel
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // CAROUSEL CLASS DEFINITION
  // =========================

  var Carousel = function (element, options) {
    this.$element    = $(element).on('keydown.bs.carousel', $.proxy(this.keydown, this))
    this.$indicators = this.$element.find('.carousel-indicators')
    this.options     = options
    this.paused      =
    this.sliding     =
    this.interval    =
    this.$active     =
    this.$items      = null

    this.options.pause == 'hover' && this.$element
      .on('mouseenter.bs.carousel', $.proxy(this.pause, this))
      .on('mouseleave.bs.carousel', $.proxy(this.cycle, this))
  }

  Carousel.VERSION  = '3.2.0'

  Carousel.DEFAULTS = {
    interval: 5000,
    pause: 'hover',
    wrap: true
  }

  Carousel.prototype.keydown = function (e) {
    switch (e.which) {
      case 37: this.prev(); break
      case 39: this.next(); break
      default: return
    }

    e.preventDefault()
  }

  Carousel.prototype.cycle = function (e) {
    e || (this.paused = false)

    this.interval && clearInterval(this.interval)

    this.options.interval
      && !this.paused
      && (this.interval = setInterval($.proxy(this.next, this), this.options.interval))

    return this
  }

  Carousel.prototype.getItemIndex = function (item) {
    this.$items = item.parent().children('.item')
    return this.$items.index(item || this.$active)
  }

  Carousel.prototype.to = function (pos) {
    var that        = this
    var activeIndex = this.getItemIndex(this.$active = this.$element.find('.item.active'))

    if (pos > (this.$items.length - 1) || pos < 0) return

    if (this.sliding)       return this.$element.one('slid.bs.carousel', function () { that.to(pos) }) // yes, "slid"
    if (activeIndex == pos) return this.pause().cycle()

    return this.slide(pos > activeIndex ? 'next' : 'prev', $(this.$items[pos]))
  }

  Carousel.prototype.pause = function (e) {
    e || (this.paused = true)

    if (this.$element.find('.next, .prev').length && $.support.transition) {
      this.$element.trigger($.support.transition.end)
      this.cycle(true)
    }

    this.interval = clearInterval(this.interval)

    return this
  }

  Carousel.prototype.next = function () {
    if (this.sliding) return
    return this.slide('next')
  }

  Carousel.prototype.prev = function () {
    if (this.sliding) return
    return this.slide('prev')
  }

  Carousel.prototype.slide = function (type, next) {
    var $active   = this.$element.find('.item.active')
    var $next     = next || $active[type]()
    var isCycling = this.interval
    var direction = type == 'next' ? 'left' : 'right'
    var fallback  = type == 'next' ? 'first' : 'last'
    var that      = this

    if (!$next.length) {
      if (!this.options.wrap) return
      $next = this.$element.find('.item')[fallback]()
    }

    if ($next.hasClass('active')) return (this.sliding = false)

    var relatedTarget = $next[0]
    var slideEvent = $.Event('slide.bs.carousel', {
      relatedTarget: relatedTarget,
      direction: direction
    })
    this.$element.trigger(slideEvent)
    if (slideEvent.isDefaultPrevented()) return

    this.sliding = true

    isCycling && this.pause()

    if (this.$indicators.length) {
      this.$indicators.find('.active').removeClass('active')
      var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)])
      $nextIndicator && $nextIndicator.addClass('active')
    }

    var slidEvent = $.Event('slid.bs.carousel', { relatedTarget: relatedTarget, direction: direction }) // yes, "slid"
    if ($.support.transition && this.$element.hasClass('slide')) {
      $next.addClass(type)
      $next[0].offsetWidth // force reflow
      $active.addClass(direction)
      $next.addClass(direction)
      $active
        .one('bsTransitionEnd', function () {
          $next.removeClass([type, direction].join(' ')).addClass('active')
          $active.removeClass(['active', direction].join(' '))
          that.sliding = false
          setTimeout(function () {
            that.$element.trigger(slidEvent)
          }, 0)
        })
        .emulateTransitionEnd($active.css('transition-duration').slice(0, -1) * 1000)
    } else {
      $active.removeClass('active')
      $next.addClass('active')
      this.sliding = false
      this.$element.trigger(slidEvent)
    }

    isCycling && this.cycle()

    return this
  }


  // CAROUSEL PLUGIN DEFINITION
  // ==========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.carousel')
      var options = $.extend({}, Carousel.DEFAULTS, $this.data(), typeof option == 'object' && option)
      var action  = typeof option == 'string' ? option : options.slide

      if (!data) $this.data('bs.carousel', (data = new Carousel(this, options)))
      if (typeof option == 'number') data.to(option)
      else if (action) data[action]()
      else if (options.interval) data.pause().cycle()
    })
  }

  var old = $.fn.carousel

  $.fn.carousel             = Plugin
  $.fn.carousel.Constructor = Carousel


  // CAROUSEL NO CONFLICT
  // ====================

  $.fn.carousel.noConflict = function () {
    $.fn.carousel = old
    return this
  }


  // CAROUSEL DATA-API
  // =================

  $(document).on('click.bs.carousel.data-api', '[data-slide], [data-slide-to]', function (e) {
    var href
    var $this   = $(this)
    var $target = $($this.attr('data-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '')) // strip for ie7
    if (!$target.hasClass('carousel')) return
    var options = $.extend({}, $target.data(), $this.data())
    var slideIndex = $this.attr('data-slide-to')
    if (slideIndex) options.interval = false

    Plugin.call($target, options)

    if (slideIndex) {
      $target.data('bs.carousel').to(slideIndex)
    }

    e.preventDefault()
  })

  $(window).on('load', function () {
    $('[data-ride="carousel"]').each(function () {
      var $carousel = $(this)
      Plugin.call($carousel, $carousel.data())
    })
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: collapse.js v3.2.0
 * http://getbootstrap.com/javascript/#collapse
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // COLLAPSE PUBLIC CLASS DEFINITION
  // ================================

  var Collapse = function (element, options) {
    this.$element      = $(element)
    this.options       = $.extend({}, Collapse.DEFAULTS, options)
    this.transitioning = null

    if (this.options.parent) this.$parent = $(this.options.parent)
    if (this.options.toggle) this.toggle()
  }

  Collapse.VERSION  = '3.2.0'

  Collapse.DEFAULTS = {
    toggle: true
  }

  Collapse.prototype.dimension = function () {
    var hasWidth = this.$element.hasClass('width')
    return hasWidth ? 'width' : 'height'
  }

  Collapse.prototype.show = function () {
    if (this.transitioning || this.$element.hasClass('in')) return

    var startEvent = $.Event('show.bs.collapse')
    this.$element.trigger(startEvent)
    if (startEvent.isDefaultPrevented()) return

    var actives = this.$parent && this.$parent.find('> .panel > .in')

    if (actives && actives.length) {
      var hasData = actives.data('bs.collapse')
      if (hasData && hasData.transitioning) return
      Plugin.call(actives, 'hide')
      hasData || actives.data('bs.collapse', null)
    }

    var dimension = this.dimension()

    this.$element
      .removeClass('collapse')
      .addClass('collapsing')[dimension](0)

    this.transitioning = 1

    var complete = function () {
      this.$element
        .removeClass('collapsing')
        .addClass('collapse in')[dimension]('')
      this.transitioning = 0
      this.$element
        .trigger('shown.bs.collapse')
    }

    if (!$.support.transition) return complete.call(this)

    var scrollSize = $.camelCase(['scroll', dimension].join('-'))

    this.$element
      .one('bsTransitionEnd', $.proxy(complete, this))
      .emulateTransitionEnd(350)[dimension](this.$element[0][scrollSize])
  }

  Collapse.prototype.hide = function () {
    if (this.transitioning || !this.$element.hasClass('in')) return

    var startEvent = $.Event('hide.bs.collapse')
    this.$element.trigger(startEvent)
    if (startEvent.isDefaultPrevented()) return

    var dimension = this.dimension()

    this.$element[dimension](this.$element[dimension]())[0].offsetHeight

    this.$element
      .addClass('collapsing')
      .removeClass('collapse')
      .removeClass('in')

    this.transitioning = 1

    var complete = function () {
      this.transitioning = 0
      this.$element
        .trigger('hidden.bs.collapse')
        .removeClass('collapsing')
        .addClass('collapse')
    }

    if (!$.support.transition) return complete.call(this)

    this.$element
      [dimension](0)
      .one('bsTransitionEnd', $.proxy(complete, this))
      .emulateTransitionEnd(350)
  }

  Collapse.prototype.toggle = function () {
    this[this.$element.hasClass('in') ? 'hide' : 'show']()
  }


  // COLLAPSE PLUGIN DEFINITION
  // ==========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.collapse')
      var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == 'object' && option)

      if (!data && options.toggle && option == 'show') option = !option
      if (!data) $this.data('bs.collapse', (data = new Collapse(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.collapse

  $.fn.collapse             = Plugin
  $.fn.collapse.Constructor = Collapse


  // COLLAPSE NO CONFLICT
  // ====================

  $.fn.collapse.noConflict = function () {
    $.fn.collapse = old
    return this
  }


  // COLLAPSE DATA-API
  // =================

  $(document).on('click.bs.collapse.data-api', '[data-toggle="collapse"]', function (e) {
    var href
    var $this   = $(this)
    var target  = $this.attr('data-target')
        || e.preventDefault()
        || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '') // strip for ie7
    var $target = $(target)
    var data    = $target.data('bs.collapse')
    var option  = data ? 'toggle' : $this.data()
    var parent  = $this.attr('data-parent')
    var $parent = parent && $(parent)

    if (!data || !data.transitioning) {
      if ($parent) $parent.find('[data-toggle="collapse"][data-parent="' + parent + '"]').not($this).addClass('collapsed')
      $this[$target.hasClass('in') ? 'addClass' : 'removeClass']('collapsed')
    }

    Plugin.call($target, option)
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: dropdown.js v3.2.0
 * http://getbootstrap.com/javascript/#dropdowns
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // DROPDOWN CLASS DEFINITION
  // =========================

  var backdrop = '.dropdown-backdrop'
  var toggle   = '[data-toggle="dropdown"]'
  var Dropdown = function (element) {
    $(element).on('click.bs.dropdown', this.toggle)
  }

  Dropdown.VERSION = '3.2.0'

  Dropdown.prototype.toggle = function (e) {
    var $this = $(this)

    if ($this.is('.disabled, :disabled')) return

    var $parent  = getParent($this)
    var isActive = $parent.hasClass('open')

    clearMenus()

    if (!isActive) {
      if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) {
        // if mobile we use a backdrop because click events don't delegate
        $('<div class="dropdown-backdrop"/>').insertAfter($(this)).on('click', clearMenus)
      }

      var relatedTarget = { relatedTarget: this }
      $parent.trigger(e = $.Event('show.bs.dropdown', relatedTarget))

      if (e.isDefaultPrevented()) return

      $this.trigger('focus')

      $parent
        .toggleClass('open')
        .trigger('shown.bs.dropdown', relatedTarget)
    }

    return false
  }

  Dropdown.prototype.keydown = function (e) {
    if (!/(38|40|27)/.test(e.keyCode)) return

    var $this = $(this)

    e.preventDefault()
    e.stopPropagation()

    if ($this.is('.disabled, :disabled')) return

    var $parent  = getParent($this)
    var isActive = $parent.hasClass('open')

    if (!isActive || (isActive && e.keyCode == 27)) {
      if (e.which == 27) $parent.find(toggle).trigger('focus')
      return $this.trigger('click')
    }

    var desc = ' li:not(.divider):visible a'
    var $items = $parent.find('[role="menu"]' + desc + ', [role="listbox"]' + desc)

    if (!$items.length) return

    var index = $items.index($items.filter(':focus'))

    if (e.keyCode == 38 && index > 0)                 index--                        // up
    if (e.keyCode == 40 && index < $items.length - 1) index++                        // down
    if (!~index)                                      index = 0

    $items.eq(index).trigger('focus')
  }

  function clearMenus(e) {
    if (e && e.which === 3) return
    $(backdrop).remove()
    $(toggle).each(function () {
      var $parent = getParent($(this))
      var relatedTarget = { relatedTarget: this }
      if (!$parent.hasClass('open')) return
      $parent.trigger(e = $.Event('hide.bs.dropdown', relatedTarget))
      if (e.isDefaultPrevented()) return
      $parent.removeClass('open').trigger('hidden.bs.dropdown', relatedTarget)
    })
  }

  function getParent($this) {
    var selector = $this.attr('data-target')

    if (!selector) {
      selector = $this.attr('href')
      selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
    }

    var $parent = selector && $(selector)

    return $parent && $parent.length ? $parent : $this.parent()
  }


  // DROPDOWN PLUGIN DEFINITION
  // ==========================

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this)
      var data  = $this.data('bs.dropdown')

      if (!data) $this.data('bs.dropdown', (data = new Dropdown(this)))
      if (typeof option == 'string') data[option].call($this)
    })
  }

  var old = $.fn.dropdown

  $.fn.dropdown             = Plugin
  $.fn.dropdown.Constructor = Dropdown


  // DROPDOWN NO CONFLICT
  // ====================

  $.fn.dropdown.noConflict = function () {
    $.fn.dropdown = old
    return this
  }


  // APPLY TO STANDARD DROPDOWN ELEMENTS
  // ===================================

  $(document)
    .on('click.bs.dropdown.data-api', clearMenus)
    .on('click.bs.dropdown.data-api', '.dropdown form', function (e) { e.stopPropagation() })
    .on('click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle)
    .on('keydown.bs.dropdown.data-api', toggle + ', [role="menu"], [role="listbox"]', Dropdown.prototype.keydown)

}(jQuery);

/* ========================================================================
 * Bootstrap: tab.js v3.2.0
 * http://getbootstrap.com/javascript/#tabs
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // TAB CLASS DEFINITION
  // ====================

  var Tab = function (element) {
    this.element = $(element)
  }

  Tab.VERSION = '3.2.0'

  Tab.prototype.show = function () {
    var $this    = this.element
    var $ul      = $this.closest('ul:not(.dropdown-menu)')
    var selector = $this.data('target')

    if (!selector) {
      selector = $this.attr('href')
      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
    }

    if ($this.parent('li').hasClass('active')) return

    var previous = $ul.find('.active:last a')[0]
    var e        = $.Event('show.bs.tab', {
      relatedTarget: previous
    })

    $this.trigger(e)

    if (e.isDefaultPrevented()) return

    var $target = $(selector)

    this.activate($this.closest('li'), $ul)
    this.activate($target, $target.parent(), function () {
      $this.trigger({
        type: 'shown.bs.tab',
        relatedTarget: previous
      })
    })
  }

  Tab.prototype.activate = function (element, container, callback) {
    var $active    = container.find('> .active')
    var transition = callback
      && $.support.transition
      && $active.hasClass('fade')

    function next() {
      $active
        .removeClass('active')
        .find('> .dropdown-menu > .active')
        .removeClass('active')

      element.addClass('active')

      if (transition) {
        element[0].offsetWidth // reflow for transition
        element.addClass('in')
      } else {
        element.removeClass('fade')
      }

      if (element.parent('.dropdown-menu')) {
        element.closest('li.dropdown').addClass('active')
      }

      callback && callback()
    }

    transition ?
      $active
        .one('bsTransitionEnd', next)
        .emulateTransitionEnd(150) :
      next()

    $active.removeClass('in')
  }


  // TAB PLUGIN DEFINITION
  // =====================

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this)
      var data  = $this.data('bs.tab')

      if (!data) $this.data('bs.tab', (data = new Tab(this)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.tab

  $.fn.tab             = Plugin
  $.fn.tab.Constructor = Tab


  // TAB NO CONFLICT
  // ===============

  $.fn.tab.noConflict = function () {
    $.fn.tab = old
    return this
  }


  // TAB DATA-API
  // ============

  $(document).on('click.bs.tab.data-api', '[data-toggle="tab"], [data-toggle="pill"]', function (e) {
    e.preventDefault()
    Plugin.call($(this), 'show')
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: transition.js v3.2.0
 * http://getbootstrap.com/javascript/#transitions
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)
  // ============================================================

  function transitionEnd() {
    var el = document.createElement('bootstrap')

    var transEndEventNames = {
      WebkitTransition : 'webkitTransitionEnd',
      MozTransition    : 'transitionend',
      OTransition      : 'oTransitionEnd otransitionend',
      transition       : 'transitionend'
    }

    for (var name in transEndEventNames) {
      if (el.style[name] !== undefined) {
        return { end: transEndEventNames[name] }
      }
    }

    return false // explicit for ie8 (  ._.)
  }

  // http://blog.alexmaccaw.com/css-transitions
  $.fn.emulateTransitionEnd = function (duration) {
    var called = false
    var $el = this
    $(this).one('bsTransitionEnd', function () { called = true })
    var callback = function () { if (!called) $($el).trigger($.support.transition.end) }
    setTimeout(callback, duration)
    return this
  }

  $(function () {
    $.support.transition = transitionEnd()

    if (!$.support.transition) return

    $.event.special.bsTransitionEnd = {
      bindType: $.support.transition.end,
      delegateType: $.support.transition.end,
      handle: function (e) {
        if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments)
      }
    }
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: scrollspy.js v3.2.0
 * http://getbootstrap.com/javascript/#scrollspy
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // SCROLLSPY CLASS DEFINITION
  // ==========================

  function ScrollSpy(element, options) {
    var process  = $.proxy(this.process, this)

    this.$body          = $('body')
    this.$scrollElement = $(element).is('body') ? $(window) : $(element)
    this.options        = $.extend({}, ScrollSpy.DEFAULTS, options)
    this.selector       = (this.options.target || '') + ' .nav li > a'
    this.offsets        = []
    this.targets        = []
    this.activeTarget   = null
    this.scrollHeight   = 0

    this.$scrollElement.on('scroll.bs.scrollspy', process)
    this.refresh()
    this.process()
  }

  ScrollSpy.VERSION  = '3.2.0'

  ScrollSpy.DEFAULTS = {
    offset: 10
  }

  ScrollSpy.prototype.getScrollHeight = function () {
    return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight)
  }

  ScrollSpy.prototype.refresh = function () {
    var offsetMethod = 'offset'
    var offsetBase   = 0

    if (!$.isWindow(this.$scrollElement[0])) {
      offsetMethod = 'position'
      offsetBase   = this.$scrollElement.scrollTop()
    }

    this.offsets = []
    this.targets = []
    this.scrollHeight = this.getScrollHeight()

    var self     = this

    this.$body
      .find(this.selector)
      .map(function () {
        var $el   = $(this)
        var href  = $el.data('target') || $el.attr('href')
        var $href = /^#./.test(href) && $(href)

        return ($href
          && $href.length
          && $href.is(':visible')
          && [[$href[offsetMethod]().top + offsetBase, href]]) || null
      })
      .sort(function (a, b) { return a[0] - b[0] })
      .each(function () {
        self.offsets.push(this[0])
        self.targets.push(this[1])
      })
  }

  ScrollSpy.prototype.process = function () {
    var scrollTop    = this.$scrollElement.scrollTop() + this.options.offset
    var scrollHeight = this.getScrollHeight()
    var maxScroll    = this.options.offset + scrollHeight - this.$scrollElement.height()
    var offsets      = this.offsets
    var targets      = this.targets
    var activeTarget = this.activeTarget
    var i

    if (this.scrollHeight != scrollHeight) {
      this.refresh()
    }

    if (scrollTop >= maxScroll) {
      return activeTarget != (i = targets[targets.length - 1]) && this.activate(i)
    }

    if (activeTarget && scrollTop <= offsets[0]) {
      return activeTarget != (i = targets[0]) && this.activate(i)
    }

    for (i = offsets.length; i--;) {
      activeTarget != targets[i]
        && scrollTop >= offsets[i]
        && (!offsets[i + 1] || scrollTop <= offsets[i + 1])
        && this.activate(targets[i])
    }
  }

  ScrollSpy.prototype.activate = function (target) {
    this.activeTarget = target

    $(this.selector)
      .parentsUntil(this.options.target, '.active')
      .removeClass('active')

    var selector = this.selector +
        '[data-target="' + target + '"],' +
        this.selector + '[href="' + target + '"]'

    var active = $(selector)
      .parents('li')
      .addClass('active')

    if (active.parent('.dropdown-menu').length) {
      active = active
        .closest('li.dropdown')
        .addClass('active')
    }

    active.trigger('activate.bs.scrollspy')
  }


  // SCROLLSPY PLUGIN DEFINITION
  // ===========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.scrollspy')
      var options = typeof option == 'object' && option

      if (!data) $this.data('bs.scrollspy', (data = new ScrollSpy(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.scrollspy

  $.fn.scrollspy             = Plugin
  $.fn.scrollspy.Constructor = ScrollSpy


  // SCROLLSPY NO CONFLICT
  // =====================

  $.fn.scrollspy.noConflict = function () {
    $.fn.scrollspy = old
    return this
  }


  // SCROLLSPY DATA-API
  // ==================

  $(window).on('load.bs.scrollspy.data-api', function () {
    $('[data-spy="scroll"]').each(function () {
      var $spy = $(this)
      Plugin.call($spy, $spy.data())
    })
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: modal.js v3.2.0
 * http://getbootstrap.com/javascript/#modals
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // MODAL CLASS DEFINITION
  // ======================

  var Modal = function (element, options) {
    this.options        = options
    this.$body          = $(document.body)
    this.$element       = $(element)
    this.$backdrop      =
    this.isShown        = null
    this.scrollbarWidth = 0

    if (this.options.remote) {
      this.$element
        .find('.modal-content')
        .load(this.options.remote, $.proxy(function () {
          this.$element.trigger('loaded.bs.modal')
        }, this))
    }
  }

  Modal.VERSION  = '3.2.0'

  Modal.DEFAULTS = {
    backdrop: true,
    keyboard: true,
    show: true
  }

  Modal.prototype.toggle = function (_relatedTarget) {
    return this.isShown ? this.hide() : this.show(_relatedTarget)
  }

  Modal.prototype.show = function (_relatedTarget) {
    var that = this
    var e    = $.Event('show.bs.modal', { relatedTarget: _relatedTarget })

    this.$element.trigger(e)

    if (this.isShown || e.isDefaultPrevented()) return

    this.isShown = true

    this.checkScrollbar()
    this.$body.addClass('modal-open')

    this.setScrollbar()
    this.escape()

    this.$element.on('click.dismiss.bs.modal', '[data-dismiss="modal"]', $.proxy(this.hide, this))

    this.backdrop(function () {
      var transition = $.support.transition && that.$element.hasClass('fade')

      if (!that.$element.parent().length) {
        that.$element.appendTo(that.$body) // don't move modals dom position
      }

      that.$element
        .show()
        .scrollTop(0)

      if (transition) {
        that.$element[0].offsetWidth // force reflow
      }

      that.$element
        .addClass('in')
        .attr('aria-hidden', false)

      that.enforceFocus()

      var e = $.Event('shown.bs.modal', { relatedTarget: _relatedTarget })

      transition ?
        that.$element.find('.modal-dialog') // wait for modal to slide in
          .one('bsTransitionEnd', function () {
            that.$element.trigger('focus').trigger(e)
          })
          .emulateTransitionEnd(300) :
        that.$element.trigger('focus').trigger(e)
    })
  }

  Modal.prototype.hide = function (e) {
    if (e) e.preventDefault()

    e = $.Event('hide.bs.modal')

    this.$element.trigger(e)

    if (!this.isShown || e.isDefaultPrevented()) return

    this.isShown = false

    this.$body.removeClass('modal-open')

    this.resetScrollbar()
    this.escape()

    $(document).off('focusin.bs.modal')

    this.$element
      .removeClass('in')
      .attr('aria-hidden', true)
      .off('click.dismiss.bs.modal')

    $.support.transition && this.$element.hasClass('fade') ?
      this.$element
        .one('bsTransitionEnd', $.proxy(this.hideModal, this))
        .emulateTransitionEnd(300) :
      this.hideModal()
  }

  Modal.prototype.enforceFocus = function () {
    $(document)
      .off('focusin.bs.modal') // guard against infinite focus loop
      .on('focusin.bs.modal', $.proxy(function (e) {
        if (this.$element[0] !== e.target && !this.$element.has(e.target).length) {
          this.$element.trigger('focus')
        }
      }, this))
  }

  Modal.prototype.escape = function () {
    if (this.isShown && this.options.keyboard) {
      this.$element.on('keyup.dismiss.bs.modal', $.proxy(function (e) {
        e.which == 27 && this.hide()
      }, this))
    } else if (!this.isShown) {
      this.$element.off('keyup.dismiss.bs.modal')
    }
  }

  Modal.prototype.hideModal = function () {
    var that = this
    this.$element.hide()
    this.backdrop(function () {
      that.$element.trigger('hidden.bs.modal')
    })
  }

  Modal.prototype.removeBackdrop = function () {
    this.$backdrop && this.$backdrop.remove()
    this.$backdrop = null
  }

  Modal.prototype.backdrop = function (callback) {
    var that = this
    var animate = this.$element.hasClass('fade') ? 'fade' : ''

    if (this.isShown && this.options.backdrop) {
      var doAnimate = $.support.transition && animate

      this.$backdrop = $('<div class="modal-backdrop ' + animate + '" />')
        .appendTo(this.$body)

      this.$element.on('click.dismiss.bs.modal', $.proxy(function (e) {
        if (e.target !== e.currentTarget) return
        this.options.backdrop == 'static'
          ? this.$element[0].focus.call(this.$element[0])
          : this.hide.call(this)
      }, this))

      if (doAnimate) this.$backdrop[0].offsetWidth // force reflow

      this.$backdrop.addClass('in')

      if (!callback) return

      doAnimate ?
        this.$backdrop
          .one('bsTransitionEnd', callback)
          .emulateTransitionEnd(150) :
        callback()

    } else if (!this.isShown && this.$backdrop) {
      this.$backdrop.removeClass('in')

      var callbackRemove = function () {
        that.removeBackdrop()
        callback && callback()
      }
      $.support.transition && this.$element.hasClass('fade') ?
        this.$backdrop
          .one('bsTransitionEnd', callbackRemove)
          .emulateTransitionEnd(150) :
        callbackRemove()

    } else if (callback) {
      callback()
    }
  }

  Modal.prototype.checkScrollbar = function () {
    if (document.body.clientWidth >= window.innerWidth) return
    this.scrollbarWidth = this.scrollbarWidth || this.measureScrollbar()
  }

  Modal.prototype.setScrollbar = function () {
    var bodyPad = parseInt((this.$body.css('padding-right') || 0), 10)
    if (this.scrollbarWidth) this.$body.css('padding-right', bodyPad + this.scrollbarWidth)
  }

  Modal.prototype.resetScrollbar = function () {
    this.$body.css('padding-right', '')
  }

  Modal.prototype.measureScrollbar = function () { // thx walsh
    var scrollDiv = document.createElement('div')
    scrollDiv.className = 'modal-scrollbar-measure'
    this.$body.append(scrollDiv)
    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth
    this.$body[0].removeChild(scrollDiv)
    return scrollbarWidth
  }


  // MODAL PLUGIN DEFINITION
  // =======================

  function Plugin(option, _relatedTarget) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.modal')
      var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == 'object' && option)

      if (!data) $this.data('bs.modal', (data = new Modal(this, options)))
      if (typeof option == 'string') data[option](_relatedTarget)
      else if (options.show) data.show(_relatedTarget)
    })
  }

  var old = $.fn.modal

  $.fn.modal             = Plugin
  $.fn.modal.Constructor = Modal


  // MODAL NO CONFLICT
  // =================

  $.fn.modal.noConflict = function () {
    $.fn.modal = old
    return this
  }


  // MODAL DATA-API
  // ==============

  $(document).on('click.bs.modal.data-api', '[data-toggle="modal"]', function (e) {
    var $this   = $(this)
    var href    = $this.attr('href')
    var $target = $($this.attr('data-target') || (href && href.replace(/.*(?=#[^\s]+$)/, ''))) // strip for ie7
    var option  = $target.data('bs.modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data())

    if ($this.is('a')) e.preventDefault()

    $target.one('show.bs.modal', function (showEvent) {
      if (showEvent.isDefaultPrevented()) return // only register focus restorer if modal will actually get shown
      $target.one('hidden.bs.modal', function () {
        $this.is(':visible') && $this.trigger('focus')
      })
    })
    Plugin.call($target, option, this)
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: tooltip.js v3.2.0
 * http://getbootstrap.com/javascript/#tooltip
 * Inspired by the original jQuery.tipsy by Jason Frame
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // TOOLTIP PUBLIC CLASS DEFINITION
  // ===============================

  var Tooltip = function (element, options) {
    this.type       =
    this.options    =
    this.enabled    =
    this.timeout    =
    this.hoverState =
    this.$element   = null

    this.init('tooltip', element, options)
  }

  Tooltip.VERSION  = '3.2.0'

  Tooltip.DEFAULTS = {
    animation: true,
    placement: 'top',
    selector: false,
    template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
    trigger: 'hover focus',
    title: '',
    delay: 0,
    html: false,
    container: false,
    viewport: {
      selector: 'body',
      padding: 0
    }
  }

  Tooltip.prototype.init = function (type, element, options) {
    this.enabled   = true
    this.type      = type
    this.$element  = $(element)
    this.options   = this.getOptions(options)
    this.$viewport = this.options.viewport && $(this.options.viewport.selector || this.options.viewport)

    var triggers = this.options.trigger.split(' ')

    for (var i = triggers.length; i--;) {
      var trigger = triggers[i]

      if (trigger == 'click') {
        this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this))
      } else if (trigger != 'manual') {
        var eventIn  = trigger == 'hover' ? 'mouseenter' : 'focusin'
        var eventOut = trigger == 'hover' ? 'mouseleave' : 'focusout'

        this.$element.on(eventIn  + '.' + this.type, this.options.selector, $.proxy(this.enter, this))
        this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this))
      }
    }

    this.options.selector ?
      (this._options = $.extend({}, this.options, { trigger: 'manual', selector: '' })) :
      this.fixTitle()
  }

  Tooltip.prototype.getDefaults = function () {
    return Tooltip.DEFAULTS
  }

  Tooltip.prototype.getOptions = function (options) {
    options = $.extend({}, this.getDefaults(), this.$element.data(), options)

    if (options.delay && typeof options.delay == 'number') {
      options.delay = {
        show: options.delay,
        hide: options.delay
      }
    }

    return options
  }

  Tooltip.prototype.getDelegateOptions = function () {
    var options  = {}
    var defaults = this.getDefaults()

    this._options && $.each(this._options, function (key, value) {
      if (defaults[key] != value) options[key] = value
    })

    return options
  }

  Tooltip.prototype.enter = function (obj) {
    var self = obj instanceof this.constructor ?
      obj : $(obj.currentTarget).data('bs.' + this.type)

    if (!self) {
      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
      $(obj.currentTarget).data('bs.' + this.type, self)
    }

    clearTimeout(self.timeout)

    self.hoverState = 'in'

    if (!self.options.delay || !self.options.delay.show) return self.show()

    self.timeout = setTimeout(function () {
      if (self.hoverState == 'in') self.show()
    }, self.options.delay.show)
  }

  Tooltip.prototype.leave = function (obj) {
    var self = obj instanceof this.constructor ?
      obj : $(obj.currentTarget).data('bs.' + this.type)

    if (!self) {
      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
      $(obj.currentTarget).data('bs.' + this.type, self)
    }

    clearTimeout(self.timeout)

    self.hoverState = 'out'

    if (!self.options.delay || !self.options.delay.hide) return self.hide()

    self.timeout = setTimeout(function () {
      if (self.hoverState == 'out') self.hide()
    }, self.options.delay.hide)
  }

  Tooltip.prototype.show = function () {
    var e = $.Event('show.bs.' + this.type)

    if (this.hasContent() && this.enabled) {
      this.$element.trigger(e)

      var inDom = $.contains(document.documentElement, this.$element[0])
      if (e.isDefaultPrevented() || !inDom) return
      var that = this

      var $tip = this.tip()

      var tipId = this.getUID(this.type)

      this.setContent()
      $tip.attr('id', tipId)
      this.$element.attr('aria-describedby', tipId)

      if (this.options.animation) $tip.addClass('fade')

      var placement = typeof this.options.placement == 'function' ?
        this.options.placement.call(this, $tip[0], this.$element[0]) :
        this.options.placement

      var autoToken = /\s?auto?\s?/i
      var autoPlace = autoToken.test(placement)
      if (autoPlace) placement = placement.replace(autoToken, '') || 'top'

      $tip
        .detach()
        .css({ top: 0, left: 0, display: 'block' })
        .addClass(placement)
        .data('bs.' + this.type, this)

      this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element)

      var pos          = this.getPosition()
      var actualWidth  = $tip[0].offsetWidth
      var actualHeight = $tip[0].offsetHeight

      if (autoPlace) {
        var orgPlacement = placement
        var $parent      = this.$element.parent()
        var parentDim    = this.getPosition($parent)

        placement = placement == 'bottom' && pos.top   + pos.height       + actualHeight - parentDim.scroll > parentDim.height ? 'top'    :
                    placement == 'top'    && pos.top   - parentDim.scroll - actualHeight < 0                                   ? 'bottom' :
                    placement == 'right'  && pos.right + actualWidth      > parentDim.width                                    ? 'left'   :
                    placement == 'left'   && pos.left  - actualWidth      < parentDim.left                                     ? 'right'  :
                    placement

        $tip
          .removeClass(orgPlacement)
          .addClass(placement)
      }

      var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight)

      this.applyPlacement(calculatedOffset, placement)

      var complete = function () {
        that.$element.trigger('shown.bs.' + that.type)
        that.hoverState = null
      }

      $.support.transition && this.$tip.hasClass('fade') ?
        $tip
          .one('bsTransitionEnd', complete)
          .emulateTransitionEnd(150) :
        complete()
    }
  }

  Tooltip.prototype.applyPlacement = function (offset, placement) {
    var $tip   = this.tip()
    var width  = $tip[0].offsetWidth
    var height = $tip[0].offsetHeight

    // manually read margins because getBoundingClientRect includes difference
    var marginTop = parseInt($tip.css('margin-top'), 10)
    var marginLeft = parseInt($tip.css('margin-left'), 10)

    // we must check for NaN for ie 8/9
    if (isNaN(marginTop))  marginTop  = 0
    if (isNaN(marginLeft)) marginLeft = 0

    offset.top  = offset.top  + marginTop
    offset.left = offset.left + marginLeft

    // $.fn.offset doesn't round pixel values
    // so we use setOffset directly with our own function B-0
    $.offset.setOffset($tip[0], $.extend({
      using: function (props) {
        $tip.css({
          top: Math.round(props.top),
          left: Math.round(props.left)
        })
      }
    }, offset), 0)

    $tip.addClass('in')

    // check to see if placing tip in new offset caused the tip to resize itself
    var actualWidth  = $tip[0].offsetWidth
    var actualHeight = $tip[0].offsetHeight

    if (placement == 'top' && actualHeight != height) {
      offset.top = offset.top + height - actualHeight
    }

    var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight)

    if (delta.left) offset.left += delta.left
    else offset.top += delta.top

    var arrowDelta          = delta.left ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight
    var arrowPosition       = delta.left ? 'left'        : 'top'
    var arrowOffsetPosition = delta.left ? 'offsetWidth' : 'offsetHeight'

    $tip.offset(offset)
    this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], arrowPosition)
  }

  Tooltip.prototype.replaceArrow = function (delta, dimension, position) {
    this.arrow().css(position, delta ? (50 * (1 - delta / dimension) + '%') : '')
  }

  Tooltip.prototype.setContent = function () {
    var $tip  = this.tip()
    var title = this.getTitle()

    $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title)
    $tip.removeClass('fade in top bottom left right')
  }

  Tooltip.prototype.hide = function () {
    var that = this
    var $tip = this.tip()
    var e    = $.Event('hide.bs.' + this.type)

    this.$element.removeAttr('aria-describedby')

    function complete() {
      if (that.hoverState != 'in') $tip.detach()
      that.$element.trigger('hidden.bs.' + that.type)
    }

    this.$element.trigger(e)

    if (e.isDefaultPrevented()) return

    $tip.removeClass('in')

    $.support.transition && this.$tip.hasClass('fade') ?
      $tip
        .one('bsTransitionEnd', complete)
        .emulateTransitionEnd(150) :
      complete()

    this.hoverState = null

    return this
  }

  Tooltip.prototype.fixTitle = function () {
    var $e = this.$element
    if ($e.attr('title') || typeof ($e.attr('data-original-title')) != 'string') {
      $e.attr('data-original-title', $e.attr('title') || '').attr('title', '')
    }
  }

  Tooltip.prototype.hasContent = function () {
    return this.getTitle()
  }

  Tooltip.prototype.getPosition = function ($element) {
    $element   = $element || this.$element
    var el     = $element[0]
    var isBody = el.tagName == 'BODY'
    return $.extend({}, (typeof el.getBoundingClientRect == 'function') ? el.getBoundingClientRect() : null, {
      scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop(),
      width:  isBody ? $(window).width()  : $element.outerWidth(),
      height: isBody ? $(window).height() : $element.outerHeight()
    }, isBody ? { top: 0, left: 0 } : $element.offset())
  }

  Tooltip.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) {
    return placement == 'bottom' ? { top: pos.top + pos.height,   left: pos.left + pos.width / 2 - actualWidth / 2  } :
           placement == 'top'    ? { top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2  } :
           placement == 'left'   ? { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth } :
        /* placement == 'right' */ { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width   }

  }

  Tooltip.prototype.getViewportAdjustedDelta = function (placement, pos, actualWidth, actualHeight) {
    var delta = { top: 0, left: 0 }
    if (!this.$viewport) return delta

    var viewportPadding = this.options.viewport && this.options.viewport.padding || 0
    var viewportDimensions = this.getPosition(this.$viewport)

    if (/right|left/.test(placement)) {
      var topEdgeOffset    = pos.top - viewportPadding - viewportDimensions.scroll
      var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight
      if (topEdgeOffset < viewportDimensions.top) { // top overflow
        delta.top = viewportDimensions.top - topEdgeOffset
      } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow
        delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset
      }
    } else {
      var leftEdgeOffset  = pos.left - viewportPadding
      var rightEdgeOffset = pos.left + viewportPadding + actualWidth
      if (leftEdgeOffset < viewportDimensions.left) { // left overflow
        delta.left = viewportDimensions.left - leftEdgeOffset
      } else if (rightEdgeOffset > viewportDimensions.width) { // right overflow
        delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset
      }
    }

    return delta
  }

  Tooltip.prototype.getTitle = function () {
    var title
    var $e = this.$element
    var o  = this.options

    title = $e.attr('data-original-title')
      || (typeof o.title == 'function' ? o.title.call($e[0]) :  o.title)

    return title
  }

  Tooltip.prototype.getUID = function (prefix) {
    do prefix += ~~(Math.random() * 1000000)
    while (document.getElementById(prefix))
    return prefix
  }

  Tooltip.prototype.tip = function () {
    return (this.$tip = this.$tip || $(this.options.template))
  }

  Tooltip.prototype.arrow = function () {
    return (this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow'))
  }

  Tooltip.prototype.validate = function () {
    if (!this.$element[0].parentNode) {
      this.hide()
      this.$element = null
      this.options  = null
    }
  }

  Tooltip.prototype.enable = function () {
    this.enabled = true
  }

  Tooltip.prototype.disable = function () {
    this.enabled = false
  }

  Tooltip.prototype.toggleEnabled = function () {
    this.enabled = !this.enabled
  }

  Tooltip.prototype.toggle = function (e) {
    var self = this
    if (e) {
      self = $(e.currentTarget).data('bs.' + this.type)
      if (!self) {
        self = new this.constructor(e.currentTarget, this.getDelegateOptions())
        $(e.currentTarget).data('bs.' + this.type, self)
      }
    }

    self.tip().hasClass('in') ? self.leave(self) : self.enter(self)
  }

  Tooltip.prototype.destroy = function () {
    clearTimeout(this.timeout)
    this.hide().$element.off('.' + this.type).removeData('bs.' + this.type)
  }


  // TOOLTIP PLUGIN DEFINITION
  // =========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.tooltip')
      var options = typeof option == 'object' && option

      if (!data && option == 'destroy') return
      if (!data) $this.data('bs.tooltip', (data = new Tooltip(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.tooltip

  $.fn.tooltip             = Plugin
  $.fn.tooltip.Constructor = Tooltip


  // TOOLTIP NO CONFLICT
  // ===================

  $.fn.tooltip.noConflict = function () {
    $.fn.tooltip = old
    return this
  }

}(jQuery);

/* ========================================================================
 * Bootstrap: popover.js v3.2.0
 * http://getbootstrap.com/javascript/#popovers
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // POPOVER PUBLIC CLASS DEFINITION
  // ===============================

  var Popover = function (element, options) {
    this.init('popover', element, options)
  }

  if (!$.fn.tooltip) throw new Error('Popover requires tooltip.js')

  Popover.VERSION  = '3.2.0'

  Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
    placement: 'right',
    trigger: 'click',
    content: '',
    template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
  })


  // NOTE: POPOVER EXTENDS tooltip.js
  // ================================

  Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype)

  Popover.prototype.constructor = Popover

  Popover.prototype.getDefaults = function () {
    return Popover.DEFAULTS
  }

  Popover.prototype.setContent = function () {
    var $tip    = this.tip()
    var title   = this.getTitle()
    var content = this.getContent()

    $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title)
    $tip.find('.popover-content').empty()[ // we use append for html objects to maintain js events
      this.options.html ? (typeof content == 'string' ? 'html' : 'append') : 'text'
    ](content)

    $tip.removeClass('fade top bottom left right in')

    // IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do
    // this manually by checking the contents.
    if (!$tip.find('.popover-title').html()) $tip.find('.popover-title').hide()
  }

  Popover.prototype.hasContent = function () {
    return this.getTitle() || this.getContent()
  }

  Popover.prototype.getContent = function () {
    var $e = this.$element
    var o  = this.options

    return $e.attr('data-content')
      || (typeof o.content == 'function' ?
            o.content.call($e[0]) :
            o.content)
  }

  Popover.prototype.arrow = function () {
    return (this.$arrow = this.$arrow || this.tip().find('.arrow'))
  }

  Popover.prototype.tip = function () {
    if (!this.$tip) this.$tip = $(this.options.template)
    return this.$tip
  }


  // POPOVER PLUGIN DEFINITION
  // =========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.popover')
      var options = typeof option == 'object' && option

      if (!data && option == 'destroy') return
      if (!data) $this.data('bs.popover', (data = new Popover(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.popover

  $.fn.popover             = Plugin
  $.fn.popover.Constructor = Popover


  // POPOVER NO CONFLICT
  // ===================

  $.fn.popover.noConflict = function () {
    $.fn.popover = old
    return this
  }

}(jQuery);

/* ========================================================================
 * bootstrap-switch - v3.0.2
 * http://www.bootstrap-switch.org
 * ========================================================================
 * Copyright 2012-2013 Mattia Larentis
 *
 * ========================================================================
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================================
 */


(function(){var t=[].slice;!function(e,s){"use strict";var o;return o=function(){function t(t,s){null==s&&(s={}),this.$element=e(t),this.options=e.extend({},e.fn.bootstrapSwitch.defaults,{state:this.$element.is(":checked"),size:this.$element.data("size"),animate:this.$element.data("animate"),disabled:this.$element.is(":disabled"),readonly:this.$element.is("[readonly]"),indeterminate:this.$element.data("indeterminate"),onColor:this.$element.data("on-color"),offColor:this.$element.data("off-color"),onText:this.$element.data("on-text"),offText:this.$element.data("off-text"),labelText:this.$element.data("label-text"),baseClass:this.$element.data("base-class"),wrapperClass:this.$element.data("wrapper-class"),radioAllOff:this.$element.data("radio-all-off")},s),this.$wrapper=e("<div>",{"class":function(t){return function(){var e;return e=[""+t.options.baseClass].concat(t._getClasses(t.options.wrapperClass)),e.push(t.options.state?""+t.options.baseClass+"-on":""+t.options.baseClass+"-off"),null!=t.options.size&&e.push(""+t.options.baseClass+"-"+t.options.size),t.options.animate&&e.push(""+t.options.baseClass+"-animate"),t.options.disabled&&e.push(""+t.options.baseClass+"-disabled"),t.options.readonly&&e.push(""+t.options.baseClass+"-readonly"),t.options.indeterminate&&e.push(""+t.options.baseClass+"-indeterminate"),t.$element.attr("id")&&e.push(""+t.options.baseClass+"-id-"+t.$element.attr("id")),e.join(" ")}}(this)()}),this.$container=e("<div>",{"class":""+this.options.baseClass+"-container"}),this.$on=e("<span>",{html:this.options.onText,"class":""+this.options.baseClass+"-handle-on "+this.options.baseClass+"-"+this.options.onColor}),this.$off=e("<span>",{html:this.options.offText,"class":""+this.options.baseClass+"-handle-off "+this.options.baseClass+"-"+this.options.offColor}),this.$label=e("<label>",{html:this.options.labelText,"class":""+this.options.baseClass+"-label"}),this.options.indeterminate&&this.$element.prop("indeterminate",!0),this.$element.on("init.bootstrapSwitch",function(e){return function(){return e.options.onInit.apply(t,arguments)}}(this)),this.$element.on("switchChange.bootstrapSwitch",function(e){return function(){return e.options.onSwitchChange.apply(t,arguments)}}(this)),this.$container=this.$element.wrap(this.$container).parent(),this.$wrapper=this.$container.wrap(this.$wrapper).parent(),this.$element.before(this.$on).before(this.$label).before(this.$off).trigger("init.bootstrapSwitch"),this._elementHandlers(),this._handleHandlers(),this._labelHandlers(),this._formHandler()}return t.prototype._constructor=t,t.prototype.state=function(t,e){return"undefined"==typeof t?this.options.state:this.options.disabled||this.options.readonly||this.options.indeterminate?this.$element:this.options.state&&!this.options.radioAllOff&&this.$element.is(":radio")?this.$element:(t=!!t,this.$element.prop("checked",t).trigger("change.bootstrapSwitch",e),this.$element)},t.prototype.toggleState=function(t){return this.options.disabled||this.options.readonly||this.options.indeterminate?this.$element:this.$element.prop("checked",!this.options.state).trigger("change.bootstrapSwitch",t)},t.prototype.size=function(t){return"undefined"==typeof t?this.options.size:(null!=this.options.size&&this.$wrapper.removeClass(""+this.options.baseClass+"-"+this.options.size),t&&this.$wrapper.addClass(""+this.options.baseClass+"-"+t),this.options.size=t,this.$element)},t.prototype.animate=function(t){return"undefined"==typeof t?this.options.animate:(t=!!t,this.$wrapper[t?"addClass":"removeClass"](""+this.options.baseClass+"-animate"),this.options.animate=t,this.$element)},t.prototype.disabled=function(t){return"undefined"==typeof t?this.options.disabled:(t=!!t,this.$wrapper[t?"addClass":"removeClass"](""+this.options.baseClass+"-disabled"),this.$element.prop("disabled",t),this.options.disabled=t,this.$element)},t.prototype.toggleDisabled=function(){return this.$element.prop("disabled",!this.options.disabled),this.$wrapper.toggleClass(""+this.options.baseClass+"-disabled"),this.options.disabled=!this.options.disabled,this.$element},t.prototype.readonly=function(t){return"undefined"==typeof t?this.options.readonly:(t=!!t,this.$wrapper[t?"addClass":"removeClass"](""+this.options.baseClass+"-readonly"),this.$element.prop("readonly",t),this.options.readonly=t,this.$element)},t.prototype.toggleReadonly=function(){return this.$element.prop("readonly",!this.options.readonly),this.$wrapper.toggleClass(""+this.options.baseClass+"-readonly"),this.options.readonly=!this.options.readonly,this.$element},t.prototype.indeterminate=function(t){return"undefined"==typeof t?this.options.indeterminate:(t=!!t,this.$wrapper[t?"addClass":"removeClass"](""+this.options.baseClass+"-indeterminate"),this.$element.prop("indeterminate",t),this.options.indeterminate=t,this.$element)},t.prototype.toggleIndeterminate=function(){return this.$element.prop("indeterminate",!this.options.indeterminate),this.$wrapper.toggleClass(""+this.options.baseClass+"-indeterminate"),this.options.indeterminate=!this.options.indeterminate,this.$element},t.prototype.onColor=function(t){var e;return e=this.options.onColor,"undefined"==typeof t?e:(null!=e&&this.$on.removeClass(""+this.options.baseClass+"-"+e),this.$on.addClass(""+this.options.baseClass+"-"+t),this.options.onColor=t,this.$element)},t.prototype.offColor=function(t){var e;return e=this.options.offColor,"undefined"==typeof t?e:(null!=e&&this.$off.removeClass(""+this.options.baseClass+"-"+e),this.$off.addClass(""+this.options.baseClass+"-"+t),this.options.offColor=t,this.$element)},t.prototype.onText=function(t){return"undefined"==typeof t?this.options.onText:(this.$on.html(t),this.options.onText=t,this.$element)},t.prototype.offText=function(t){return"undefined"==typeof t?this.options.offText:(this.$off.html(t),this.options.offText=t,this.$element)},t.prototype.labelText=function(t){return"undefined"==typeof t?this.options.labelText:(this.$label.html(t),this.options.labelText=t,this.$element)},t.prototype.baseClass=function(){return this.options.baseClass},t.prototype.wrapperClass=function(t){return"undefined"==typeof t?this.options.wrapperClass:(t||(t=e.fn.bootstrapSwitch.defaults.wrapperClass),this.$wrapper.removeClass(this._getClasses(this.options.wrapperClass).join(" ")),this.$wrapper.addClass(this._getClasses(t).join(" ")),this.options.wrapperClass=t,this.$element)},t.prototype.radioAllOff=function(t){return"undefined"==typeof t?this.options.radioAllOff:(this.options.radioAllOff=t,this.$element)},t.prototype.onInit=function(t){return"undefined"==typeof t?this.options.onInit:(t||(t=e.fn.bootstrapSwitch.defaults.onInit),this.options.onInit=t,this.$element)},t.prototype.onSwitchChange=function(t){return"undefined"==typeof t?this.options.onSwitchChange:(t||(t=e.fn.bootstrapSwitch.defaults.onSwitchChange),this.options.onSwitchChange=t,this.$element)},t.prototype.destroy=function(){var t;return t=this.$element.closest("form"),t.length&&t.off("reset.bootstrapSwitch").removeData("bootstrap-switch"),this.$container.children().not(this.$element).remove(),this.$element.unwrap().unwrap().off(".bootstrapSwitch").removeData("bootstrap-switch"),this.$element},t.prototype._elementHandlers=function(){return this.$element.on({"change.bootstrapSwitch":function(t){return function(s,o){var n;return s.preventDefault(),s.stopImmediatePropagation(),n=t.$element.is(":checked"),n!==t.options.state?(t.options.state=n,t.$wrapper.removeClass(n?""+t.options.baseClass+"-off":""+t.options.baseClass+"-on").addClass(n?""+t.options.baseClass+"-on":""+t.options.baseClass+"-off"),o?void 0:(t.$element.is(":radio")&&e("[name='"+t.$element.attr("name")+"']").not(t.$element).prop("checked",!1).trigger("change.bootstrapSwitch",!0),t.$element.trigger("switchChange.bootstrapSwitch",[n]))):void 0}}(this),"focus.bootstrapSwitch":function(t){return function(e){return e.preventDefault(),t.$wrapper.addClass(""+t.options.baseClass+"-focused")}}(this),"blur.bootstrapSwitch":function(t){return function(e){return e.preventDefault(),t.$wrapper.removeClass(""+t.options.baseClass+"-focused")}}(this),"keydown.bootstrapSwitch":function(t){return function(e){if(e.which&&!t.options.disabled&&!t.options.readonly&&!t.options.indeterminate)switch(e.which){case 37:return e.preventDefault(),e.stopImmediatePropagation(),t.state(!1);case 39:return e.preventDefault(),e.stopImmediatePropagation(),t.state(!0)}}}(this)})},t.prototype._handleHandlers=function(){return this.$on.on("click.bootstrapSwitch",function(t){return function(){return t.state(!1),t.$element.trigger("focus.bootstrapSwitch")}}(this)),this.$off.on("click.bootstrapSwitch",function(t){return function(){return t.state(!0),t.$element.trigger("focus.bootstrapSwitch")}}(this))},t.prototype._labelHandlers=function(){return this.$label.on({"mousemove.bootstrapSwitch touchmove.bootstrapSwitch":function(t){return function(e){var s,o,n,i;if(t.isLabelDragging)return e.preventDefault(),t.isLabelDragged=!0,o=e.pageX||e.originalEvent.touches[0].pageX,n=(o-t.$wrapper.offset().left)/t.$wrapper.width()*100,s=25,i=75,t.options.animate&&t.$wrapper.removeClass(""+t.options.baseClass+"-animate"),s>n?n=s:n>i&&(n=i),t.$container.css("margin-left",""+(n-i)+"%"),t.$element.trigger("focus.bootstrapSwitch")}}(this),"mousedown.bootstrapSwitch touchstart.bootstrapSwitch":function(t){return function(e){return t.isLabelDragging||t.options.disabled||t.options.readonly||t.options.indeterminate?void 0:(e.preventDefault(),t.isLabelDragging=!0,t.$element.trigger("focus.bootstrapSwitch"))}}(this),"mouseup.bootstrapSwitch touchend.bootstrapSwitch":function(t){return function(e){return t.isLabelDragging?(e.preventDefault(),t.isLabelDragged?(t.isLabelDragged=!1,t.state(parseInt(t.$container.css("margin-left"),10)>-(t.$container.width()/6)),t.options.animate&&t.$wrapper.addClass(""+t.options.baseClass+"-animate"),t.$container.css("margin-left","")):t.state(!t.options.state),t.isLabelDragging=!1):void 0}}(this),"mouseleave.bootstrapSwitch":function(t){return function(){return t.$label.trigger("mouseup.bootstrapSwitch")}}(this)})},t.prototype._formHandler=function(){var t;return t=this.$element.closest("form"),t.data("bootstrap-switch")?void 0:t.on("reset.bootstrapSwitch",function(){return s.setTimeout(function(){return t.find("input").filter(function(){return e(this).data("bootstrap-switch")}).each(function(){return e(this).bootstrapSwitch("state",this.checked)})},1)}).data("bootstrap-switch",!0)},t.prototype._getClasses=function(t){var s,o,n,i;if(!e.isArray(t))return[""+this.options.baseClass+"-"+t];for(o=[],n=0,i=t.length;i>n;n++)s=t[n],o.push(""+this.options.baseClass+"-"+s);return o},t}(),e.fn.bootstrapSwitch=function(){var s,n,i;return n=arguments[0],s=2<=arguments.length?t.call(arguments,1):[],i=this,this.each(function(){var t,a;return t=e(this),a=t.data("bootstrap-switch"),a||t.data("bootstrap-switch",a=new o(this,n)),"string"==typeof n?i=a[n].apply(a,s):void 0}),i},e.fn.bootstrapSwitch.Constructor=o,e.fn.bootstrapSwitch.defaults={state:!0,size:null,animate:!0,disabled:!1,readonly:!1,indeterminate:!1,onColor:"primary",offColor:"default",onText:"ON",offText:"OFF",labelText:"&nbsp;",baseClass:"bootstrap-switch",wrapperClass:"wrapper",radioAllOff:!1,onInit:function(){},onSwitchChange:function(){}}}(window.jQuery,window)}).call(this);
/**
 * ScrollIt
 * ScrollIt.js(scrollitdotjs) makes it easy to make long, vertically scrolling pages.
 *
 * Latest version: https://github.com/cmpolis/scrollIt.js
 *
 * License <https://github.com/cmpolis/scrollIt.js/blob/master/LICENSE.txt>
 */

(function($) {
    'use strict';

    var pluginName = 'ScrollIt',
        pluginVersion = '1.0.3';

    /*
     * OPTIONS
     */
    var defaults = {
        upKey: 38,
        downKey: 40,
        easing: 'linear',
        scrollTime: 600,
        activeClass: 'active',
        onPageChange: null,
        topOffset : 0
    };

    $.scrollIt = function(options) {

        /*
         * DECLARATIONS
         */
        var settings = $.extend(defaults, options),
            active = 0,
            lastIndex = $('[data-scroll-index]:last').attr('data-scroll-index');

        /*
         * METHODS
         */

        /**
         * navigate
         *
         * sets up navigation animation
         */
        var navigate = function(ndx) {
            if(ndx < 0 || ndx > lastIndex) return;

            var targetTop = $('[data-scroll-index=' + ndx + ']').offset().top + settings.topOffset + 1;
            $('html,body').animate({
                scrollTop: targetTop,
                easing: settings.easing
            }, settings.scrollTime);
        };

        /**
         * doScroll
         *
         * runs navigation() when criteria are met
         */
        var doScroll = function (e) {
            var target = $(e.target).closest("[data-scroll-nav]").attr('data-scroll-nav') ||
            $(e.target).closest("[data-scroll-goto]").attr('data-scroll-goto');
            navigate(parseInt(target));
        };

        /**
         * keyNavigation
         *
         * sets up keyboard navigation behavior
         */
        var keyNavigation = function (e) {
            var key = e.which;
            if(key == settings.upKey && active > 0) {
                navigate(parseInt(active) - 1);
                return false;
            } else if(key == settings.downKey && active < lastIndex) {
                navigate(parseInt(active) + 1);
                return false;
            }
            return true;
        };

        /**
         * updateActive
         *
         * sets the currently active item
         */
        var updateActive = function(ndx) {
            if(settings.onPageChange && ndx && (active != ndx)) settings.onPageChange(ndx);

            active = ndx;
            $('[data-scroll-nav]').removeClass(settings.activeClass);
            $('[data-scroll-nav=' + ndx + ']').addClass(settings.activeClass);
        };

        /**
         * watchActive
         *
         * watches currently active item and updates accordingly
         */
        var watchActive = function() {
            var winTop = $(window).scrollTop();

            var visible = $('[data-scroll-index]').filter(function(ndx, div) {
                return winTop >= $(div).offset().top + settings.topOffset &&
                winTop < $(div).offset().top + (settings.topOffset) + $(div).outerHeight()
            });
            var newActive = visible.first().attr('data-scroll-index');
            updateActive(newActive);
        };

        /*
         * runs methods
         */
        $(window).on('scroll',watchActive).on('scroll');

        $(window).on('keydown', keyNavigation);

        $('body').on('click','[data-scroll-nav], [data-scroll-goto]', function(e){
            e.preventDefault();
            doScroll(e);
        });

    };
}(jQuery));
//! moment.js
//! version : 2.5.1
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

(function (undefined) {

    /************************************
        Constants
    ************************************/

    var moment,
        VERSION = "2.5.1",
        global = this,
        round = Math.round,
        i,

        YEAR = 0,
        MONTH = 1,
        DATE = 2,
        HOUR = 3,
        MINUTE = 4,
        SECOND = 5,
        MILLISECOND = 6,

        // internal storage for language config files
        languages = {},

        // moment internal properties
        momentProperties = {
            _isAMomentObject: null,
            _i : null,
            _f : null,
            _l : null,
            _strict : null,
            _isUTC : null,
            _offset : null,  // optional. Combine with _isUTC
            _pf : null,
            _lang : null  // optional
        },

        // check for nodeJS
        hasModule = (typeof module !== 'undefined' && module.exports && typeof require !== 'undefined'),

        // ASP.NET json date format regex
        aspNetJsonRegex = /^\/?Date\((\-?\d+)/i,
        aspNetTimeSpanJsonRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/,

        // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
        // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
        isoDurationRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/,

        // format tokens
        formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|X|zz?|ZZ?|.)/g,
        localFormattingTokens = /(\[[^\[]*\])|(\\)?(LT|LL?L?L?|l{1,4})/g,

        // parsing token regexes
        parseTokenOneOrTwoDigits = /\d\d?/, // 0 - 99
        parseTokenOneToThreeDigits = /\d{1,3}/, // 0 - 999
        parseTokenOneToFourDigits = /\d{1,4}/, // 0 - 9999
        parseTokenOneToSixDigits = /[+\-]?\d{1,6}/, // -999,999 - 999,999
        parseTokenDigits = /\d+/, // nonzero number of digits
        parseTokenWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i, // any word (or two) characters or numbers including two/three word month in arabic.
        parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
        parseTokenT = /T/i, // T (ISO separator)
        parseTokenTimestampMs = /[\+\-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123

        //strict parsing regexes
        parseTokenOneDigit = /\d/, // 0 - 9
        parseTokenTwoDigits = /\d\d/, // 00 - 99
        parseTokenThreeDigits = /\d{3}/, // 000 - 999
        parseTokenFourDigits = /\d{4}/, // 0000 - 9999
        parseTokenSixDigits = /[+-]?\d{6}/, // -999,999 - 999,999
        parseTokenSignedNumber = /[+-]?\d+/, // -inf - inf

        // iso 8601 regex
        // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
        isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,

        isoFormat = 'YYYY-MM-DDTHH:mm:ssZ',

        isoDates = [
            ['YYYYYY-MM-DD', /[+-]\d{6}-\d{2}-\d{2}/],
            ['YYYY-MM-DD', /\d{4}-\d{2}-\d{2}/],
            ['GGGG-[W]WW-E', /\d{4}-W\d{2}-\d/],
            ['GGGG-[W]WW', /\d{4}-W\d{2}/],
            ['YYYY-DDD', /\d{4}-\d{3}/]
        ],

        // iso time formats and regexes
        isoTimes = [
            ['HH:mm:ss.SSSS', /(T| )\d\d:\d\d:\d\d\.\d{1,3}/],
            ['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/],
            ['HH:mm', /(T| )\d\d:\d\d/],
            ['HH', /(T| )\d\d/]
        ],

        // timezone chunker "+10:00" > ["10", "00"] or "-1530" > ["-15", "30"]
        parseTimezoneChunker = /([\+\-]|\d\d)/gi,

        // getter and setter names
        proxyGettersAndSetters = 'Date|Hours|Minutes|Seconds|Milliseconds'.split('|'),
        unitMillisecondFactors = {
            'Milliseconds' : 1,
            'Seconds' : 1e3,
            'Minutes' : 6e4,
            'Hours' : 36e5,
            'Days' : 864e5,
            'Months' : 2592e6,
            'Years' : 31536e6
        },

        unitAliases = {
            ms : 'millisecond',
            s : 'second',
            m : 'minute',
            h : 'hour',
            d : 'day',
            D : 'date',
            w : 'week',
            W : 'isoWeek',
            M : 'month',
            y : 'year',
            DDD : 'dayOfYear',
            e : 'weekday',
            E : 'isoWeekday',
            gg: 'weekYear',
            GG: 'isoWeekYear'
        },

        camelFunctions = {
            dayofyear : 'dayOfYear',
            isoweekday : 'isoWeekday',
            isoweek : 'isoWeek',
            weekyear : 'weekYear',
            isoweekyear : 'isoWeekYear'
        },

        // format function strings
        formatFunctions = {},

        // tokens to ordinalize and pad
        ordinalizeTokens = 'DDD w W M D d'.split(' '),
        paddedTokens = 'M D H h m s w W'.split(' '),

        formatTokenFunctions = {
            M    : function () {
                return this.month() + 1;
            },
            MMM  : function (format) {
                return this.lang().monthsShort(this, format);
            },
            MMMM : function (format) {
                return this.lang().months(this, format);
            },
            D    : function () {
                return this.date();
            },
            DDD  : function () {
                return this.dayOfYear();
            },
            d    : function () {
                return this.day();
            },
            dd   : function (format) {
                return this.lang().weekdaysMin(this, format);
            },
            ddd  : function (format) {
                return this.lang().weekdaysShort(this, format);
            },
            dddd : function (format) {
                return this.lang().weekdays(this, format);
            },
            w    : function () {
                return this.week();
            },
            W    : function () {
                return this.isoWeek();
            },
            YY   : function () {
                return leftZeroFill(this.year() % 100, 2);
            },
            YYYY : function () {
                return leftZeroFill(this.year(), 4);
            },
            YYYYY : function () {
                return leftZeroFill(this.year(), 5);
            },
            YYYYYY : function () {
                var y = this.year(), sign = y >= 0 ? '+' : '-';
                return sign + leftZeroFill(Math.abs(y), 6);
            },
            gg   : function () {
                return leftZeroFill(this.weekYear() % 100, 2);
            },
            gggg : function () {
                return leftZeroFill(this.weekYear(), 4);
            },
            ggggg : function () {
                return leftZeroFill(this.weekYear(), 5);
            },
            GG   : function () {
                return leftZeroFill(this.isoWeekYear() % 100, 2);
            },
            GGGG : function () {
                return leftZeroFill(this.isoWeekYear(), 4);
            },
            GGGGG : function () {
                return leftZeroFill(this.isoWeekYear(), 5);
            },
            e : function () {
                return this.weekday();
            },
            E : function () {
                return this.isoWeekday();
            },
            a    : function () {
                return this.lang().meridiem(this.hours(), this.minutes(), true);
            },
            A    : function () {
                return this.lang().meridiem(this.hours(), this.minutes(), false);
            },
            H    : function () {
                return this.hours();
            },
            h    : function () {
                return this.hours() % 12 || 12;
            },
            m    : function () {
                return this.minutes();
            },
            s    : function () {
                return this.seconds();
            },
            S    : function () {
                return toInt(this.milliseconds() / 100);
            },
            SS   : function () {
                return leftZeroFill(toInt(this.milliseconds() / 10), 2);
            },
            SSS  : function () {
                return leftZeroFill(this.milliseconds(), 3);
            },
            SSSS : function () {
                return leftZeroFill(this.milliseconds(), 3);
            },
            Z    : function () {
                var a = -this.zone(),
                    b = "+";
                if (a < 0) {
                    a = -a;
                    b = "-";
                }
                return b + leftZeroFill(toInt(a / 60), 2) + ":" + leftZeroFill(toInt(a) % 60, 2);
            },
            ZZ   : function () {
                var a = -this.zone(),
                    b = "+";
                if (a < 0) {
                    a = -a;
                    b = "-";
                }
                return b + leftZeroFill(toInt(a / 60), 2) + leftZeroFill(toInt(a) % 60, 2);
            },
            z : function () {
                return this.zoneAbbr();
            },
            zz : function () {
                return this.zoneName();
            },
            X    : function () {
                return this.unix();
            },
            Q : function () {
                return this.quarter();
            }
        },

        lists = ['months', 'monthsShort', 'weekdays', 'weekdaysShort', 'weekdaysMin'];

    function defaultParsingFlags() {
        // We need to deep clone this object, and es5 standard is not very
        // helpful.
        return {
            empty : false,
            unusedTokens : [],
            unusedInput : [],
            overflow : -2,
            charsLeftOver : 0,
            nullInput : false,
            invalidMonth : null,
            invalidFormat : false,
            userInvalidated : false,
            iso: false
        };
    }

    function padToken(func, count) {
        return function (a) {
            return leftZeroFill(func.call(this, a), count);
        };
    }
    function ordinalizeToken(func, period) {
        return function (a) {
            return this.lang().ordinal(func.call(this, a), period);
        };
    }

    while (ordinalizeTokens.length) {
        i = ordinalizeTokens.pop();
        formatTokenFunctions[i + 'o'] = ordinalizeToken(formatTokenFunctions[i], i);
    }
    while (paddedTokens.length) {
        i = paddedTokens.pop();
        formatTokenFunctions[i + i] = padToken(formatTokenFunctions[i], 2);
    }
    formatTokenFunctions.DDDD = padToken(formatTokenFunctions.DDD, 3);


    /************************************
        Constructors
    ************************************/

    function Language() {

    }

    // Moment prototype object
    function Moment(config) {
        checkOverflow(config);
        extend(this, config);
    }

    // Duration Constructor
    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 36e5; // 1000 * 60 * 60
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            years * 12;

        this._data = {};

        this._bubble();
    }

    /************************************
        Helpers
    ************************************/


    function extend(a, b) {
        for (var i in b) {
            if (b.hasOwnProperty(i)) {
                a[i] = b[i];
            }
        }

        if (b.hasOwnProperty("toString")) {
            a.toString = b.toString;
        }

        if (b.hasOwnProperty("valueOf")) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function cloneMoment(m) {
        var result = {}, i;
        for (i in m) {
            if (m.hasOwnProperty(i) && momentProperties.hasOwnProperty(i)) {
                result[i] = m[i];
            }
        }

        return result;
    }

    function absRound(number) {
        if (number < 0) {
            return Math.ceil(number);
        } else {
            return Math.floor(number);
        }
    }

    // left zero fill a number
    // see http://jsperf.com/left-zero-filling for performance comparison
    function leftZeroFill(number, targetLength, forceSign) {
        var output = '' + Math.abs(number),
            sign = number >= 0;

        while (output.length < targetLength) {
            output = '0' + output;
        }
        return (sign ? (forceSign ? '+' : '') : '-') + output;
    }

    // helper function for _.addTime and _.subtractTime
    function addOrSubtractDurationFromMoment(mom, duration, isAdding, ignoreUpdateOffset) {
        var milliseconds = duration._milliseconds,
            days = duration._days,
            months = duration._months,
            minutes,
            hours;

        if (milliseconds) {
            mom._d.setTime(+mom._d + milliseconds * isAdding);
        }
        // store the minutes and hours so we can restore them
        if (days || months) {
            minutes = mom.minute();
            hours = mom.hour();
        }
        if (days) {
            mom.date(mom.date() + days * isAdding);
        }
        if (months) {
            mom.month(mom.month() + months * isAdding);
        }
        if (milliseconds && !ignoreUpdateOffset) {
            moment.updateOffset(mom);
        }
        // restore the minutes and hours after possibly changing dst
        if (days || months) {
            mom.minute(minutes);
            mom.hour(hours);
        }
    }

    // check if is an array
    function isArray(input) {
        return Object.prototype.toString.call(input) === '[object Array]';
    }

    function isDate(input) {
        return  Object.prototype.toString.call(input) === '[object Date]' ||
                input instanceof Date;
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function normalizeUnits(units) {
        if (units) {
            var lowered = units.toLowerCase().replace(/(.)s$/, '$1');
            units = unitAliases[units] || camelFunctions[lowered] || lowered;
        }
        return units;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (inputObject.hasOwnProperty(prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    function makeList(field) {
        var count, setter;

        if (field.indexOf('week') === 0) {
            count = 7;
            setter = 'day';
        }
        else if (field.indexOf('month') === 0) {
            count = 12;
            setter = 'month';
        }
        else {
            return;
        }

        moment[field] = function (format, index) {
            var i, getter,
                method = moment.fn._lang[field],
                results = [];

            if (typeof format === 'number') {
                index = format;
                format = undefined;
            }

            getter = function (i) {
                var m = moment().utc().set(setter, i);
                return method.call(moment.fn._lang, m, format || '');
            };

            if (index != null) {
                return getter(index);
            }
            else {
                for (i = 0; i < count; i++) {
                    results.push(getter(i));
                }
                return results;
            }
        };
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            if (coercedNumber >= 0) {
                value = Math.floor(coercedNumber);
            } else {
                value = Math.ceil(coercedNumber);
            }
        }

        return value;
    }

    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    function checkOverflow(m) {
        var overflow;
        if (m._a && m._pf.overflow === -2) {
            overflow =
                m._a[MONTH] < 0 || m._a[MONTH] > 11 ? MONTH :
                m._a[DATE] < 1 || m._a[DATE] > daysInMonth(m._a[YEAR], m._a[MONTH]) ? DATE :
                m._a[HOUR] < 0 || m._a[HOUR] > 23 ? HOUR :
                m._a[MINUTE] < 0 || m._a[MINUTE] > 59 ? MINUTE :
                m._a[SECOND] < 0 || m._a[SECOND] > 59 ? SECOND :
                m._a[MILLISECOND] < 0 || m._a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (m._pf._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }

            m._pf.overflow = overflow;
        }
    }

    function isValid(m) {
        if (m._isValid == null) {
            m._isValid = !isNaN(m._d.getTime()) &&
                m._pf.overflow < 0 &&
                !m._pf.empty &&
                !m._pf.invalidMonth &&
                !m._pf.nullInput &&
                !m._pf.invalidFormat &&
                !m._pf.userInvalidated;

            if (m._strict) {
                m._isValid = m._isValid &&
                    m._pf.charsLeftOver === 0 &&
                    m._pf.unusedTokens.length === 0;
            }
        }
        return m._isValid;
    }

    function normalizeLanguage(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function makeAs(input, model) {
        return model._isUTC ? moment(input).zone(model._offset || 0) :
            moment(input).local();
    }

    /************************************
        Languages
    ************************************/


    extend(Language.prototype, {

        set : function (config) {
            var prop, i;
            for (i in config) {
                prop = config[i];
                if (typeof prop === 'function') {
                    this[i] = prop;
                } else {
                    this['_' + i] = prop;
                }
            }
        },

        _months : "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        months : function (m) {
            return this._months[m.month()];
        },

        _monthsShort : "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
        monthsShort : function (m) {
            return this._monthsShort[m.month()];
        },

        monthsParse : function (monthName) {
            var i, mom, regex;

            if (!this._monthsParse) {
                this._monthsParse = [];
            }

            for (i = 0; i < 12; i++) {
                // make the regex if we don't have it already
                if (!this._monthsParse[i]) {
                    mom = moment.utc([2000, i]);
                    regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                    this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (this._monthsParse[i].test(monthName)) {
                    return i;
                }
            }
        },

        _weekdays : "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        weekdays : function (m) {
            return this._weekdays[m.day()];
        },

        _weekdaysShort : "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        weekdaysShort : function (m) {
            return this._weekdaysShort[m.day()];
        },

        _weekdaysMin : "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
        weekdaysMin : function (m) {
            return this._weekdaysMin[m.day()];
        },

        weekdaysParse : function (weekdayName) {
            var i, mom, regex;

            if (!this._weekdaysParse) {
                this._weekdaysParse = [];
            }

            for (i = 0; i < 7; i++) {
                // make the regex if we don't have it already
                if (!this._weekdaysParse[i]) {
                    mom = moment([2000, 1]).day(i);
                    regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                    this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (this._weekdaysParse[i].test(weekdayName)) {
                    return i;
                }
            }
        },

        _longDateFormat : {
            LT : "h:mm A",
            L : "MM/DD/YYYY",
            LL : "MMMM D YYYY",
            LLL : "MMMM D YYYY LT",
            LLLL : "dddd, MMMM D YYYY LT"
        },
        longDateFormat : function (key) {
            var output = this._longDateFormat[key];
            if (!output && this._longDateFormat[key.toUpperCase()]) {
                output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function (val) {
                    return val.slice(1);
                });
                this._longDateFormat[key] = output;
            }
            return output;
        },

        isPM : function (input) {
            // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
            // Using charAt should be more compatible.
            return ((input + '').toLowerCase().charAt(0) === 'p');
        },

        _meridiemParse : /[ap]\.?m?\.?/i,
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'pm' : 'PM';
            } else {
                return isLower ? 'am' : 'AM';
            }
        },

        _calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        calendar : function (key, mom) {
            var output = this._calendar[key];
            return typeof output === 'function' ? output.apply(mom) : output;
        },

        _relativeTime : {
            future : "in %s",
            past : "%s ago",
            s : "a few seconds",
            m : "a minute",
            mm : "%d minutes",
            h : "an hour",
            hh : "%d hours",
            d : "a day",
            dd : "%d days",
            M : "a month",
            MM : "%d months",
            y : "a year",
            yy : "%d years"
        },
        relativeTime : function (number, withoutSuffix, string, isFuture) {
            var output = this._relativeTime[string];
            return (typeof output === 'function') ?
                output(number, withoutSuffix, string, isFuture) :
                output.replace(/%d/i, number);
        },
        pastFuture : function (diff, output) {
            var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
            return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);
        },

        ordinal : function (number) {
            return this._ordinal.replace("%d", number);
        },
        _ordinal : "%d",

        preparse : function (string) {
            return string;
        },

        postformat : function (string) {
            return string;
        },

        week : function (mom) {
            return weekOfYear(mom, this._week.dow, this._week.doy).week;
        },

        _week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        },

        _invalidDate: 'Invalid date',
        invalidDate: function () {
            return this._invalidDate;
        }
    });

    // Loads a language definition into the `languages` cache.  The function
    // takes a key and optionally values.  If not in the browser and no values
    // are provided, it will load the language file module.  As a convenience,
    // this function also returns the language values.
    function loadLang(key, values) {
        values.abbr = key;
        if (!languages[key]) {
            languages[key] = new Language();
        }
        languages[key].set(values);
        return languages[key];
    }

    // Remove a language from the `languages` cache. Mostly useful in tests.
    function unloadLang(key) {
        delete languages[key];
    }

    // Determines which language definition to use and returns it.
    //
    // With no parameters, it will return the global language.  If you
    // pass in a language key, such as 'en', it will return the
    // definition for 'en', so long as 'en' has already been loaded using
    // moment.lang.
    function getLangDefinition(key) {
        var i = 0, j, lang, next, split,
            get = function (k) {
                if (!languages[k] && hasModule) {
                    try {
                        require('./lang/' + k);
                    } catch (e) { }
                }
                return languages[k];
            };

        if (!key) {
            return moment.fn._lang;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            lang = get(key);
            if (lang) {
                return lang;
            }
            key = [key];
        }

        //pick the language from the array
        //try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
        //substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
        while (i < key.length) {
            split = normalizeLanguage(key[i]).split('-');
            j = split.length;
            next = normalizeLanguage(key[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                lang = get(split.slice(0, j).join('-'));
                if (lang) {
                    return lang;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return moment.fn._lang;
    }

    /************************************
        Formatting
    ************************************/


    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, "");
        }
        return input.replace(/\\/g, "");
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = "";
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {

        if (!m.isValid()) {
            return m.lang().invalidDate();
        }

        format = expandFormat(format, m.lang());

        if (!formatFunctions[format]) {
            formatFunctions[format] = makeFormatFunction(format);
        }

        return formatFunctions[format](m);
    }

    function expandFormat(format, lang) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return lang.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }


    /************************************
        Parsing
    ************************************/


    // get the regex to find the next token
    function getParseRegexForToken(token, config) {
        var a, strict = config._strict;
        switch (token) {
        case 'DDDD':
            return parseTokenThreeDigits;
        case 'YYYY':
        case 'GGGG':
        case 'gggg':
            return strict ? parseTokenFourDigits : parseTokenOneToFourDigits;
        case 'Y':
        case 'G':
        case 'g':
            return parseTokenSignedNumber;
        case 'YYYYYY':
        case 'YYYYY':
        case 'GGGGG':
        case 'ggggg':
            return strict ? parseTokenSixDigits : parseTokenOneToSixDigits;
        case 'S':
            if (strict) { return parseTokenOneDigit; }
            /* falls through */
        case 'SS':
            if (strict) { return parseTokenTwoDigits; }
            /* falls through */
        case 'SSS':
            if (strict) { return parseTokenThreeDigits; }
            /* falls through */
        case 'DDD':
            return parseTokenOneToThreeDigits;
        case 'MMM':
        case 'MMMM':
        case 'dd':
        case 'ddd':
        case 'dddd':
            return parseTokenWord;
        case 'a':
        case 'A':
            return getLangDefinition(config._l)._meridiemParse;
        case 'X':
            return parseTokenTimestampMs;
        case 'Z':
        case 'ZZ':
            return parseTokenTimezone;
        case 'T':
            return parseTokenT;
        case 'SSSS':
            return parseTokenDigits;
        case 'MM':
        case 'DD':
        case 'YY':
        case 'GG':
        case 'gg':
        case 'HH':
        case 'hh':
        case 'mm':
        case 'ss':
        case 'ww':
        case 'WW':
            return strict ? parseTokenTwoDigits : parseTokenOneOrTwoDigits;
        case 'M':
        case 'D':
        case 'd':
        case 'H':
        case 'h':
        case 'm':
        case 's':
        case 'w':
        case 'W':
        case 'e':
        case 'E':
            return parseTokenOneOrTwoDigits;
        default :
            a = new RegExp(regexpEscape(unescapeFormat(token.replace('\\', '')), "i"));
            return a;
        }
    }

    function timezoneMinutesFromString(string) {
        string = string || "";
        var possibleTzMatches = (string.match(parseTokenTimezone) || []),
            tzChunk = possibleTzMatches[possibleTzMatches.length - 1] || [],
            parts = (tzChunk + '').match(parseTimezoneChunker) || ['-', 0, 0],
            minutes = +(parts[1] * 60) + toInt(parts[2]);

        return parts[0] === '+' ? -minutes : minutes;
    }

    // function to convert string input to date
    function addTimeToArrayFromToken(token, input, config) {
        var a, datePartArray = config._a;

        switch (token) {
        // MONTH
        case 'M' : // fall through to MM
        case 'MM' :
            if (input != null) {
                datePartArray[MONTH] = toInt(input) - 1;
            }
            break;
        case 'MMM' : // fall through to MMMM
        case 'MMMM' :
            a = getLangDefinition(config._l).monthsParse(input);
            // if we didn't find a month name, mark the date as invalid.
            if (a != null) {
                datePartArray[MONTH] = a;
            } else {
                config._pf.invalidMonth = input;
            }
            break;
        // DAY OF MONTH
        case 'D' : // fall through to DD
        case 'DD' :
            if (input != null) {
                datePartArray[DATE] = toInt(input);
            }
            break;
        // DAY OF YEAR
        case 'DDD' : // fall through to DDDD
        case 'DDDD' :
            if (input != null) {
                config._dayOfYear = toInt(input);
            }

            break;
        // YEAR
        case 'YY' :
            datePartArray[YEAR] = toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
            break;
        case 'YYYY' :
        case 'YYYYY' :
        case 'YYYYYY' :
            datePartArray[YEAR] = toInt(input);
            break;
        // AM / PM
        case 'a' : // fall through to A
        case 'A' :
            config._isPm = getLangDefinition(config._l).isPM(input);
            break;
        // 24 HOUR
        case 'H' : // fall through to hh
        case 'HH' : // fall through to hh
        case 'h' : // fall through to hh
        case 'hh' :
            datePartArray[HOUR] = toInt(input);
            break;
        // MINUTE
        case 'm' : // fall through to mm
        case 'mm' :
            datePartArray[MINUTE] = toInt(input);
            break;
        // SECOND
        case 's' : // fall through to ss
        case 'ss' :
            datePartArray[SECOND] = toInt(input);
            break;
        // MILLISECOND
        case 'S' :
        case 'SS' :
        case 'SSS' :
        case 'SSSS' :
            datePartArray[MILLISECOND] = toInt(('0.' + input) * 1000);
            break;
        // UNIX TIMESTAMP WITH MS
        case 'X':
            config._d = new Date(parseFloat(input) * 1000);
            break;
        // TIMEZONE
        case 'Z' : // fall through to ZZ
        case 'ZZ' :
            config._useUTC = true;
            config._tzm = timezoneMinutesFromString(input);
            break;
        case 'w':
        case 'ww':
        case 'W':
        case 'WW':
        case 'd':
        case 'dd':
        case 'ddd':
        case 'dddd':
        case 'e':
        case 'E':
            token = token.substr(0, 1);
            /* falls through */
        case 'gg':
        case 'gggg':
        case 'GG':
        case 'GGGG':
        case 'GGGGG':
            token = token.substr(0, 2);
            if (input) {
                config._w = config._w || {};
                config._w[token] = input;
            }
            break;
        }
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function dateFromConfig(config) {
        var i, date, input = [], currentDate,
            yearToUse, fixYear, w, temp, lang, weekday, week;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            fixYear = function (val) {
                var int_val = parseInt(val, 10);
                return val ?
                  (val.length < 3 ? (int_val > 68 ? 1900 + int_val : 2000 + int_val) : int_val) :
                  (config._a[YEAR] == null ? moment().weekYear() : config._a[YEAR]);
            };

            w = config._w;
            if (w.GG != null || w.W != null || w.E != null) {
                temp = dayOfYearFromWeeks(fixYear(w.GG), w.W || 1, w.E, 4, 1);
            }
            else {
                lang = getLangDefinition(config._l);
                weekday = w.d != null ?  parseWeekday(w.d, lang) :
                  (w.e != null ?  parseInt(w.e, 10) + lang._week.dow : 0);

                week = parseInt(w.w, 10) || 1;

                //if we're parsing 'd', then the low day numbers may be next week
                if (w.d != null && weekday < lang._week.dow) {
                    week++;
                }

                temp = dayOfYearFromWeeks(fixYear(w.gg), week, weekday, lang._week.doy, lang._week.dow);
            }

            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear) {
            yearToUse = config._a[YEAR] == null ? currentDate[YEAR] : config._a[YEAR];

            if (config._dayOfYear > daysInYear(yearToUse)) {
                config._pf._overflowDayOfYear = true;
            }

            date = makeUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // add the offsets to the time to be parsed so that we can have a clean array for checking isValid
        input[HOUR] += toInt((config._tzm || 0) / 60);
        input[MINUTE] += toInt((config._tzm || 0) % 60);

        config._d = (config._useUTC ? makeUTCDate : makeDate).apply(null, input);
    }

    function dateFromObject(config) {
        var normalizedInput;

        if (config._d) {
            return;
        }

        normalizedInput = normalizeObjectUnits(config._i);
        config._a = [
            normalizedInput.year,
            normalizedInput.month,
            normalizedInput.day,
            normalizedInput.hour,
            normalizedInput.minute,
            normalizedInput.second,
            normalizedInput.millisecond
        ];

        dateFromConfig(config);
    }

    function currentDateArray(config) {
        var now = new Date();
        if (config._useUTC) {
            return [
                now.getUTCFullYear(),
                now.getUTCMonth(),
                now.getUTCDate()
            ];
        } else {
            return [now.getFullYear(), now.getMonth(), now.getDate()];
        }
    }

    // date from string and format string
    function makeDateFromStringAndFormat(config) {

        config._a = [];
        config._pf.empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var lang = getLangDefinition(config._l),
            string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, lang).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    config._pf.unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    config._pf.empty = false;
                }
                else {
                    config._pf.unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                config._pf.unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        config._pf.charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            config._pf.unusedInput.push(string);
        }

        // handle am pm
        if (config._isPm && config._a[HOUR] < 12) {
            config._a[HOUR] += 12;
        }
        // if is 12 am, change hours to 0
        if (config._isPm === false && config._a[HOUR] === 12) {
            config._a[HOUR] = 0;
        }

        dateFromConfig(config);
        checkOverflow(config);
    }

    function unescapeFormat(s) {
        return s.replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        });
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function regexpEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    // date from string and array of format strings
    function makeDateFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            config._pf.invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = extend({}, config);
            tempConfig._pf = defaultParsingFlags();
            tempConfig._f = config._f[i];
            makeDateFromStringAndFormat(tempConfig);

            if (!isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += tempConfig._pf.charsLeftOver;

            //or tokens
            currentScore += tempConfig._pf.unusedTokens.length * 10;

            tempConfig._pf.score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    // date from iso format
    function makeDateFromString(config) {
        var i, l,
            string = config._i,
            match = isoRegex.exec(string);

        if (match) {
            config._pf.iso = true;
            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(string)) {
                    // match[5] should be "T" or undefined
                    config._f = isoDates[i][0] + (match[6] || " ");
                    break;
                }
            }
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(string)) {
                    config._f += isoTimes[i][0];
                    break;
                }
            }
            if (string.match(parseTokenTimezone)) {
                config._f += "Z";
            }
            makeDateFromStringAndFormat(config);
        }
        else {
            config._d = new Date(string);
        }
    }

    function makeDateFromInput(config) {
        var input = config._i,
            matched = aspNetJsonRegex.exec(input);

        if (input === undefined) {
            config._d = new Date();
        } else if (matched) {
            config._d = new Date(+matched[1]);
        } else if (typeof input === 'string') {
            makeDateFromString(config);
        } else if (isArray(input)) {
            config._a = input.slice(0);
            dateFromConfig(config);
        } else if (isDate(input)) {
            config._d = new Date(+input);
        } else if (typeof(input) === 'object') {
            dateFromObject(config);
        } else {
            config._d = new Date(input);
        }
    }

    function makeDate(y, m, d, h, M, s, ms) {
        //can't just apply() to create a date:
        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
        var date = new Date(y, m, d, h, M, s, ms);

        //the date constructor doesn't accept years < 1970
        if (y < 1970) {
            date.setFullYear(y);
        }
        return date;
    }

    function makeUTCDate(y) {
        var date = new Date(Date.UTC.apply(null, arguments));
        if (y < 1970) {
            date.setUTCFullYear(y);
        }
        return date;
    }

    function parseWeekday(input, language) {
        if (typeof input === 'string') {
            if (!isNaN(input)) {
                input = parseInt(input, 10);
            }
            else {
                input = language.weekdaysParse(input);
                if (typeof input !== 'number') {
                    return null;
                }
            }
        }
        return input;
    }

    /************************************
        Relative Time
    ************************************/


    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, lang) {
        return lang.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime(milliseconds, withoutSuffix, lang) {
        var seconds = round(Math.abs(milliseconds) / 1000),
            minutes = round(seconds / 60),
            hours = round(minutes / 60),
            days = round(hours / 24),
            years = round(days / 365),
            args = seconds < 45 && ['s', seconds] ||
                minutes === 1 && ['m'] ||
                minutes < 45 && ['mm', minutes] ||
                hours === 1 && ['h'] ||
                hours < 22 && ['hh', hours] ||
                days === 1 && ['d'] ||
                days <= 25 && ['dd', days] ||
                days <= 45 && ['M'] ||
                days < 345 && ['MM', round(days / 30)] ||
                years === 1 && ['y'] || ['yy', years];
        args[2] = withoutSuffix;
        args[3] = milliseconds > 0;
        args[4] = lang;
        return substituteTimeAgo.apply({}, args);
    }


    /************************************
        Week of Year
    ************************************/


    // firstDayOfWeek       0 = sun, 6 = sat
    //                      the day of the week that starts the week
    //                      (usually sunday or monday)
    // firstDayOfWeekOfYear 0 = sun, 6 = sat
    //                      the first week is the week that contains the first
    //                      of this day of the week
    //                      (eg. ISO weeks use thursday (4))
    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
        var end = firstDayOfWeekOfYear - firstDayOfWeek,
            daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
            adjustedMoment;


        if (daysToDayOfWeek > end) {
            daysToDayOfWeek -= 7;
        }

        if (daysToDayOfWeek < end - 7) {
            daysToDayOfWeek += 7;
        }

        adjustedMoment = moment(mom).add('d', daysToDayOfWeek);
        return {
            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
            year: adjustedMoment.year()
        };
    }

    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
        var d = makeUTCDate(year, 0, 1).getUTCDay(), daysToAdd, dayOfYear;

        weekday = weekday != null ? weekday : firstDayOfWeek;
        daysToAdd = firstDayOfWeek - d + (d > firstDayOfWeekOfYear ? 7 : 0) - (d < firstDayOfWeek ? 7 : 0);
        dayOfYear = 7 * (week - 1) + (weekday - firstDayOfWeek) + daysToAdd + 1;

        return {
            year: dayOfYear > 0 ? year : year - 1,
            dayOfYear: dayOfYear > 0 ?  dayOfYear : daysInYear(year - 1) + dayOfYear
        };
    }

    /************************************
        Top Level Functions
    ************************************/

    function makeMoment(config) {
        var input = config._i,
            format = config._f;

        if (input === null) {
            return moment.invalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = getLangDefinition().preparse(input);
        }

        if (moment.isMoment(input)) {
            config = cloneMoment(input);

            config._d = new Date(+input._d);
        } else if (format) {
            if (isArray(format)) {
                makeDateFromStringAndArray(config);
            } else {
                makeDateFromStringAndFormat(config);
            }
        } else {
            makeDateFromInput(config);
        }

        return new Moment(config);
    }

    moment = function (input, format, lang, strict) {
        var c;

        if (typeof(lang) === "boolean") {
            strict = lang;
            lang = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c = {};
        c._isAMomentObject = true;
        c._i = input;
        c._f = format;
        c._l = lang;
        c._strict = strict;
        c._isUTC = false;
        c._pf = defaultParsingFlags();

        return makeMoment(c);
    };

    // creating with utc
    moment.utc = function (input, format, lang, strict) {
        var c;

        if (typeof(lang) === "boolean") {
            strict = lang;
            lang = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c = {};
        c._isAMomentObject = true;
        c._useUTC = true;
        c._isUTC = true;
        c._l = lang;
        c._i = input;
        c._f = format;
        c._strict = strict;
        c._pf = defaultParsingFlags();

        return makeMoment(c).utc();
    };

    // creating with unix timestamp (in seconds)
    moment.unix = function (input) {
        return moment(input * 1000);
    };

    // duration
    moment.duration = function (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            parseIso;

        if (moment.isDuration(input)) {
            duration = {
                ms: input._milliseconds,
                d: input._days,
                M: input._months
            };
        } else if (typeof input === 'number') {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetTimeSpanJsonRegex.exec(input))) {
            sign = (match[1] === "-") ? -1 : 1;
            duration = {
                y: 0,
                d: toInt(match[DATE]) * sign,
                h: toInt(match[HOUR]) * sign,
                m: toInt(match[MINUTE]) * sign,
                s: toInt(match[SECOND]) * sign,
                ms: toInt(match[MILLISECOND]) * sign
            };
        } else if (!!(match = isoDurationRegex.exec(input))) {
            sign = (match[1] === "-") ? -1 : 1;
            parseIso = function (inp) {
                // We'd normally use ~~inp for this, but unfortunately it also
                // converts floats to ints.
                // inp may be undefined, so careful calling replace on it.
                var res = inp && parseFloat(inp.replace(',', '.'));
                // apply sign while we're at it
                return (isNaN(res) ? 0 : res) * sign;
            };
            duration = {
                y: parseIso(match[2]),
                M: parseIso(match[3]),
                d: parseIso(match[4]),
                h: parseIso(match[5]),
                m: parseIso(match[6]),
                s: parseIso(match[7]),
                w: parseIso(match[8])
            };
        }

        ret = new Duration(duration);

        if (moment.isDuration(input) && input.hasOwnProperty('_lang')) {
            ret._lang = input._lang;
        }

        return ret;
    };

    // version number
    moment.version = VERSION;

    // default format
    moment.defaultFormat = isoFormat;

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    moment.updateOffset = function () {};

    // This function will load languages and then set the global language.  If
    // no arguments are passed in, it will simply return the current global
    // language key.
    moment.lang = function (key, values) {
        var r;
        if (!key) {
            return moment.fn._lang._abbr;
        }
        if (values) {
            loadLang(normalizeLanguage(key), values);
        } else if (values === null) {
            unloadLang(key);
            key = 'en';
        } else if (!languages[key]) {
            getLangDefinition(key);
        }
        r = moment.duration.fn._lang = moment.fn._lang = getLangDefinition(key);
        return r._abbr;
    };

    // returns language data
    moment.langData = function (key) {
        if (key && key._lang && key._lang._abbr) {
            key = key._lang._abbr;
        }
        return getLangDefinition(key);
    };

    // compare moment object
    moment.isMoment = function (obj) {
        return obj instanceof Moment ||
            (obj != null &&  obj.hasOwnProperty('_isAMomentObject'));
    };

    // for typechecking Duration objects
    moment.isDuration = function (obj) {
        return obj instanceof Duration;
    };

    for (i = lists.length - 1; i >= 0; --i) {
        makeList(lists[i]);
    }

    moment.normalizeUnits = function (units) {
        return normalizeUnits(units);
    };

    moment.invalid = function (flags) {
        var m = moment.utc(NaN);
        if (flags != null) {
            extend(m._pf, flags);
        }
        else {
            m._pf.userInvalidated = true;
        }

        return m;
    };

    moment.parseZone = function (input) {
        return moment(input).parseZone();
    };

    /************************************
        Moment Prototype
    ************************************/


    extend(moment.fn = Moment.prototype, {

        clone : function () {
            return moment(this);
        },

        valueOf : function () {
            return +this._d + ((this._offset || 0) * 60000);
        },

        unix : function () {
            return Math.floor(+this / 1000);
        },

        toString : function () {
            return this.clone().lang('en').format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
        },

        toDate : function () {
            return this._offset ? new Date(+this) : this._d;
        },

        toISOString : function () {
            var m = moment(this).utc();
            if (0 < m.year() && m.year() <= 9999) {
                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            } else {
                return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            }
        },

        toArray : function () {
            var m = this;
            return [
                m.year(),
                m.month(),
                m.date(),
                m.hours(),
                m.minutes(),
                m.seconds(),
                m.milliseconds()
            ];
        },

        isValid : function () {
            return isValid(this);
        },

        isDSTShifted : function () {

            if (this._a) {
                return this.isValid() && compareArrays(this._a, (this._isUTC ? moment.utc(this._a) : moment(this._a)).toArray()) > 0;
            }

            return false;
        },

        parsingFlags : function () {
            return extend({}, this._pf);
        },

        invalidAt: function () {
            return this._pf.overflow;
        },

        utc : function () {
            return this.zone(0);
        },

        local : function () {
            this.zone(0);
            this._isUTC = false;
            return this;
        },

        format : function (inputString) {
            var output = formatMoment(this, inputString || moment.defaultFormat);
            return this.lang().postformat(output);
        },

        add : function (input, val) {
            var dur;
            // switch args to support add('s', 1) and add(1, 's')
            if (typeof input === 'string') {
                dur = moment.duration(+val, input);
            } else {
                dur = moment.duration(input, val);
            }
            addOrSubtractDurationFromMoment(this, dur, 1);
            return this;
        },

        subtract : function (input, val) {
            var dur;
            // switch args to support subtract('s', 1) and subtract(1, 's')
            if (typeof input === 'string') {
                dur = moment.duration(+val, input);
            } else {
                dur = moment.duration(input, val);
            }
            addOrSubtractDurationFromMoment(this, dur, -1);
            return this;
        },

        diff : function (input, units, asFloat) {
            var that = makeAs(input, this),
                zoneDiff = (this.zone() - that.zone()) * 6e4,
                diff, output;

            units = normalizeUnits(units);

            if (units === 'year' || units === 'month') {
                // average number of days in the months in the given dates
                diff = (this.daysInMonth() + that.daysInMonth()) * 432e5; // 24 * 60 * 60 * 1000 / 2
                // difference in months
                output = ((this.year() - that.year()) * 12) + (this.month() - that.month());
                // adjust by taking difference in days, average number of days
                // and dst in the given months.
                output += ((this - moment(this).startOf('month')) -
                        (that - moment(that).startOf('month'))) / diff;
                // same as above but with zones, to negate all dst
                output -= ((this.zone() - moment(this).startOf('month').zone()) -
                        (that.zone() - moment(that).startOf('month').zone())) * 6e4 / diff;
                if (units === 'year') {
                    output = output / 12;
                }
            } else {
                diff = (this - that);
                output = units === 'second' ? diff / 1e3 : // 1000
                    units === 'minute' ? diff / 6e4 : // 1000 * 60
                    units === 'hour' ? diff / 36e5 : // 1000 * 60 * 60
                    units === 'day' ? (diff - zoneDiff) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                    units === 'week' ? (diff - zoneDiff) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                    diff;
            }
            return asFloat ? output : absRound(output);
        },

        from : function (time, withoutSuffix) {
            return moment.duration(this.diff(time)).lang(this.lang()._abbr).humanize(!withoutSuffix);
        },

        fromNow : function (withoutSuffix) {
            return this.from(moment(), withoutSuffix);
        },

        calendar : function () {
            // We want to compare the start of today, vs this.
            // Getting start-of-today depends on whether we're zone'd or not.
            var sod = makeAs(moment(), this).startOf('day'),
                diff = this.diff(sod, 'days', true),
                format = diff < -6 ? 'sameElse' :
                    diff < -1 ? 'lastWeek' :
                    diff < 0 ? 'lastDay' :
                    diff < 1 ? 'sameDay' :
                    diff < 2 ? 'nextDay' :
                    diff < 7 ? 'nextWeek' : 'sameElse';
            return this.format(this.lang().calendar(format, this));
        },

        isLeapYear : function () {
            return isLeapYear(this.year());
        },

        isDST : function () {
            return (this.zone() < this.clone().month(0).zone() ||
                this.zone() < this.clone().month(5).zone());
        },

        day : function (input) {
            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
            if (input != null) {
                input = parseWeekday(input, this.lang());
                return this.add({ d : input - day });
            } else {
                return day;
            }
        },

        month : function (input) {
            var utc = this._isUTC ? 'UTC' : '',
                dayOfMonth;

            if (input != null) {
                if (typeof input === 'string') {
                    input = this.lang().monthsParse(input);
                    if (typeof input !== 'number') {
                        return this;
                    }
                }

                dayOfMonth = this.date();
                this.date(1);
                this._d['set' + utc + 'Month'](input);
                this.date(Math.min(dayOfMonth, this.daysInMonth()));

                moment.updateOffset(this);
                return this;
            } else {
                return this._d['get' + utc + 'Month']();
            }
        },

        startOf: function (units) {
            units = normalizeUnits(units);
            // the following switch intentionally omits break keywords
            // to utilize falling through the cases.
            switch (units) {
            case 'year':
                this.month(0);
                /* falls through */
            case 'month':
                this.date(1);
                /* falls through */
            case 'week':
            case 'isoWeek':
            case 'day':
                this.hours(0);
                /* falls through */
            case 'hour':
                this.minutes(0);
                /* falls through */
            case 'minute':
                this.seconds(0);
                /* falls through */
            case 'second':
                this.milliseconds(0);
                /* falls through */
            }

            // weeks are a special case
            if (units === 'week') {
                this.weekday(0);
            } else if (units === 'isoWeek') {
                this.isoWeekday(1);
            }

            return this;
        },

        endOf: function (units) {
            units = normalizeUnits(units);
            return this.startOf(units).add((units === 'isoWeek' ? 'week' : units), 1).subtract('ms', 1);
        },

        isAfter: function (input, units) {
            units = typeof units !== 'undefined' ? units : 'millisecond';
            return +this.clone().startOf(units) > +moment(input).startOf(units);
        },

        isBefore: function (input, units) {
            units = typeof units !== 'undefined' ? units : 'millisecond';
            return +this.clone().startOf(units) < +moment(input).startOf(units);
        },

        isSame: function (input, units) {
            units = units || 'ms';
            return +this.clone().startOf(units) === +makeAs(input, this).startOf(units);
        },

        min: function (other) {
            other = moment.apply(null, arguments);
            return other < this ? this : other;
        },

        max: function (other) {
            other = moment.apply(null, arguments);
            return other > this ? this : other;
        },

        zone : function (input) {
            var offset = this._offset || 0;
            if (input != null) {
                if (typeof input === "string") {
                    input = timezoneMinutesFromString(input);
                }
                if (Math.abs(input) < 16) {
                    input = input * 60;
                }
                this._offset = input;
                this._isUTC = true;
                if (offset !== input) {
                    addOrSubtractDurationFromMoment(this, moment.duration(offset - input, 'm'), 1, true);
                }
            } else {
                return this._isUTC ? offset : this._d.getTimezoneOffset();
            }
            return this;
        },

        zoneAbbr : function () {
            return this._isUTC ? "UTC" : "";
        },

        zoneName : function () {
            return this._isUTC ? "Coordinated Universal Time" : "";
        },

        parseZone : function () {
            if (this._tzm) {
                this.zone(this._tzm);
            } else if (typeof this._i === 'string') {
                this.zone(this._i);
            }
            return this;
        },

        hasAlignedHourOffset : function (input) {
            if (!input) {
                input = 0;
            }
            else {
                input = moment(input).zone();
            }

            return (this.zone() - input) % 60 === 0;
        },

        daysInMonth : function () {
            return daysInMonth(this.year(), this.month());
        },

        dayOfYear : function (input) {
            var dayOfYear = round((moment(this).startOf('day') - moment(this).startOf('year')) / 864e5) + 1;
            return input == null ? dayOfYear : this.add("d", (input - dayOfYear));
        },

        quarter : function () {
            return Math.ceil((this.month() + 1.0) / 3.0);
        },

        weekYear : function (input) {
            var year = weekOfYear(this, this.lang()._week.dow, this.lang()._week.doy).year;
            return input == null ? year : this.add("y", (input - year));
        },

        isoWeekYear : function (input) {
            var year = weekOfYear(this, 1, 4).year;
            return input == null ? year : this.add("y", (input - year));
        },

        week : function (input) {
            var week = this.lang().week(this);
            return input == null ? week : this.add("d", (input - week) * 7);
        },

        isoWeek : function (input) {
            var week = weekOfYear(this, 1, 4).week;
            return input == null ? week : this.add("d", (input - week) * 7);
        },

        weekday : function (input) {
            var weekday = (this.day() + 7 - this.lang()._week.dow) % 7;
            return input == null ? weekday : this.add("d", input - weekday);
        },

        isoWeekday : function (input) {
            // behaves the same as moment#day except
            // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
            // as a setter, sunday should belong to the previous week.
            return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
        },

        get : function (units) {
            units = normalizeUnits(units);
            return this[units]();
        },

        set : function (units, value) {
            units = normalizeUnits(units);
            if (typeof this[units] === 'function') {
                this[units](value);
            }
            return this;
        },

        // If passed a language key, it will set the language for this
        // instance.  Otherwise, it will return the language configuration
        // variables for this instance.
        lang : function (key) {
            if (key === undefined) {
                return this._lang;
            } else {
                this._lang = getLangDefinition(key);
                return this;
            }
        }
    });

    // helper for adding shortcuts
    function makeGetterAndSetter(name, key) {
        moment.fn[name] = moment.fn[name + 's'] = function (input) {
            var utc = this._isUTC ? 'UTC' : '';
            if (input != null) {
                this._d['set' + utc + key](input);
                moment.updateOffset(this);
                return this;
            } else {
                return this._d['get' + utc + key]();
            }
        };
    }

    // loop through and add shortcuts (Month, Date, Hours, Minutes, Seconds, Milliseconds)
    for (i = 0; i < proxyGettersAndSetters.length; i ++) {
        makeGetterAndSetter(proxyGettersAndSetters[i].toLowerCase().replace(/s$/, ''), proxyGettersAndSetters[i]);
    }

    // add shortcut for year (uses different syntax than the getter/setter 'year' == 'FullYear')
    makeGetterAndSetter('year', 'FullYear');

    // add plural methods
    moment.fn.days = moment.fn.day;
    moment.fn.months = moment.fn.month;
    moment.fn.weeks = moment.fn.week;
    moment.fn.isoWeeks = moment.fn.isoWeek;

    // add aliased format methods
    moment.fn.toJSON = moment.fn.toISOString;

    /************************************
        Duration Prototype
    ************************************/


    extend(moment.duration.fn = Duration.prototype, {

        _bubble : function () {
            var milliseconds = this._milliseconds,
                days = this._days,
                months = this._months,
                data = this._data,
                seconds, minutes, hours, years;

            // The following code bubbles up values, see the tests for
            // examples of what that means.
            data.milliseconds = milliseconds % 1000;

            seconds = absRound(milliseconds / 1000);
            data.seconds = seconds % 60;

            minutes = absRound(seconds / 60);
            data.minutes = minutes % 60;

            hours = absRound(minutes / 60);
            data.hours = hours % 24;

            days += absRound(hours / 24);
            data.days = days % 30;

            months += absRound(days / 30);
            data.months = months % 12;

            years = absRound(months / 12);
            data.years = years;
        },

        weeks : function () {
            return absRound(this.days() / 7);
        },

        valueOf : function () {
            return this._milliseconds +
              this._days * 864e5 +
              (this._months % 12) * 2592e6 +
              toInt(this._months / 12) * 31536e6;
        },

        humanize : function (withSuffix) {
            var difference = +this,
                output = relativeTime(difference, !withSuffix, this.lang());

            if (withSuffix) {
                output = this.lang().pastFuture(difference, output);
            }

            return this.lang().postformat(output);
        },

        add : function (input, val) {
            // supports only 2.0-style add(1, 's') or add(moment)
            var dur = moment.duration(input, val);

            this._milliseconds += dur._milliseconds;
            this._days += dur._days;
            this._months += dur._months;

            this._bubble();

            return this;
        },

        subtract : function (input, val) {
            var dur = moment.duration(input, val);

            this._milliseconds -= dur._milliseconds;
            this._days -= dur._days;
            this._months -= dur._months;

            this._bubble();

            return this;
        },

        get : function (units) {
            units = normalizeUnits(units);
            return this[units.toLowerCase() + 's']();
        },

        as : function (units) {
            units = normalizeUnits(units);
            return this['as' + units.charAt(0).toUpperCase() + units.slice(1) + 's']();
        },

        lang : moment.fn.lang,

        toIsoString : function () {
            // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
            var years = Math.abs(this.years()),
                months = Math.abs(this.months()),
                days = Math.abs(this.days()),
                hours = Math.abs(this.hours()),
                minutes = Math.abs(this.minutes()),
                seconds = Math.abs(this.seconds() + this.milliseconds() / 1000);

            if (!this.asSeconds()) {
                // this is the same as C#'s (Noda) and python (isodate)...
                // but not other JS (goog.date)
                return 'P0D';
            }

            return (this.asSeconds() < 0 ? '-' : '') +
                'P' +
                (years ? years + 'Y' : '') +
                (months ? months + 'M' : '') +
                (days ? days + 'D' : '') +
                ((hours || minutes || seconds) ? 'T' : '') +
                (hours ? hours + 'H' : '') +
                (minutes ? minutes + 'M' : '') +
                (seconds ? seconds + 'S' : '');
        }
    });

    function makeDurationGetter(name) {
        moment.duration.fn[name] = function () {
            return this._data[name];
        };
    }

    function makeDurationAsGetter(name, factor) {
        moment.duration.fn['as' + name] = function () {
            return +this / factor;
        };
    }

    for (i in unitMillisecondFactors) {
        if (unitMillisecondFactors.hasOwnProperty(i)) {
            makeDurationAsGetter(i, unitMillisecondFactors[i]);
            makeDurationGetter(i.toLowerCase());
        }
    }

    makeDurationAsGetter('Weeks', 6048e5);
    moment.duration.fn.asMonths = function () {
        return (+this - this.years() * 31536e6) / 2592e6 + this.years() * 12;
    };


    /************************************
        Default Lang
    ************************************/


    // Set default language, other languages will inherit from English.
    moment.lang('en', {
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    /* EMBED_LANGUAGES */

    /************************************
        Exposing Moment
    ************************************/

    function makeGlobal(deprecate) {
        var warned = false, local_moment = moment;
        /*global ender:false */
        if (typeof ender !== 'undefined') {
            return;
        }
        // here, `this` means `window` in the browser, or `global` on the server
        // add `moment` as a global object via a string identifier,
        // for Closure Compiler "advanced" mode
        if (deprecate) {
            global.moment = function () {
                if (!warned && console && console.warn) {
                    warned = true;
                    console.warn(
                            "Accessing Moment through the global scope is " +
                            "deprecated, and will be removed in an upcoming " +
                            "release.");
                }
                return local_moment.apply(null, arguments);
            };
            extend(global.moment, local_moment);
        } else {
            global['moment'] = moment;
        }
    }

    // CommonJS module is defined
    if (hasModule) {
        module.exports = moment;
        makeGlobal(true);
    } else if (typeof define === "function" && define.amd) {
        define("moment", function (require, exports, module) {
            if (module.config && module.config() && module.config().noGlobal !== true) {
                // If user provided noGlobal, he is aware of global
                makeGlobal(module.config().noGlobal === undefined);
            }

            return moment;
        });
    } else {
        makeGlobal();
    }
}).call(this);
/* bignumber.js v1.1.0 https://github.com/MikeMcl/bignumber.js/LICENCE */

;(function ( global ) {
    'use strict';

    /*
      bignumber.js v1.1.0
      A JavaScript library for arbitrary-precision arithmetic.
      https://github.com/MikeMcl/bignumber.js
      Copyright (c) 2012 Michael Mclaughlin <M8ch88l@gmail.com>
      MIT Expat Licence
    */

    /*********************************** DEFAULTS ************************************/

    /*
     * The default values below must be integers within the stated ranges (inclusive).
     * Most of these values can be changed programmatically using BigNumber.config().
     */

    /*
     * The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP,
     * MAX_EXP, and the argument to toFixed, toPrecision and toExponential, beyond
     * which an exception is thrown (if ERRORS is true).
     */
    var MAX = 1E9,                                   // 0 to 1e+9

        // Limit of magnitude of exponent argument to toPower.
        MAX_POWER = 1E6,                             // 1 to 1e+6

        // The maximum number of decimal places for operations involving division.
        DECIMAL_PLACES = 20,                         // 0 to MAX

        /*
         * The rounding mode used when rounding to the above decimal places, and when
         * using toFixed, toPrecision and toExponential, and round (default value).
         * UP         0 Away from zero.
         * DOWN       1 Towards zero.
         * CEIL       2 Towards +Infinity.
         * FLOOR      3 Towards -Infinity.
         * HALF_UP    4 Towards nearest neighbour. If equidistant, up.
         * HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
         * HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
         * HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
         * HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
         */
        ROUNDING_MODE = 4,                           // 0 to 8

        // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]

        // The exponent value at and beneath which toString returns exponential notation.
        // Number type: -7
        TO_EXP_NEG = -7,                             // 0 to -MAX

        // The exponent value at and above which toString returns exponential notation.
        // Number type: 21
        TO_EXP_POS = 21,                             // 0 to MAX

        // RANGE : [MIN_EXP, MAX_EXP]

        // The minimum exponent value, beneath which underflow to zero occurs.
        // Number type: -324  (5e-324)
        MIN_EXP = -MAX,                              // -1 to -MAX

        // The maximum exponent value, above which overflow to Infinity occurs.
        // Number type:  308  (1.7976931348623157e+308)
        MAX_EXP = MAX,                               // 1 to MAX

        // Whether BigNumber Errors are ever thrown.
        // CHANGE parseInt to parseFloat if changing ERRORS to false.
        ERRORS = true,                               // true or false
        parse = parseInt,                            // parseInt or parseFloat

    /***********************************************************************************/

        P = BigNumber.prototype,
        DIGITS = '0123456789abcdefghijklmnopqrstuvwxyz',
        outOfRange,
        id = 0,
        isValid = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,
        trim = String.prototype.trim || function () {return this.replace(/^\s+|\s+$/g, '')},
        ONE = BigNumber(1);


    // CONSTRUCTOR


    /*
     * The exported function.
     * Create and return a new instance of a BigNumber object.
     *
     * n {number|string|BigNumber} A numeric value.
     * [b] {number} The base of n. Integer, 2 to 36 inclusive.
     */
    function BigNumber( n, b ) {
        var e, i, isNum, digits, valid,
            x = this;

        // Enable constructor usage without new.
        if ( !(x instanceof BigNumber) ) {
            return new BigNumber( n, b )
        }

        // Duplicate.
        if ( n instanceof BigNumber ) {
            id = 0;

            // e is undefined.
            if ( b !== e ) {
                n += ''
            } else {
                x['s'] = n['s'];
                x['e'] = n['e'];
                x['c'] = ( n = n['c'] ) ? n.slice() : n;
                return
            }
        }

        // If number, check if minus zero.
        if ( typeof n != 'string' ) {
            n = ( isNum = typeof n == 'number' ||
                Object.prototype.toString.call(n) == '[object Number]' ) &&
                    n === 0 && 1 / n < 0 ? '-0' : n + ''
        }

        if ( b === e && isValid.test(n) ) {

            // Determine sign.
            x['s'] = n.charAt(0) == '-' ? ( n = n.slice(1), -1 ) : 1

        // Either n is not a valid BigNumber or a base has been specified.
        } else {

            // Enable exponential notation to be used with base 10 argument.
            // Ensure return value is rounded to DECIMAL_PLACES as with other bases.
            if ( b == 10 ) {

                return setMode( n, DECIMAL_PLACES, ROUNDING_MODE )
            }

            n = trim.call(n).replace( /^\+(?!-)/, '' );

            x['s'] = n.charAt(0) == '-' ? ( n = n.replace( /^-(?!-)/, '' ), -1 ) : 1;

            if ( b != null ) {

                if ( ( b == (b | 0) || !ERRORS ) &&
                  !( outOfRange = !( b >= 2 && b <= 36 ) ) ) {

                    digits = '[' + DIGITS.slice( 0, b = b | 0 ) + ']+';

                    // Before non-decimal number validity test and base conversion
                    // remove the `.` from e.g. '1.', and replace e.g. '.1' with '0.1'.
                    n = n.replace( /\.$/, '' ).replace( /^\./, '0.' );

                    // Any number in exponential form will fail due to the e+/-.
                    if ( valid = new RegExp(
                      '^' + digits + '(?:\\.' + digits + ')?$', 'i' ).test(n) ) {

                        if ( isNum ) {

                            if ( n.replace( '.', '' ).length > 15 ) {

                                // 'new BigNumber() number type has more than 15 significant digits: {n}'
                                ifExceptionsThrow( n, 0 )
                            }

                            // Prevent later check for length on converted number.
                            isNum = !isNum
                        }
                        n = convert( n, 10, b, x['s'] )

                    } else if ( n != 'Infinity' && n != 'NaN' ) {

                        // 'new BigNumber() not a base {b} number: {n}'
                        ifExceptionsThrow( n, 1, b );
                        n = 'NaN'
                    }
                } else {

                    // 'new BigNumber() base not an integer: {b}'
                    // 'new BigNumber() base out of range: {b}'
                    ifExceptionsThrow( b, 2 );

                    // Ignore base.
                    valid = isValid.test(n)
                }
            } else {
                valid = isValid.test(n)
            }

            if ( !valid ) {

                // Infinity/NaN
                x['c'] = x['e'] = null;

                // NaN
                if ( n != 'Infinity' ) {

                    // No exception on NaN.
                    if ( n != 'NaN' ) {

                        // 'new BigNumber() not a number: {n}'
                        ifExceptionsThrow( n, 3 )
                    }
                    x['s'] = null
                }
                id = 0;

                return
            }
        }

        // Decimal point?
        if ( ( e = n.indexOf('.') ) > -1 ) {
            n = n.replace( '.', '' )
        }

        // Exponential form?
        if ( ( i = n.search(/e/i) ) > 0 ) {

            // Determine exponent.
            if ( e < 0 ) {
                e = i
            }
            e += +n.slice( i + 1 );
            n = n.substring( 0, i )

        } else if ( e < 0 ) {

            // Integer.
            e = n.length
        }

        // Disallow numbers over 15 digits if number type.
        if ( b = n.length, isNum && b > 15 ) {

            // 'new BigNumber() number type has more than 15 significant digits: {n}'
            ifExceptionsThrow( n, 0 )
        }

        // Determine leading zeros.
        for ( i = id = 0; n.charAt(i) == '0'; i++ ) {
        }

        // Overflow?
        if ( ( e -= i + 1 ) > MAX_EXP ) {

            // Infinity.
            x['c'] = x['e'] = null

        // Zero or underflow?
        } else if ( i == b || e < MIN_EXP ) {

            // Zero.
            x['c'] = [ x['e'] = 0 ]
        } else {

            // Determine trailing zeros.
            for ( ; n.charAt(--b) == '0'; ) {
            }

            x['e'] = e;
            x['c'] = [];

            // Convert string to array of digits (without leading and trailing zeros).
            for ( e = 0; i <= b; x['c'][e++] = +n.charAt(i++) ) {
            }
        }
    }


    // CONSTRUCTOR PROPERTIES/METHODS


    BigNumber['ROUND_UP'] = 0;
    BigNumber['ROUND_DOWN'] = 1;
    BigNumber['ROUND_CEIL'] = 2;
    BigNumber['ROUND_FLOOR'] = 3;
    BigNumber['ROUND_HALF_UP'] = 4;
    BigNumber['ROUND_HALF_DOWN'] = 5;
    BigNumber['ROUND_HALF_EVEN'] = 6;
    BigNumber['ROUND_HALF_CEIL'] = 7;
    BigNumber['ROUND_HALF_FLOOR'] = 8;


    /*
     * Configure infrequently-changing library-wide settings.
     *
     * Accept an object or an argument list, with one or many of the following
     * properties or parameters respectively:
     * [ DECIMAL_PLACES [, ROUNDING_MODE [, EXPONENTIAL_AT [, RANGE [, ERRORS ]]]]]
     *
     * E.g.
     * BigNumber.config(20, 4) is equivalent to
     * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })
     * Ignore properties/parameters set to null or undefined.
     *
     * Return an object with the properties current values.
     */
    BigNumber['config'] = function () {
        var v, p,
            i = 0,
            r = {},
            a = arguments,
            o = a[0],
            c = 'config',
            inRange = function ( n, lo, hi ) {
              return !( ( outOfRange = n < lo || n > hi ) ||
                parse(n) != n && n !== 0 )
            },
            has = o && typeof o == 'object'
              ? function () {if ( o.hasOwnProperty(p) ) return ( v = o[p] ) != null}
              : function () {if ( a.length > i ) return ( v = a[i++] ) != null};

        // [DECIMAL_PLACES] {number} Integer, 0 to MAX inclusive.
        if ( has( p = 'DECIMAL_PLACES' ) ) {

            if ( inRange( v, 0, MAX ) ) {
                DECIMAL_PLACES = v | 0
            } else {

                // 'config() DECIMAL_PLACES not an integer: {v}'
                // 'config() DECIMAL_PLACES out of range: {v}'
                ifExceptionsThrow( v, p, c )
            }
        }
        r[p] = DECIMAL_PLACES;

        // [ROUNDING_MODE] {number} Integer, 0 to 8 inclusive.
        if ( has( p = 'ROUNDING_MODE' ) ) {

            if ( inRange( v, 0, 8 ) ) {
                ROUNDING_MODE = v | 0
            } else {

                // 'config() ROUNDING_MODE not an integer: {v}'
                // 'config() ROUNDING_MODE out of range: {v}'
                ifExceptionsThrow( v, p, c )
            }
        }
        r[p] = ROUNDING_MODE;

        /*
         * [EXPONENTIAL_AT] {number|number[]} Integer, -MAX to MAX inclusive or
         * [ integer -MAX to 0 inclusive, 0 to MAX inclusive ].
         */
        if ( has( p = 'EXPONENTIAL_AT' ) ) {

            if ( inRange( v, -MAX, MAX ) ) {
                TO_EXP_NEG = -( TO_EXP_POS = ~~( v < 0 ? -v : +v ) )
            } else if ( !outOfRange && v && inRange( v[0], -MAX, 0 ) &&
              inRange( v[1], 0, MAX ) ) {
                TO_EXP_NEG = ~~v[0], TO_EXP_POS = ~~v[1]
            } else {

                // 'config() EXPONENTIAL_AT not an integer or not [integer, integer]: {v}'
                // 'config() EXPONENTIAL_AT out of range or not [negative, positive: {v}'
                ifExceptionsThrow( v, p, c, 1 )
            }
        }
        r[p] = [ TO_EXP_NEG, TO_EXP_POS ];

        /*
         * [RANGE][ {number|number[]} Non-zero integer, -MAX to MAX inclusive or
         * [ integer -MAX to -1 inclusive, integer 1 to MAX inclusive ].
         */
        if ( has( p = 'RANGE' ) ) {

            if ( inRange( v, -MAX, MAX ) && ~~v ) {
                MIN_EXP = -( MAX_EXP = ~~( v < 0 ? -v : +v ) )
            } else if ( !outOfRange && v && inRange( v[0], -MAX, -1 ) &&
              inRange( v[1], 1, MAX ) ) {
                MIN_EXP = ~~v[0], MAX_EXP = ~~v[1]
            } else {

                // 'config() RANGE not a non-zero integer or not [integer, integer]: {v}'
                // 'config() RANGE out of range or not [negative, positive: {v}'
                ifExceptionsThrow( v, p, c, 1, 1 )
            }
        }
        r[p] = [ MIN_EXP, MAX_EXP ];

        // [ERRORS] {boolean|number} true, false, 1 or 0.
        if ( has( p = 'ERRORS' ) ) {

            if ( v === !!v || v === 1 || v === 0 ) {
                parse = ( outOfRange = id = 0, ERRORS = !!v )
                  ? parseInt
                  : parseFloat
            } else {

                // 'config() ERRORS not a boolean or binary digit: {v}'
                ifExceptionsThrow( v, p, c, 0, 0, 1 )
            }
        }
        r[p] = ERRORS;

        return r
    };


    // PRIVATE FUNCTIONS


    // Assemble error messages. Throw BigNumber Errors.
    function ifExceptionsThrow( arg, i, j, isArray, isRange, isErrors) {
        if ( ERRORS ) {
            var method = ['new BigNumber', 'cmp', 'div', 'eq', 'gt', 'gte', 'lt',
                     'lte', 'minus', 'mod', 'plus', 'times', 'toFr'
                    ][ id ? id < 0 ? -id : id : 1 / id < 0 ? 1 : 0 ] + '()',
                error = outOfRange ? ' out of range' : ' not a' +
                  ( isRange ? ' non-zero' : 'n' ) + ' integer';

            error = ( [
                method + ' number type has more than 15 significant digits',
                method + ' not a base ' + j + ' number',
                method + ' base' + error,
                method + ' not a number' ][i] ||
                  j + '() ' + i + ( isErrors
                    ? ' not a boolean or binary digit'
                    : error + ( isArray
                      ? ' or not [' + ( outOfRange
                        ? ' negative, positive'
                        : ' integer, integer' ) + ' ]'
                      : '' ) ) ) + ': ' + arg;

            outOfRange = id = 0;
            throw {
                name : 'BigNumber Error',
                message : error,
                toString : function () {return this.name + ': ' + this.message}
            }
        }
    }


    /*
     * Convert a numeric string of baseIn to a numeric string of baseOut.
     */
    function convert( nStr, baseOut, baseIn, sign ) {
        var e, dvs, dvd, nArr, fracArr, fracBN;

        // Convert string of base bIn to an array of numbers of baseOut.
        // Eg. strToArr('255', 10) where baseOut is 16, returns [15, 15].
        // Eg. strToArr('ff', 16)  where baseOut is 10, returns [2, 5, 5].
        function strToArr( str, bIn ) {
            var j,
                i = 0,
                strL = str.length,
                arrL,
                arr = [0];

            for ( bIn = bIn || baseIn; i < strL; i++ ) {

                for ( arrL = arr.length, j = 0; j < arrL; arr[j] *= bIn, j++ ) {
                }

                for ( arr[0] += DIGITS.indexOf( str.charAt(i) ), j = 0;
                      j < arr.length;
                      j++ ) {

                    if ( arr[j] > baseOut - 1 ) {

                        if ( arr[j + 1] == null ) {
                            arr[j + 1] = 0
                        }
                        arr[j + 1] += arr[j] / baseOut ^ 0;
                        arr[j] %= baseOut
                    }
                }
            }

            return arr.reverse()
        }

        // Convert array to string.
        // E.g. arrToStr( [9, 10, 11] ) becomes '9ab' (in bases above 11).
        function arrToStr( arr ) {
            var i = 0,
                arrL = arr.length,
                str = '';

            for ( ; i < arrL; str += DIGITS.charAt( arr[i++] ) ) {
            }

            return str
        }

        nStr = nStr.toLowerCase();

        /*
         * If non-integer convert integer part and fraction part separately.
         * Convert the fraction part as if it is an integer than use division to
         * reduce it down again to a value less than one.
         */
        if ( ( e = nStr.indexOf( '.' ) ) > -1 ) {

            /*
             * Calculate the power to which to raise the base to get the number
             * to divide the fraction part by after it has been converted as an
             * integer to the required base.
             */
            e = nStr.length - e - 1;

            // Use toFixed to avoid possible exponential notation.
            dvs = strToArr( new BigNumber(baseIn)['pow'](e)['toF'](), 10 );

            nArr = nStr.split('.');

            // Convert the base of the fraction part (as integer).
            dvd = strToArr( nArr[1] );

            // Convert the base of the integer part.
            nArr = strToArr( nArr[0] );

            // Result will be a BigNumber with a value less than 1.
            fracBN = divide( dvd, dvs, dvd.length - dvs.length, sign, baseOut,
              // Is least significant digit of integer part an odd number?
              nArr[nArr.length - 1] & 1 );

            fracArr = fracBN['c'];

            // e can be <= 0  ( if e == 0, fracArr is [0] or [1] ).
            if ( e = fracBN['e'] ) {

                // Append zeros according to the exponent of the result.
                for ( ; ++e; fracArr.unshift(0) ) {
                }

                // Append the fraction part to the converted integer part.
                nStr = arrToStr(nArr) + '.' + arrToStr(fracArr)

            // fracArr is [1].
            // Fraction digits rounded up, so increment last digit of integer part.
            } else if ( fracArr[0] ) {

                if ( nArr[ e = nArr.length - 1 ] < baseOut - 1 ) {
                    ++nArr[e];
                    nStr = arrToStr(nArr)
                } else {
                    nStr = new BigNumber( arrToStr(nArr),
                      baseOut )['plus'](ONE)['toS'](baseOut)
                }

            // fracArr is [0]. No fraction digits.
            } else {
                nStr = arrToStr(nArr)
            }
        } else {

            // Simple integer. Convert base.
            nStr = arrToStr( strToArr(nStr) )
        }

        return nStr
    }


    // Perform division in the specified base. Called by div and convert.
    function divide( dvd, dvs, exp, s, base, isOdd ) {
        var dvsL, dvsT, next, cmp, remI,
            dvsZ = dvs.slice(),
            dvdI = dvsL = dvs.length,
            dvdL = dvd.length,
            rem = dvd.slice( 0, dvsL ),
            remL = rem.length,
            quo = new BigNumber(ONE),
            qc = quo['c'] = [],
            qi = 0,
            dig = DECIMAL_PLACES + ( quo['e'] = exp ) + 1;

        quo['s'] = s;
        s = dig < 0 ? 0 : dig;

        // Add zeros to make remainder as long as divisor.
        for ( ; remL++ < dvsL; rem.push(0) ) {
        }

        // Create version of divisor with leading zero.
        dvsZ.unshift(0);

        do {

            // 'next' is how many times the divisor goes into the current remainder.
            for ( next = 0; next < base; next++ ) {

                // Compare divisor and remainder.
                if ( dvsL != ( remL = rem.length ) ) {
                    cmp = dvsL > remL ? 1 : -1
                } else {
                    for ( remI = -1, cmp = 0; ++remI < dvsL; ) {

                        if ( dvs[remI] != rem[remI] ) {
                            cmp = dvs[remI] > rem[remI] ? 1 : -1;
                            break
                        }
                    }
                }

                // Subtract divisor from remainder (if divisor < remainder).
                if ( cmp < 0 ) {

                    // Remainder cannot be more than one digit longer than divisor.
                    // Equalise lengths using divisor with extra leading zero?
                    for ( dvsT = remL == dvsL ? dvs : dvsZ; remL; ) {

                        if ( rem[--remL] < dvsT[remL] ) {

                            for ( remI = remL;
                              remI && !rem[--remI];
                                rem[remI] = base - 1 ) {
                            }
                            --rem[remI];
                            rem[remL] += base
                        }
                        rem[remL] -= dvsT[remL]
                    }
                    for ( ; !rem[0]; rem.shift() ) {
                    }
                } else {
                    break
                }
            }

            // Add the 'next' digit to the result array.
            qc[qi++] = cmp ? next : ++next;

            // Update the remainder.
            rem[0] && cmp
              ? ( rem[remL] = dvd[dvdI] || 0 )
              : ( rem = [ dvd[dvdI] ] )

        } while ( ( dvdI++ < dvdL || rem[0] != null ) && s-- );

        // Leading zero? Do not remove if result is simply zero (qi == 1).
        if ( !qc[0] && qi != 1 ) {

            // There can't be more than one zero.
            --quo['e'];
            qc.shift()
        }

        // Round?
        if ( qi > dig ) {
            rnd( quo, DECIMAL_PLACES, base, isOdd, rem[0] != null )
        }

        // Overflow?
        if ( quo['e'] > MAX_EXP ) {

            // Infinity.
            quo['c'] = quo['e'] = null

        // Underflow?
        } else if ( quo['e'] < MIN_EXP ) {

            // Zero.
            quo['c'] = [quo['e'] = 0]
        }

        return quo
    }


    /*
     * Return a string representing the value of BigNumber n in normal or
     * exponential notation rounded to the specified decimal places or
     * significant digits.
     * Called by toString, toExponential (exp 1), toFixed, and toPrecision (exp 2).
     * d is the index (with the value in normal notation) of the digit that may be
     * rounded up.
     */
    function format( n, d, exp ) {

        // Initially, i is the number of decimal places required.
        var i = d - (n = new BigNumber(n))['e'],
            c = n['c'];

        // +-Infinity or NaN?
        if ( !c ) {
            return n['toS']()
        }

        // Round?
        if ( c.length > ++d ) {
            rnd( n, i, 10 )
        }

        // Recalculate d if toFixed as n['e'] may have changed if value rounded up.
        i = c[0] == 0 ? i + 1 : exp ? d : n['e'] + i + 1;

        // Append zeros?
        for ( ; c.length < i; c.push(0) ) {
        }
        i = n['e'];

        /*
         * toPrecision returns exponential notation if the number of significant
         * digits specified is less than the number of digits necessary to
         * represent the integer part of the value in normal notation.
         */
        return exp == 1 || exp == 2 && ( --d < i || i <= TO_EXP_NEG )

          // Exponential notation.
          ? ( n['s'] < 0 && c[0] ? '-' : '' ) + ( c.length > 1
            ? ( c.splice( 1, 0, '.' ), c.join('') )
            : c[0] ) + ( i < 0 ? 'e' : 'e+' ) + i

          // Normal notation.
          : n['toS']()
    }


    // Round if necessary.
    // Called by divide, format, setMode and sqrt.
    function rnd( x, dp, base, isOdd, r ) {
        var xc = x['c'],
            isNeg = x['s'] < 0,
            half = base / 2,
            i = x['e'] + dp + 1,

            // 'next' is the digit after the digit that may be rounded up.
            next = xc[i],

            /*
             * 'more' is whether there are digits after 'next'.
             * E.g.
             * 0.005 (e = -3) to be rounded to 0 decimal places (dp = 0) gives i = -2
             * The 'next' digit is zero, and there ARE 'more' digits after it.
             * 0.5 (e = -1) dp = 0 gives i = 0
             * The 'next' digit is 5 and there are no 'more' digits after it.
             */
            more = r || i < 0 || xc[i + 1] != null;

        r = ROUNDING_MODE < 4
          ? ( next != null || more ) &&
            ( ROUNDING_MODE == 0 ||
               ROUNDING_MODE == 2 && !isNeg ||
                 ROUNDING_MODE == 3 && isNeg )
          : next > half || next == half &&
            ( ROUNDING_MODE == 4 || more ||

              /*
               * isOdd is used in base conversion and refers to the least significant
               * digit of the integer part of the value to be converted. The fraction
               * part is rounded by this method separately from the integer part.
               */
              ROUNDING_MODE == 6 && ( xc[i - 1] & 1 || !dp && isOdd ) ||
                ROUNDING_MODE == 7 && !isNeg ||
                  ROUNDING_MODE == 8 && isNeg );

        if ( i < 1 || !xc[0] ) {
            xc.length = 0;
            xc.push(0);

            if ( r ) {

                // 1, 0.1, 0.01, 0.001, 0.0001 etc.
                xc[0] = 1;
                x['e'] = -dp
            } else {

                // Zero.
                x['e'] = 0
            }

            return x
        }

        // Remove any digits after the required decimal places.
        xc.length = i--;

        // Round up?
        if ( r ) {

            // Rounding up may mean the previous digit has to be rounded up and so on.
            for ( --base; ++xc[i] > base; ) {
                xc[i] = 0;

                if ( !i-- ) {
                    ++x['e'];
                    xc.unshift(1)
                }
            }
        }

        // Remove trailing zeros.
        for ( i = xc.length; !xc[--i]; xc.pop() ) {
        }

        return x
    }


    // Round after setting the appropriate rounding mode.
    // Handles ceil, floor and round.
    function setMode( x, dp, rm ) {
        var r = ROUNDING_MODE;

        ROUNDING_MODE = rm;
        x = new BigNumber(x);
        x['c'] && rnd( x, dp, 10 );
        ROUNDING_MODE = r;

        return x
    }


    // PROTOTYPE/INSTANCE METHODS


    /*
     * Return a new BigNumber whose value is the absolute value of this BigNumber.
     */
    P['abs'] = P['absoluteValue'] = function () {
        var x = new BigNumber(this);

        if ( x['s'] < 0 ) {
            x['s'] = 1
        }

        return x
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber
     * rounded to a whole number in the direction of Infinity.
     */
    P['ceil'] = function () {
        return setMode( this, 0, 2 )
    };


    /*
     * Return
     * 1 if the value of this BigNumber is greater than the value of BigNumber(y, b),
     * -1 if the value of this BigNumber is less than the value of BigNumber(y, b),
     * 0 if they have the same value,
     * or null if the value of either is NaN.
     */
    P['comparedTo'] = P['cmp'] = function ( y, b ) {
        var a,
            x = this,
            xc = x['c'],
            yc = ( id = -id, y = new BigNumber( y, b ) )['c'],
            i = x['s'],
            j = y['s'],
            k = x['e'],
            l = y['e'];

        // Either NaN?
        if ( !i || !j ) {
            return null
        }

        a = xc && !xc[0], b = yc && !yc[0];

        // Either zero?
        if ( a || b ) {
            return a ? b ? 0 : -j : i
        }

        // Signs differ?
        if ( i != j ) {
            return i
        }

        // Either Infinity?
        if ( a = i < 0, b = k == l, !xc || !yc ) {
            return b ? 0 : !xc ^ a ? 1 : -1
        }

        // Compare exponents.
        if ( !b ) {
            return k > l ^ a ? 1 : -1
        }

        // Compare digit by digit.
        for ( i = -1,
              j = ( k = xc.length ) < ( l = yc.length ) ? k : l;
              ++i < j; ) {

            if ( xc[i] != yc[i] ) {
                return xc[i] > yc[i] ^ a ? 1 : -1
            }
        }
        // Compare lengths.
        return k == l ? 0 : k > l ^ a ? 1 : -1
    };


    /*
     *  n / 0 = I
     *  n / N = N
     *  n / I = 0
     *  0 / n = 0
     *  0 / 0 = N
     *  0 / N = N
     *  0 / I = 0
     *  N / n = N
     *  N / 0 = N
     *  N / N = N
     *  N / I = N
     *  I / n = I
     *  I / 0 = I
     *  I / N = N
     *  I / I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber
     * divided by the value of BigNumber(y, b), rounded according to
     * DECIMAL_PLACES and ROUNDING_MODE.
     */
    P['dividedBy'] = P['div'] = function ( y, b ) {
        var xc = this['c'],
            xe = this['e'],
            xs = this['s'],
            yc = ( id = 2, y = new BigNumber( y, b ) )['c'],
            ye = y['e'],
            ys = y['s'],
            s = xs == ys ? 1 : -1;

        // Either NaN/Infinity/0?
        return !xe && ( !xc || !xc[0] ) || !ye && ( !yc || !yc[0] )

          // Either NaN?
          ? new BigNumber( !xs || !ys ||

            // Both 0 or both Infinity?
            ( xc ? yc && xc[0] == yc[0] : !yc )

              // Return NaN.
              ? NaN

              // x is 0 or y is Infinity?
              : xc && xc[0] == 0 || !yc

                // Return +-0.
                ? s * 0

                // y is 0. Return +-Infinity.
                : s / 0 )

          : divide( xc, yc, xe - ye, s, 10 )
    };


    /*
     * Return true if the value of this BigNumber is equal to the value of
     * BigNumber(n, b), otherwise returns false.
     */
    P['equals'] = P['eq'] = function ( n, b ) {
        id = 3;
        return this['cmp']( n, b ) === 0
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber
     * rounded to a whole number in the direction of -Infinity.
     */
    P['floor'] = function () {
        return setMode( this, 0, 3 )
    };


    /*
     * Return true if the value of this BigNumber is greater than the value of
     * BigNumber(n, b), otherwise returns false.
     */
    P['greaterThan'] = P['gt'] = function ( n, b ) {
        id = 4;
        return this['cmp']( n, b ) > 0
    };


    /*
     * Return true if the value of this BigNumber is greater than or equal to
     * the value of BigNumber(n, b), otherwise returns false.
     */
    P['greaterThanOrEqualTo'] = P['gte'] = function ( n, b ) {
        id = 5;
        return ( b = this['cmp']( n, b ) ) == 1 || b === 0
    };


    /*
     * Return true if the value of this BigNumber is a finite number, otherwise
     * returns false.
     */
    P['isFinite'] = P['isF'] = function () {
        return !!this['c']
    };


    /*
     * Return true if the value of this BigNumber is NaN, otherwise returns
     * false.
     */
    P['isNaN'] = function () {
        return !this['s']
    };


    /*
     * Return true if the value of this BigNumber is negative, otherwise
     * returns false.
     */
    P['isNegative'] = P['isNeg'] = function () {
        return this['s'] < 0
    };


    /*
     * Return true if the value of this BigNumber is 0 or -0, otherwise returns
     * false.
     */
    P['isZero'] = P['isZ'] = function () {
        return !!this['c'] && this['c'][0] == 0
    };


    /*
     * Return true if the value of this BigNumber is less than the value of
     * BigNumber(n, b), otherwise returns false.
     */
    P['lessThan'] = P['lt'] = function ( n, b ) {
        id = 6;
        return this['cmp']( n, b ) < 0
    };


    /*
     * Return true if the value of this BigNumber is less than or equal to the
     * value of BigNumber(n, b), otherwise returns false.
     */
    P['lessThanOrEqualTo'] = P['lte'] = function ( n, b ) {
        id = 7;
        return ( b = this['cmp']( n, b ) ) == -1 || b === 0
    };


    /*
     *  n - 0 = n
     *  n - N = N
     *  n - I = -I
     *  0 - n = -n
     *  0 - 0 = 0
     *  0 - N = N
     *  0 - I = -I
     *  N - n = N
     *  N - 0 = N
     *  N - N = N
     *  N - I = N
     *  I - n = I
     *  I - 0 = I
     *  I - N = N
     *  I - I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber minus
     * the value of BigNumber(y, b).
     */
    P['minus'] = function ( y, b ) {
        var d, i, j, xLTy,
            x = this,
            a = x['s'];

        b = ( id = 8, y = new BigNumber( y, b ) )['s'];

        // Either NaN?
        if ( !a || !b ) {
            return new BigNumber(NaN)
        }

        // Signs differ?
        if ( a != b ) {
            return y['s'] = -b, x['plus'](y)
        }

        var xc = x['c'],
            xe = x['e'],
            yc = y['c'],
            ye = y['e'];

        if ( !xe || !ye ) {

            // Either Infinity?
            if ( !xc || !yc ) {
                return xc ? ( y['s'] = -b, y ) : new BigNumber( yc ? x : NaN )
            }

            // Either zero?
            if ( !xc[0] || !yc[0] ) {

                // y is non-zero?
                return yc[0]
                  ? ( y['s'] = -b, y )

                  // x is non-zero?
                  : new BigNumber( xc[0]
                    ? x

                    // Both are zero.
                    : 0 )
            }
        }

        // Determine which is the bigger number.
        // Prepend zeros to equalise exponents.
        if ( xc = xc.slice(), a = xe - ye ) {
            d = ( xLTy = a < 0 ) ? ( a = -a, xc ) : ( ye = xe, yc );

            for ( d.reverse(), b = a; b--; d.push(0) ) {
            }
            d.reverse()
        } else {

            // Exponents equal. Check digit by digit.
            j = ( ( xLTy = xc.length < yc.length ) ? xc : yc ).length;

            for ( a = b = 0; b < j; b++ ) {

                if ( xc[b] != yc[b] ) {
                    xLTy = xc[b] < yc[b];
                    break
                }
            }
        }

        // x < y? Point xc to the array of the bigger number.
        if ( xLTy ) {
            d = xc, xc = yc, yc = d;
            y['s'] = -y['s']
        }

        /*
         * Append zeros to xc if shorter. No need to add zeros to yc if shorter
         * as subtraction only needs to start at yc.length.
         */
        if ( ( b = -( ( j = xc.length ) - yc.length ) ) > 0 ) {

            for ( ; b--; xc[j++] = 0 ) {
            }
        }

        // Subtract yc from xc.
        for ( b = yc.length; b > a; ){

            if ( xc[--b] < yc[b] ) {

                for ( i = b; i && !xc[--i]; xc[i] = 9 ) {
                }
                --xc[i];
                xc[b] += 10
            }
            xc[b] -= yc[b]
        }

        // Remove trailing zeros.
        for ( ; xc[--j] == 0; xc.pop() ) {
        }

        // Remove leading zeros and adjust exponent accordingly.
        for ( ; xc[0] == 0; xc.shift(), --ye ) {
        }

        /*
         * No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity
         * when neither x or y are Infinity.
         */

        // Underflow?
        if ( ye < MIN_EXP || !xc[0] ) {

            // Result must be zero.
            xc = [ye = 0]
        }

        return y['c'] = xc, y['e'] = ye, y
    };


    /*
     *   n % 0 =  N
     *   n % N =  N
     *   0 % n =  0
     *  -0 % n = -0
     *   0 % 0 =  N
     *   0 % N =  N
     *   N % n =  N
     *   N % 0 =  N
     *   N % N =  N
     *
     * Return a new BigNumber whose value is the value of this BigNumber modulo
     * the value of BigNumber(y, b).
     */
    P['modulo'] = P['mod'] = function ( y, b ) {
        var x = this,
            xc = x['c'],
            yc = ( id = 9, y = new BigNumber( y, b ) )['c'],
            i = x['s'],
            j = y['s'];

        // Is x or y NaN, or y zero?
        b = !i || !j || yc && !yc[0];

        if ( b || xc && !xc[0] ) {
            return new BigNumber( b ? NaN : x )
        }

        x['s'] = y['s'] = 1;
        b = y['cmp'](x) == 1;
        x['s'] = i, y['s'] = j;

        return b
          ? new BigNumber(x)
          : ( i = DECIMAL_PLACES, j = ROUNDING_MODE,
            DECIMAL_PLACES = 0, ROUNDING_MODE = 1,
              x = x['div'](y),
                DECIMAL_PLACES = i, ROUNDING_MODE = j,
                  this['minus']( x['times'](y) ) )
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber
     * negated, i.e. multiplied by -1.
     */
    P['negated'] = P['neg'] = function () {
        var x = new BigNumber(this);

        return x['s'] = -x['s'] || null, x
    };


    /*
     *  n + 0 = n
     *  n + N = N
     *  n + I = I
     *  0 + n = n
     *  0 + 0 = 0
     *  0 + N = N
     *  0 + I = I
     *  N + n = N
     *  N + 0 = N
     *  N + N = N
     *  N + I = N
     *  I + n = I
     *  I + 0 = I
     *  I + N = N
     *  I + I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber plus
     * the value of BigNumber(y, b).
     */
    P['plus'] = function ( y, b ) {
        var d,
            x = this,
            a = x['s'];

        b = ( id = 10, y = new BigNumber( y, b ) )['s'];

        // Either NaN?
        if ( !a || !b ) {
            return new BigNumber(NaN)
        }

        // Signs differ?
        if ( a != b ) {
            return y['s'] = -b, x['minus'](y)
        }

        var xe = x['e'],
            xc = x['c'],
            ye = y['e'],
            yc = y['c'];

        if ( !xe || !ye ) {

            // Either Infinity?
            if ( !xc || !yc ) {

                // Return +-Infinity.
                return new BigNumber( a / 0 )
            }

            // Either zero?
            if ( !xc[0] || !yc[0] ) {

                // y is non-zero?
                return yc[0]
                  ? y
                  : new BigNumber( xc[0]

                    // x is non-zero?
                    ? x

                    // Both are zero. Return zero.
                    : a * 0 )
            }
        }

        // Prepend zeros to equalise exponents.
        // Note: Faster to use reverse then do unshifts.
        if ( xc = xc.slice(), a = xe - ye ) {
            d = a > 0 ? ( ye = xe, yc ) : ( a = -a, xc );

            for ( d.reverse(); a--; d.push(0) ) {
            }
            d.reverse()
        }

        // Point xc to the longer array.
        if ( xc.length - yc.length < 0 ) {
            d = yc, yc = xc, xc = d
        }

        /*
         * Only start adding at yc.length - 1 as the
         * further digits of xc can be left as they are.
         */
        for ( a = yc.length, b = 0; a;
             b = ( xc[--a] = xc[a] + yc[a] + b ) / 10 ^ 0, xc[a] %= 10 ) {
        }

        // No need to check for zero, as +x + +y != 0 && -x + -y != 0

        if ( b ) {
            xc.unshift(b);

            // Overflow? (MAX_EXP + 1 possible)
            if ( ++ye > MAX_EXP ) {

                // Infinity.
                xc = ye = null
            }
        }

         // Remove trailing zeros.
        for ( a = xc.length; xc[--a] == 0; xc.pop() ) {
        }

        return y['c'] = xc, y['e'] = ye, y
    };


    /*
     * Return a BigNumber whose value is the value of this BigNumber raised to
     * the power e. If e is negative round according to DECIMAL_PLACES and
     * ROUNDING_MODE.
     *
     * e {number} Integer, -MAX_POWER to MAX_POWER inclusive.
     */
    P['toPower'] = P['pow'] = function ( e ) {

        // e to integer, avoiding NaN or Infinity becoming 0.
        var i = e * 0 == 0 ? e | 0 : e,
            x = new BigNumber(this),
            y = new BigNumber(ONE);

        // Use Math.pow?
        // Pass +-Infinity for out of range exponents.
        if ( ( ( ( outOfRange = e < -MAX_POWER || e > MAX_POWER ) &&
          (i = e * 1 / 0) ) ||

             /*
              * Any exponent that fails the parse becomes NaN.
              *
              * Include 'e !== 0' because on Opera -0 == parseFloat(-0) is false,
              * despite -0 === parseFloat(-0) && -0 == parseFloat('-0') is true.
              */
             parse(e) != e && e !== 0 && !(i = NaN) ) &&

              // 'pow() exponent not an integer: {e}'
              // 'pow() exponent out of range: {e}'
              !ifExceptionsThrow( e, 'exponent', 'pow' ) ||

                // Pass zero to Math.pow, as any value to the power zero is 1.
                !i ) {

            // i is +-Infinity, NaN or 0.
            return new BigNumber( Math.pow( x['toS'](), i ) )
        }

        for ( i = i < 0 ? -i : i; ; ) {

            if ( i & 1 ) {
                y = y['times'](x)
            }
            i >>= 1;

            if ( !i ) {
                break
            }
            x = x['times'](x)
        }

        return e < 0 ? ONE['div'](y) : y
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber
     * rounded to a maximum of dp decimal places using rounding mode rm, or to
     * 0 and ROUNDING_MODE respectively if omitted.
     *
     * [dp] {number} Integer, 0 to MAX inclusive.
     * [rm] {number} Integer, 0 to 8 inclusive.
     */
    P['round'] = function ( dp, rm ) {

        dp = dp == null || ( ( ( outOfRange = dp < 0 || dp > MAX ) ||
          parse(dp) != dp ) &&

            // 'round() decimal places out of range: {dp}'
            // 'round() decimal places not an integer: {dp}'
            !ifExceptionsThrow( dp, 'decimal places', 'round' ) )
              ? 0
              : dp | 0;

        rm = rm == null || ( ( ( outOfRange = rm < 0 || rm > 8 ) ||

          // Include '&& rm !== 0' because with Opera -0 == parseFloat(-0) is false.
          parse(rm) != rm && rm !== 0 ) &&

            // 'round() mode not an integer: {rm}'
            // 'round() mode out of range: {rm}'
            !ifExceptionsThrow( rm, 'mode', 'round' ) )
              ? ROUNDING_MODE
              : rm | 0;

        return setMode( this, dp, rm )
    };


    /*
     *  sqrt(-n) =  N
     *  sqrt( N) =  N
     *  sqrt(-I) =  N
     *  sqrt( I) =  I
     *  sqrt( 0) =  0
     *  sqrt(-0) = -0
     *
     * Return a new BigNumber whose value is the square root of the value of
     * this BigNumber, rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */
    P['squareRoot'] = P['sqrt'] = function () {
        var estimate, r, approx,
            x = this,
            xc = x['c'],
            i = x['s'],
            e = x['e'],
            half = new BigNumber('0.5');

        // Negative/NaN/Infinity/zero?
        if ( i !== 1 || !xc || !xc[0] ) {
            return new BigNumber( !i || i < 0 && ( !xc || xc[0] )
              ? NaN
              : xc ? x : 1 / 0 )
        }

        // Estimate.
        i = Math.sqrt( x['toS']() );

        // Math.sqrt underflow/overflow?
        // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
        if ( i == 0 || i == 1 / 0 ) {
            estimate = xc.join('');

            if ( !( estimate.length + e & 1 ) ) {
                estimate += '0'
            }

            r = new BigNumber( Math.sqrt(estimate).toString() );
            r['e'] = ( ( ( e + 1 ) / 2 ) | 0 ) - ( e < 0 || e & 1 )
        } else {
            r = new BigNumber( i.toString() )
        }

        i = r['e'] + ( DECIMAL_PLACES += 4 );

        // Newton-Raphson loop.
        do {
            approx = r;
            r = half['times']( approx['plus']( x['div'](approx) ) )
        } while ( approx['c'].slice( 0, i ).join('') !==
                       r['c'].slice( 0, i ).join('') );

        rnd( r, DECIMAL_PLACES -= 4, 10 );

        return r
    };


    /*
     *  n * 0 = 0
     *  n * N = N
     *  n * I = I
     *  0 * n = 0
     *  0 * 0 = 0
     *  0 * N = N
     *  0 * I = N
     *  N * n = N
     *  N * 0 = N
     *  N * N = N
     *  N * I = N
     *  I * n = I
     *  I * 0 = N
     *  I * N = N
     *  I * I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber times
     * the value of BigNumber(y, b).
     */
    P['times'] = function ( y, b ) {
        var c,
            x = this,
            xc = x['c'],
            yc = ( id = 11, y = new BigNumber( y, b ) )['c'],
            i = x['e'],
            j = y['e'],
            a = x['s'];

        y['s'] = a == ( b = y['s'] ) ? 1 : -1;

        // Either NaN/Infinity/0?
        if ( !i && ( !xc || !xc[0] ) || !j && ( !yc || !yc[0] ) ) {

            // Either NaN?
            return new BigNumber( !a || !b ||

              // x is 0 and y is Infinity  or  y is 0 and x is Infinity?
              xc && !xc[0] && !yc || yc && !yc[0] && !xc

                // Return NaN.
                ? NaN

                // Either Infinity?
                : !xc || !yc

                  // Return +-Infinity.
                  ? y['s'] / 0

                  // x or y is 0. Return +-0.
                  : y['s'] * 0 )
        }
        y['e'] = i + j;

        if ( ( a = xc.length ) < ( b = yc.length ) ) {
            c = xc, xc = yc, yc = c, j = a, a = b, b = j
        }

        for ( j = a + b, c = []; j--; c.push(0) ) {
        }

        // Multiply!
        for ( i = b - 1; i > -1; i-- ) {

            for ( b = 0, j = a + i;
                  j > i;
                  b = c[j] + yc[i] * xc[j - i - 1] + b,
                  c[j--] = b % 10 | 0,
                  b = b / 10 | 0 ) {
            }

            if ( b ) {
                c[j] = ( c[j] + b ) % 10
            }
        }

        b && ++y['e'];

        // Remove any leading zero.
        !c[0] && c.shift();

        // Remove trailing zeros.
        for ( j = c.length; !c[--j]; c.pop() ) {
        }

        // No zero check needed as only x * 0 == 0 etc.

        // Overflow?
        y['c'] = y['e'] > MAX_EXP

          // Infinity.
          ? ( y['e'] = null )

          // Underflow?
          : y['e'] < MIN_EXP

            // Zero.
            ? [ y['e'] = 0 ]

            // Neither.
            : c;

        return y
    };


    /*
     * Return a string representing the value of this BigNumber in exponential
     * notation to dp fixed decimal places and rounded using ROUNDING_MODE if
     * necessary.
     *
     * [dp] {number} Integer, 0 to MAX inclusive.
     */
    P['toExponential'] = P['toE'] = function ( dp ) {

        return format( this,
          ( dp == null || ( ( outOfRange = dp < 0 || dp > MAX ) ||

            /*
             * Include '&& dp !== 0' because with Opera -0 == parseFloat(-0) is
             * false, despite -0 == parseFloat('-0') && 0 == -0 being true.
             */
            parse(dp) != dp && dp !== 0 ) &&

              // 'toE() decimal places not an integer: {dp}'
              // 'toE() decimal places out of range: {dp}'
              !ifExceptionsThrow( dp, 'decimal places', 'toE' ) ) && this['c']
                ? this['c'].length - 1
                : dp | 0, 1 )
    };


    /*
     * Return a string representing the value of this BigNumber in normal
     * notation to dp fixed decimal places and rounded using ROUNDING_MODE if
     * necessary.
     *
     * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',
     * but e.g. (-0.00001).toFixed(0) is '-0'.
     *
     * [dp] {number} Integer, 0 to MAX inclusive.
     */
    P['toFixed'] = P['toF'] = function ( dp ) {
        var n, str, d,
            x = this;

        if ( !( dp == null || ( ( outOfRange = dp < 0 || dp > MAX ) ||
            parse(dp) != dp && dp !== 0 ) &&

            // 'toF() decimal places not an integer: {dp}'
            // 'toF() decimal places out of range: {dp}'
            !ifExceptionsThrow( dp, 'decimal places', 'toF' ) ) ) {
              d = x['e'] + ( dp | 0 )
        }

        n = TO_EXP_NEG, dp = TO_EXP_POS;
        TO_EXP_NEG = -( TO_EXP_POS = 1 / 0 );

        // Note: str is initially undefined.
        if ( d == str ) {
            str = x['toS']()
        } else {
            str = format( x, d );

            // (-0).toFixed() is '0', but (-0.1).toFixed() is '-0'.
            // (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.
            if ( x['s'] < 0 && x['c'] ) {

                // As e.g. -0 toFixed(3), will wrongly be returned as -0.000 from toString.
                if ( !x['c'][0] ) {
                    str = str.replace(/^-/, '')

                // As e.g. -0.5 if rounded to -0 will cause toString to omit the minus sign.
                } else if ( str.indexOf('-') < 0 ) {
                    str = '-' + str
                }
            }
        }
        TO_EXP_NEG = n, TO_EXP_POS = dp;

        return str
    };


    /*
     * Return a string array representing the value of this BigNumber as a
     * simple fraction with an integer numerator and an integer denominator.
     * The denominator will be a positive non-zero value less than or equal to
     * the specified maximum denominator. If a maximum denominator is not
     * specified, the denominator will be the lowest value necessary to
     * represent the number exactly.
     *
     * [maxD] {number|string|BigNumber} Integer >= 1 and < Infinity.
     */
    P['toFraction'] = P['toFr'] = function ( maxD ) {
        var q, frac, n0, d0, d2, n, e,
            n1 = d0 = new BigNumber(ONE),
            d1 = n0 = new BigNumber('0'),
            x = this,
            xc = x['c'],
            exp = MAX_EXP,
            dp = DECIMAL_PLACES,
            rm = ROUNDING_MODE,
            d = new BigNumber(ONE);

        // NaN, Infinity.
        if ( !xc ) {
            return x['toS']()
        }

        e = d['e'] = xc.length - x['e'] - 1;

        // If max denominator is undefined or null...
        if ( maxD == null ||

             // or NaN...
             ( !( id = 12, n = new BigNumber(maxD) )['s'] ||

               // or less than 1, or Infinity...
               ( outOfRange = n['cmp'](n1) < 0 || !n['c'] ) ||

                 // or not an integer...
                 ( ERRORS && n['e'] < n['c'].length - 1 ) ) &&

                   // 'toFr() max denominator not an integer: {maxD}'
                   // 'toFr() max denominator out of range: {maxD}'
                   !ifExceptionsThrow( maxD, 'max denominator', 'toFr' ) ||

                     // or greater than the maxD needed to specify the value exactly...
                     ( maxD = n )['cmp'](d) > 0 ) {

            // d is e.g. 10, 100, 1000, 10000... , n1 is 1.
            maxD = e > 0 ? d : n1
        }

        MAX_EXP = 1 / 0;
        n = new BigNumber( xc.join('') );

        for ( DECIMAL_PLACES = 0, ROUNDING_MODE = 1; ; )  {
            q = n['div'](d);
            d2 = d0['plus']( q['times'](d1) );

            if ( d2['cmp'](maxD) == 1 ) {
                break
            }

            d0 = d1, d1 = d2;

            n1 = n0['plus']( q['times']( d2 = n1 ) );
            n0 = d2;

            d = n['minus']( q['times']( d2 = d ) );
            n = d2
        }

        d2 = maxD['minus'](d0)['div'](d1);
        n0 = n0['plus']( d2['times'](n1) );
        d0 = d0['plus']( d2['times'](d1) );

        n0['s'] = n1['s'] = x['s'];

        DECIMAL_PLACES = e * 2;
        ROUNDING_MODE = rm;

        // Determine which fraction is closer to x, n0 / d0 or n1 / d1?
        frac = n1['div'](d1)['minus'](x)['abs']()['cmp'](
          n0['div'](d0)['minus'](x)['abs']() ) < 1
          ? [ n1['toS'](), d1['toS']() ]
          : [ n0['toS'](), d0['toS']() ];

        return MAX_EXP = exp, DECIMAL_PLACES = dp, frac
    };


    /*
     * Return a string representing the value of this BigNumber to sd significant
     * digits and rounded using ROUNDING_MODE if necessary.
     * If sd is less than the number of digits necessary to represent the integer
     * part of the value in normal notation, then use exponential notation.
     *
     * sd {number} Integer, 1 to MAX inclusive.
     */
    P['toPrecision'] = P['toP'] = function ( sd ) {

        /*
         * ERRORS true: Throw if sd not undefined, null or an integer in range.
         * ERRORS false: Ignore sd if not a number or not in range.
         * Truncate non-integers.
         */
        return sd == null || ( ( ( outOfRange = sd < 1 || sd > MAX ) ||
          parse(sd) != sd ) &&

            // 'toP() precision not an integer: {sd}'
            // 'toP() precision out of range: {sd}'
            !ifExceptionsThrow( sd, 'precision', 'toP' ) )
              ? this['toS']()
              : format( this, --sd | 0, 2 )
    };


    /*
     * Return a string representing the value of this BigNumber in base b, or
     * base 10 if b is omitted. If a base is specified, including base 10,
     * round according to DECIMAL_PLACES and ROUNDING_MODE.
     * If a base is not specified, and this BigNumber has a positive exponent
     * that is equal to or greater than TO_EXP_POS, or a negative exponent equal
     * to or less than TO_EXP_NEG, return exponential notation.
     *
     * [b] {number} Integer, 2 to 36 inclusive.
     */
    P['toString'] = P['toS'] = function ( b ) {
        var u, str, strL,
            x = this,
            xe = x['e'];

        // Infinity or NaN?
        if ( xe === null ) {
            str = x['s'] ? 'Infinity' : 'NaN'

        // Exponential format?
        } else if ( b === u && ( xe <= TO_EXP_NEG || xe >= TO_EXP_POS ) ) {
            return format( x, x['c'].length - 1, 1 )
        } else {
            str = x['c'].join('');

            // Negative exponent?
            if ( xe < 0 ) {

                // Prepend zeros.
                for ( ; ++xe; str = '0' + str ) {
                }
                str = '0.' + str

            // Positive exponent?
            } else if ( strL = str.length, xe > 0 ) {

                if ( ++xe > strL ) {

                    // Append zeros.
                    for ( xe -= strL; xe-- ; str += '0' ) {
                    }
                } else if ( xe < strL ) {
                    str = str.slice( 0, xe ) + '.' + str.slice(xe)
                }

            // Exponent zero.
            } else {
                if ( u = str.charAt(0), strL > 1 ) {
                    str = u + '.' + str.slice(1)

                // Avoid '-0'
                } else if ( u == '0' ) {
                    return u
                }
            }

            if ( b != null ) {

                if ( !( outOfRange = !( b >= 2 && b <= 36 ) ) &&
                  ( b == (b | 0) || !ERRORS ) ) {
                    str = convert( str, b | 0, 10, x['s'] );

                    // Avoid '-0'
                    if ( str == '0' ) {
                        return str
                    }
                } else {

                    // 'toS() base not an integer: {b}'
                    // 'toS() base out of range: {b}'
                    ifExceptionsThrow( b, 'base', 'toS' )
                }
            }

        }

        return x['s'] < 0 ? '-' + str : str
    };


    /*
     * Return as toString, but do not accept a base argument.
     */
    P['valueOf'] = function () {
        return this['toS']()
    };


    // Add aliases for BigDecimal methods.
    //P['add'] = P['plus'];
    //P['subtract'] = P['minus'];
    //P['multiply'] = P['times'];
    //P['divide'] = P['div'];
    //P['remainder'] = P['mod'];
    //P['compareTo'] = P['cmp'];
    //P['negate'] = P['neg'];


    // EXPORT


    // Node and other CommonJS-like environments that support module.exports.
    if ( typeof module !== 'undefined' && module.exports ) {
        module.exports = BigNumber

    //AMD.
    } else if ( typeof define == 'function' && define.amd ) {
        define( function () {
            return BigNumber
        })

    //Browser.
    } else {
        global['BigNumber'] = BigNumber
    }

})( this );

//     Underscore.js 1.5.1
//     http://underscorejs.org
//     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Establish the object that gets returned to break out of a loop iteration.
  var breaker = {};

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    concat           = ArrayProto.concat,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeForEach      = ArrayProto.forEach,
    nativeMap          = ArrayProto.map,
    nativeReduce       = ArrayProto.reduce,
    nativeReduceRight  = ArrayProto.reduceRight,
    nativeFilter       = ArrayProto.filter,
    nativeEvery        = ArrayProto.every,
    nativeSome         = ArrayProto.some,
    nativeIndexOf      = ArrayProto.indexOf,
    nativeLastIndexOf  = ArrayProto.lastIndexOf,
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind;

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object via a string identifier,
  // for Closure Compiler "advanced" mode.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.5.1';

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles objects with the built-in `forEach`, arrays, and raw objects.
  // Delegates to **ECMAScript 5**'s native `forEach` if available.
  var each = _.each = _.forEach = function(obj, iterator, context) {
    if (obj == null) return;
    if (nativeForEach && obj.forEach === nativeForEach) {
      obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, length = obj.length; i < length; i++) {
        if (iterator.call(context, obj[i], i, obj) === breaker) return;
      }
    } else {
      var keys = _.keys(obj);
      for (var i = 0, length = keys.length; i < length; i++) {
        if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;
      }
    }
  };

  // Return the results of applying the iterator to each element.
  // Delegates to **ECMAScript 5**'s native `map` if available.
  _.map = _.collect = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
    each(obj, function(value, index, list) {
      results.push(iterator.call(context, value, index, list));
    });
    return results;
  };

  var reduceError = 'Reduce of empty array with no initial value';

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduce && obj.reduce === nativeReduce) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function(value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var length = obj.length;
    if (length !== +length) {
      var keys = _.keys(obj);
      length = keys.length;
    }
    each(obj, function(value, index, list) {
      index = keys ? keys[--length] : --length;
      if (!initial) {
        memo = obj[index];
        initial = true;
      } else {
        memo = iterator.call(context, memo, obj[index], index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, iterator, context) {
    var result;
    any(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Delegates to **ECMAScript 5**'s native `filter` if available.
  // Aliased as `select`.
  _.filter = _.select = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
    each(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, iterator, context) {
    return _.filter(obj, function(value, index, list) {
      return !iterator.call(context, value, index, list);
    }, context);
  };

  // Determine whether all of the elements match a truth test.
  // Delegates to **ECMAScript 5**'s native `every` if available.
  // Aliased as `all`.
  _.every = _.all = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = true;
    if (obj == null) return result;
    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
    each(obj, function(value, index, list) {
      if (!(result = result && iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if at least one element in the object matches a truth test.
  // Delegates to **ECMAScript 5**'s native `some` if available.
  // Aliased as `any`.
  var any = _.some = _.any = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = false;
    if (obj == null) return result;
    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
    each(obj, function(value, index, list) {
      if (result || (result = iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if the array or object contains a given value (using `===`).
  // Aliased as `include`.
  _.contains = _.include = function(obj, target) {
    if (obj == null) return false;
    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
    return any(obj, function(value) {
      return value === target;
    });
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      return (isFunc ? method : value[method]).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, function(value){ return value[key]; });
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs, first) {
    if (_.isEmpty(attrs)) return first ? void 0 : [];
    return _[first ? 'find' : 'filter'](obj, function(value) {
      for (var key in attrs) {
        if (attrs[key] !== value[key]) return false;
      }
      return true;
    });
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.where(obj, attrs, true);
  };

  // Return the maximum element or (element-based computation).
  // Can't optimize arrays of integers longer than 65,535 elements.
  // See [WebKit Bug 80797](https://bugs.webkit.org/show_bug.cgi?id=80797)
  _.max = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.max.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj)) return -Infinity;
    var result = {computed : -Infinity, value: -Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed > result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.min.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj)) return Infinity;
    var result = {computed : Infinity, value: Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed < result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Shuffle an array.
  _.shuffle = function(obj) {
    var rand;
    var index = 0;
    var shuffled = [];
    each(obj, function(value) {
      rand = _.random(index++);
      shuffled[index - 1] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };

  // An internal function to generate lookup iterators.
  var lookupIterator = function(value) {
    return _.isFunction(value) ? value : function(obj){ return obj[value]; };
  };

  // Sort the object's values by a criterion produced by an iterator.
  _.sortBy = function(obj, value, context) {
    var iterator = lookupIterator(value);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value : value,
        index : index,
        criteria : iterator.call(context, value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index < right.index ? -1 : 1;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, value, context) {
      var result = {};
      var iterator = value == null ? _.identity : lookupIterator(value);
      each(obj, function(value, index) {
        var key = iterator.call(context, value, index, obj);
        behavior(result, key, value);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, key, value) {
    (_.has(result, key) ? result[key] : (result[key] = [])).push(value);
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, key, value) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, key, value) {
    _.has(result, key) ? result[key]++ : result[key] = 1;
  });

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iterator, context) {
    iterator = iterator == null ? _.identity : lookupIterator(iterator);
    var value = iterator.call(context, obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = (low + high) >>> 1;
      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
    }
    return low;
  };

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (obj.length === +obj.length) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    return (n == null) || guard ? array[0] : slice.call(array, 0, n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N. The **guard** check allows it to work with
  // `_.map`.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array. The **guard** check allows it to work with `_.map`.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if ((n == null) || guard) {
      return array[array.length - 1];
    } else {
      return slice.call(array, Math.max(array.length - n, 0));
    }
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, (n == null) || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, output) {
    if (shallow && _.every(input, _.isArray)) {
      return concat.apply(output, input);
    }
    each(input, function(value) {
      if (_.isArray(value) || _.isArguments(value)) {
        shallow ? push.apply(output, value) : flatten(value, shallow, output);
      } else {
        output.push(value);
      }
    });
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iterator, context) {
    if (_.isFunction(isSorted)) {
      context = iterator;
      iterator = isSorted;
      isSorted = false;
    }
    var initial = iterator ? _.map(array, iterator, context) : array;
    var results = [];
    var seen = [];
    each(initial, function(value, index) {
      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {
        seen.push(value);
        results.push(array[index]);
      }
    });
    return results;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(_.flatten(arguments, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function(item) {
      return _.every(rest, function(other) {
        return _.indexOf(other, item) >= 0;
      });
    });
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
    return _.filter(array, function(value){ return !_.contains(rest, value); });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    var length = _.max(_.pluck(arguments, "length").concat(0));
    var results = new Array(length);
    for (var i = 0; i < length; i++) {
      results[i] = _.pluck(arguments, '' + i);
    }
    return results;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    if (list == null) return {};
    var result = {};
    for (var i = 0, length = list.length; i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
  // we need this function. Return the position of the first occurrence of an
  // item in an array, or -1 if the item is not included in the array.
  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    if (array == null) return -1;
    var i = 0, length = array.length;
    if (isSorted) {
      if (typeof isSorted == 'number') {
        i = (isSorted < 0 ? Math.max(0, length + isSorted) : isSorted);
      } else {
        i = _.sortedIndex(array, item);
        return array[i] === item ? i : -1;
      }
    }
    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
    for (; i < length; i++) if (array[i] === item) return i;
    return -1;
  };

  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
  _.lastIndexOf = function(array, item, from) {
    if (array == null) return -1;
    var hasIndex = from != null;
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
    }
    var i = (hasIndex ? from : array.length);
    while (i--) if (array[i] === item) return i;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(length);

    while(idx < length) {
      range[idx++] = start;
      start += step;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Reusable constructor function for prototype setting.
  var ctor = function(){};

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    var args, bound;
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError;
    args = slice.call(arguments, 2);
    return bound = function() {
      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
      ctor.prototype = func.prototype;
      var self = new ctor;
      ctor.prototype = null;
      var result = func.apply(self, args.concat(slice.call(arguments)));
      if (Object(result) === result) return result;
      return self;
    };
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context.
  _.partial = function(func) {
    var args = slice.call(arguments, 1);
    return function() {
      return func.apply(this, args.concat(slice.call(arguments)));
    };
  };

  // Bind all of an object's methods to that object. Useful for ensuring that
  // all callbacks defined on an object belong to it.
  _.bindAll = function(obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length === 0) throw new Error("bindAll must be passed function names");
    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function() {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
    };
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){ return func.apply(null, args); }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    options || (options = {});
    var later = function() {
      previous = options.leading === false ? 0 : new Date;
      timeout = null;
      result = func.apply(context, args);
    };
    return function() {
      var now = new Date;
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0) {
        clearTimeout(timeout);
        timeout = null;
        previous = now;
        result = func.apply(context, args);
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var result;
    var timeout = null;
    return function() {
      var context = this, args = arguments;
      var later = function() {
        timeout = null;
        if (!immediate) result = func.apply(context, args);
      };
      var callNow = immediate && !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      if (callNow) result = func.apply(context, args);
      return result;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = function(func) {
    var ran = false, memo;
    return function() {
      if (ran) return memo;
      ran = true;
      memo = func.apply(this, arguments);
      func = null;
      return memo;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return function() {
      var args = [func];
      push.apply(args, arguments);
      return wrapper.apply(this, args);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var funcs = arguments;
    return function() {
      var args = arguments;
      for (var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };

  // Returns a function that will only be executed after being called N times.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = nativeKeys || function(obj) {
    if (obj !== Object(obj)) throw new TypeError('Invalid object');
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = new Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = new Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    each(keys, function(key) {
      if (key in obj) copy[key] = obj[key];
    });
    return copy;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    for (var key in obj) {
      if (!_.contains(keys, key)) copy[key] = obj[key];
    }
    return copy;
  };

  // Fill in a given object with default properties.
  _.defaults = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          if (obj[prop] === void 0) obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a == 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className != toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return a == String(b);
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a == +b;
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] == a) return bStack[length] == b;
    }
    // Objects with different constructors are not equivalent, but `Object`s
    // from different frames are.
    var aCtor = a.constructor, bCtor = b.constructor;
    if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&
                             _.isFunction(bCtor) && (bCtor instanceof bCtor))) {
      return false;
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    var size = 0, result = true;
    // Recursively compare objects and arrays.
    if (className == '[object Array]') {
      // Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size == b.length;
      if (result) {
        // Deep compare the contents, ignoring non-numeric properties.
        while (size--) {
          if (!(result = eq(a[size], b[size], aStack, bStack))) break;
        }
      }
    } else {
      // Deep compare objects.
      for (var key in a) {
        if (_.has(a, key)) {
          // Count the expected number of properties.
          size++;
          // Deep compare each member.
          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
        }
      }
      // Ensure that both objects contain the same number of properties.
      if (result) {
        for (key in b) {
          if (_.has(b, key) && !(size--)) break;
        }
        result = !size;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return result;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b, [], []);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
    for (var key in obj) if (_.has(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) == '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    return obj === Object(obj);
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) == '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return !!(obj && _.has(obj, 'callee'));
    };
  }

  // Optimize `isFunction` if appropriate.
  if (typeof (/./) !== 'function') {
    _.isFunction = function(obj) {
      return typeof obj === 'function';
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj != +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iterators.
  _.identity = function(value) {
    return value;
  };

  // Run a function **n** times.
  _.times = function(n, iterator, context) {
    var accum = Array(Math.max(0, n));
    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // List of HTML entities for escaping.
  var entityMap = {
    escape: {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;'
    }
  };
  entityMap.unescape = _.invert(entityMap.escape);

  // Regexes containing the keys and values listed immediately above.
  var entityRegexes = {
    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
  };

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  _.each(['escape', 'unescape'], function(method) {
    _[method] = function(string) {
      if (string == null) return '';
      return ('' + string).replace(entityRegexes[method], function(match) {
        return entityMap[method][match];
      });
    };
  });

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property) {
    if (object == null) return void 0;
    var value = object[property];
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result.call(this, func.apply(_, args));
      };
    });
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\t':     't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  _.template = function(text, data, settings) {
    var render;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = new RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset)
        .replace(escaper, function(match) { return '\\' + escapes[match]; });

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      }
      if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      }
      if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }
      index = offset + match.length;
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + "return __p;\n";

    try {
      render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    if (data) return render(data, _);
    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled function source as a convenience for precompilation.
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function, which will delegate to the wrapper.
  _.chain = function(obj) {
    return _(obj).chain();
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(obj) {
    return this._chain ? _(obj).chain() : obj;
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];
      return result.call(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result.call(this, method.apply(this._wrapped, arguments));
    };
  });

  _.extend(_.prototype, {

    // Start chaining a wrapped Underscore object.
    chain: function() {
      this._chain = true;
      return this;
    },

    // Extracts the result from a wrapped and chained object.
    value: function() {
      return this._wrapped;
    }

  });

}).call(this);
/*!
* ZeroClipboard
* The ZeroClipboard library provides an easy way to copy text to the clipboard using an invisible Adobe Flash movie and a JavaScript interface.
* Copyright (c) 2013 Jon Rohan, James M. Greene
* Licensed MIT
* http://zeroclipboard.org/
* v1.2.0-beta.4
*/

(function() {
  "use strict";
  var _camelizeCssPropName = function() {
    var matcherRegex = /\-([a-z])/g, replacerFn = function(match, group) {
      return group.toUpperCase();
    };
    return function(prop) {
      return prop.replace(matcherRegex, replacerFn);
    };
  }();
  var _getStyle = function(el, prop) {
    var value, camelProp, tagName, possiblePointers, i, len;
    if (window.getComputedStyle) {
      value = window.getComputedStyle(el, null).getPropertyValue(prop);
    } else {
      camelProp = _camelizeCssPropName(prop);
      if (el.currentStyle) {
        value = el.currentStyle[camelProp];
      } else {
        value = el.style[camelProp];
      }
    }
    if (prop === "cursor") {
      if (!value || value === "auto") {
        tagName = el.tagName.toLowerCase();
        possiblePointers = [ "a" ];
        for (i = 0, len = possiblePointers.length; i < len; i++) {
          if (tagName === possiblePointers[i]) {
            return "pointer";
          }
        }
      }
    }
    return value;
  };
  var _elementMouseOver = function(event) {
    if (!ZeroClipboard.prototype._singleton) return;
    if (!event) {
      event = window.event;
    }
    var target;
    if (this !== window) {
      target = this;
    } else if (event.target) {
      target = event.target;
    } else if (event.srcElement) {
      target = event.srcElement;
    }
    ZeroClipboard.prototype._singleton.setCurrent(target);
  };
  var _addEventHandler = function(element, method, func) {
    if (element.addEventListener) {
      element.addEventListener(method, func, false);
    } else if (element.attachEvent) {
      element.attachEvent("on" + method, func);
    }
  };
  var _removeEventHandler = function(element, method, func) {
    if (element.removeEventListener) {
      element.removeEventListener(method, func, false);
    } else if (element.detachEvent) {
      element.detachEvent("on" + method, func);
    }
  };
  var _addClass = function(element, value) {
    if (element.addClass) {
      element.addClass(value);
      return element;
    }
    if (value && typeof value === "string") {
      var classNames = (value || "").split(/\s+/);
      if (element.nodeType === 1) {
        if (!element.className) {
          element.className = value;
        } else {
          var className = " " + element.className + " ", setClass = element.className;
          for (var c = 0, cl = classNames.length; c < cl; c++) {
            if (className.indexOf(" " + classNames[c] + " ") < 0) {
              setClass += " " + classNames[c];
            }
          }
          element.className = setClass.replace(/^\s+|\s+$/g, "");
        }
      }
    }
    return element;
  };
  var _removeClass = function(element, value) {
    if (element.removeClass) {
      element.removeClass(value);
      return element;
    }
    if (value && typeof value === "string" || value === undefined) {
      var classNames = (value || "").split(/\s+/);
      if (element.nodeType === 1 && element.className) {
        if (value) {
          var className = (" " + element.className + " ").replace(/[\n\t]/g, " ");
          for (var c = 0, cl = classNames.length; c < cl; c++) {
            className = className.replace(" " + classNames[c] + " ", " ");
          }
          element.className = className.replace(/^\s+|\s+$/g, "");
        } else {
          element.className = "";
        }
      }
    }
    return element;
  };
  var _getZoomFactor = function() {
    var rect, physicalWidth, logicalWidth, zoomFactor = 1;
    if (typeof document.body.getBoundingClientRect === "function") {
      rect = document.body.getBoundingClientRect();
      physicalWidth = rect.right - rect.left;
      logicalWidth = document.body.offsetWidth;
      zoomFactor = Math.round(physicalWidth / logicalWidth * 100) / 100;
    }
    return zoomFactor;
  };
  var _getDOMObjectPosition = function(obj) {
    var info = {
      left: 0,
      top: 0,
      width: 0,
      height: 0,
      zIndex: 999999999
    };
    var zi = _getStyle(obj, "z-index");
    if (zi && zi !== "auto") {
      info.zIndex = parseInt(zi, 10);
    }
    if (obj.getBoundingClientRect) {
      var rect = obj.getBoundingClientRect();
      var pageXOffset, pageYOffset, zoomFactor;
      if ("pageXOffset" in window && "pageYOffset" in window) {
        pageXOffset = window.pageXOffset;
        pageYOffset = window.pageYOffset;
      } else {
        zoomFactor = _getZoomFactor();
        pageXOffset = Math.round(document.documentElement.scrollLeft / zoomFactor);
        pageYOffset = Math.round(document.documentElement.scrollTop / zoomFactor);
      }
      var leftBorderWidth = document.documentElement.clientLeft || 0;
      var topBorderWidth = document.documentElement.clientTop || 0;
      info.left = rect.left + pageXOffset - leftBorderWidth;
      info.top = rect.top + pageYOffset - topBorderWidth;
      info.width = "width" in rect ? rect.width : rect.right - rect.left;
      info.height = "height" in rect ? rect.height : rect.bottom - rect.top;
    }
    return info;
  };
  var _noCache = function(path, options) {
    var useNoCache = !(options && options.useNoCache === false);
    if (useNoCache) {
      return (path.indexOf("?") === -1 ? "?" : "&") + "nocache=" + new Date().getTime();
    } else {
      return "";
    }
  };
  var _vars = function(options) {
    var str = [];
    var origins = [];
    if (options.trustedOrigins) {
      if (typeof options.trustedOrigins === "string") {
        origins = origins.push(options.trustedOrigins);
      } else if (typeof options.trustedOrigins === "object" && "length" in options.trustedOrigins) {
        origins = origins.concat(options.trustedOrigins);
      }
    }
    if (options.trustedDomains) {
      if (typeof options.trustedDomains === "string") {
        origins = origins.push(options.trustedDomains);
      } else if (typeof options.trustedDomains === "object" && "length" in options.trustedDomains) {
        origins = origins.concat(options.trustedDomains);
      }
    }
    if (origins.length) {
      str.push("trustedOrigins=" + encodeURIComponent(origins.join(",")));
    }
    if (typeof options.amdModuleId === "string" && options.amdModuleId) {
      str.push("amdModuleId=" + encodeURIComponent(options.amdModuleId));
    }
    if (typeof options.cjsModuleId === "string" && options.cjsModuleId) {
      str.push("cjsModuleId=" + encodeURIComponent(options.cjsModuleId));
    }
    return str.join("&");
  };
  var _inArray = function(elem, array) {
    if (array.indexOf) {
      return array.indexOf(elem);
    }
    for (var i = 0, length = array.length; i < length; i++) {
      if (array[i] === elem) {
        return i;
      }
    }
    return -1;
  };
  var _prepGlue = function(elements) {
    if (typeof elements === "string") throw new TypeError("ZeroClipboard doesn't accept query strings.");
    if (!elements.length) return [ elements ];
    return elements;
  };
  var _dispatchCallback = function(func, element, instance, args, async) {
    if (async) {
      window.setTimeout(function() {
        func.call(element, instance, args);
      }, 0);
    } else {
      func.call(element, instance, args);
    }
  };
  var ZeroClipboard = function(elements, options) {
    if (elements) (ZeroClipboard.prototype._singleton || this).glue(elements);
    if (ZeroClipboard.prototype._singleton) return ZeroClipboard.prototype._singleton;
    ZeroClipboard.prototype._singleton = this;
    this.options = {};
    for (var kd in _defaults) this.options[kd] = _defaults[kd];
    for (var ko in options) this.options[ko] = options[ko];
    this.handlers = {};
    if (ZeroClipboard.detectFlashSupport()) _bridge();
  };
  var currentElement, gluedElements = [];
  ZeroClipboard.prototype.setCurrent = function(element) {
    currentElement = element;
    this.reposition();
    var titleAttr = element.getAttribute("title");
    if (titleAttr) {
      this.setTitle(titleAttr);
    }
    var useHandCursor = this.options.forceHandCursor === true || _getStyle(element, "cursor") === "pointer";
    _setHandCursor.call(this, useHandCursor);
  };
  ZeroClipboard.prototype.setText = function(newText) {
    if (newText && newText !== "") {
      this.options.text = newText;
      if (this.ready()) this.flashBridge.setText(newText);
    }
  };
  ZeroClipboard.prototype.setTitle = function(newTitle) {
    if (newTitle && newTitle !== "") this.htmlBridge.setAttribute("title", newTitle);
  };
  ZeroClipboard.prototype.setSize = function(width, height) {
    if (this.ready()) this.flashBridge.setSize(width, height);
  };
  ZeroClipboard.prototype.setHandCursor = function(enabled) {
    enabled = typeof enabled === "boolean" ? enabled : !!enabled;
    _setHandCursor.call(this, enabled);
    this.options.forceHandCursor = enabled;
  };
  var _setHandCursor = function(enabled) {
    if (this.ready()) this.flashBridge.setHandCursor(enabled);
  };
  ZeroClipboard.version = "1.2.0-beta.4";
  var _defaults = {
    moviePath: "/ZeroClipboard.swf",
    trustedOrigins: null,
    text: null,
    hoverClass: "zeroclipboard-is-hover",
    activeClass: "zeroclipboard-is-active",
    allowScriptAccess: "sameDomain",
    useNoCache: true,
    forceHandCursor: false
  };
  ZeroClipboard.setDefaults = function(options) {
    for (var ko in options) _defaults[ko] = options[ko];
  };
  ZeroClipboard.destroy = function() {
    ZeroClipboard.prototype._singleton.unglue(gluedElements);
    var bridge = ZeroClipboard.prototype._singleton.htmlBridge;
    bridge.parentNode.removeChild(bridge);
    delete ZeroClipboard.prototype._singleton;
  };
  ZeroClipboard.detectFlashSupport = function() {
    var hasFlash = false;
    if (typeof ActiveXObject === "function") {
      try {
        if (new ActiveXObject("ShockwaveFlash.ShockwaveFlash")) {
          hasFlash = true;
        }
      } catch (error) {}
    }
    if (!hasFlash && navigator.mimeTypes["application/x-shockwave-flash"]) {
      hasFlash = true;
    }
    return hasFlash;
  };
  var _amdModuleId = null;
  var _cjsModuleId = null;
  var _bridge = function() {
    var client = ZeroClipboard.prototype._singleton;
    var container = document.getElementById("global-zeroclipboard-html-bridge");
    if (!container) {
      var opts = {};
      for (var ko in client.options) opts[ko] = client.options[ko];
      opts.amdModuleId = _amdModuleId;
      opts.cjsModuleId = _cjsModuleId;
      var flashvars = _vars(opts);
      var html = '      <object classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000" id="global-zeroclipboard-flash-bridge" width="100%" height="100%">         <param name="movie" value="' + client.options.moviePath + _noCache(client.options.moviePath, client.options) + '"/>         <param name="allowScriptAccess" value="' + client.options.allowScriptAccess + '"/>         <param name="scale" value="exactfit"/>         <param name="loop" value="false"/>         <param name="menu" value="false"/>         <param name="quality" value="best" />         <param name="bgcolor" value="#ffffff"/>         <param name="wmode" value="transparent"/>         <param name="flashvars" value="' + flashvars + '"/>         <embed src="' + client.options.moviePath + _noCache(client.options.moviePath, client.options) + '"           loop="false" menu="false"           quality="best" bgcolor="#ffffff"           width="100%" height="100%"           name="global-zeroclipboard-flash-bridge"           allowScriptAccess="always"           allowFullScreen="false"           type="application/x-shockwave-flash"           wmode="transparent"           pluginspage="http://www.macromedia.com/go/getflashplayer"           flashvars="' + flashvars + '"           scale="exactfit">         </embed>       </object>';
      container = document.createElement("div");
      container.id = "global-zeroclipboard-html-bridge";
      container.setAttribute("class", "global-zeroclipboard-container");
      container.setAttribute("data-clipboard-ready", false);
      container.style.position = "absolute";
      container.style.left = "-9999px";
      container.style.top = "-9999px";
      container.style.width = "15px";
      container.style.height = "15px";
      container.style.zIndex = "9999";
      container.innerHTML = html;
      document.body.appendChild(container);
    }
    client.htmlBridge = container;
    client.flashBridge = document["global-zeroclipboard-flash-bridge"] || container.children[0].lastElementChild;
  };
  ZeroClipboard.prototype.resetBridge = function() {
    this.htmlBridge.style.left = "-9999px";
    this.htmlBridge.style.top = "-9999px";
    this.htmlBridge.removeAttribute("title");
    this.htmlBridge.removeAttribute("data-clipboard-text");
    _removeClass(currentElement, this.options.activeClass);
    currentElement = null;
    this.options.text = null;
  };
  ZeroClipboard.prototype.ready = function() {
    var ready = this.htmlBridge.getAttribute("data-clipboard-ready");
    return ready === "true" || ready === true;
  };
  ZeroClipboard.prototype.reposition = function() {
    if (!currentElement) return false;
    var pos = _getDOMObjectPosition(currentElement);
    this.htmlBridge.style.top = pos.top + "px";
    this.htmlBridge.style.left = pos.left + "px";
    this.htmlBridge.style.width = pos.width + "px";
    this.htmlBridge.style.height = pos.height + "px";
    this.htmlBridge.style.zIndex = pos.zIndex + 1;
    this.setSize(pos.width, pos.height);
  };
  ZeroClipboard.dispatch = function(eventName, args) {
    ZeroClipboard.prototype._singleton.receiveEvent(eventName, args);
  };
  ZeroClipboard.prototype.on = function(eventName, func) {
    var events = eventName.toString().split(/\s/g);
    for (var i = 0; i < events.length; i++) {
      eventName = events[i].toLowerCase().replace(/^on/, "");
      if (!this.handlers[eventName]) this.handlers[eventName] = func;
    }
    if (this.handlers.noflash && !ZeroClipboard.detectFlashSupport()) {
      this.receiveEvent("onNoFlash", null);
    }
  };
  ZeroClipboard.prototype.addEventListener = ZeroClipboard.prototype.on;
  ZeroClipboard.prototype.off = function(eventName, func) {
    var events = eventName.toString().split(/\s/g);
    for (var i = 0; i < events.length; i++) {
      eventName = events[i].toLowerCase().replace(/^on/, "");
      for (var event in this.handlers) {
        if (event === eventName && this.handlers[event] === func) {
          delete this.handlers[event];
        }
      }
    }
  };
  ZeroClipboard.prototype.removeEventListener = ZeroClipboard.prototype.off;
  ZeroClipboard.prototype.receiveEvent = function(eventName, args) {
    eventName = eventName.toString().toLowerCase().replace(/^on/, "");
    var element = currentElement;
    var performCallbackAsync = true;
    switch (eventName) {
     case "load":
      if (args && parseFloat(args.flashVersion.replace(",", ".").replace(/[^0-9\.]/gi, "")) < 10) {
        this.receiveEvent("onWrongFlash", {
          flashVersion: args.flashVersion
        });
        return;
      }
      this.htmlBridge.setAttribute("data-clipboard-ready", true);
      break;

     case "mouseover":
      _addClass(element, this.options.hoverClass);
      break;

     case "mouseout":
      _removeClass(element, this.options.hoverClass);
      this.resetBridge();
      break;

     case "mousedown":
      _addClass(element, this.options.activeClass);
      break;

     case "mouseup":
      _removeClass(element, this.options.activeClass);
      break;

     case "datarequested":
      var targetId = element.getAttribute("data-clipboard-target"), targetEl = !targetId ? null : document.getElementById(targetId);
      if (targetEl) {
        var textContent = targetEl.value || targetEl.textContent || targetEl.innerText;
        if (textContent) this.setText(textContent);
      } else {
        var defaultText = element.getAttribute("data-clipboard-text");
        if (defaultText) this.setText(defaultText);
      }
      performCallbackAsync = false;
      break;

     case "complete":
      this.options.text = null;
      break;
    }
    if (this.handlers[eventName]) {
      var func = this.handlers[eventName];
      if (typeof func === "string" && typeof window[func] === "function") {
        func = window[func];
      }
      if (typeof func === "function") {
        _dispatchCallback(func, element, this, args, performCallbackAsync);
      }
    }
  };
  ZeroClipboard.prototype.glue = function(elements) {
    elements = _prepGlue(elements);
    for (var i = 0; i < elements.length; i++) {
      if (_inArray(elements[i], gluedElements) == -1) {
        gluedElements.push(elements[i]);
        _addEventHandler(elements[i], "mouseover", _elementMouseOver);
      }
    }
  };
  ZeroClipboard.prototype.unglue = function(elements) {
    elements = _prepGlue(elements);
    for (var i = 0; i < elements.length; i++) {
      _removeEventHandler(elements[i], "mouseover", _elementMouseOver);
      var arrayIndex = _inArray(elements[i], gluedElements);
      if (arrayIndex != -1) gluedElements.splice(arrayIndex, 1);
    }
  };
  if (typeof define === "function" && define.amd) {
    define([ "require", "exports", "module" ], function(require, exports, module) {
      _amdModuleId = module && module.id || null;
      return ZeroClipboard;
    });
  } else if (typeof module !== "undefined" && module) {
    _cjsModuleId = module.id || null;
    module.exports = ZeroClipboard;
  } else {
    window.ZeroClipboard = ZeroClipboard;
  }
})();
/*! Flight v1.3.0 | (c) Twitter, Inc. | MIT License */

!function(t,n){"object"==typeof exports&&"object"==typeof module?module.exports=n():"function"==typeof define&&define.amd?define(n):"object"==typeof exports?exports.flight=n():t.flight=n()}(this,function(){return function(t){function n(o){if(e[o])return e[o].exports;var i=e[o]={exports:{},id:o,loaded:!1};return t[o].call(i.exports,i,i.exports,n),i.loaded=!0,i.exports}var e={};return n.m=t,n.c=e,n.p="",n(0)}([function(t,n,e){var o,i;o=[e(1),e(2),e(3),e(4),e(5),e(6),e(7)],i=function(t,n,e,o,i,r,a){"use strict";return{advice:t,component:n,compose:e,debug:o,logger:i,registry:r,utils:a}}.apply(n,o),!(void 0!==i&&(t.exports=i))},function(t,n,e){var o,i;o=[e(7)],i=function(t){"use strict";var n={around:function(t,n){return function(){var e=0,o=arguments.length,i=new Array(o+1);for(i[0]=t.bind(this);o>e;e++)i[e+1]=arguments[e];return n.apply(this,i)}},before:function(t,n){var e="function"==typeof n?n:n.obj[n.fnName];return function(){return e.apply(this,arguments),t.apply(this,arguments)}},after:function(t,n){var e="function"==typeof n?n:n.obj[n.fnName];return function(){var n=(t.unbound||t).apply(this,arguments);return e.apply(this,arguments),n}},withAdvice:function(){["before","after","around"].forEach(function(e){this[e]=function(o,i){t.mutateProperty(this,o,function(){return this[o]="function"==typeof this[o]?n[e](this[o],i):i,this[o]})}},this)}};return n}.apply(n,o),!(void 0!==i&&(t.exports=i))},function(t,n,e){var o,i;o=[e(1),e(7),e(3),e(8),e(6),e(5),e(4)],i=function(t,n,e,o,i,r,a){"use strict";function s(){var t=i.findComponentInfo(this);t&&Object.keys(t.instances).forEach(function(n){var e=t.instances[n];e&&e.instance&&e.instance.teardown()})}function c(t){for(var e=arguments.length,o=new Array(e-1),r=1;e>r;r++)o[r-1]=arguments[r];if(!t)throw new Error("Component needs to be attachTo'd a jQuery object, native node or selector string");var a=n.merge.apply(n,o),s=i.findComponentInfo(this);$(t).each(function(t,n){s&&s.isAttachedTo(n)||(new this).initialize(n,a)}.bind(this))}function u(){var t=this.mixedIn||this.prototype.mixedIn||[];return t.map(function(t){if(null==t.name){var n=t.toString().match(l);return n&&n[1]?n[1]:""}return"withBase"!=t.name?t.name:""}).filter(Boolean).join(", ")}function f(){for(var l=arguments.length,h=new Array(l),p=0;l>p;p++)h[p]=arguments[p];var d=function(){};return d.toString=d.prototype.toString=u,a.enabled&&(d.describe=d.prototype.describe=d.toString()),d.attachTo=c,d.mixin=function(){var t=f(),o=Object.create(d.prototype);return o.mixedIn=[].concat(d.prototype.mixedIn),o.defaults=n.merge(d.prototype.defaults),o.attrDef=d.prototype.attrDef,e.mixin(o,arguments),t.prototype=o,t.prototype.constructor=t,t},d.teardownAll=s,a.enabled&&h.unshift(r),h.unshift(o,t.withAdvice,i.withRegistration),e.mixin(d.prototype,h),d}var l=/function (.*?)\s?\(/;return f.teardownAll=function(){i.components.slice().forEach(function(t){t.component.teardownAll()}),i.reset()},f}.apply(n,o),!(void 0!==i&&(t.exports=i))},function(t,n,e){var o,i;o=[e(7)],i=function(t){"use strict";function n(n,e){Object.keys(n).forEach(function(i){o.indexOf(i)<0&&t.propertyWritability(n,i,e)})}function e(t,e){t.mixedIn=t.hasOwnProperty("mixedIn")?t.mixedIn:[];for(var o=0;o<e.length;o++)-1==t.mixedIn.indexOf(e[o])&&(n(t,!1),e[o].call(t),t.mixedIn.push(e[o]));n(t,!0)}var o=["mixedIn","attrDef"];return{mixin:e}}.apply(n,o),!(void 0!==i&&(t.exports=i))},function(t,n,e){var o,i;o=[e(6)],i=function(t){"use strict";function n(t,e,o){o=o||{};var i=o.obj||window,r=o.path||(i==window?"window":""),a=Object.keys(i);a.forEach(function(o){(g[t]||t)(e,i,o)&&console.log([r,".",o].join(""),"->",["(",typeof i[o],")"].join(""),i[o]),"[object Object]"==Object.prototype.toString.call(i[o])&&i[o]!=i&&-1==r.split(".").indexOf(o)&&n(t,e,{obj:i[o],path:[r,o].join(".")})})}function e(t,e,o,i){e&&typeof o!=e?console.error([o,"must be",e].join(" ")):n(t,o,i)}function o(t,n){e("name","string",t,n)}function i(t,n){e("nameContains","string",t,n)}function r(t,n){e("type","function",t,n)}function a(t,n){e("value",null,t,n)}function s(t,n){e("valueCoerced",null,t,n)}function c(t,e){n(t,null,e)}function u(){var t=[].slice.call(arguments);v.eventNames.length||(v.eventNames=m),v.actions=t.length?t:m,p()}function f(){var t=[].slice.call(arguments);v.actions.length||(v.actions=m),v.eventNames=t.length?t:m,p()}function l(){v.actions=[],v.eventNames=[],p()}function h(){v.actions=m,v.eventNames=m,p()}function p(){try{window.localStorage&&(localStorage.setItem("logFilter_eventNames",v.eventNames),localStorage.setItem("logFilter_actions",v.actions))}catch(t){}}function d(){var t,n;try{t=window.localStorage&&localStorage.getItem("logFilter_eventNames"),n=window.localStorage&&localStorage.getItem("logFilter_actions")}catch(e){return}t&&(v.eventNames=t),n&&(v.actions=n),Object.keys(v).forEach(function(t){var n=v[t];"string"==typeof n&&n!==m&&(v[t]=n?n.split(","):[])})}var g={name:function(t,n,e){return t==e},nameContains:function(t,n,e){return e.indexOf(t)>-1},type:function(t,n,e){return n[e]instanceof t},value:function(t,n,e){return n[e]===t},valueCoerced:function(t,n,e){return n[e]==t}},m="all",v={eventNames:[],actions:[]};return{enable:function(t){this.enabled=!!t,t&&window.console&&(console.info("Booting in DEBUG mode"),console.info("You can configure event logging with DEBUG.events.logAll()/logNone()/logByName()/logByAction()")),d(),window.DEBUG=this},registry:t,find:{byName:o,byNameContains:i,byType:r,byValue:a,byValueCoerced:s,custom:c},events:{logFilter:v,logByAction:u,logByName:f,logAll:h,logNone:l}}}.apply(n,o),!(void 0!==i&&(t.exports=i))},function(t,n,e){var o,i;o=[e(7)],i=function(t){"use strict";function n(t){var n=t.tagName?t.tagName.toLowerCase():t.toString(),e=t.className?"."+t.className:"",o=n+e;return t.tagName?["'","'"].join(o):o}function e(t,e,o){if(window.DEBUG&&window.DEBUG.enabled){var r,a,s,c,u,f,l,h,p,d;"function"==typeof o[o.length-1]&&(c=o.pop(),c=c.unbound||c),1==o.length?(s=e.$node[0],a=o[0]):2!=o.length||"object"!=typeof o[1]||o[1].type?(s=o[0],a=o[1],"trigger"==t&&(u=o[2])):(s=e.$node[0],a=o[0],"trigger"==t&&(u=o[1])),r="object"==typeof a?a.type:a,f=DEBUG.events.logFilter,h="all"==f.actions||f.actions.indexOf(t)>-1,l=function(t){return t.test?t:new RegExp("^"+t.replace(/\*/g,".*")+"$")},p="all"==f.eventNames||f.eventNames.some(function(t){return l(t).test(r)}),h&&p&&(d=[i[t],t,"["+r+"]"],u&&d.push(u),d.push(n(s)),d.push(e.constructor.describe.split(" ").slice(0,3).join(" ")),console.groupCollapsed&&"trigger"==t&&console.groupCollapsed(t,r),console.info.apply(console,d))}}function o(){this.before("trigger",function(){e("trigger",this,t.toArray(arguments))}),console.groupCollapsed&&this.after("trigger",function(){console.groupEnd()}),this.before("on",function(){e("on",this,t.toArray(arguments))}),this.before("off",function(){e("off",this,t.toArray(arguments))})}var i={on:"<-",trigger:"->",off:"x "};return o}.apply(n,o),!(void 0!==i&&(t.exports=i))},function(t,n){var e,o;e=[],o=function(){"use strict";function t(t,n){var e,o,i,r=n.length;return"function"==typeof n[r-1]&&(r-=1,i=n[r]),"object"==typeof n[r-1]&&(r-=1),2==r?(e=n[0],o=n[1]):(e=t.node,o=n[0]),{element:e,type:o,callback:i}}function n(t,n){return t.element==n.element&&t.type==n.type&&(null==n.callback||t.callback==n.callback)}function e(){function e(t){this.component=t,this.attachedTo=[],this.instances={},this.addInstance=function(t){var n=new o(t);return this.instances[t.identity]=n,this.attachedTo.push(t.node),n},this.removeInstance=function(t){delete this.instances[t.identity];var n=this.attachedTo.indexOf(t.node);n>-1&&this.attachedTo.splice(n,1),Object.keys(this.instances).length||i.removeComponentInfo(this)},this.isAttachedTo=function(t){return this.attachedTo.indexOf(t)>-1}}function o(t){this.instance=t,this.events=[],this.addBind=function(t){this.events.push(t),i.events.push(t)},this.removeBind=function(t){for(var e,o=0;e=this.events[o];o++)n(e,t)&&this.events.splice(o,1)}}var i=this;(this.reset=function(){this.components=[],this.allInstances={},this.events=[]}).call(this),this.addInstance=function(t){var n=this.findComponentInfo(t);n||(n=new e(t.constructor),this.components.push(n));var o=n.addInstance(t);return this.allInstances[t.identity]=o,n},this.removeInstance=function(t){var n=this.findComponentInfo(t);n&&n.removeInstance(t),delete this.allInstances[t.identity]},this.removeComponentInfo=function(t){var n=this.components.indexOf(t);n>-1&&this.components.splice(n,1)},this.findComponentInfo=function(t){for(var n,e=t.attachTo?t:t.constructor,o=0;n=this.components[o];o++)if(n.component===e)return n;return null},this.findInstanceInfo=function(t){return this.allInstances[t.identity]||null},this.getBoundEventNames=function(t){return this.findInstanceInfo(t).events.map(function(t){return t.type})},this.findInstanceInfoByNode=function(t){var n=[];return Object.keys(this.allInstances).forEach(function(e){var o=this.allInstances[e];o.instance.node===t&&n.push(o)},this),n},this.on=function(n){for(var e,o=i.findInstanceInfo(this),r=arguments.length,a=1,s=new Array(r-1);r>a;a++)s[a-1]=arguments[a];if(o){e=n.apply(null,s),e&&(s[s.length-1]=e);var c=t(this,s);o.addBind(c)}},this.off=function(){var e=t(this,arguments),o=i.findInstanceInfo(this);o&&o.removeBind(e);for(var r,a=0;r=i.events[a];a++)n(r,e)&&i.events.splice(a,1)},i.trigger=function(){},this.teardown=function(){i.removeInstance(this)},this.withRegistration=function(){this.after("initialize",function(){i.addInstance(this)}),this.around("on",i.on),this.after("off",i.off),window.DEBUG&&(!1).enabled&&this.after("trigger",i.trigger),this.after("teardown",{obj:i,fnName:"teardown"})}}return new e}.apply(n,e),!(void 0!==o&&(t.exports=o))},function(t,n,e){var o,i;o=[e(4)],i=function(t){"use strict";function n(){var n=t.enabled&&!Object.propertyIsEnumerable("getOwnPropertyDescriptor");if(n)try{Object.getOwnPropertyDescriptor(Object,"keys")}catch(e){return!1}return n}var e=100,o={isDomObj:function(t){return!(!t.nodeType&&t!==window)},toArray:function(t,n){n=n||0;for(var e=t.length,o=new Array(e-n),i=n;e>i;i++)o[i-n]=t[i];return o},merge:function(){var t=arguments.length,n=new Array(t+1);if(0===t)return{};for(var e=0;t>e;e++)n[e+1]=arguments[e];return n[0]={},n[n.length-1]===!0&&(n.pop(),n.unshift(!0)),$.extend.apply(void 0,n)},push:function(t,n,e){return t&&Object.keys(n||{}).forEach(function(o){if(t[o]&&e)throw new Error('utils.push attempted to overwrite "'+o+'" while running in protected mode');"object"==typeof t[o]&&"object"==typeof n[o]?this.push(t[o],n[o]):t[o]=n[o]},this),t},getEnumerableProperty:function(t,n){return t.propertyIsEnumerable(n)?t[n]:void 0},compose:function(){var t=arguments;return function(){for(var n=arguments,e=t.length-1;e>=0;e--)n=[t[e].apply(this,n)];return n[0]}},uniqueArray:function(t){for(var n={},e=[],o=0,i=t.length;i>o;++o)n.hasOwnProperty(t[o])||(e.push(t[o]),n[t[o]]=1);return e},debounce:function(t,n,o){"number"!=typeof n&&(n=e);var i,r;return function(){var e=this,a=arguments,s=function(){i=null,o||(r=t.apply(e,a))},c=o&&!i;return i&&clearTimeout(i),i=setTimeout(s,n),c&&(r=t.apply(e,a)),r}},throttle:function(t,n){"number"!=typeof n&&(n=e);var o,i,r,a,s,c,u=this.debounce(function(){s=a=!1},n);return function(){o=this,i=arguments;var e=function(){r=null,s&&(c=t.apply(o,i)),u()};return r||(r=setTimeout(e,n)),a?s=!0:(a=!0,c=t.apply(o,i)),u(),c}},countThen:function(t,n){return function(){return--t?void 0:n.apply(this,arguments)}},delegate:function(t){return function(n,e){var o,i=$(n.target);Object.keys(t).forEach(function(r){return!n.isPropagationStopped()&&(o=i.closest(r)).length?(e=e||{},e.el=o[0],t[r].apply(this,[n,e])):void 0},this)}},once:function(t){var n,e;return function(){return n?e:(n=!0,e=t.apply(this,arguments))}},propertyWritability:function(t,e,o){n()&&t.hasOwnProperty(e)&&Object.defineProperty(t,e,{writable:o})},mutateProperty:function(t,e,o){var i;return n()&&t.hasOwnProperty(e)?(i=Object.getOwnPropertyDescriptor(t,e).writable,Object.defineProperty(t,e,{writable:!0}),o.call(t),void Object.defineProperty(t,e,{writable:i})):void o.call(t)}};return o}.apply(n,o),!(void 0!==i&&(t.exports=i))},function(t,n,e){var o,i;o=[e(7),e(6),e(4)],i=function(t,n,e){"use strict";function o(t){t.events.slice().forEach(function(t){var n=[t.type];t.element&&n.unshift(t.element),"function"==typeof t.callback&&n.push(t.callback),this.off.apply(this,n)},t.instance)}function i(t,n){try{window.postMessage(n,"*")}catch(e){throw console.log("unserializable data for event",t,":",n),new Error(["The event",t,"on component",this.toString(),"was triggered with non-serializable data"].join(" "))}}function r(t){var n,o=[];if(this.attr=new this.attrDef,e.enabled&&window.console){for(var i in this.attrDef.prototype)o.push(i);n=Object.keys(t);for(var r=n.length-1;r>=0;r--)if(-1==o.indexOf(n[r])){console.warn('Passed unused attributes including "'+n[r]+'" to component "'+this.toString()+'".');break}}for(var i in this.attrDef.prototype){if("undefined"==typeof t[i]){if(null===this.attr[i])throw new Error('Required attribute "'+i+'" not specified in attachTo for component "'+this.toString()+'".')}else this.attr[i]=t[i];"function"==typeof this.attr[i]&&(this.attr[i]=this.attr[i].call(this))}}function a(t){var n=Object.create(t);for(var e in this.defaults)t.hasOwnProperty(e)||(n[e]=this.defaults[e]);this.attr=n,Object.keys(this.defaults||{}).forEach(function(t){if(null===this.defaults[t]&&null===this.attr[t])throw new Error('Required attribute "'+t+'" not specified in attachTo for component "'+this.toString()+'".')},this)}function s(t){return function(n,e){$(n.target).trigger(t,e)}}function c(){this.trigger=function(){var t,n,o,r,a,s=arguments.length-1,c=arguments[s];return"string"==typeof c||c&&c.defaultBehavior||(s--,o=c),1==s?(t=$(arguments[0]),r=arguments[1]):(t=this.$node,r=arguments[0]),r.defaultBehavior&&(a=r.defaultBehavior,r=$.Event(r.type)),n=r.type||r,e.enabled&&window.postMessage&&i.call(this,n,o),"object"==typeof this.attr.eventData&&(o=$.extend(!0,{},this.attr.eventData,o)),t.trigger(r||n,o),a&&!r.isDefaultPrevented()&&(this[a]||a).call(this,r,o),t},this.on=function(){var n,e,o,i,r=arguments.length-1,a=arguments[r];if(i="object"==typeof a?t.delegate(this.resolveDelegateRules(a)):"string"==typeof a?s(a):a,2==r?(n=$(arguments[0]),e=arguments[1]):(n=this.$node,e=arguments[0]),"function"!=typeof i&&"object"!=typeof i)throw new Error('Unable to bind to "'+e+'" because the given callback is not a function or an object');return o=i.bind(this),o.target=i,o.context=this,n.on(e,o),i.bound||(i.bound=[]),i.bound.push(o),o},this.off=function(){var t,e,o,i=arguments.length-1;if("function"==typeof arguments[i]&&(o=arguments[i],i-=1),1==i?(t=$(arguments[0]),e=arguments[1]):(t=this.$node,e=arguments[0]),o){var r=o.target?o.target.bound:o.bound||[];r&&r.some(function(t,n,e){return t.context&&this.identity==t.context.identity?(e.splice(n,1),o=t,!0):void 0},this),t.off(e,o)}else n.findInstanceInfo(this).events.forEach(function(n){e==n.type&&t.off(e,n.callback)});return t},this.resolveDelegateRules=function(t){var n={};return Object.keys(t).forEach(function(e){if(!(e in this.attr))throw new Error('Component "'+this.toString()+'" wants to listen on "'+e+'" but no such attribute was defined.');n[this.attr[e]]="string"==typeof t[e]?s(t[e]):t[e]},this),n},this.select=function(t){return this.$node.find(this.attr[t])},this.attributes=function(t){var n=function(){};this.attrDef&&(n.prototype=new this.attrDef);for(var e in t)n.prototype[e]=t[e];this.attrDef=n},this.defaultAttrs=function(n){t.push(this.defaults,n,!0)||(this.defaults=n)},this.initialize=function(t,n){if(n=n||{},this.identity||(this.identity=u++),!t)throw new Error("Component needs a node");return t.jquery?(this.node=t[0],this.$node=t):(this.node=t,this.$node=$(t)),this.attrDef?r.call(this,n):a.call(this,n),this},this.teardown=function(){o(n.findInstanceInfo(this))}}var u=0;return c}.apply(n,o),!(void 0!==i&&(t.exports=i))}])});
/*!
 * Pusher JavaScript Library v2.2.0
 * http://pusherapp.com/
 *
 * Copyright 2013, Pusher
 * Released under the MIT licence.
 */


(function(){function b(a,d){(null===a||void 0===a)&&b.warn("Warning","You must pass your app key when you instantiate Pusher.");d=d||{};var c=this;this.key=a;this.config=b.Util.extend(b.getGlobalConfig(),d.cluster?b.getClusterConfig(d.cluster):{},d);this.channels=new b.Channels;this.global_emitter=new b.EventsDispatcher;this.sessionID=Math.floor(1E9*Math.random());this.timeline=new b.Timeline(this.key,this.sessionID,{cluster:this.config.cluster,features:b.Util.getClientFeatures(),params:this.config.timelineParams||
{},limit:50,level:b.Timeline.INFO,version:b.VERSION});this.config.disableStats||(this.timelineSender=new b.TimelineSender(this.timeline,{host:this.config.statsHost,path:"/timeline/v2/jsonp"}));this.connection=new b.ConnectionManager(this.key,b.Util.extend({getStrategy:function(a){a=b.Util.extend({},c.config,a);return b.StrategyBuilder.build(b.getDefaultStrategy(a),a)},timeline:this.timeline,activityTimeout:this.config.activity_timeout,pongTimeout:this.config.pong_timeout,unavailableTimeout:this.config.unavailable_timeout},
this.config,{encrypted:this.isEncrypted()}));this.connection.bind("connected",function(){c.subscribeAll();c.timelineSender&&c.timelineSender.send(c.connection.isEncrypted())});this.connection.bind("message",function(a){var d=0===a.event.indexOf("pusher_internal:");if(a.channel){var b=c.channel(a.channel);b&&b.handleEvent(a.event,a.data)}d||c.global_emitter.emit(a.event,a.data)});this.connection.bind("disconnected",function(){c.channels.disconnect()});this.connection.bind("error",function(a){b.warn("Error",
a)});b.instances.push(this);this.timeline.info({instances:b.instances.length});b.isReady&&c.connect()}var c=b.prototype;b.instances=[];b.isReady=!1;b.debug=function(){b.log&&b.log(b.Util.stringify.apply(this,arguments))};b.warn=function(){var a=b.Util.stringify.apply(this,arguments);window.console&&(window.console.warn?window.console.warn(a):window.console.log&&window.console.log(a));b.log&&b.log(a)};b.ready=function(){b.isReady=!0;for(var a=0,d=b.instances.length;a<d;a++)b.instances[a].connect()};
c.channel=function(a){return this.channels.find(a)};c.allChannels=function(){return this.channels.all()};c.connect=function(){this.connection.connect();if(this.timelineSender&&!this.timelineSenderTimer){var a=this.connection.isEncrypted(),d=this.timelineSender;this.timelineSenderTimer=new b.PeriodicTimer(6E4,function(){d.send(a)})}};c.disconnect=function(){this.connection.disconnect();this.timelineSenderTimer&&(this.timelineSenderTimer.ensureAborted(),this.timelineSenderTimer=null)};c.bind=function(a,
d){this.global_emitter.bind(a,d);return this};c.bind_all=function(a){this.global_emitter.bind_all(a);return this};c.subscribeAll=function(){for(var a in this.channels.channels)this.channels.channels.hasOwnProperty(a)&&this.subscribe(a)};c.subscribe=function(a){a=this.channels.add(a,this);"connected"===this.connection.state&&a.subscribe();return a};c.unsubscribe=function(a){a=this.channels.remove(a);"connected"===this.connection.state&&a.unsubscribe()};c.send_event=function(a,d,b){return this.connection.send_event(a,
d,b)};c.isEncrypted=function(){return"https:"===b.Util.getDocument().location.protocol?!0:Boolean(this.config.encrypted)};b.HTTP={};this.Pusher=b}).call(this);
(function(){function b(a){window.clearTimeout(a)}function c(a){window.clearInterval(a)}function a(a,d,b,c){var k=this;this.clear=d;this.timer=a(function(){null!==k.timer&&(k.timer=c(k.timer))},b)}var d=a.prototype;d.isRunning=function(){return null!==this.timer};d.ensureAborted=function(){this.timer&&(this.clear(this.timer),this.timer=null)};Pusher.Timer=function(d,c){return new a(setTimeout,b,d,function(a){c();return null})};Pusher.PeriodicTimer=function(d,b){return new a(setInterval,c,d,function(a){b();
return a})}}).call(this);
(function(){Pusher.Util={now:function(){return Date.now?Date.now():(new Date).valueOf()},defer:function(b){return new Pusher.Timer(0,b)},extend:function(b){for(var c=1;c<arguments.length;c++){var a=arguments[c],d;for(d in a)b[d]=a[d]&&a[d].constructor&&a[d].constructor===Object?Pusher.Util.extend(b[d]||{},a[d]):a[d]}return b},stringify:function(){for(var b=["Pusher"],c=0;c<arguments.length;c++)"string"===typeof arguments[c]?b.push(arguments[c]):void 0===window.JSON?b.push(arguments[c].toString()):b.push(JSON.stringify(arguments[c]));
return b.join(" : ")},arrayIndexOf:function(b,c){var a=Array.prototype.indexOf;if(null===b)return-1;if(a&&b.indexOf===a)return b.indexOf(c);for(var a=0,d=b.length;a<d;a++)if(b[a]===c)return a;return-1},objectApply:function(b,c){for(var a in b)Object.prototype.hasOwnProperty.call(b,a)&&c(b[a],a,b)},keys:function(b){var c=[];Pusher.Util.objectApply(b,function(a,d){c.push(d)});return c},values:function(b){var c=[];Pusher.Util.objectApply(b,function(a){c.push(a)});return c},apply:function(b,c,a){for(var d=
0;d<b.length;d++)c.call(a||window,b[d],d,b)},map:function(b,c){for(var a=[],d=0;d<b.length;d++)a.push(c(b[d],d,b,a));return a},mapObject:function(b,c){var a={};Pusher.Util.objectApply(b,function(d,b){a[b]=c(d)});return a},filter:function(b,c){c=c||function(a){return!!a};for(var a=[],d=0;d<b.length;d++)c(b[d],d,b,a)&&a.push(b[d]);return a},filterObject:function(b,c){var a={};Pusher.Util.objectApply(b,function(d,h){if(c&&c(d,h,b,a)||Boolean(d))a[h]=d});return a},flatten:function(b){var c=[];Pusher.Util.objectApply(b,
function(a,d){c.push([d,a])});return c},any:function(b,c){for(var a=0;a<b.length;a++)if(c(b[a],a,b))return!0;return!1},all:function(b,c){for(var a=0;a<b.length;a++)if(!c(b[a],a,b))return!1;return!0},method:function(b){var c=Array.prototype.slice.call(arguments,1);return function(a){return a[b].apply(a,c.concat(arguments))}},getWindow:function(){return window},getDocument:function(){return document},getNavigator:function(){return navigator},getLocalStorage:function(){try{return window.localStorage}catch(b){}},
getClientFeatures:function(){return Pusher.Util.keys(Pusher.Util.filterObject({ws:Pusher.WSTransport,flash:Pusher.FlashTransport},function(b){return b.isSupported({})}))},addWindowListener:function(b,c){var a=Pusher.Util.getWindow();void 0!==a.addEventListener?a.addEventListener(b,c,!1):a.attachEvent("on"+b,c)},removeWindowListener:function(b,c){var a=Pusher.Util.getWindow();void 0!==a.addEventListener?a.removeEventListener(b,c,!1):a.detachEvent("on"+b,c)},isXHRSupported:function(){var b=window.XMLHttpRequest;
return Boolean(b)&&void 0!==(new b).withCredentials},isXDRSupported:function(b){b=b?"https:":"http:";var c=Pusher.Util.getDocument().location.protocol;return Boolean(window.XDomainRequest)&&c===b}}}).call(this);
(function(){Pusher.VERSION="2.2.0";Pusher.PROTOCOL=7;Pusher.host="ws.pusherapp.com";Pusher.ws_port=80;Pusher.wss_port=443;Pusher.sockjs_host="sockjs.pusher.com";Pusher.sockjs_http_port=80;Pusher.sockjs_https_port=443;Pusher.sockjs_path="/pusher";Pusher.stats_host="stats.pusher.com";Pusher.channel_auth_endpoint="/pusher/auth";Pusher.channel_auth_transport="ajax";Pusher.activity_timeout=12E4;Pusher.pong_timeout=3E4;Pusher.unavailable_timeout=1E4;Pusher.cdn_http="http://js.pusher.com/";Pusher.cdn_https=
"https://d3dy5gmtp8yhk7.cloudfront.net/";Pusher.dependency_suffix=".min";Pusher.getDefaultStrategy=function(b){return[[":def","ws_options",{hostUnencrypted:b.wsHost+":"+b.wsPort,hostEncrypted:b.wsHost+":"+b.wssPort}],[":def","wss_options",[":extend",":ws_options",{encrypted:!0}]],[":def","sockjs_options",{hostUnencrypted:b.httpHost+":"+b.httpPort,hostEncrypted:b.httpHost+":"+b.httpsPort}],[":def","timeouts",{loop:!0,timeout:15E3,timeoutLimit:6E4}],[":def","ws_manager",[":transport_manager",{lives:2,
minPingDelay:1E4,maxPingDelay:b.activity_timeout}]],[":def","streaming_manager",[":transport_manager",{lives:2,minPingDelay:1E4,maxPingDelay:b.activity_timeout}]],[":def_transport","ws","ws",3,":ws_options",":ws_manager"],[":def_transport","wss","ws",3,":wss_options",":ws_manager"],[":def_transport","flash","flash",2,":ws_options",":ws_manager"],[":def_transport","sockjs","sockjs",1,":sockjs_options"],[":def_transport","xhr_streaming","xhr_streaming",1,":sockjs_options",":streaming_manager"],[":def_transport",
"xdr_streaming","xdr_streaming",1,":sockjs_options",":streaming_manager"],[":def_transport","xhr_polling","xhr_polling",1,":sockjs_options"],[":def_transport","xdr_polling","xdr_polling",1,":sockjs_options"],[":def","ws_loop",[":sequential",":timeouts",":ws"]],[":def","wss_loop",[":sequential",":timeouts",":wss"]],[":def","flash_loop",[":sequential",":timeouts",":flash"]],[":def","sockjs_loop",[":sequential",":timeouts",":sockjs"]],[":def","streaming_loop",[":sequential",":timeouts",[":if",[":is_supported",
":xhr_streaming"],":xhr_streaming",":xdr_streaming"]]],[":def","polling_loop",[":sequential",":timeouts",[":if",[":is_supported",":xhr_polling"],":xhr_polling",":xdr_polling"]]],[":def","http_loop",[":if",[":is_supported",":streaming_loop"],[":best_connected_ever",":streaming_loop",[":delayed",4E3,[":polling_loop"]]],[":polling_loop"]]],[":def","http_fallback_loop",[":if",[":is_supported",":http_loop"],[":http_loop"],[":sockjs_loop"]]],[":def","strategy",[":cached",18E5,[":first_connected",[":if",
[":is_supported",":ws"],b.encrypted?[":best_connected_ever",":ws_loop",[":delayed",2E3,[":http_fallback_loop"]]]:[":best_connected_ever",":ws_loop",[":delayed",2E3,[":wss_loop"]],[":delayed",5E3,[":http_fallback_loop"]]],[":if",[":is_supported",":flash"],[":best_connected_ever",":flash_loop",[":delayed",2E3,[":http_fallback_loop"]]],[":http_fallback_loop"]]]]]]]}}).call(this);
(function(){Pusher.getGlobalConfig=function(){return{wsHost:Pusher.host,wsPort:Pusher.ws_port,wssPort:Pusher.wss_port,httpHost:Pusher.sockjs_host,httpPort:Pusher.sockjs_http_port,httpsPort:Pusher.sockjs_https_port,httpPath:Pusher.sockjs_path,statsHost:Pusher.stats_host,authEndpoint:Pusher.channel_auth_endpoint,authTransport:Pusher.channel_auth_transport,activity_timeout:Pusher.activity_timeout,pong_timeout:Pusher.pong_timeout,unavailable_timeout:Pusher.unavailable_timeout}};Pusher.getClusterConfig=
function(b){return{wsHost:"ws-"+b+".pusher.com",httpHost:"sockjs-"+b+".pusher.com"}}}).call(this);(function(){function b(b){var a=function(a){Error.call(this,a);this.name=b};Pusher.Util.extend(a.prototype,Error.prototype);return a}Pusher.Errors={BadEventName:b("BadEventName"),RequestTimedOut:b("RequestTimedOut"),TransportPriorityTooLow:b("TransportPriorityTooLow"),TransportClosed:b("TransportClosed"),UnsupportedTransport:b("UnsupportedTransport"),UnsupportedStrategy:b("UnsupportedStrategy")}}).call(this);
(function(){function b(a){this.callbacks=new c;this.global_callbacks=[];this.failThrough=a}function c(){this._callbacks={}}var a=b.prototype;a.bind=function(a,b,c){this.callbacks.add(a,b,c);return this};a.bind_all=function(a){this.global_callbacks.push(a);return this};a.unbind=function(a,b,c){this.callbacks.remove(a,b,c);return this};a.unbind_all=function(a,b){this.callbacks.remove(a,b);return this};a.emit=function(a,b){var c;for(c=0;c<this.global_callbacks.length;c++)this.global_callbacks[c](a,b);
var e=this.callbacks.get(a);if(e&&0<e.length)for(c=0;c<e.length;c++)e[c].fn.call(e[c].context||window,b);else this.failThrough&&this.failThrough(a,b);return this};c.prototype.get=function(a){return this._callbacks["_"+a]};c.prototype.add=function(a,b,c){a="_"+a;this._callbacks[a]=this._callbacks[a]||[];this._callbacks[a].push({fn:b,context:c})};c.prototype.remove=function(a,b,c){!a&&!b&&!c?this._callbacks={}:(a=a?["_"+a]:Pusher.Util.keys(this._callbacks),b||c?Pusher.Util.apply(a,function(a){this._callbacks[a]=
Pusher.Util.filter(this._callbacks[a]||[],function(a){return b&&b!==a.fn||c&&c!==a.context});0===this._callbacks[a].length&&delete this._callbacks[a]},this):Pusher.Util.apply(a,function(a){delete this._callbacks[a]},this))};Pusher.EventsDispatcher=b}).call(this);
(function(){function b(a,d){this.lastId=0;this.prefix=a;this.name=d}var c=b.prototype;c.create=function(a){this.lastId++;var d=this.lastId,b=this.prefix+d,c=this.name+"["+d+"]",e=!1,g=function(){e||(a.apply(null,arguments),e=!0)};this[d]=g;return{number:d,id:b,name:c,callback:g}};c.remove=function(a){delete this[a.number]};Pusher.ScriptReceiverFactory=b;Pusher.ScriptReceivers=new b("_pusher_script_","Pusher.ScriptReceivers")}).call(this);
(function(){function b(a){this.src=a}var c=b.prototype;c.send=function(a){var d=this,b="Error loading "+d.src;d.script=document.createElement("script");d.script.id=a.id;d.script.src=d.src;d.script.type="text/javascript";d.script.charset="UTF-8";d.script.addEventListener?(d.script.onerror=function(){a.callback(b)},d.script.onload=function(){a.callback(null)}):d.script.onreadystatechange=function(){("loaded"===d.script.readyState||"complete"===d.script.readyState)&&a.callback(null)};void 0===d.script.async&&
document.attachEvent&&/opera/i.test(navigator.userAgent)?(d.errorScript=document.createElement("script"),d.errorScript.id=a.id+"_error",d.errorScript.text=a.name+"('"+b+"');",d.script.async=d.errorScript.async=!1):d.script.async=!0;var c=document.getElementsByTagName("head")[0];c.insertBefore(d.script,c.firstChild);d.errorScript&&c.insertBefore(d.errorScript,d.script.nextSibling)};c.cleanup=function(){this.script&&(this.script.onload=this.script.onerror=null,this.script.onreadystatechange=null);this.script&&
this.script.parentNode&&this.script.parentNode.removeChild(this.script);this.errorScript&&this.errorScript.parentNode&&this.errorScript.parentNode.removeChild(this.errorScript);this.errorScript=this.script=null};Pusher.ScriptRequest=b}).call(this);
(function(){function b(a){this.options=a;this.receivers=a.receivers||Pusher.ScriptReceivers;this.loading={}}var c=b.prototype;c.load=function(a,d){var b=this;if(b.loading[a]&&0<b.loading[a].length)b.loading[a].push(d);else{b.loading[a]=[d];var c=new Pusher.ScriptRequest(b.getPath(a)),e=b.receivers.create(function(d){b.receivers.remove(e);if(b.loading[a]){var k=b.loading[a];delete b.loading[a];for(var l=function(a){a||c.cleanup()},m=0;m<k.length;m++)k[m](d,l)}});c.send(e)}};c.getRoot=function(a){var d=
Pusher.Util.getDocument().location.protocol;return(a&&a.encrypted||"https:"===d?this.options.cdn_https:this.options.cdn_http).replace(/\/*$/,"")+"/"+this.options.version};c.getPath=function(a,d){return this.getRoot(d)+"/"+a+this.options.suffix+".js"};Pusher.DependencyLoader=b}).call(this);
(function(){function b(){Pusher.ready()}function c(a){document.body?a():setTimeout(function(){c(a)},0)}function a(){c(b)}Pusher.DependenciesReceivers=new Pusher.ScriptReceiverFactory("_pusher_dependencies","Pusher.DependenciesReceivers");Pusher.Dependencies=new Pusher.DependencyLoader({cdn_http:Pusher.cdn_http,cdn_https:Pusher.cdn_https,version:Pusher.VERSION,suffix:Pusher.dependency_suffix,receivers:Pusher.DependenciesReceivers});window.JSON?a():Pusher.Dependencies.load("json2",a)})();
(function(){for(var b=String.fromCharCode,c=0;64>c;c++)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(c);var a=function(a){var d=a.charCodeAt(0);return 128>d?a:2048>d?b(192|d>>>6)+b(128|d&63):b(224|d>>>12&15)+b(128|d>>>6&63)+b(128|d&63)},d=function(a){var d=[0,2,1][a.length%3];a=a.charCodeAt(0)<<16|(1<a.length?a.charCodeAt(1):0)<<8|(2<a.length?a.charCodeAt(2):0);return["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(a>>>18),"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(a>>>
12&63),2<=d?"=":"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(a>>>6&63),1<=d?"=":"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(a&63)].join("")},h=window.btoa||function(a){return a.replace(/[\s\S]{1,3}/g,d)};Pusher.Base64={encode:function(d){return h(d.replace(/[^\x00-\x7F]/g,a))}}}).call(this);
(function(){function b(a,b){this.url=a;this.data=b}function c(a){return Pusher.Util.mapObject(a,function(a){"object"===typeof a&&(a=JSON.stringify(a));return encodeURIComponent(Pusher.Base64.encode(a.toString()))})}var a=b.prototype;a.send=function(a){if(!this.request){var b=Pusher.Util.filterObject(this.data,function(a){return void 0!==a}),b=Pusher.Util.map(Pusher.Util.flatten(c(b)),Pusher.Util.method("join","=")).join("&");this.request=new Pusher.ScriptRequest(this.url+"/"+a.number+"?"+b);this.request.send(a)}};
a.cleanup=function(){this.request&&this.request.cleanup()};Pusher.JSONPRequest=b}).call(this);
(function(){function b(a,b,c){this.key=a;this.session=b;this.events=[];this.options=c||{};this.uniqueID=this.sent=0}var c=b.prototype;b.ERROR=3;b.INFO=6;b.DEBUG=7;c.log=function(a,b){a<=this.options.level&&(this.events.push(Pusher.Util.extend({},b,{timestamp:Pusher.Util.now()})),this.options.limit&&this.events.length>this.options.limit&&this.events.shift())};c.error=function(a){this.log(b.ERROR,a)};c.info=function(a){this.log(b.INFO,a)};c.debug=function(a){this.log(b.DEBUG,a)};c.isEmpty=function(){return 0===
this.events.length};c.send=function(a,b){var c=this,f=Pusher.Util.extend({session:c.session,bundle:c.sent+1,key:c.key,lib:"js",version:c.options.version,cluster:c.options.cluster,features:c.options.features,timeline:c.events},c.options.params);c.events=[];a(f,function(a,g){a||c.sent++;b&&b(a,g)});return!0};c.generateUniqueID=function(){this.uniqueID++;return this.uniqueID};Pusher.Timeline=b}).call(this);
(function(){function b(b,a){this.timeline=b;this.options=a||{}}b.prototype.send=function(b,a){var d=this;d.timeline.isEmpty()||d.timeline.send(function(a,f){var e=new Pusher.JSONPRequest("http"+(b?"s":"")+"://"+(d.host||d.options.host)+d.options.path,a),g=Pusher.ScriptReceivers.create(function(a,b){Pusher.ScriptReceivers.remove(g);e.cleanup();b&&b.host&&(d.host=b.host);f&&f(a,b)});e.send(g)},a)};Pusher.TimelineSender=b}).call(this);
(function(){function b(a){this.strategies=a}function c(a,b,c){var h=Pusher.Util.map(a,function(a,d,h,f){return a.connect(b,c(d,f))});return{abort:function(){Pusher.Util.apply(h,d)},forceMinPriority:function(a){Pusher.Util.apply(h,function(b){b.forceMinPriority(a)})}}}function a(a){return Pusher.Util.all(a,function(a){return Boolean(a.error)})}function d(a){!a.error&&!a.aborted&&(a.abort(),a.aborted=!0)}var h=b.prototype;h.isSupported=function(){return Pusher.Util.any(this.strategies,Pusher.Util.method("isSupported"))};
h.connect=function(b,d){return c(this.strategies,b,function(b,c){return function(h,f){(c[b].error=h)?a(c)&&d(!0):(Pusher.Util.apply(c,function(a){a.forceMinPriority(f.transport.priority)}),d(null,f))}})};Pusher.BestConnectedEverStrategy=b}).call(this);
(function(){function b(a,b,d){this.strategy=a;this.transports=b;this.ttl=d.ttl||18E5;this.encrypted=d.encrypted;this.timeline=d.timeline}function c(a){return"pusherTransport"+(a?"Encrypted":"Unencrypted")}function a(a){var b=Pusher.Util.getLocalStorage();if(b)try{var h=b[c(a)];if(h)return JSON.parse(h)}catch(k){d(a)}return null}function d(a){var b=Pusher.Util.getLocalStorage();if(b)try{delete b[c(a)]}catch(d){}}var h=b.prototype;h.isSupported=function(){return this.strategy.isSupported()};h.connect=
function(b,h){var g=this.encrypted,k=a(g),l=[this.strategy];if(k&&k.timestamp+this.ttl>=Pusher.Util.now()){var m=this.transports[k.transport];m&&(this.timeline.info({cached:!0,transport:k.transport,latency:k.latency}),l.push(new Pusher.SequentialStrategy([m],{timeout:2*k.latency+1E3,failFast:!0})))}var p=Pusher.Util.now(),n=l.pop().connect(b,function s(a,k){if(a)d(g),0<l.length?(p=Pusher.Util.now(),n=l.pop().connect(b,s)):h(a);else{var m=k.transport.name,t=Pusher.Util.now()-p,r=Pusher.Util.getLocalStorage();
if(r)try{r[c(g)]=JSON.stringify({timestamp:Pusher.Util.now(),transport:m,latency:t})}catch(u){}h(null,k)}});return{abort:function(){n.abort()},forceMinPriority:function(a){b=a;n&&n.forceMinPriority(a)}}};Pusher.CachedStrategy=b}).call(this);
(function(){function b(a,b){this.strategy=a;this.options={delay:b.delay}}var c=b.prototype;c.isSupported=function(){return this.strategy.isSupported()};c.connect=function(a,b){var c=this.strategy,f,e=new Pusher.Timer(this.options.delay,function(){f=c.connect(a,b)});return{abort:function(){e.ensureAborted();f&&f.abort()},forceMinPriority:function(b){a=b;f&&f.forceMinPriority(b)}}};Pusher.DelayedStrategy=b}).call(this);
(function(){function b(a){this.strategy=a}var c=b.prototype;c.isSupported=function(){return this.strategy.isSupported()};c.connect=function(a,b){var c=this.strategy.connect(a,function(a,e){e&&c.abort();b(a,e)});return c};Pusher.FirstConnectedStrategy=b}).call(this);
(function(){function b(a,b,c){this.test=a;this.trueBranch=b;this.falseBranch=c}var c=b.prototype;c.isSupported=function(){return(this.test()?this.trueBranch:this.falseBranch).isSupported()};c.connect=function(a,b){return(this.test()?this.trueBranch:this.falseBranch).connect(a,b)};Pusher.IfStrategy=b}).call(this);
(function(){function b(a,b){this.strategies=a;this.loop=Boolean(b.loop);this.failFast=Boolean(b.failFast);this.timeout=b.timeout;this.timeoutLimit=b.timeoutLimit}var c=b.prototype;c.isSupported=function(){return Pusher.Util.any(this.strategies,Pusher.Util.method("isSupported"))};c.connect=function(a,b){var c=this,f=this.strategies,e=0,g=this.timeout,k=null,l=function(m,p){p?b(null,p):(e+=1,c.loop&&(e%=f.length),e<f.length?(g&&(g*=2,c.timeoutLimit&&(g=Math.min(g,c.timeoutLimit))),k=c.tryStrategy(f[e],
a,{timeout:g,failFast:c.failFast},l)):b(!0))},k=this.tryStrategy(f[e],a,{timeout:g,failFast:this.failFast},l);return{abort:function(){k.abort()},forceMinPriority:function(b){a=b;k&&k.forceMinPriority(b)}}};c.tryStrategy=function(a,b,c,f){var e=null,g=null;0<c.timeout&&(e=new Pusher.Timer(c.timeout,function(){g.abort();f(!0)}));g=a.connect(b,function(a,b){if(!a||!e||!e.isRunning()||c.failFast)e&&e.ensureAborted(),f(a,b)});return{abort:function(){e&&e.ensureAborted();g.abort()},forceMinPriority:function(a){g.forceMinPriority(a)}}};
Pusher.SequentialStrategy=b}).call(this);
(function(){function b(a,b,c,e){this.name=a;this.priority=b;this.transport=c;this.options=e||{}}function c(a,b){Pusher.Util.defer(function(){b(a)});return{abort:function(){},forceMinPriority:function(){}}}var a=b.prototype;a.isSupported=function(){return this.transport.isSupported({encrypted:this.options.encrypted})};a.connect=function(a,b){if(this.isSupported()){if(this.priority<a)return c(new Pusher.Errors.TransportPriorityTooLow,b)}else return c(new Pusher.Errors.UnsupportedStrategy,b);var f=this,
e=!1,g=this.transport.createConnection(this.name,this.priority,this.options.key,this.options),k=null,l=function(){g.unbind("initialized",l);g.connect()},m=function(){k=new Pusher.Handshake(g,function(a){e=!0;q();b(null,a)})},p=function(a){q();b(a)},n=function(){q();b(new Pusher.Errors.TransportClosed(g))},q=function(){g.unbind("initialized",l);g.unbind("open",m);g.unbind("error",p);g.unbind("closed",n)};g.bind("initialized",l);g.bind("open",m);g.bind("error",p);g.bind("closed",n);g.initialize();return{abort:function(){e||
(q(),k?k.close():g.close())},forceMinPriority:function(a){e||f.priority<a&&(k?k.close():g.close())}}};Pusher.TransportStrategy=b}).call(this);
(function(){function b(a,b,c){return a+(b.encrypted?"s":"")+"://"+(b.encrypted?b.hostEncrypted:b.hostUnencrypted)+c}function c(a,b){return"/app/"+a+("?protocol="+Pusher.PROTOCOL+"&client=js&version="+Pusher.VERSION+(b?"&"+b:""))}Pusher.URLSchemes={ws:{getInitial:function(a,d){return b("ws",d,c(a,"flash=false"))}},flash:{getInitial:function(a,d){return b("ws",d,c(a,"flash=true"))}},sockjs:{getInitial:function(a,c){return b("http",c,c.httpPath||"/pusher","")},getPath:function(a,b){return c(a)}},http:{getInitial:function(a,
d){var h=(d.httpPath||"/pusher")+c(a);return b("http",d,h)}}}}).call(this);
(function(){function b(a,b,c,f,e){Pusher.EventsDispatcher.call(this);this.hooks=a;this.name=b;this.priority=c;this.key=f;this.options=e;this.state="new";this.timeline=e.timeline;this.activityTimeout=e.activityTimeout;this.id=this.timeline.generateUniqueID()}var c=b.prototype;Pusher.Util.extend(c,Pusher.EventsDispatcher.prototype);c.handlesActivityChecks=function(){return Boolean(this.hooks.handlesActivityChecks)};c.supportsPing=function(){return Boolean(this.hooks.supportsPing)};c.initialize=function(){var a=
this;a.timeline.info(a.buildTimelineMessage({transport:a.name+(a.options.encrypted?"s":"")}));a.hooks.beforeInitialize&&a.hooks.beforeInitialize();if(a.hooks.isInitialized())a.changeState("initialized");else if(a.hooks.file)a.changeState("initializing"),Pusher.Dependencies.load(a.hooks.file,function(b,c){if(a.hooks.isInitialized())a.changeState("initialized"),c(!0);else{if(b)a.onError(b);a.onClose();c(!1)}});else a.onClose()};c.connect=function(){var a=this;if(a.socket||"initialized"!==a.state)return!1;
var b=a.hooks.urls.getInitial(a.key,a.options);try{a.socket=a.hooks.getSocket(b,a.options)}catch(c){return Pusher.Util.defer(function(){a.onError(c);a.changeState("closed")}),!1}a.bindListeners();Pusher.debug("Connecting",{transport:a.name,url:b});a.changeState("connecting");return!0};c.close=function(){return this.socket?(this.socket.close(),!0):!1};c.send=function(a){var b=this;return"open"===b.state?(Pusher.Util.defer(function(){b.socket&&b.socket.send(a)}),!0):!1};c.ping=function(){"open"===this.state&&
this.supportsPing()&&this.socket.ping()};c.onOpen=function(){this.hooks.beforeOpen&&this.hooks.beforeOpen(this.socket,this.hooks.urls.getPath(this.key,this.options));this.changeState("open");this.socket.onopen=void 0};c.onError=function(a){this.emit("error",{type:"WebSocketError",error:a});this.timeline.error(this.buildTimelineMessage({error:a.toString()}))};c.onClose=function(a){a?this.changeState("closed",{code:a.code,reason:a.reason,wasClean:a.wasClean}):this.changeState("closed");this.unbindListeners();
this.socket=void 0};c.onMessage=function(a){this.emit("message",a)};c.onActivity=function(){this.emit("activity")};c.bindListeners=function(){var a=this;a.socket.onopen=function(){a.onOpen()};a.socket.onerror=function(b){a.onError(b)};a.socket.onclose=function(b){a.onClose(b)};a.socket.onmessage=function(b){a.onMessage(b)};a.supportsPing()&&(a.socket.onactivity=function(){a.onActivity()})};c.unbindListeners=function(){this.socket&&(this.socket.onopen=void 0,this.socket.onerror=void 0,this.socket.onclose=
void 0,this.socket.onmessage=void 0,this.supportsPing()&&(this.socket.onactivity=void 0))};c.changeState=function(a,b){this.state=a;this.timeline.info(this.buildTimelineMessage({state:a,params:b}));this.emit(a,b)};c.buildTimelineMessage=function(a){return Pusher.Util.extend({cid:this.id},a)};Pusher.TransportConnection=b}).call(this);
(function(){function b(a){this.hooks=a}var c=b.prototype;c.isSupported=function(a){return this.hooks.isSupported(a)};c.createConnection=function(a,b,c,f){return new Pusher.TransportConnection(this.hooks,a,b,c,f)};Pusher.Transport=b}).call(this);
(function(){Pusher.WSTransport=new Pusher.Transport({urls:Pusher.URLSchemes.ws,handlesActivityChecks:!1,supportsPing:!1,isInitialized:function(){return Boolean(window.WebSocket||window.MozWebSocket)},isSupported:function(){return Boolean(window.WebSocket||window.MozWebSocket)},getSocket:function(a){return new (window.WebSocket||window.MozWebSocket)(a)}});Pusher.FlashTransport=new Pusher.Transport({file:"flashfallback",urls:Pusher.URLSchemes.flash,handlesActivityChecks:!1,supportsPing:!1,isSupported:function(){try{return Boolean(new ActiveXObject("ShockwaveFlash.ShockwaveFlash"))}catch(a){try{var b=
Pusher.Util.getNavigator();return Boolean(b&&b.mimeTypes&&void 0!==b.mimeTypes["application/x-shockwave-flash"])}catch(c){return!1}}},beforeInitialize:function(){void 0===window.WEB_SOCKET_SUPPRESS_CROSS_DOMAIN_SWF_ERROR&&(window.WEB_SOCKET_SUPPRESS_CROSS_DOMAIN_SWF_ERROR=!0);window.WEB_SOCKET_SWF_LOCATION=Pusher.Dependencies.getRoot()+"/WebSocketMain.swf"},isInitialized:function(){return void 0!==window.FlashWebSocket},getSocket:function(a){return new FlashWebSocket(a)}});Pusher.SockJSTransport=
new Pusher.Transport({file:"sockjs",urls:Pusher.URLSchemes.sockjs,handlesActivityChecks:!0,supportsPing:!1,isSupported:function(){return!0},isInitialized:function(){return void 0!==window.SockJS},getSocket:function(a,b){return new SockJS(a,null,{js_path:Pusher.Dependencies.getPath("sockjs",{encrypted:b.encrypted}),ignore_null_origin:b.ignoreNullOrigin})},beforeOpen:function(a,b){a.send(JSON.stringify({path:b}))}});var b={urls:Pusher.URLSchemes.http,handlesActivityChecks:!1,supportsPing:!0,isInitialized:function(){return Boolean(Pusher.HTTP.Socket)}},
c=Pusher.Util.extend({getSocket:function(a){return Pusher.HTTP.getStreamingSocket(a)}},b),b=Pusher.Util.extend({getSocket:function(a){return Pusher.HTTP.getPollingSocket(a)}},b),a={file:"xhr",isSupported:Pusher.Util.isXHRSupported},d={file:"xdr",isSupported:function(a){return Pusher.Util.isXDRSupported(a.encrypted)}};Pusher.XHRStreamingTransport=new Pusher.Transport(Pusher.Util.extend({},c,a));Pusher.XDRStreamingTransport=new Pusher.Transport(Pusher.Util.extend({},c,d));Pusher.XHRPollingTransport=
new Pusher.Transport(Pusher.Util.extend({},b,a));Pusher.XDRPollingTransport=new Pusher.Transport(Pusher.Util.extend({},b,d))}).call(this);
(function(){function b(a,b,c){this.manager=a;this.transport=b;this.minPingDelay=c.minPingDelay;this.maxPingDelay=c.maxPingDelay;this.pingDelay=void 0}var c=b.prototype;c.createConnection=function(a,b,c,f){var e=this;f=Pusher.Util.extend({},f,{activityTimeout:e.pingDelay});var g=e.transport.createConnection(a,b,c,f),k=null,l=function(){g.unbind("open",l);g.bind("closed",m);k=Pusher.Util.now()},m=function(a){g.unbind("closed",m);1002===a.code||1003===a.code?e.manager.reportDeath():!a.wasClean&&k&&(a=
Pusher.Util.now()-k,a<2*e.maxPingDelay&&(e.manager.reportDeath(),e.pingDelay=Math.max(a/2,e.minPingDelay)))};g.bind("open",l);return g};c.isSupported=function(a){return this.manager.isAlive()&&this.transport.isSupported(a)};Pusher.AssistantToTheTransportManager=b}).call(this);
(function(){function b(a){this.options=a||{};this.livesLeft=this.options.lives||Infinity}var c=b.prototype;c.getAssistant=function(a){return new Pusher.AssistantToTheTransportManager(this,a,{minPingDelay:this.options.minPingDelay,maxPingDelay:this.options.maxPingDelay})};c.isAlive=function(){return 0<this.livesLeft};c.reportDeath=function(){this.livesLeft-=1};Pusher.TransportManager=b}).call(this);
(function(){function b(a){return function(b){return[a.apply(this,arguments),b]}}function c(a,b){if(0===a.length)return[[],b];var h=d(a[0],b),f=c(a.slice(1),h[1]);return[[h[0]].concat(f[0]),f[1]]}function a(a,b){if("string"===typeof a[0]&&":"===a[0].charAt(0)){var h=b[a[0].slice(1)];if(1<a.length){if("function"!==typeof h)throw"Calling non-function "+a[0];var f=[Pusher.Util.extend({},b)].concat(Pusher.Util.map(a.slice(1),function(a){return d(a,Pusher.Util.extend({},b))[0]}));return h.apply(this,f)}return[h,
b]}return c(a,b)}function d(b,c){if("string"===typeof b){var d;if("string"===typeof b&&":"===b.charAt(0)){d=c[b.slice(1)];if(void 0===d)throw"Undefined symbol "+b;d=[d,c]}else d=[b,c];return d}return"object"===typeof b&&b instanceof Array&&0<b.length?a(b,c):[b,c]}var h={ws:Pusher.WSTransport,flash:Pusher.FlashTransport,sockjs:Pusher.SockJSTransport,xhr_streaming:Pusher.XHRStreamingTransport,xdr_streaming:Pusher.XDRStreamingTransport,xhr_polling:Pusher.XHRPollingTransport,xdr_polling:Pusher.XDRPollingTransport},
f={isSupported:function(){return!1},connect:function(a,b){var c=Pusher.Util.defer(function(){b(new Pusher.Errors.UnsupportedStrategy)});return{abort:function(){c.ensureAborted()},forceMinPriority:function(){}}}},e={extend:function(a,b,c){return[Pusher.Util.extend({},b,c),a]},def:function(a,b,c){if(void 0!==a[b])throw"Redefining symbol "+b;a[b]=c;return[void 0,a]},def_transport:function(a,b,c,d,e,n){var q=h[c];if(!q)throw new Pusher.Errors.UnsupportedTransport(c);c=(!a.enabledTransports||-1!==Pusher.Util.arrayIndexOf(a.enabledTransports,
b))&&(!a.disabledTransports||-1===Pusher.Util.arrayIndexOf(a.disabledTransports,b))&&("flash"!==b||!0!==a.disableFlash)?new Pusher.TransportStrategy(b,d,n?n.getAssistant(q):q,Pusher.Util.extend({key:a.key,encrypted:a.encrypted,timeline:a.timeline,ignoreNullOrigin:a.ignoreNullOrigin},e)):f;d=a.def(a,b,c)[1];d.transports=a.transports||{};d.transports[b]=c;return[void 0,d]},transport_manager:b(function(a,b){return new Pusher.TransportManager(b)}),sequential:b(function(a,b){var c=Array.prototype.slice.call(arguments,
2);return new Pusher.SequentialStrategy(c,b)}),cached:b(function(a,b,c){return new Pusher.CachedStrategy(c,a.transports,{ttl:b,timeline:a.timeline,encrypted:a.encrypted})}),first_connected:b(function(a,b){return new Pusher.FirstConnectedStrategy(b)}),best_connected_ever:b(function(){var a=Array.prototype.slice.call(arguments,1);return new Pusher.BestConnectedEverStrategy(a)}),delayed:b(function(a,b,c){return new Pusher.DelayedStrategy(c,{delay:b})}),"if":b(function(a,b,c,d){return new Pusher.IfStrategy(b,
c,d)}),is_supported:b(function(a,b){return function(){return b.isSupported()}})};Pusher.StrategyBuilder={build:function(a,b){var c=Pusher.Util.extend({},e,b);return d(a,c)[1].strategy}}}).call(this);
(function(){Pusher.Protocol={decodeMessage:function(b){try{var c=JSON.parse(b.data);if("string"===typeof c.data)try{c.data=JSON.parse(c.data)}catch(a){if(!(a instanceof SyntaxError))throw a;}return c}catch(d){throw{type:"MessageParseError",error:d,data:b.data};}},encodeMessage:function(b){return JSON.stringify(b)},processHandshake:function(b){b=this.decodeMessage(b);if("pusher:connection_established"===b.event){if(!b.data.activity_timeout)throw"No activity timeout specified in handshake";return{action:"connected",
id:b.data.socket_id,activityTimeout:1E3*b.data.activity_timeout}}if("pusher:error"===b.event)return{action:this.getCloseAction(b.data),error:this.getCloseError(b.data)};throw"Invalid handshake";},getCloseAction:function(b){return 4E3>b.code?1002<=b.code&&1004>=b.code?"backoff":null:4E3===b.code?"ssl_only":4100>b.code?"refused":4200>b.code?"backoff":4300>b.code?"retry":"refused"},getCloseError:function(b){return 1E3!==b.code&&1001!==b.code?{type:"PusherError",data:{code:b.code,message:b.reason||b.message}}:
null}}}).call(this);
(function(){function b(a,b){Pusher.EventsDispatcher.call(this);this.id=a;this.transport=b;this.activityTimeout=b.activityTimeout;this.bindListeners()}var c=b.prototype;Pusher.Util.extend(c,Pusher.EventsDispatcher.prototype);c.handlesActivityChecks=function(){return this.transport.handlesActivityChecks()};c.send=function(a){return this.transport.send(a)};c.send_event=function(a,b,c){a={event:a,data:b};c&&(a.channel=c);Pusher.debug("Event sent",a);return this.send(Pusher.Protocol.encodeMessage(a))};c.ping=
function(){this.transport.supportsPing()?this.transport.ping():this.send_event("pusher:ping",{})};c.close=function(){this.transport.close()};c.bindListeners=function(){var a=this,b={message:function(b){var c;try{c=Pusher.Protocol.decodeMessage(b)}catch(d){a.emit("error",{type:"MessageParseError",error:d,data:b.data})}if(void 0!==c){Pusher.debug("Event recd",c);switch(c.event){case "pusher:error":a.emit("error",{type:"PusherError",data:c.data});break;case "pusher:ping":a.emit("ping");break;case "pusher:pong":a.emit("pong")}a.emit("message",
c)}},activity:function(){a.emit("activity")},error:function(b){a.emit("error",{type:"WebSocketError",error:b})},closed:function(b){c();b&&b.code&&a.handleCloseEvent(b);a.transport=null;a.emit("closed")}},c=function(){Pusher.Util.objectApply(b,function(b,c){a.transport.unbind(c,b)})};Pusher.Util.objectApply(b,function(b,c){a.transport.bind(c,b)})};c.handleCloseEvent=function(a){var b=Pusher.Protocol.getCloseAction(a);(a=Pusher.Protocol.getCloseError(a))&&this.emit("error",a);b&&this.emit(b)};Pusher.Connection=
b}).call(this);
(function(){function b(a,b){this.transport=a;this.callback=b;this.bindListeners()}var c=b.prototype;c.close=function(){this.unbindListeners();this.transport.close()};c.bindListeners=function(){var a=this;a.onMessage=function(b){a.unbindListeners();try{var c=Pusher.Protocol.processHandshake(b);"connected"===c.action?a.finish("connected",{connection:new Pusher.Connection(c.id,a.transport),activityTimeout:c.activityTimeout}):(a.finish(c.action,{error:c.error}),a.transport.close())}catch(f){a.finish("error",{error:f}),
a.transport.close()}};a.onClosed=function(b){a.unbindListeners();var c=Pusher.Protocol.getCloseAction(b)||"backoff";b=Pusher.Protocol.getCloseError(b);a.finish(c,{error:b})};a.transport.bind("message",a.onMessage);a.transport.bind("closed",a.onClosed)};c.unbindListeners=function(){this.transport.unbind("message",this.onMessage);this.transport.unbind("closed",this.onClosed)};c.finish=function(a,b){this.callback(Pusher.Util.extend({transport:this.transport,action:a},b))};Pusher.Handshake=b}).call(this);
(function(){function b(a,b){Pusher.EventsDispatcher.call(this);this.key=a;this.options=b||{};this.state="initialized";this.connection=null;this.encrypted=!!b.encrypted;this.timeline=this.options.timeline;this.connectionCallbacks=this.buildConnectionCallbacks();this.errorCallbacks=this.buildErrorCallbacks();this.handshakeCallbacks=this.buildHandshakeCallbacks(this.errorCallbacks);var c=this;Pusher.Network.bind("online",function(){c.timeline.info({netinfo:"online"});("connecting"===c.state||"unavailable"===
c.state)&&c.retryIn(0)});Pusher.Network.bind("offline",function(){c.timeline.info({netinfo:"offline"});"connected"===c.state&&c.sendActivityCheck()});this.updateStrategy()}var c=b.prototype;Pusher.Util.extend(c,Pusher.EventsDispatcher.prototype);c.connect=function(){!this.connection&&!this.runner&&(this.strategy.isSupported()?(this.updateState("connecting"),this.startConnecting(),this.setUnavailableTimer()):this.updateState("failed"))};c.send=function(a){return this.connection?this.connection.send(a):
!1};c.send_event=function(a,b,c){return this.connection?this.connection.send_event(a,b,c):!1};c.disconnect=function(){this.disconnectInternally();this.updateState("disconnected")};c.isEncrypted=function(){return this.encrypted};c.startConnecting=function(){var a=this,b=function(c,f){c?a.runner=a.strategy.connect(0,b):"error"===f.action?(a.emit("error",{type:"HandshakeError",error:f.error}),a.timeline.error({handshakeError:f.error})):(a.abortConnecting(),a.handshakeCallbacks[f.action](f))};a.runner=
a.strategy.connect(0,b)};c.abortConnecting=function(){this.runner&&(this.runner.abort(),this.runner=null)};c.disconnectInternally=function(){this.abortConnecting();this.clearRetryTimer();this.clearUnavailableTimer();this.stopActivityCheck();this.connection&&this.abandonConnection().close()};c.updateStrategy=function(){this.strategy=this.options.getStrategy({key:this.key,timeline:this.timeline,encrypted:this.encrypted})};c.retryIn=function(a){var b=this;b.timeline.info({action:"retry",delay:a});0<
a&&b.emit("connecting_in",Math.round(a/1E3));b.retryTimer=new Pusher.Timer(a||0,function(){b.disconnectInternally();b.connect()})};c.clearRetryTimer=function(){this.retryTimer&&(this.retryTimer.ensureAborted(),this.retryTimer=null)};c.setUnavailableTimer=function(){var a=this;a.unavailableTimer=new Pusher.Timer(a.options.unavailableTimeout,function(){a.updateState("unavailable")})};c.clearUnavailableTimer=function(){this.unavailableTimer&&this.unavailableTimer.ensureAborted()};c.sendActivityCheck=
function(){var a=this;a.stopActivityCheck();a.connection.ping();a.activityTimer=new Pusher.Timer(a.options.pongTimeout,function(){a.timeline.error({pong_timed_out:a.options.pongTimeout});a.retryIn(0)})};c.resetActivityCheck=function(){var a=this;a.stopActivityCheck();a.connection.handlesActivityChecks()||(a.activityTimer=new Pusher.Timer(a.activityTimeout,function(){a.sendActivityCheck()}))};c.stopActivityCheck=function(){this.activityTimer&&this.activityTimer.ensureAborted()};c.buildConnectionCallbacks=
function(){var a=this;return{message:function(b){a.resetActivityCheck();a.emit("message",b)},ping:function(){a.send_event("pusher:pong",{})},activity:function(){a.resetActivityCheck()},error:function(b){a.emit("error",{type:"WebSocketError",error:b})},closed:function(){a.abandonConnection();a.shouldRetry()&&a.retryIn(1E3)}}};c.buildHandshakeCallbacks=function(a){var b=this;return Pusher.Util.extend({},a,{connected:function(a){b.activityTimeout=Math.min(b.options.activityTimeout,a.activityTimeout,
a.connection.activityTimeout||Infinity);b.clearUnavailableTimer();b.setConnection(a.connection);b.socket_id=b.connection.id;b.updateState("connected",{socket_id:b.socket_id})}})};c.buildErrorCallbacks=function(){function a(a){return function(c){c.error&&b.emit("error",{type:"WebSocketError",error:c.error});a(c)}}var b=this;return{ssl_only:a(function(){b.encrypted=!0;b.updateStrategy();b.retryIn(0)}),refused:a(function(){b.disconnect()}),backoff:a(function(){b.retryIn(1E3)}),retry:a(function(){b.retryIn(0)})}};
c.setConnection=function(a){this.connection=a;for(var b in this.connectionCallbacks)this.connection.bind(b,this.connectionCallbacks[b]);this.resetActivityCheck()};c.abandonConnection=function(){if(this.connection){for(var a in this.connectionCallbacks)this.connection.unbind(a,this.connectionCallbacks[a]);a=this.connection;this.connection=null;return a}};c.updateState=function(a,b){var c=this.state;this.state=a;c!==a&&(Pusher.debug("State changed",c+" -> "+a),this.timeline.info({state:a,params:b}),
this.emit("state_change",{previous:c,current:a}),this.emit(a,b))};c.shouldRetry=function(){return"connecting"===this.state||"connected"===this.state};Pusher.ConnectionManager=b}).call(this);
(function(){function b(){Pusher.EventsDispatcher.call(this);var b=this;void 0!==window.addEventListener&&(window.addEventListener("online",function(){b.emit("online")},!1),window.addEventListener("offline",function(){b.emit("offline")},!1))}Pusher.Util.extend(b.prototype,Pusher.EventsDispatcher.prototype);b.prototype.isOnline=function(){return void 0===window.navigator.onLine?!0:window.navigator.onLine};Pusher.NetInfo=b;Pusher.Network=new b}).call(this);
(function(){function b(){this.reset()}var c=b.prototype;c.get=function(a){return Object.prototype.hasOwnProperty.call(this.members,a)?{id:a,info:this.members[a]}:null};c.each=function(a){var b=this;Pusher.Util.objectApply(b.members,function(c,f){a(b.get(f))})};c.setMyID=function(a){this.myID=a};c.onSubscription=function(a){this.members=a.presence.hash;this.count=a.presence.count;this.me=this.get(this.myID)};c.addMember=function(a){null===this.get(a.user_id)&&this.count++;this.members[a.user_id]=a.user_info;
return this.get(a.user_id)};c.removeMember=function(a){var b=this.get(a.user_id);b&&(delete this.members[a.user_id],this.count--);return b};c.reset=function(){this.members={};this.count=0;this.me=this.myID=null};Pusher.Members=b}).call(this);
(function(){function b(a,b){Pusher.EventsDispatcher.call(this,function(b,c){Pusher.debug("No callbacks on "+a+" for "+b)});this.name=a;this.pusher=b;this.subscribed=!1}var c=b.prototype;Pusher.Util.extend(c,Pusher.EventsDispatcher.prototype);c.authorize=function(a,b){return b(!1,{})};c.trigger=function(a,b){if(0!==a.indexOf("client-"))throw new Pusher.Errors.BadEventName("Event '"+a+"' does not start with 'client-'");return this.pusher.send_event(a,b,this.name)};c.disconnect=function(){this.subscribed=
!1};c.handleEvent=function(a,b){0===a.indexOf("pusher_internal:")?"pusher_internal:subscription_succeeded"===a&&(this.subscribed=!0,this.emit("pusher:subscription_succeeded",b)):this.emit(a,b)};c.subscribe=function(){var a=this;a.authorize(a.pusher.connection.socket_id,function(b,c){b?a.handleEvent("pusher:subscription_error",c):a.pusher.send_event("pusher:subscribe",{auth:c.auth,channel_data:c.channel_data,channel:a.name})})};c.unsubscribe=function(){this.pusher.send_event("pusher:unsubscribe",{channel:this.name})};
Pusher.Channel=b}).call(this);(function(){function b(a,b){Pusher.Channel.call(this,a,b)}var c=b.prototype;Pusher.Util.extend(c,Pusher.Channel.prototype);c.authorize=function(a,b){return(new Pusher.Channel.Authorizer(this,this.pusher.config)).authorize(a,b)};Pusher.PrivateChannel=b}).call(this);
(function(){function b(a,b){Pusher.PrivateChannel.call(this,a,b);this.members=new Pusher.Members}var c=b.prototype;Pusher.Util.extend(c,Pusher.PrivateChannel.prototype);c.authorize=function(a,b){var c=this;Pusher.PrivateChannel.prototype.authorize.call(c,a,function(a,e){if(!a){if(void 0===e.channel_data){Pusher.warn("Invalid auth response for channel '"+c.name+"', expected 'channel_data' field");b("Invalid auth response");return}var g=JSON.parse(e.channel_data);c.members.setMyID(g.user_id)}b(a,e)})};
c.handleEvent=function(a,b){switch(a){case "pusher_internal:subscription_succeeded":this.members.onSubscription(b);this.subscribed=!0;this.emit("pusher:subscription_succeeded",this.members);break;case "pusher_internal:member_added":var c=this.members.addMember(b);this.emit("pusher:member_added",c);break;case "pusher_internal:member_removed":(c=this.members.removeMember(b))&&this.emit("pusher:member_removed",c);break;default:Pusher.PrivateChannel.prototype.handleEvent.call(this,a,b)}};c.disconnect=
function(){this.members.reset();Pusher.PrivateChannel.prototype.disconnect.call(this)};Pusher.PresenceChannel=b}).call(this);
(function(){function b(){this.channels={}}var c=b.prototype;c.add=function(a,b){if(!this.channels[a]){var c=this.channels,f;f=0===a.indexOf("private-")?new Pusher.PrivateChannel(a,b):0===a.indexOf("presence-")?new Pusher.PresenceChannel(a,b):new Pusher.Channel(a,b);c[a]=f}return this.channels[a]};c.all=function(a){return Pusher.Util.values(this.channels)};c.find=function(a){return this.channels[a]};c.remove=function(a){var b=this.channels[a];delete this.channels[a];return b};c.disconnect=function(){Pusher.Util.objectApply(this.channels,
function(a){a.disconnect()})};Pusher.Channels=b}).call(this);
(function(){Pusher.Channel.Authorizer=function(b,a){this.channel=b;this.type=a.authTransport;this.options=a;this.authOptions=(a||{}).auth||{}};Pusher.Channel.Authorizer.prototype={composeQuery:function(b){b="&socket_id="+encodeURIComponent(b)+"&channel_name="+encodeURIComponent(this.channel.name);for(var a in this.authOptions.params)b+="&"+encodeURIComponent(a)+"="+encodeURIComponent(this.authOptions.params[a]);return b},authorize:function(b,a){return Pusher.authorizers[this.type].call(this,b,a)}};
var b=1;Pusher.auth_callbacks={};Pusher.authorizers={ajax:function(b,a){var d;d=Pusher.XHR?new Pusher.XHR:window.XMLHttpRequest?new window.XMLHttpRequest:new ActiveXObject("Microsoft.XMLHTTP");d.open("POST",this.options.authEndpoint,!0);d.setRequestHeader("Content-Type","application/x-www-form-urlencoded");for(var h in this.authOptions.headers)d.setRequestHeader(h,this.authOptions.headers[h]);d.onreadystatechange=function(){if(4===d.readyState)if(200===d.status){var b,c=!1;try{b=JSON.parse(d.responseText),
c=!0}catch(g){a(!0,"JSON returned from webapp was invalid, yet status code was 200. Data was: "+d.responseText)}c&&a(!1,b)}else Pusher.warn("Couldn't get auth info from your webapp",d.status),a(!0,d.status)};d.send(this.composeQuery(b));return d},jsonp:function(c,a){void 0!==this.authOptions.headers&&Pusher.warn("Warn","To send headers with the auth request, you must use AJAX, rather than JSONP.");var d=b.toString();b++;var h=Pusher.Util.getDocument(),f=h.createElement("script");Pusher.auth_callbacks[d]=
function(b){a(!1,b)};f.src=this.options.authEndpoint+"?callback="+encodeURIComponent("Pusher.auth_callbacks['"+d+"']")+this.composeQuery(c);d=h.getElementsByTagName("head")[0]||h.documentElement;d.insertBefore(f,d.firstChild)}}}).call(this);
;(function(){

/**
 * Require the given path.
 *
 * @param {String} path
 * @return {Object} exports
 * @api public
 */

function require(path, parent, orig) {
  var resolved = require.resolve(path);

  // lookup failed
  if (null == resolved) {
    orig = orig || path;
    parent = parent || 'root';
    var err = new Error('Failed to require "' + orig + '" from "' + parent + '"');
    err.path = orig;
    err.parent = parent;
    err.require = true;
    throw err;
  }

  var module = require.modules[resolved];

  // perform real require()
  // by invoking the module's
  // registered function
  if (!module._resolving && !module.exports) {
    var mod = {};
    mod.exports = {};
    mod.client = mod.component = true;
    module._resolving = true;
    module.call(this, mod.exports, require.relative(resolved), mod);
    delete module._resolving;
    module.exports = mod.exports;
  }

  return module.exports;
}

/**
 * Registered modules.
 */

require.modules = {};

/**
 * Registered aliases.
 */

require.aliases = {};

/**
 * Resolve `path`.
 *
 * Lookup:
 *
 *   - PATH/index.js
 *   - PATH.js
 *   - PATH
 *
 * @param {String} path
 * @return {String} path or null
 * @api private
 */

require.resolve = function(path) {
  if (path.charAt(0) === '/') path = path.slice(1);

  var paths = [
    path,
    path + '.js',
    path + '.json',
    path + '/index.js',
    path + '/index.json'
  ];

  for (var i = 0; i < paths.length; i++) {
    var path = paths[i];
    if (require.modules.hasOwnProperty(path)) return path;
    if (require.aliases.hasOwnProperty(path)) return require.aliases[path];
  }
};

/**
 * Normalize `path` relative to the current path.
 *
 * @param {String} curr
 * @param {String} path
 * @return {String}
 * @api private
 */

require.normalize = function(curr, path) {
  var segs = [];

  if ('.' != path.charAt(0)) return path;

  curr = curr.split('/');
  path = path.split('/');

  for (var i = 0; i < path.length; ++i) {
    if ('..' == path[i]) {
      curr.pop();
    } else if ('.' != path[i] && '' != path[i]) {
      segs.push(path[i]);
    }
  }

  return curr.concat(segs).join('/');
};

/**
 * Register module at `path` with callback `definition`.
 *
 * @param {String} path
 * @param {Function} definition
 * @api private
 */

require.register = function(path, definition) {
  require.modules[path] = definition;
};

/**
 * Alias a module definition.
 *
 * @param {String} from
 * @param {String} to
 * @api private
 */

require.alias = function(from, to) {
  if (!require.modules.hasOwnProperty(from)) {
    throw new Error('Failed to alias "' + from + '", it does not exist');
  }
  require.aliases[to] = from;
};

/**
 * Return a require function relative to the `parent` path.
 *
 * @param {String} parent
 * @return {Function}
 * @api private
 */

require.relative = function(parent) {
  var p = require.normalize(parent, '..');

  /**
   * lastIndexOf helper.
   */

  function lastIndexOf(arr, obj) {
    var i = arr.length;
    while (i--) {
      if (arr[i] === obj) return i;
    }
    return -1;
  }

  /**
   * The relative require() itself.
   */

  function localRequire(path) {
    var resolved = localRequire.resolve(path);
    return require(resolved, parent, path);
  }

  /**
   * Resolve relative to the parent.
   */

  localRequire.resolve = function(path) {
    var c = path.charAt(0);
    if ('/' == c) return path.slice(1);
    if ('.' == c) return require.normalize(p, path);

    // resolve deps by returning
    // the dep in the nearest "deps"
    // directory
    var segs = parent.split('/');
    var i = lastIndexOf(segs, 'deps') + 1;
    if (!i) i = 0;
    path = segs.slice(0, i + 1).join('/') + '/deps/' + path;
    return path;
  };

  /**
   * Check if module is defined at `path`.
   */

  localRequire.exists = function(path) {
    return require.modules.hasOwnProperty(localRequire.resolve(path));
  };

  return localRequire;
};
require.register("component-classes/index.js", function(exports, require, module){
/**
 * Module dependencies.
 */

var index = require('indexof');

/**
 * Whitespace regexp.
 */

var re = /\s+/;

/**
 * toString reference.
 */

var toString = Object.prototype.toString;

/**
 * Wrap `el` in a `ClassList`.
 *
 * @param {Element} el
 * @return {ClassList}
 * @api public
 */

module.exports = function(el){
  return new ClassList(el);
};

/**
 * Initialize a new ClassList for `el`.
 *
 * @param {Element} el
 * @api private
 */

function ClassList(el) {
  if (!el) throw new Error('A DOM element reference is required');
  this.el = el;
  this.list = el.classList;
}

/**
 * Add class `name` if not already present.
 *
 * @param {String} name
 * @return {ClassList}
 * @api public
 */

ClassList.prototype.add = function(name){
  // classList
  if (this.list) {
    this.list.add(name);
    return this;
  }

  // fallback
  var arr = this.array();
  var i = index(arr, name);
  if (!~i) arr.push(name);
  this.el.className = arr.join(' ');
  return this;
};

/**
 * Remove class `name` when present, or
 * pass a regular expression to remove
 * any which match.
 *
 * @param {String|RegExp} name
 * @return {ClassList}
 * @api public
 */

ClassList.prototype.remove = function(name){
  if ('[object RegExp]' == toString.call(name)) {
    return this.removeMatching(name);
  }

  // classList
  if (this.list) {
    this.list.remove(name);
    return this;
  }

  // fallback
  var arr = this.array();
  var i = index(arr, name);
  if (~i) arr.splice(i, 1);
  this.el.className = arr.join(' ');
  return this;
};

/**
 * Remove all classes matching `re`.
 *
 * @param {RegExp} re
 * @return {ClassList}
 * @api private
 */

ClassList.prototype.removeMatching = function(re){
  var arr = this.array();
  for (var i = 0; i < arr.length; i++) {
    if (re.test(arr[i])) {
      this.remove(arr[i]);
    }
  }
  return this;
};

/**
 * Toggle class `name`, can force state via `force`.
 *
 * For browsers that support classList, but do not support `force` yet,
 * the mistake will be detected and corrected.
 *
 * @param {String} name
 * @param {Boolean} force
 * @return {ClassList}
 * @api public
 */

ClassList.prototype.toggle = function(name, force){
  // classList
  if (this.list) {
    if ("undefined" !== typeof force) {
      if (force !== this.list.toggle(name, force)) {
        this.list.toggle(name); // toggle again to correct
      }
    } else {
      this.list.toggle(name);
    }
    return this;
  }

  // fallback
  if ("undefined" !== typeof force) {
    if (!force) {
      this.remove(name);
    } else {
      this.add(name);
    }
  } else {
    if (this.has(name)) {
      this.remove(name);
    } else {
      this.add(name);
    }
  }

  return this;
};

/**
 * Return an array of classes.
 *
 * @return {Array}
 * @api public
 */

ClassList.prototype.array = function(){
  var str = this.el.className.replace(/^\s+|\s+$/g, '');
  var arr = str.split(re);
  if ('' === arr[0]) arr.shift();
  return arr;
};

/**
 * Check if class `name` is present.
 *
 * @param {String} name
 * @return {ClassList}
 * @api public
 */

ClassList.prototype.has =
ClassList.prototype.contains = function(name){
  return this.list
    ? this.list.contains(name)
    : !! ~index(this.array(), name);
};

});
require.register("segmentio-extend/index.js", function(exports, require, module){

module.exports = function extend (object) {
    // Takes an unlimited number of extenders.
    var args = Array.prototype.slice.call(arguments, 1);

    // For each extender, copy their properties on our object.
    for (var i = 0, source; source = args[i]; i++) {
        if (!source) continue;
        for (var property in source) {
            object[property] = source[property];
        }
    }

    return object;
};
});
require.register("component-indexof/index.js", function(exports, require, module){
module.exports = function(arr, obj){
  if (arr.indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};
});
require.register("component-event/index.js", function(exports, require, module){
var bind = window.addEventListener ? 'addEventListener' : 'attachEvent',
    unbind = window.removeEventListener ? 'removeEventListener' : 'detachEvent',
    prefix = bind !== 'addEventListener' ? 'on' : '';

/**
 * Bind `el` event `type` to `fn`.
 *
 * @param {Element} el
 * @param {String} type
 * @param {Function} fn
 * @param {Boolean} capture
 * @return {Function}
 * @api public
 */

exports.bind = function(el, type, fn, capture){
  el[bind](prefix + type, fn, capture || false);
  return fn;
};

/**
 * Unbind `el` event `type`'s callback `fn`.
 *
 * @param {Element} el
 * @param {String} type
 * @param {Function} fn
 * @param {Boolean} capture
 * @return {Function}
 * @api public
 */

exports.unbind = function(el, type, fn, capture){
  el[unbind](prefix + type, fn, capture || false);
  return fn;
};
});
require.register("javve-to-array/index.js", function(exports, require, module){
/**
 * Convert an array-like object into an `Array`.
 * If `collection` is already an `Array`, then will return a clone of `collection`.
 *
 * @param {Array | Mixed} collection An `Array` or array-like object to convert e.g. `arguments` or `NodeList`
 * @return {Array} Naive conversion of `collection` to a new `Array`.
 * @api public
 */

module.exports = function toArray(collection) {
  if (typeof collection === 'undefined') return []
  if (collection === null) return [null]
  if (collection === window) return [window]
  if (typeof collection === 'string') return [collection]
  if (collection instanceof Array) return collection
  if (typeof collection.length != 'number') return [collection]
  if (typeof collection === 'function') return [collection]

  var arr = []
  for (var i = 0; i < collection.length; i++) {
    if (Object.prototype.hasOwnProperty.call(collection, i) || i in collection) {
      arr.push(collection[i])
    }
  }
  if (!arr.length) return []
  return arr
}

});
require.register("javve-events/index.js", function(exports, require, module){
var events = require('event'),
  toArray = require('to-array');

/**
 * Bind `el` event `type` to `fn`.
 *
 * @param {Element} el, NodeList, HTMLCollection or Array
 * @param {String} type
 * @param {Function} fn
 * @param {Boolean} capture
 * @api public
 */

exports.bind = function(el, type, fn, capture){
  el = toArray(el);
  for ( var i = 0; i < el.length; i++ ) {
    events.bind(el[i], type, fn, capture);
  }
};

/**
 * Unbind `el` event `type`'s callback `fn`.
 *
 * @param {Element} el, NodeList, HTMLCollection or Array
 * @param {String} type
 * @param {Function} fn
 * @param {Boolean} capture
 * @api public
 */

exports.unbind = function(el, type, fn, capture){
  el = toArray(el);
  for ( var i = 0; i < el.length; i++ ) {
    events.unbind(el[i], type, fn, capture);
  }
};

});
require.register("javve-get-by-class/index.js", function(exports, require, module){
/**
 * Find all elements with class `className` inside `container`.
 * Use `single = true` to increase performance in older browsers
 * when only one element is needed.
 *
 * @param {String} className
 * @param {Element} container
 * @param {Boolean} single
 * @api public
 */

module.exports = (function() {
  if (document.getElementsByClassName) {
    return function(container, className, single) {
      if (single) {
        return container.getElementsByClassName(className)[0];
      } else {
        return container.getElementsByClassName(className);
      }
    };
  } else if (document.querySelector) {
    return function(container, className, single) {
      className = '.' + className;
      if (single) {
        return container.querySelector(className);
      } else {
        return container.querySelectorAll(className);
      }
    };
  } else {
    return function(container, className, single) {
      var classElements = [],
        tag = '*';
      if (container == null) {
        container = document;
      }
      var els = container.getElementsByTagName(tag);
      var elsLen = els.length;
      var pattern = new RegExp("(^|\\s)"+className+"(\\s|$)");
      for (var i = 0, j = 0; i < elsLen; i++) {
        if ( pattern.test(els[i].className) ) {
          if (single) {
            return els[i];
          } else {
            classElements[j] = els[i];
            j++;
          }
        }
      }
      return classElements;
    };
  }
})();

});
require.register("javve-get-attribute/index.js", function(exports, require, module){
/**
 * Return the value for `attr` at `element`.
 *
 * @param {Element} el
 * @param {String} attr
 * @api public
 */

module.exports = function(el, attr) {
  var result = (el.getAttribute && el.getAttribute(attr)) || null;
  if( !result ) {
    var attrs = el.attributes;
    var length = attrs.length;
    for(var i = 0; i < length; i++) {
      if (attr[i] !== undefined) {
        if(attr[i].nodeName === attr) {
          result = attr[i].nodeValue;
        }
      }
    }
  }
  return result;
}
});
require.register("javve-natural-sort/index.js", function(exports, require, module){
/*
 * Natural Sort algorithm for Javascript - Version 0.7 - Released under MIT license
 * Author: Jim Palmer (based on chunking idea from Dave Koelle)
 */

module.exports = function(a, b, options) {
  var re = /(^-?[0-9]+(\.?[0-9]*)[df]?e?[0-9]?$|^0x[0-9a-f]+$|[0-9]+)/gi,
    sre = /(^[ ]*|[ ]*$)/g,
    dre = /(^([\w ]+,?[\w ]+)?[\w ]+,?[\w ]+\d+:\d+(:\d+)?[\w ]?|^\d{1,4}[\/\-]\d{1,4}[\/\-]\d{1,4}|^\w+, \w+ \d+, \d{4})/,
    hre = /^0x[0-9a-f]+$/i,
    ore = /^0/,
    options = options || {},
    i = function(s) { return options.insensitive && (''+s).toLowerCase() || ''+s },
    // convert all to strings strip whitespace
    x = i(a).replace(sre, '') || '',
    y = i(b).replace(sre, '') || '',
    // chunk/tokenize
    xN = x.replace(re, '\0$1\0').replace(/\0$/,'').replace(/^\0/,'').split('\0'),
    yN = y.replace(re, '\0$1\0').replace(/\0$/,'').replace(/^\0/,'').split('\0'),
    // numeric, hex or date detection
    xD = parseInt(x.match(hre)) || (xN.length != 1 && x.match(dre) && Date.parse(x)),
    yD = parseInt(y.match(hre)) || xD && y.match(dre) && Date.parse(y) || null,
    oFxNcL, oFyNcL,
    mult = options.desc ? -1 : 1;
  // first try and sort Hex codes or Dates
  if (yD)
    if ( xD < yD ) return -1 * mult;
    else if ( xD > yD ) return 1 * mult;
  // natural sorting through split numeric strings and default strings
  for(var cLoc=0, numS=Math.max(xN.length, yN.length); cLoc < numS; cLoc++) {
    // find floats not starting with '0', string or 0 if not defined (Clint Priest)
    oFxNcL = !(xN[cLoc] || '').match(ore) && parseFloat(xN[cLoc]) || xN[cLoc] || 0;
    oFyNcL = !(yN[cLoc] || '').match(ore) && parseFloat(yN[cLoc]) || yN[cLoc] || 0;
    // handle numeric vs string comparison - number < string - (Kyle Adams)
    if (isNaN(oFxNcL) !== isNaN(oFyNcL)) { return (isNaN(oFxNcL)) ? 1 : -1; }
    // rely on string comparison if different types - i.e. '02' < 2 != '02' < '2'
    else if (typeof oFxNcL !== typeof oFyNcL) {
      oFxNcL += '';
      oFyNcL += '';
    }
    if (oFxNcL < oFyNcL) return -1 * mult;
    if (oFxNcL > oFyNcL) return 1 * mult;
  }
  return 0;
};

/*
var defaultSort = getSortFunction();

module.exports = function(a, b, options) {
  if (arguments.length == 1) {
    options = a;
    return getSortFunction(options);
  } else {
    return defaultSort(a,b);
  }
}
*/
});
require.register("javve-to-string/index.js", function(exports, require, module){
module.exports = function(s) {
    s = (s === undefined) ? "" : s;
    s = (s === null) ? "" : s;
    s = s.toString();
    return s;
};

});
require.register("component-type/index.js", function(exports, require, module){
/**
 * toString ref.
 */

var toString = Object.prototype.toString;

/**
 * Return the type of `val`.
 *
 * @param {Mixed} val
 * @return {String}
 * @api public
 */

module.exports = function(val){
  switch (toString.call(val)) {
    case '[object Date]': return 'date';
    case '[object RegExp]': return 'regexp';
    case '[object Arguments]': return 'arguments';
    case '[object Array]': return 'array';
    case '[object Error]': return 'error';
  }

  if (val === null) return 'null';
  if (val === undefined) return 'undefined';
  if (val !== val) return 'nan';
  if (val && val.nodeType === 1) return 'element';

  return typeof val.valueOf();
};

});
require.register("list.js/index.js", function(exports, require, module){
/*
ListJS with beta 1.0.0
By Jonny Strmberg (www.jonnystromberg.com, www.listjs.com)
*/
(function( window, undefined ) {
"use strict";

var document = window.document,
    getByClass = require('get-by-class'),
    extend = require('extend'),
    indexOf = require('indexof');

var List = function(id, options, values) {

    var self = this,
		init,
        Item = require('./src/item')(self),
        addAsync = require('./src/add-async')(self),
        parse = require('./src/parse')(self);

    init = {
        start: function() {
            self.listClass      = "list";
            self.searchClass    = "search";
            self.sortClass      = "sort";
            self.page           = 200;
            self.i              = 1;
            self.items          = [];
            self.visibleItems   = [];
            self.matchingItems  = [];
            self.searched       = false;
            self.filtered       = false;
            self.handlers       = { 'updated': [] };
            self.plugins        = {};
            self.helpers        = {
                getByClass: getByClass,
                extend: extend,
                indexOf: indexOf
            };

            extend(self, options);

            self.listContainer = (typeof(id) === 'string') ? document.getElementById(id) : id;
            if (!self.listContainer) { return; }
            self.list           = getByClass(self.listContainer, self.listClass, true);

            self.templater      = require('./src/templater')(self);
            self.search         = require('./src/search')(self);
            self.filter         = require('./src/filter')(self);
            self.sort           = require('./src/sort')(self);

            this.items();
            self.update();
            this.plugins();
        },
        items: function() {
            parse(self.list);
            if (values !== undefined) {
                self.add(values);
            }
        },
        plugins: function() {
            for (var i = 0; i < self.plugins.length; i++) {
                var plugin = self.plugins[i];
                self[plugin.name] = plugin;
                plugin.init(self);
            }
        }
    };


    /*
    * Add object to list
    */
    this.add = function(values, callback) {
        if (callback) {
            addAsync(values, callback);
            return;
        }
        var added = [],
            notCreate = false;
        if (values[0] === undefined){
            values = [values];
        }
        for (var i = 0, il = values.length; i < il; i++) {
            var item = null;
            if (values[i] instanceof Item) {
                item = values[i];
                item.reload();
            } else {
                notCreate = (self.items.length > self.page) ? true : false;
                item = new Item(values[i], undefined, notCreate);
            }
            self.items.push(item);
            added.push(item);
        }
        self.update();
        return added;
    };

	this.show = function(i, page) {
		this.i = i;
		this.page = page;
		self.update();
        return self;
	};

    /* Removes object from list.
    * Loops through the list and removes objects where
    * property "valuename" === value
    */
    this.remove = function(valueName, value, options) {
        var found = 0;
        for (var i = 0, il = self.items.length; i < il; i++) {
            if (self.items[i].values()[valueName] == value) {
                self.templater.remove(self.items[i], options);
                self.items.splice(i,1);
                il--;
                i--;
                found++;
            }
        }
        self.update();
        return found;
    };

    /* Gets the objects in the list which
    * property "valueName" === value
    */
    this.get = function(valueName, value) {
        var matchedItems = [];
        for (var i = 0, il = self.items.length; i < il; i++) {
            var item = self.items[i];
            if (item.values()[valueName] == value) {
                matchedItems.push(item);
            }
        }
        return matchedItems;
    };

    /*
    * Get size of the list
    */
    this.size = function() {
        return self.items.length;
    };

    /*
    * Removes all items from the list
    */
    this.clear = function() {
        self.templater.clear();
        self.items = [];
        return self;
    };

    this.on = function(event, callback) {
        self.handlers[event].push(callback);
        return self;
    };

    this.off = function(event, callback) {
        var e = self.handlers[event];
        var index = indexOf(e, callback);
        if (index > -1) {
            e.splice(index, 1);
        }
        return self;
    };

    this.trigger = function(event) {
        var i = self.handlers[event].length;
        while(i--) {
            self.handlers[event][i](self);
        }
        return self;
    };

    this.reset = {
        filter: function() {
            var is = self.items,
                il = is.length;
            while (il--) {
                is[il].filtered = false;
            }
            return self;
        },
        search: function() {
            var is = self.items,
                il = is.length;
            while (il--) {
                is[il].found = false;
            }
            return self;
        }
    };

    this.update = function() {
        var is = self.items,
			il = is.length;

        self.visibleItems = [];
        self.matchingItems = [];
        self.templater.clear();
        for (var i = 0; i < il; i++) {
            if (is[i].matching() && ((self.matchingItems.length+1) >= self.i && self.visibleItems.length < self.page)) {
                is[i].show();
                self.visibleItems.push(is[i]);
                self.matchingItems.push(is[i]);
			} else if (is[i].matching()) {
                self.matchingItems.push(is[i]);
                is[i].hide();
			} else {
                is[i].hide();
			}
        }
        self.trigger('updated');
        return self;
    };

    init.start();
};

module.exports = List;

})(window);

});
require.register("list.js/src/search.js", function(exports, require, module){
var events = require('events'),
    getByClass = require('get-by-class'),
    toString = require('to-string');

module.exports = function(list) {
    var item,
        text,
        columns,
        searchString,
        customSearch;

    var prepare = {
        resetList: function() {
            list.i = 1;
            list.templater.clear();
            customSearch = undefined;
        },
        setOptions: function(args) {
            if (args.length == 2 && args[1] instanceof Array) {
                columns = args[1];
            } else if (args.length == 2 && typeof(args[1]) == "function") {
                customSearch = args[1];
            } else if (args.length == 3) {
                columns = args[1];
                customSearch = args[2];
            }
        },
        setColumns: function() {
            columns = (columns === undefined) ? prepare.toArray(list.items[0].values()) : columns;
        },
        setSearchString: function(s) {
            s = toString(s).toLowerCase();
            s = s.replace(/[-[\]{}()*+?.,\\^$|#]/g, "\\$&"); // Escape regular expression characters
            searchString = s;
        },
        toArray: function(values) {
            var tmpColumn = [];
            for (var name in values) {
                tmpColumn.push(name);
            }
            return tmpColumn;
        }
    };
    var search = {
        list: function() {
            for (var k = 0, kl = list.items.length; k < kl; k++) {
                search.item(list.items[k]);
            }
        },
        item: function(item) {
            item.found = false;
            for (var j = 0, jl = columns.length; j < jl; j++) {
                if (search.values(item.values(), columns[j])) {
                    item.found = true;
                    return;
                }
            }
        },
        values: function(values, column) {
            if (values.hasOwnProperty(column)) {
                text = toString(values[column]).toLowerCase();
                if ((searchString !== "") && (text.search(searchString) > -1)) {
                    return true;
                }
            }
            return false;
        },
        reset: function() {
            list.reset.search();
            list.searched = false;
        }
    };

    var searchMethod = function(str) {
        list.trigger('searchStart');

        prepare.resetList();
        prepare.setSearchString(str);
        prepare.setOptions(arguments); // str, cols|searchFunction, searchFunction
        prepare.setColumns();

        if (searchString === "" ) {
            search.reset();
        } else {
            list.searched = true;
            if (customSearch) {
                customSearch(searchString, columns);
            } else {
                search.list();
            }
        }

        list.update();
        list.trigger('searchComplete');
        return list.visibleItems;
    };

    list.handlers.searchStart = list.handlers.searchStart || [];
    list.handlers.searchComplete = list.handlers.searchComplete || [];

    events.bind(getByClass(list.listContainer, list.searchClass), 'keyup', function(e) {
        var target = e.target || e.srcElement; // IE have srcElement
        searchMethod(target.value);
    });

    list.helpers.toString = toString;
    return searchMethod;
};

});
require.register("list.js/src/sort.js", function(exports, require, module){
var naturalSort = require('natural-sort'),
    classes = require('classes'),
    events = require('events'),
    getByClass = require('get-by-class'),
    getAttribute = require('get-attribute');

module.exports = function(list) {
    list.sortFunction = list.sortFunction || function(itemA, itemB, options) {
        options.desc = options.order == "desc" ? true : false; // Natural sort uses this format
        return naturalSort(itemA.values()[options.valueName], itemB.values()[options.valueName], options);
    };

    var buttons = {
        els: undefined,
        clear: function() {
            for (var i = 0, il = buttons.els.length; i < il; i++) {
                classes(buttons.els[i]).remove('asc');
                classes(buttons.els[i]).remove('desc');
            }
        },
        getOrder: function(btn) {
            var predefinedOrder = getAttribute(btn, 'data-order');
            if (predefinedOrder == "asc" || predefinedOrder == "desc") {
                return predefinedOrder;
            } else if (classes(btn).has('desc')) {
                return "asc";
            } else if (classes(btn).has('asc')) {
                return "desc";
            } else {
                return "asc";
            }
        },
        getInSensitive: function(btn, options) {
            var insensitive = getAttribute(btn, 'data-insensitive');
            if (insensitive === "true") {
                options.insensitive = true;
            } else {
                options.insensitive = false;
            }
        },
        setOrder: function(options) {
            for (var i = 0, il = buttons.els.length; i < il; i++) {
                var btn = buttons.els[i];
                if (getAttribute(btn, 'data-sort') !== options.valueName) {
                    continue;
                }
                var predefinedOrder = getAttribute(btn, 'data-order');
                if (predefinedOrder == "asc" || predefinedOrder == "desc") {
                    if (predefinedOrder == options.order) {
                        classes(btn).add(options.order);
                    }
                } else {
                    classes(btn).add(options.order);
                }
            }
        }
    };
    var sort = function() {
        list.trigger('sortStart');
        options = {};

        var target = arguments[0].currentTarget || arguments[0].srcElement || undefined;

        if (target) {
            options.valueName = getAttribute(target, 'data-sort');
            buttons.getInSensitive(target, options);
            options.order = buttons.getOrder(target);
        } else {
            options = arguments[1] || options;
            options.valueName = arguments[0];
            options.order = options.order || "asc";
            options.insensitive = (typeof options.insensitive == "undefined") ? true : options.insensitive;
        }
        buttons.clear();
        buttons.setOrder(options);

        options.sortFunction = options.sortFunction || list.sortFunction;
        list.items.sort(function(a, b) {
            return options.sortFunction(a, b, options);
        });
        list.update();
        list.trigger('sortComplete');
    };

    // Add handlers
    list.handlers.sortStart = list.handlers.sortStart || [];
    list.handlers.sortComplete = list.handlers.sortComplete || [];

    buttons.els = getByClass(list.listContainer, list.sortClass);
    events.bind(buttons.els, 'click', sort);
    list.on('searchStart', buttons.clear);
    list.on('filterStart', buttons.clear);

    // Helpers
    list.helpers.classes = classes;
    list.helpers.naturalSort = naturalSort;
    list.helpers.events = events;
    list.helpers.getAttribute = getAttribute;

    return sort;
};

});
require.register("list.js/src/item.js", function(exports, require, module){
module.exports = function(list) {
    return function(initValues, element, notCreate) {
        var item = this;

        this._values = {};

        this.found = false; // Show if list.searched == true and this.found == true
        this.filtered = false;// Show if list.filtered == true and this.filtered == true

        var init = function(initValues, element, notCreate) {
            if (element === undefined) {
                if (notCreate) {
                    item.values(initValues, notCreate);
                } else {
                    item.values(initValues);
                }
            } else {
                item.elm = element;
                var values = list.templater.get(item, initValues);
                item.values(values);
            }
        };
        this.values = function(newValues, notCreate) {
            if (newValues !== undefined) {
                for(var name in newValues) {
                    item._values[name] = newValues[name];
                }
                if (notCreate !== true) {
                    list.templater.set(item, item.values());
                }
            } else {
                return item._values;
            }
        };
        this.show = function() {
            list.templater.show(item);
        };
        this.hide = function() {
            list.templater.hide(item);
        };
        this.matching = function() {
            return (
                (list.filtered && list.searched && item.found && item.filtered) ||
                (list.filtered && !list.searched && item.filtered) ||
                (!list.filtered && list.searched && item.found) ||
                (!list.filtered && !list.searched)
            );
        };
        this.visible = function() {
            return (item.elm.parentNode == list.list) ? true : false;
        };
        init(initValues, element, notCreate);
    };
};

});
require.register("list.js/src/templater.js", function(exports, require, module){
var getByClass = require('get-by-class');

var Templater = function(list) {
    var itemSource = getItemSource(list.item),
        templater = this;

    function getItemSource(item) {
        if (item === undefined) {
            var nodes = list.list.childNodes,
                items = [];

            for (var i = 0, il = nodes.length; i < il; i++) {
                // Only textnodes have a data attribute
                if (nodes[i].data === undefined) {
                    return nodes[i];
                }
            }
            return null;
        } else if (item.indexOf("<") !== -1) { // Try create html element of list, do not work for tables!!
            var div = document.createElement('div');
            div.innerHTML = item;
            return div.firstChild;
        } else {
            return document.getElementById(list.item);
        }
    }

    /* Get values from element */
    this.get = function(item, valueNames) {
        templater.create(item);
        var values = {};
        for(var i = 0, il = valueNames.length; i < il; i++) {
            var elm = getByClass(item.elm, valueNames[i], true);
            values[valueNames[i]] = elm ? elm.innerHTML : "";
        }
        return values;
    };

    /* Sets values at element */
    this.set = function(item, values) {
        if (!templater.create(item)) {
            for(var v in values) {
                if (values.hasOwnProperty(v)) {
                    // TODO speed up if possible
                    var elm = getByClass(item.elm, v, true);
                    if (elm) {
                        /* src attribute for image tag & text for other tags */
                        if (elm.tagName === "IMG" && values[v] !== "") {
                            elm.src = values[v];
                        } else {
                            elm.innerHTML = values[v];
                        }
                    }
                }
            }
        }
    };

    this.create = function(item) {
        if (item.elm !== undefined) {
            return false;
        }
        /* If item source does not exists, use the first item in list as
        source for new items */
        var newItem = itemSource.cloneNode(true);
        newItem.removeAttribute('id');
        item.elm = newItem;
        templater.set(item, item.values());
        return true;
    };
    this.remove = function(item) {
        list.list.removeChild(item.elm);
    };
    this.show = function(item) {
        templater.create(item);
        list.list.appendChild(item.elm);
    };
    this.hide = function(item) {
        if (item.elm !== undefined && item.elm.parentNode === list.list) {
            list.list.removeChild(item.elm);
        }
    };
    this.clear = function() {
        /* .innerHTML = ''; fucks up IE */
        if (list.list.hasChildNodes()) {
            while (list.list.childNodes.length >= 1)
            {
                list.list.removeChild(list.list.firstChild);
            }
        }
    };
};

module.exports = function(list) {
    return new Templater(list);
};

});
require.register("list.js/src/filter.js", function(exports, require, module){
module.exports = function(list) {

    // Add handlers
    list.handlers.filterStart = list.handlers.filterStart || [];
    list.handlers.filterComplete = list.handlers.filterComplete || [];

    return function(filterFunction) {
        list.trigger('filterStart');
        list.i = 1; // Reset paging
        list.reset.filter();
        if (filterFunction === undefined) {
            list.filtered = false;
        } else {
            list.filtered = true;
            var is = list.items;
            for (var i = 0, il = is.length; i < il; i++) {
                var item = is[i];
                if (filterFunction(item)) {
                    item.filtered = true;
                } else {
                    item.filtered = false;
                }
            }
        }
        list.update();
        list.trigger('filterComplete');
        return list.visibleItems;
    };
};

});
require.register("list.js/src/add-async.js", function(exports, require, module){
module.exports = function(list) {
    return function(values, callback, items) {
        var valuesToAdd = values.splice(0, 100);
        items = items || [];
        items = items.concat(list.add(valuesToAdd));
        if (values.length > 0) {
            setTimeout(function() {
                addAsync(values, callback, items);
            }, 10);
        } else {
            list.update();
            callback(items);
        }
    };
};
});
require.register("list.js/src/parse.js", function(exports, require, module){
module.exports = function(list) {

    var Item = require('./item')(list);

    var getChildren = function(parent) {
        var nodes = parent.childNodes,
            items = [];
        for (var i = 0, il = nodes.length; i < il; i++) {
            // Only textnodes have a data attribute
            if (nodes[i].data === undefined) {
                items.push(nodes[i]);
            }
        }
        return items;
    };

    var parse = function(itemElements, valueNames) {
        for (var i = 0, il = itemElements.length; i < il; i++) {
            list.items.push(new Item(valueNames, itemElements[i]));
        }
    };
    var parseAsync = function(itemElements, valueNames) {
        var itemsToIndex = itemElements.splice(0, 100); // TODO: If < 100 items, what happens in IE etc?
        parse(itemsToIndex, valueNames);
        if (itemElements.length > 0) {
            setTimeout(function() {
                init.items.indexAsync(itemElements, valueNames);
            }, 10);
        } else {
            list.update();
            // TODO: Add indexed callback
        }
    };

    return function() {
        var itemsToIndex = getChildren(list.list),
            valueNames = list.valueNames;

        if (list.indexAsync) {
            parseAsync(itemsToIndex, valueNames);
        } else {
            parse(itemsToIndex, valueNames);
        }
    };
};

});




















require.alias("component-classes/index.js", "list.js/deps/classes/index.js");
require.alias("component-classes/index.js", "classes/index.js");
require.alias("component-indexof/index.js", "component-classes/deps/indexof/index.js");

require.alias("segmentio-extend/index.js", "list.js/deps/extend/index.js");
require.alias("segmentio-extend/index.js", "extend/index.js");

require.alias("component-indexof/index.js", "list.js/deps/indexof/index.js");
require.alias("component-indexof/index.js", "indexof/index.js");

require.alias("javve-events/index.js", "list.js/deps/events/index.js");
require.alias("javve-events/index.js", "events/index.js");
require.alias("component-event/index.js", "javve-events/deps/event/index.js");

require.alias("javve-to-array/index.js", "javve-events/deps/to-array/index.js");

require.alias("javve-get-by-class/index.js", "list.js/deps/get-by-class/index.js");
require.alias("javve-get-by-class/index.js", "get-by-class/index.js");

require.alias("javve-get-attribute/index.js", "list.js/deps/get-attribute/index.js");
require.alias("javve-get-attribute/index.js", "get-attribute/index.js");

require.alias("javve-natural-sort/index.js", "list.js/deps/natural-sort/index.js");
require.alias("javve-natural-sort/index.js", "natural-sort/index.js");

require.alias("javve-to-string/index.js", "list.js/deps/to-string/index.js");
require.alias("javve-to-string/index.js", "list.js/deps/to-string/index.js");
require.alias("javve-to-string/index.js", "to-string/index.js");
require.alias("javve-to-string/index.js", "javve-to-string/index.js");
require.alias("component-type/index.js", "list.js/deps/type/index.js");
require.alias("component-type/index.js", "type/index.js");
if (typeof exports == "object") {
  module.exports = require("list.js");
} else if (typeof define == "function" && define.amd) {
  define(function(){ return require("list.js"); });
} else {
  this["List"] = require("list.js");
}})();
/*! Copyright (c) 2013 Brandon Aaron (http://brandon.aaron.sh)
 * Licensed under the MIT License (LICENSE.txt).
 *
 * Version: 3.1.11
 *
 * Requires: jQuery 1.2.2+
 */


(function (factory) {
    if ( typeof define === 'function' && define.amd ) {
        // AMD. Register as an anonymous module.
        define(['jquery'], factory);
    } else if (typeof exports === 'object') {
        // Node/CommonJS style for Browserify
        module.exports = factory;
    } else {
        // Browser globals
        factory(jQuery);
    }
}(function ($) {

    var toFix  = ['wheel', 'mousewheel', 'DOMMouseScroll', 'MozMousePixelScroll'],
        toBind = ( 'onwheel' in document || document.documentMode >= 9 ) ?
                    ['wheel'] : ['mousewheel', 'DomMouseScroll', 'MozMousePixelScroll'],
        slice  = Array.prototype.slice,
        nullLowestDeltaTimeout, lowestDelta;

    if ( $.event.fixHooks ) {
        for ( var i = toFix.length; i; ) {
            $.event.fixHooks[ toFix[--i] ] = $.event.mouseHooks;
        }
    }

    var special = $.event.special.mousewheel = {
        version: '3.1.11',

        setup: function() {
            if ( this.addEventListener ) {
                for ( var i = toBind.length; i; ) {
                    this.addEventListener( toBind[--i], handler, false );
                }
            } else {
                this.onmousewheel = handler;
            }
            // Store the line height and page height for this particular element
            $.data(this, 'mousewheel-line-height', special.getLineHeight(this));
            $.data(this, 'mousewheel-page-height', special.getPageHeight(this));
        },

        teardown: function() {
            if ( this.removeEventListener ) {
                for ( var i = toBind.length; i; ) {
                    this.removeEventListener( toBind[--i], handler, false );
                }
            } else {
                this.onmousewheel = null;
            }
            // Clean up the data we added to the element
            $.removeData(this, 'mousewheel-line-height');
            $.removeData(this, 'mousewheel-page-height');
        },

        getLineHeight: function(elem) {
            var $parent = $(elem)['offsetParent' in $.fn ? 'offsetParent' : 'parent']();
            if (!$parent.length) {
                $parent = $('body');
            }
            return parseInt($parent.css('fontSize'), 10);
        },

        getPageHeight: function(elem) {
            return $(elem).height();
        },

        settings: {
            adjustOldDeltas: true, // see shouldAdjustOldDeltas() below
            normalizeOffset: true  // calls getBoundingClientRect for each event
        }
    };

    $.fn.extend({
        mousewheel: function(fn) {
            return fn ? this.bind('mousewheel', fn) : this.trigger('mousewheel');
        },

        unmousewheel: function(fn) {
            return this.unbind('mousewheel', fn);
        }
    });


    function handler(event) {
        var orgEvent   = event || window.event,
            args       = slice.call(arguments, 1),
            delta      = 0,
            deltaX     = 0,
            deltaY     = 0,
            absDelta   = 0,
            offsetX    = 0,
            offsetY    = 0;
        event = $.event.fix(orgEvent);
        event.type = 'mousewheel';

        // Old school scrollwheel delta
        if ( 'detail'      in orgEvent ) { deltaY = orgEvent.detail * -1;      }
        if ( 'wheelDelta'  in orgEvent ) { deltaY = orgEvent.wheelDelta;       }
        if ( 'wheelDeltaY' in orgEvent ) { deltaY = orgEvent.wheelDeltaY;      }
        if ( 'wheelDeltaX' in orgEvent ) { deltaX = orgEvent.wheelDeltaX * -1; }

        // Firefox < 17 horizontal scrolling related to DOMMouseScroll event
        if ( 'axis' in orgEvent && orgEvent.axis === orgEvent.HORIZONTAL_AXIS ) {
            deltaX = deltaY * -1;
            deltaY = 0;
        }

        // Set delta to be deltaY or deltaX if deltaY is 0 for backwards compatabilitiy
        delta = deltaY === 0 ? deltaX : deltaY;

        // New school wheel delta (wheel event)
        if ( 'deltaY' in orgEvent ) {
            deltaY = orgEvent.deltaY * -1;
            delta  = deltaY;
        }
        if ( 'deltaX' in orgEvent ) {
            deltaX = orgEvent.deltaX;
            if ( deltaY === 0 ) { delta  = deltaX * -1; }
        }

        // No change actually happened, no reason to go any further
        if ( deltaY === 0 && deltaX === 0 ) { return; }

        // Need to convert lines and pages to pixels if we aren't already in pixels
        // There are three delta modes:
        //   * deltaMode 0 is by pixels, nothing to do
        //   * deltaMode 1 is by lines
        //   * deltaMode 2 is by pages
        if ( orgEvent.deltaMode === 1 ) {
            var lineHeight = $.data(this, 'mousewheel-line-height');
            delta  *= lineHeight;
            deltaY *= lineHeight;
            deltaX *= lineHeight;
        } else if ( orgEvent.deltaMode === 2 ) {
            var pageHeight = $.data(this, 'mousewheel-page-height');
            delta  *= pageHeight;
            deltaY *= pageHeight;
            deltaX *= pageHeight;
        }

        // Store lowest absolute delta to normalize the delta values
        absDelta = Math.max( Math.abs(deltaY), Math.abs(deltaX) );

        if ( !lowestDelta || absDelta < lowestDelta ) {
            lowestDelta = absDelta;

            // Adjust older deltas if necessary
            if ( shouldAdjustOldDeltas(orgEvent, absDelta) ) {
                lowestDelta /= 40;
            }
        }

        // Adjust older deltas if necessary
        if ( shouldAdjustOldDeltas(orgEvent, absDelta) ) {
            // Divide all the things by 40!
            delta  /= 40;
            deltaX /= 40;
            deltaY /= 40;
        }

        // Get a whole, normalized value for the deltas
        delta  = Math[ delta  >= 1 ? 'floor' : 'ceil' ](delta  / lowestDelta);
        deltaX = Math[ deltaX >= 1 ? 'floor' : 'ceil' ](deltaX / lowestDelta);
        deltaY = Math[ deltaY >= 1 ? 'floor' : 'ceil' ](deltaY / lowestDelta);

        // Normalise offsetX and offsetY properties
        if ( special.settings.normalizeOffset && this.getBoundingClientRect ) {
            var boundingRect = this.getBoundingClientRect();
            offsetX = event.clientX - boundingRect.left;
            offsetY = event.clientY - boundingRect.top;
        }

        // Add information to the event object
        event.deltaX = deltaX;
        event.deltaY = deltaY;
        event.deltaFactor = lowestDelta;
        event.offsetX = offsetX;
        event.offsetY = offsetY;
        // Go ahead and set deltaMode to 0 since we converted to pixels
        // Although this is a little odd since we overwrite the deltaX/Y
        // properties with normalized deltas.
        event.deltaMode = 0;

        // Add event and delta to the front of the arguments
        args.unshift(event, delta, deltaX, deltaY);

        // Clearout lowestDelta after sometime to better
        // handle multiple device types that give different
        // a different lowestDelta
        // Ex: trackpad = 3 and mouse wheel = 120
        if (nullLowestDeltaTimeout) { clearTimeout(nullLowestDeltaTimeout); }
        nullLowestDeltaTimeout = setTimeout(nullLowestDelta, 200);

        return ($.event.dispatch || $.event.handle).apply(this, args);
    }

    function nullLowestDelta() {
        lowestDelta = null;
    }

    function shouldAdjustOldDeltas(orgEvent, absDelta) {
        // If this is an older event and the delta is divisable by 120,
        // then we are assuming that the browser is treating this as an
        // older mouse wheel event and that we should divide the deltas
        // by 40 to try and get a more usable deltaFactor.
        // Side note, this actually impacts the reported scroll distance
        // in older browsers and can cause scrolling to be slower than native.
        // Turn this off by setting $.event.special.mousewheel.settings.adjustOldDeltas to false.
        return special.settings.adjustOldDeltas && orgEvent.type === 'mousewheel' && absDelta % 120 === 0;
    }

}));
/**
 * @fileoverview
 * - Using the 'QRCode for Javascript library'
 * - Fixed dataset of 'QRCode for Javascript library' for support full-spec.
 * - this library has no dependencies.
 * 
 * @author davidshimjs
 * @see <a href="http://www.d-project.com/" target="_blank">http://www.d-project.com/</a>
 * @see <a href="http://jeromeetienne.github.com/jquery-qrcode/" target="_blank">http://jeromeetienne.github.com/jquery-qrcode/</a>
 */

var QRCode;

(function () {
	//---------------------------------------------------------------------
	// QRCode for JavaScript
	//
	// Copyright (c) 2009 Kazuhiko Arase
	//
	// URL: http://www.d-project.com/
	//
	// Licensed under the MIT license:
	//   http://www.opensource.org/licenses/mit-license.php
	//
	// The word "QR Code" is registered trademark of 
	// DENSO WAVE INCORPORATED
	//   http://www.denso-wave.com/qrcode/faqpatent-e.html
	//
	//---------------------------------------------------------------------
	function QR8bitByte(data) {
		this.mode = QRMode.MODE_8BIT_BYTE;
		this.data = data;
		this.parsedData = [];

		// Added to support UTF-8 Characters
		for (var i = 0, l = this.data.length; i < l; i++) {
			var byteArray = [];
			var code = this.data.charCodeAt(i);

			if (code > 0x10000) {
				byteArray[0] = 0xF0 | ((code & 0x1C0000) >>> 18);
				byteArray[1] = 0x80 | ((code & 0x3F000) >>> 12);
				byteArray[2] = 0x80 | ((code & 0xFC0) >>> 6);
				byteArray[3] = 0x80 | (code & 0x3F);
			} else if (code > 0x800) {
				byteArray[0] = 0xE0 | ((code & 0xF000) >>> 12);
				byteArray[1] = 0x80 | ((code & 0xFC0) >>> 6);
				byteArray[2] = 0x80 | (code & 0x3F);
			} else if (code > 0x80) {
				byteArray[0] = 0xC0 | ((code & 0x7C0) >>> 6);
				byteArray[1] = 0x80 | (code & 0x3F);
			} else {
				byteArray[0] = code;
			}

			this.parsedData.push(byteArray);
		}

		this.parsedData = Array.prototype.concat.apply([], this.parsedData);

		if (this.parsedData.length != this.data.length) {
			this.parsedData.unshift(191);
			this.parsedData.unshift(187);
			this.parsedData.unshift(239);
		}
	}

	QR8bitByte.prototype = {
		getLength: function (buffer) {
			return this.parsedData.length;
		},
		write: function (buffer) {
			for (var i = 0, l = this.parsedData.length; i < l; i++) {
				buffer.put(this.parsedData[i], 8);
			}
		}
	};

	function QRCodeModel(typeNumber, errorCorrectLevel) {
		this.typeNumber = typeNumber;
		this.errorCorrectLevel = errorCorrectLevel;
		this.modules = null;
		this.moduleCount = 0;
		this.dataCache = null;
		this.dataList = [];
	}

	QRCodeModel.prototype={addData:function(data){var newData=new QR8bitByte(data);this.dataList.push(newData);this.dataCache=null;},isDark:function(row,col){if(row<0||this.moduleCount<=row||col<0||this.moduleCount<=col){throw new Error(row+","+col);}
	return this.modules[row][col];},getModuleCount:function(){return this.moduleCount;},make:function(){this.makeImpl(false,this.getBestMaskPattern());},makeImpl:function(test,maskPattern){this.moduleCount=this.typeNumber*4+17;this.modules=new Array(this.moduleCount);for(var row=0;row<this.moduleCount;row++){this.modules[row]=new Array(this.moduleCount);for(var col=0;col<this.moduleCount;col++){this.modules[row][col]=null;}}
	this.setupPositionProbePattern(0,0);this.setupPositionProbePattern(this.moduleCount-7,0);this.setupPositionProbePattern(0,this.moduleCount-7);this.setupPositionAdjustPattern();this.setupTimingPattern();this.setupTypeInfo(test,maskPattern);if(this.typeNumber>=7){this.setupTypeNumber(test);}
	if(this.dataCache==null){this.dataCache=QRCodeModel.createData(this.typeNumber,this.errorCorrectLevel,this.dataList);}
	this.mapData(this.dataCache,maskPattern);},setupPositionProbePattern:function(row,col){for(var r=-1;r<=7;r++){if(row+r<=-1||this.moduleCount<=row+r)continue;for(var c=-1;c<=7;c++){if(col+c<=-1||this.moduleCount<=col+c)continue;if((0<=r&&r<=6&&(c==0||c==6))||(0<=c&&c<=6&&(r==0||r==6))||(2<=r&&r<=4&&2<=c&&c<=4)){this.modules[row+r][col+c]=true;}else{this.modules[row+r][col+c]=false;}}}},getBestMaskPattern:function(){var minLostPoint=0;var pattern=0;for(var i=0;i<8;i++){this.makeImpl(true,i);var lostPoint=QRUtil.getLostPoint(this);if(i==0||minLostPoint>lostPoint){minLostPoint=lostPoint;pattern=i;}}
	return pattern;},createMovieClip:function(target_mc,instance_name,depth){var qr_mc=target_mc.createEmptyMovieClip(instance_name,depth);var cs=1;this.make();for(var row=0;row<this.modules.length;row++){var y=row*cs;for(var col=0;col<this.modules[row].length;col++){var x=col*cs;var dark=this.modules[row][col];if(dark){qr_mc.beginFill(0,100);qr_mc.moveTo(x,y);qr_mc.lineTo(x+cs,y);qr_mc.lineTo(x+cs,y+cs);qr_mc.lineTo(x,y+cs);qr_mc.endFill();}}}
	return qr_mc;},setupTimingPattern:function(){for(var r=8;r<this.moduleCount-8;r++){if(this.modules[r][6]!=null){continue;}
	this.modules[r][6]=(r%2==0);}
	for(var c=8;c<this.moduleCount-8;c++){if(this.modules[6][c]!=null){continue;}
	this.modules[6][c]=(c%2==0);}},setupPositionAdjustPattern:function(){var pos=QRUtil.getPatternPosition(this.typeNumber);for(var i=0;i<pos.length;i++){for(var j=0;j<pos.length;j++){var row=pos[i];var col=pos[j];if(this.modules[row][col]!=null){continue;}
	for(var r=-2;r<=2;r++){for(var c=-2;c<=2;c++){if(r==-2||r==2||c==-2||c==2||(r==0&&c==0)){this.modules[row+r][col+c]=true;}else{this.modules[row+r][col+c]=false;}}}}}},setupTypeNumber:function(test){var bits=QRUtil.getBCHTypeNumber(this.typeNumber);for(var i=0;i<18;i++){var mod=(!test&&((bits>>i)&1)==1);this.modules[Math.floor(i/3)][i%3+this.moduleCount-8-3]=mod;}
	for(var i=0;i<18;i++){var mod=(!test&&((bits>>i)&1)==1);this.modules[i%3+this.moduleCount-8-3][Math.floor(i/3)]=mod;}},setupTypeInfo:function(test,maskPattern){var data=(this.errorCorrectLevel<<3)|maskPattern;var bits=QRUtil.getBCHTypeInfo(data);for(var i=0;i<15;i++){var mod=(!test&&((bits>>i)&1)==1);if(i<6){this.modules[i][8]=mod;}else if(i<8){this.modules[i+1][8]=mod;}else{this.modules[this.moduleCount-15+i][8]=mod;}}
	for(var i=0;i<15;i++){var mod=(!test&&((bits>>i)&1)==1);if(i<8){this.modules[8][this.moduleCount-i-1]=mod;}else if(i<9){this.modules[8][15-i-1+1]=mod;}else{this.modules[8][15-i-1]=mod;}}
	this.modules[this.moduleCount-8][8]=(!test);},mapData:function(data,maskPattern){var inc=-1;var row=this.moduleCount-1;var bitIndex=7;var byteIndex=0;for(var col=this.moduleCount-1;col>0;col-=2){if(col==6)col--;while(true){for(var c=0;c<2;c++){if(this.modules[row][col-c]==null){var dark=false;if(byteIndex<data.length){dark=(((data[byteIndex]>>>bitIndex)&1)==1);}
	var mask=QRUtil.getMask(maskPattern,row,col-c);if(mask){dark=!dark;}
	this.modules[row][col-c]=dark;bitIndex--;if(bitIndex==-1){byteIndex++;bitIndex=7;}}}
	row+=inc;if(row<0||this.moduleCount<=row){row-=inc;inc=-inc;break;}}}}};QRCodeModel.PAD0=0xEC;QRCodeModel.PAD1=0x11;QRCodeModel.createData=function(typeNumber,errorCorrectLevel,dataList){var rsBlocks=QRRSBlock.getRSBlocks(typeNumber,errorCorrectLevel);var buffer=new QRBitBuffer();for(var i=0;i<dataList.length;i++){var data=dataList[i];buffer.put(data.mode,4);buffer.put(data.getLength(),QRUtil.getLengthInBits(data.mode,typeNumber));data.write(buffer);}
	var totalDataCount=0;for(var i=0;i<rsBlocks.length;i++){totalDataCount+=rsBlocks[i].dataCount;}
	if(buffer.getLengthInBits()>totalDataCount*8){throw new Error("code length overflow. ("
	+buffer.getLengthInBits()
	+">"
	+totalDataCount*8
	+")");}
	if(buffer.getLengthInBits()+4<=totalDataCount*8){buffer.put(0,4);}
	while(buffer.getLengthInBits()%8!=0){buffer.putBit(false);}
	while(true){if(buffer.getLengthInBits()>=totalDataCount*8){break;}
	buffer.put(QRCodeModel.PAD0,8);if(buffer.getLengthInBits()>=totalDataCount*8){break;}
	buffer.put(QRCodeModel.PAD1,8);}
	return QRCodeModel.createBytes(buffer,rsBlocks);};QRCodeModel.createBytes=function(buffer,rsBlocks){var offset=0;var maxDcCount=0;var maxEcCount=0;var dcdata=new Array(rsBlocks.length);var ecdata=new Array(rsBlocks.length);for(var r=0;r<rsBlocks.length;r++){var dcCount=rsBlocks[r].dataCount;var ecCount=rsBlocks[r].totalCount-dcCount;maxDcCount=Math.max(maxDcCount,dcCount);maxEcCount=Math.max(maxEcCount,ecCount);dcdata[r]=new Array(dcCount);for(var i=0;i<dcdata[r].length;i++){dcdata[r][i]=0xff&buffer.buffer[i+offset];}
	offset+=dcCount;var rsPoly=QRUtil.getErrorCorrectPolynomial(ecCount);var rawPoly=new QRPolynomial(dcdata[r],rsPoly.getLength()-1);var modPoly=rawPoly.mod(rsPoly);ecdata[r]=new Array(rsPoly.getLength()-1);for(var i=0;i<ecdata[r].length;i++){var modIndex=i+modPoly.getLength()-ecdata[r].length;ecdata[r][i]=(modIndex>=0)?modPoly.get(modIndex):0;}}
	var totalCodeCount=0;for(var i=0;i<rsBlocks.length;i++){totalCodeCount+=rsBlocks[i].totalCount;}
	var data=new Array(totalCodeCount);var index=0;for(var i=0;i<maxDcCount;i++){for(var r=0;r<rsBlocks.length;r++){if(i<dcdata[r].length){data[index++]=dcdata[r][i];}}}
	for(var i=0;i<maxEcCount;i++){for(var r=0;r<rsBlocks.length;r++){if(i<ecdata[r].length){data[index++]=ecdata[r][i];}}}
	return data;};var QRMode={MODE_NUMBER:1<<0,MODE_ALPHA_NUM:1<<1,MODE_8BIT_BYTE:1<<2,MODE_KANJI:1<<3};var QRErrorCorrectLevel={L:1,M:0,Q:3,H:2};var QRMaskPattern={PATTERN000:0,PATTERN001:1,PATTERN010:2,PATTERN011:3,PATTERN100:4,PATTERN101:5,PATTERN110:6,PATTERN111:7};var QRUtil={PATTERN_POSITION_TABLE:[[],[6,18],[6,22],[6,26],[6,30],[6,34],[6,22,38],[6,24,42],[6,26,46],[6,28,50],[6,30,54],[6,32,58],[6,34,62],[6,26,46,66],[6,26,48,70],[6,26,50,74],[6,30,54,78],[6,30,56,82],[6,30,58,86],[6,34,62,90],[6,28,50,72,94],[6,26,50,74,98],[6,30,54,78,102],[6,28,54,80,106],[6,32,58,84,110],[6,30,58,86,114],[6,34,62,90,118],[6,26,50,74,98,122],[6,30,54,78,102,126],[6,26,52,78,104,130],[6,30,56,82,108,134],[6,34,60,86,112,138],[6,30,58,86,114,142],[6,34,62,90,118,146],[6,30,54,78,102,126,150],[6,24,50,76,102,128,154],[6,28,54,80,106,132,158],[6,32,58,84,110,136,162],[6,26,54,82,110,138,166],[6,30,58,86,114,142,170]],G15:(1<<10)|(1<<8)|(1<<5)|(1<<4)|(1<<2)|(1<<1)|(1<<0),G18:(1<<12)|(1<<11)|(1<<10)|(1<<9)|(1<<8)|(1<<5)|(1<<2)|(1<<0),G15_MASK:(1<<14)|(1<<12)|(1<<10)|(1<<4)|(1<<1),getBCHTypeInfo:function(data){var d=data<<10;while(QRUtil.getBCHDigit(d)-QRUtil.getBCHDigit(QRUtil.G15)>=0){d^=(QRUtil.G15<<(QRUtil.getBCHDigit(d)-QRUtil.getBCHDigit(QRUtil.G15)));}
	return((data<<10)|d)^QRUtil.G15_MASK;},getBCHTypeNumber:function(data){var d=data<<12;while(QRUtil.getBCHDigit(d)-QRUtil.getBCHDigit(QRUtil.G18)>=0){d^=(QRUtil.G18<<(QRUtil.getBCHDigit(d)-QRUtil.getBCHDigit(QRUtil.G18)));}
	return(data<<12)|d;},getBCHDigit:function(data){var digit=0;while(data!=0){digit++;data>>>=1;}
	return digit;},getPatternPosition:function(typeNumber){return QRUtil.PATTERN_POSITION_TABLE[typeNumber-1];},getMask:function(maskPattern,i,j){switch(maskPattern){case QRMaskPattern.PATTERN000:return(i+j)%2==0;case QRMaskPattern.PATTERN001:return i%2==0;case QRMaskPattern.PATTERN010:return j%3==0;case QRMaskPattern.PATTERN011:return(i+j)%3==0;case QRMaskPattern.PATTERN100:return(Math.floor(i/2)+Math.floor(j/3))%2==0;case QRMaskPattern.PATTERN101:return(i*j)%2+(i*j)%3==0;case QRMaskPattern.PATTERN110:return((i*j)%2+(i*j)%3)%2==0;case QRMaskPattern.PATTERN111:return((i*j)%3+(i+j)%2)%2==0;default:throw new Error("bad maskPattern:"+maskPattern);}},getErrorCorrectPolynomial:function(errorCorrectLength){var a=new QRPolynomial([1],0);for(var i=0;i<errorCorrectLength;i++){a=a.multiply(new QRPolynomial([1,QRMath.gexp(i)],0));}
	return a;},getLengthInBits:function(mode,type){if(1<=type&&type<10){switch(mode){case QRMode.MODE_NUMBER:return 10;case QRMode.MODE_ALPHA_NUM:return 9;case QRMode.MODE_8BIT_BYTE:return 8;case QRMode.MODE_KANJI:return 8;default:throw new Error("mode:"+mode);}}else if(type<27){switch(mode){case QRMode.MODE_NUMBER:return 12;case QRMode.MODE_ALPHA_NUM:return 11;case QRMode.MODE_8BIT_BYTE:return 16;case QRMode.MODE_KANJI:return 10;default:throw new Error("mode:"+mode);}}else if(type<41){switch(mode){case QRMode.MODE_NUMBER:return 14;case QRMode.MODE_ALPHA_NUM:return 13;case QRMode.MODE_8BIT_BYTE:return 16;case QRMode.MODE_KANJI:return 12;default:throw new Error("mode:"+mode);}}else{throw new Error("type:"+type);}},getLostPoint:function(qrCode){var moduleCount=qrCode.getModuleCount();var lostPoint=0;for(var row=0;row<moduleCount;row++){for(var col=0;col<moduleCount;col++){var sameCount=0;var dark=qrCode.isDark(row,col);for(var r=-1;r<=1;r++){if(row+r<0||moduleCount<=row+r){continue;}
	for(var c=-1;c<=1;c++){if(col+c<0||moduleCount<=col+c){continue;}
	if(r==0&&c==0){continue;}
	if(dark==qrCode.isDark(row+r,col+c)){sameCount++;}}}
	if(sameCount>5){lostPoint+=(3+sameCount-5);}}}
	for(var row=0;row<moduleCount-1;row++){for(var col=0;col<moduleCount-1;col++){var count=0;if(qrCode.isDark(row,col))count++;if(qrCode.isDark(row+1,col))count++;if(qrCode.isDark(row,col+1))count++;if(qrCode.isDark(row+1,col+1))count++;if(count==0||count==4){lostPoint+=3;}}}
	for(var row=0;row<moduleCount;row++){for(var col=0;col<moduleCount-6;col++){if(qrCode.isDark(row,col)&&!qrCode.isDark(row,col+1)&&qrCode.isDark(row,col+2)&&qrCode.isDark(row,col+3)&&qrCode.isDark(row,col+4)&&!qrCode.isDark(row,col+5)&&qrCode.isDark(row,col+6)){lostPoint+=40;}}}
	for(var col=0;col<moduleCount;col++){for(var row=0;row<moduleCount-6;row++){if(qrCode.isDark(row,col)&&!qrCode.isDark(row+1,col)&&qrCode.isDark(row+2,col)&&qrCode.isDark(row+3,col)&&qrCode.isDark(row+4,col)&&!qrCode.isDark(row+5,col)&&qrCode.isDark(row+6,col)){lostPoint+=40;}}}
	var darkCount=0;for(var col=0;col<moduleCount;col++){for(var row=0;row<moduleCount;row++){if(qrCode.isDark(row,col)){darkCount++;}}}
	var ratio=Math.abs(100*darkCount/moduleCount/moduleCount-50)/5;lostPoint+=ratio*10;return lostPoint;}};var QRMath={glog:function(n){if(n<1){throw new Error("glog("+n+")");}
	return QRMath.LOG_TABLE[n];},gexp:function(n){while(n<0){n+=255;}
	while(n>=256){n-=255;}
	return QRMath.EXP_TABLE[n];},EXP_TABLE:new Array(256),LOG_TABLE:new Array(256)};for(var i=0;i<8;i++){QRMath.EXP_TABLE[i]=1<<i;}
	for(var i=8;i<256;i++){QRMath.EXP_TABLE[i]=QRMath.EXP_TABLE[i-4]^QRMath.EXP_TABLE[i-5]^QRMath.EXP_TABLE[i-6]^QRMath.EXP_TABLE[i-8];}
	for(var i=0;i<255;i++){QRMath.LOG_TABLE[QRMath.EXP_TABLE[i]]=i;}
	function QRPolynomial(num,shift){if(num.length==undefined){throw new Error(num.length+"/"+shift);}
	var offset=0;while(offset<num.length&&num[offset]==0){offset++;}
	this.num=new Array(num.length-offset+shift);for(var i=0;i<num.length-offset;i++){this.num[i]=num[i+offset];}}
	QRPolynomial.prototype={get:function(index){return this.num[index];},getLength:function(){return this.num.length;},multiply:function(e){var num=new Array(this.getLength()+e.getLength()-1);for(var i=0;i<this.getLength();i++){for(var j=0;j<e.getLength();j++){num[i+j]^=QRMath.gexp(QRMath.glog(this.get(i))+QRMath.glog(e.get(j)));}}
	return new QRPolynomial(num,0);},mod:function(e){if(this.getLength()-e.getLength()<0){return this;}
	var ratio=QRMath.glog(this.get(0))-QRMath.glog(e.get(0));var num=new Array(this.getLength());for(var i=0;i<this.getLength();i++){num[i]=this.get(i);}
	for(var i=0;i<e.getLength();i++){num[i]^=QRMath.gexp(QRMath.glog(e.get(i))+ratio);}
	return new QRPolynomial(num,0).mod(e);}};function QRRSBlock(totalCount,dataCount){this.totalCount=totalCount;this.dataCount=dataCount;}
	QRRSBlock.RS_BLOCK_TABLE=[[1,26,19],[1,26,16],[1,26,13],[1,26,9],[1,44,34],[1,44,28],[1,44,22],[1,44,16],[1,70,55],[1,70,44],[2,35,17],[2,35,13],[1,100,80],[2,50,32],[2,50,24],[4,25,9],[1,134,108],[2,67,43],[2,33,15,2,34,16],[2,33,11,2,34,12],[2,86,68],[4,43,27],[4,43,19],[4,43,15],[2,98,78],[4,49,31],[2,32,14,4,33,15],[4,39,13,1,40,14],[2,121,97],[2,60,38,2,61,39],[4,40,18,2,41,19],[4,40,14,2,41,15],[2,146,116],[3,58,36,2,59,37],[4,36,16,4,37,17],[4,36,12,4,37,13],[2,86,68,2,87,69],[4,69,43,1,70,44],[6,43,19,2,44,20],[6,43,15,2,44,16],[4,101,81],[1,80,50,4,81,51],[4,50,22,4,51,23],[3,36,12,8,37,13],[2,116,92,2,117,93],[6,58,36,2,59,37],[4,46,20,6,47,21],[7,42,14,4,43,15],[4,133,107],[8,59,37,1,60,38],[8,44,20,4,45,21],[12,33,11,4,34,12],[3,145,115,1,146,116],[4,64,40,5,65,41],[11,36,16,5,37,17],[11,36,12,5,37,13],[5,109,87,1,110,88],[5,65,41,5,66,42],[5,54,24,7,55,25],[11,36,12],[5,122,98,1,123,99],[7,73,45,3,74,46],[15,43,19,2,44,20],[3,45,15,13,46,16],[1,135,107,5,136,108],[10,74,46,1,75,47],[1,50,22,15,51,23],[2,42,14,17,43,15],[5,150,120,1,151,121],[9,69,43,4,70,44],[17,50,22,1,51,23],[2,42,14,19,43,15],[3,141,113,4,142,114],[3,70,44,11,71,45],[17,47,21,4,48,22],[9,39,13,16,40,14],[3,135,107,5,136,108],[3,67,41,13,68,42],[15,54,24,5,55,25],[15,43,15,10,44,16],[4,144,116,4,145,117],[17,68,42],[17,50,22,6,51,23],[19,46,16,6,47,17],[2,139,111,7,140,112],[17,74,46],[7,54,24,16,55,25],[34,37,13],[4,151,121,5,152,122],[4,75,47,14,76,48],[11,54,24,14,55,25],[16,45,15,14,46,16],[6,147,117,4,148,118],[6,73,45,14,74,46],[11,54,24,16,55,25],[30,46,16,2,47,17],[8,132,106,4,133,107],[8,75,47,13,76,48],[7,54,24,22,55,25],[22,45,15,13,46,16],[10,142,114,2,143,115],[19,74,46,4,75,47],[28,50,22,6,51,23],[33,46,16,4,47,17],[8,152,122,4,153,123],[22,73,45,3,74,46],[8,53,23,26,54,24],[12,45,15,28,46,16],[3,147,117,10,148,118],[3,73,45,23,74,46],[4,54,24,31,55,25],[11,45,15,31,46,16],[7,146,116,7,147,117],[21,73,45,7,74,46],[1,53,23,37,54,24],[19,45,15,26,46,16],[5,145,115,10,146,116],[19,75,47,10,76,48],[15,54,24,25,55,25],[23,45,15,25,46,16],[13,145,115,3,146,116],[2,74,46,29,75,47],[42,54,24,1,55,25],[23,45,15,28,46,16],[17,145,115],[10,74,46,23,75,47],[10,54,24,35,55,25],[19,45,15,35,46,16],[17,145,115,1,146,116],[14,74,46,21,75,47],[29,54,24,19,55,25],[11,45,15,46,46,16],[13,145,115,6,146,116],[14,74,46,23,75,47],[44,54,24,7,55,25],[59,46,16,1,47,17],[12,151,121,7,152,122],[12,75,47,26,76,48],[39,54,24,14,55,25],[22,45,15,41,46,16],[6,151,121,14,152,122],[6,75,47,34,76,48],[46,54,24,10,55,25],[2,45,15,64,46,16],[17,152,122,4,153,123],[29,74,46,14,75,47],[49,54,24,10,55,25],[24,45,15,46,46,16],[4,152,122,18,153,123],[13,74,46,32,75,47],[48,54,24,14,55,25],[42,45,15,32,46,16],[20,147,117,4,148,118],[40,75,47,7,76,48],[43,54,24,22,55,25],[10,45,15,67,46,16],[19,148,118,6,149,119],[18,75,47,31,76,48],[34,54,24,34,55,25],[20,45,15,61,46,16]];QRRSBlock.getRSBlocks=function(typeNumber,errorCorrectLevel){var rsBlock=QRRSBlock.getRsBlockTable(typeNumber,errorCorrectLevel);if(rsBlock==undefined){throw new Error("bad rs block @ typeNumber:"+typeNumber+"/errorCorrectLevel:"+errorCorrectLevel);}
	var length=rsBlock.length/3;var list=[];for(var i=0;i<length;i++){var count=rsBlock[i*3+0];var totalCount=rsBlock[i*3+1];var dataCount=rsBlock[i*3+2];for(var j=0;j<count;j++){list.push(new QRRSBlock(totalCount,dataCount));}}
	return list;};QRRSBlock.getRsBlockTable=function(typeNumber,errorCorrectLevel){switch(errorCorrectLevel){case QRErrorCorrectLevel.L:return QRRSBlock.RS_BLOCK_TABLE[(typeNumber-1)*4+0];case QRErrorCorrectLevel.M:return QRRSBlock.RS_BLOCK_TABLE[(typeNumber-1)*4+1];case QRErrorCorrectLevel.Q:return QRRSBlock.RS_BLOCK_TABLE[(typeNumber-1)*4+2];case QRErrorCorrectLevel.H:return QRRSBlock.RS_BLOCK_TABLE[(typeNumber-1)*4+3];default:return undefined;}};function QRBitBuffer(){this.buffer=[];this.length=0;}
	QRBitBuffer.prototype={get:function(index){var bufIndex=Math.floor(index/8);return((this.buffer[bufIndex]>>>(7-index%8))&1)==1;},put:function(num,length){for(var i=0;i<length;i++){this.putBit(((num>>>(length-i-1))&1)==1);}},getLengthInBits:function(){return this.length;},putBit:function(bit){var bufIndex=Math.floor(this.length/8);if(this.buffer.length<=bufIndex){this.buffer.push(0);}
	if(bit){this.buffer[bufIndex]|=(0x80>>>(this.length%8));}
	this.length++;}};var QRCodeLimitLength=[[17,14,11,7],[32,26,20,14],[53,42,32,24],[78,62,46,34],[106,84,60,44],[134,106,74,58],[154,122,86,64],[192,152,108,84],[230,180,130,98],[271,213,151,119],[321,251,177,137],[367,287,203,155],[425,331,241,177],[458,362,258,194],[520,412,292,220],[586,450,322,250],[644,504,364,280],[718,560,394,310],[792,624,442,338],[858,666,482,382],[929,711,509,403],[1003,779,565,439],[1091,857,611,461],[1171,911,661,511],[1273,997,715,535],[1367,1059,751,593],[1465,1125,805,625],[1528,1190,868,658],[1628,1264,908,698],[1732,1370,982,742],[1840,1452,1030,790],[1952,1538,1112,842],[2068,1628,1168,898],[2188,1722,1228,958],[2303,1809,1283,983],[2431,1911,1351,1051],[2563,1989,1423,1093],[2699,2099,1499,1139],[2809,2213,1579,1219],[2953,2331,1663,1273]];
	
	function _isSupportCanvas() {
		return typeof CanvasRenderingContext2D != "undefined";
	}
	
	// android 2.x doesn't support Data-URI spec
	function _getAndroid() {
		var android = false;
		var sAgent = navigator.userAgent;
		
		if (/android/i.test(sAgent)) { // android
			android = true;
			aMat = sAgent.toString().match(/android ([0-9]\.[0-9])/i);
			
			if (aMat && aMat[1]) {
				android = parseFloat(aMat[1]);
			}
		}
		
		return android;
	}
	
	var svgDrawer = (function() {

		var Drawing = function (el, htOption) {
			this._el = el;
			this._htOption = htOption;
		};

		Drawing.prototype.draw = function (oQRCode) {
			var _htOption = this._htOption;
			var _el = this._el;
			var nCount = oQRCode.getModuleCount();
			var nWidth = Math.floor(_htOption.width / nCount);
			var nHeight = Math.floor(_htOption.height / nCount);

			this.clear();

			function makeSVG(tag, attrs) {
				var el = document.createElementNS('http://www.w3.org/2000/svg', tag);
				for (var k in attrs)
					if (attrs.hasOwnProperty(k)) el.setAttribute(k, attrs[k]);
				return el;
			}

			var svg = makeSVG("svg" , {'viewBox': '0 0 ' + String(nCount) + " " + String(nCount), 'width': '100%', 'height': '100%', 'fill': _htOption.colorLight});
			svg.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", "http://www.w3.org/1999/xlink");
			_el.appendChild(svg);

			svg.appendChild(makeSVG("rect", {"fill": _htOption.colorDark, "width": "1", "height": "1", "id": "template"}));

			for (var row = 0; row < nCount; row++) {
				for (var col = 0; col < nCount; col++) {
					if (oQRCode.isDark(row, col)) {
						var child = makeSVG("use", {"x": String(row), "y": String(col)});
						child.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#template")
						svg.appendChild(child);
					}
				}
			}
		};
		Drawing.prototype.clear = function () {
			while (this._el.hasChildNodes())
				this._el.removeChild(this._el.lastChild);
		};
		return Drawing;
	})();

	var useSVG = document.documentElement.tagName.toLowerCase() === "svg";

	// Drawing in DOM by using Table tag
	var Drawing = useSVG ? svgDrawer : !_isSupportCanvas() ? (function () {
		var Drawing = function (el, htOption) {
			this._el = el;
			this._htOption = htOption;
		};
			
		/**
		 * Draw the QRCode
		 * 
		 * @param {QRCode} oQRCode
		 */
		Drawing.prototype.draw = function (oQRCode) {
            var _htOption = this._htOption;
            var _el = this._el;
			var nCount = oQRCode.getModuleCount();
			var nWidth = Math.floor(_htOption.width / nCount);
			var nHeight = Math.floor(_htOption.height / nCount);
			var aHTML = ['<table style="border:0;border-collapse:collapse;">'];
			
			for (var row = 0; row < nCount; row++) {
				aHTML.push('<tr>');
				
				for (var col = 0; col < nCount; col++) {
					aHTML.push('<td style="border:0;border-collapse:collapse;padding:0;margin:0;width:' + nWidth + 'px;height:' + nHeight + 'px;background-color:' + (oQRCode.isDark(row, col) ? _htOption.colorDark : _htOption.colorLight) + ';"></td>');
				}
				
				aHTML.push('</tr>');
			}
			
			aHTML.push('</table>');
			_el.innerHTML = aHTML.join('');
			
			// Fix the margin values as real size.
			var elTable = _el.childNodes[0];
			var nLeftMarginTable = (_htOption.width - elTable.offsetWidth) / 2;
			var nTopMarginTable = (_htOption.height - elTable.offsetHeight) / 2;
			
			if (nLeftMarginTable > 0 && nTopMarginTable > 0) {
				elTable.style.margin = nTopMarginTable + "px " + nLeftMarginTable + "px";	
			}
		};
		
		/**
		 * Clear the QRCode
		 */
		Drawing.prototype.clear = function () {
			this._el.innerHTML = '';
		};
		
		return Drawing;
	})() : (function () { // Drawing in Canvas
		function _onMakeImage() {
			this._elImage.src = this._elCanvas.toDataURL("image/png");
			this._elImage.style.display = "block";
			this._elCanvas.style.display = "none";			
		}
		
		// Android 2.1 bug workaround
		// http://code.google.com/p/android/issues/detail?id=5141
		if (this._android && this._android <= 2.1) {
	    	var factor = 1 / window.devicePixelRatio;
	        var drawImage = CanvasRenderingContext2D.prototype.drawImage; 
	    	CanvasRenderingContext2D.prototype.drawImage = function (image, sx, sy, sw, sh, dx, dy, dw, dh) {
	    		if (("nodeName" in image) && /img/i.test(image.nodeName)) {
		        	for (var i = arguments.length - 1; i >= 1; i--) {
		            	arguments[i] = arguments[i] * factor;
		        	}
	    		} else if (typeof dw == "undefined") {
	    			arguments[1] *= factor;
	    			arguments[2] *= factor;
	    			arguments[3] *= factor;
	    			arguments[4] *= factor;
	    		}
	    		
	        	drawImage.apply(this, arguments); 
	    	};
		}
		
		/**
		 * Check whether the user's browser supports Data URI or not
		 * 
		 * @private
		 * @param {Function} fSuccess Occurs if it supports Data URI
		 * @param {Function} fFail Occurs if it doesn't support Data URI
		 */
		function _safeSetDataURI(fSuccess, fFail) {
            var self = this;
            self._fFail = fFail;
            self._fSuccess = fSuccess;

            // Check it just once
            if (self._bSupportDataURI === null) {
                var el = document.createElement("img");
                var fOnError = function() {
                    self._bSupportDataURI = false;

                    if (self._fFail) {
                        _fFail.call(self);
                    }
                };
                var fOnSuccess = function() {
                    self._bSupportDataURI = true;

                    if (self._fSuccess) {
                        self._fSuccess.call(self);
                    }
                };

                el.onabort = fOnError;
                el.onerror = fOnError;
                el.onload = fOnSuccess;
                el.src = "data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg=="; // the Image contains 1px data.
                return;
            } else if (self._bSupportDataURI === true && self._fSuccess) {
                self._fSuccess.call(self);
            } else if (self._bSupportDataURI === false && self._fFail) {
                self._fFail.call(self);
            }
		};
		
		/**
		 * Drawing QRCode by using canvas
		 * 
		 * @constructor
		 * @param {HTMLElement} el
		 * @param {Object} htOption QRCode Options 
		 */
		var Drawing = function (el, htOption) {
    		this._bIsPainted = false;
    		this._android = _getAndroid();
		
			this._htOption = htOption;
			this._elCanvas = document.createElement("canvas");
			this._elCanvas.width = htOption.width;
			this._elCanvas.height = htOption.height;
			el.appendChild(this._elCanvas);
			this._el = el;
			this._oContext = this._elCanvas.getContext("2d");
			this._bIsPainted = false;
			this._elImage = document.createElement("img");
			this._elImage.alt = "Scan me!";
			this._elImage.style.display = "none";
			this._el.appendChild(this._elImage);
			this._bSupportDataURI = null;
		};
			
		/**
		 * Draw the QRCode
		 * 
		 * @param {QRCode} oQRCode 
		 */
		Drawing.prototype.draw = function (oQRCode) {
            var _elImage = this._elImage;
            var _oContext = this._oContext;
            var _htOption = this._htOption;
            
			var nCount = oQRCode.getModuleCount();
			var nWidth = _htOption.width / nCount;
			var nHeight = _htOption.height / nCount;
			var nRoundedWidth = Math.round(nWidth);
			var nRoundedHeight = Math.round(nHeight);

			_elImage.style.display = "none";
			this.clear();
			
			for (var row = 0; row < nCount; row++) {
				for (var col = 0; col < nCount; col++) {
					var bIsDark = oQRCode.isDark(row, col);
					var nLeft = col * nWidth;
					var nTop = row * nHeight;
					_oContext.strokeStyle = bIsDark ? _htOption.colorDark : _htOption.colorLight;
					_oContext.lineWidth = 1;
					_oContext.fillStyle = bIsDark ? _htOption.colorDark : _htOption.colorLight;					
					_oContext.fillRect(nLeft, nTop, nWidth, nHeight);
					
					//    
					_oContext.strokeRect(
						Math.floor(nLeft) + 0.5,
						Math.floor(nTop) + 0.5,
						nRoundedWidth,
						nRoundedHeight
					);
					
					_oContext.strokeRect(
						Math.ceil(nLeft) - 0.5,
						Math.ceil(nTop) - 0.5,
						nRoundedWidth,
						nRoundedHeight
					);
				}
			}
			
			this._bIsPainted = true;
		};
			
		/**
		 * Make the image from Canvas if the browser supports Data URI.
		 */
		Drawing.prototype.makeImage = function () {
			if (this._bIsPainted) {
				_safeSetDataURI.call(this, _onMakeImage);
			}
		};
			
		/**
		 * Return whether the QRCode is painted or not
		 * 
		 * @return {Boolean}
		 */
		Drawing.prototype.isPainted = function () {
			return this._bIsPainted;
		};
		
		/**
		 * Clear the QRCode
		 */
		Drawing.prototype.clear = function () {
			this._oContext.clearRect(0, 0, this._elCanvas.width, this._elCanvas.height);
			this._bIsPainted = false;
		};
		
		/**
		 * @private
		 * @param {Number} nNumber
		 */
		Drawing.prototype.round = function (nNumber) {
			if (!nNumber) {
				return nNumber;
			}
			
			return Math.floor(nNumber * 1000) / 1000;
		};
		
		return Drawing;
	})();
	
	/**
	 * Get the type by string length
	 * 
	 * @private
	 * @param {String} sText
	 * @param {Number} nCorrectLevel
	 * @return {Number} type
	 */
	function _getTypeNumber(sText, nCorrectLevel) {			
		var nType = 1;
		var length = _getUTF8Length(sText);
		
		for (var i = 0, len = QRCodeLimitLength.length; i <= len; i++) {
			var nLimit = 0;
			
			switch (nCorrectLevel) {
				case QRErrorCorrectLevel.L :
					nLimit = QRCodeLimitLength[i][0];
					break;
				case QRErrorCorrectLevel.M :
					nLimit = QRCodeLimitLength[i][1];
					break;
				case QRErrorCorrectLevel.Q :
					nLimit = QRCodeLimitLength[i][2];
					break;
				case QRErrorCorrectLevel.H :
					nLimit = QRCodeLimitLength[i][3];
					break;
			}
			
			if (length <= nLimit) {
				break;
			} else {
				nType++;
			}
		}
		
		if (nType > QRCodeLimitLength.length) {
			throw new Error("Too long data");
		}
		
		return nType;
	}

	function _getUTF8Length(sText) {
		var replacedText = encodeURI(sText).toString().replace(/\%[0-9a-fA-F]{2}/g, 'a');
		return replacedText.length + (replacedText.length != sText ? 3 : 0);
	}
	
	/**
	 * @class QRCode
	 * @constructor
	 * @example 
	 * new QRCode(document.getElementById("test"), "http://jindo.dev.naver.com/collie");
	 *
	 * @example
	 * var oQRCode = new QRCode("test", {
	 *    text : "http://naver.com",
	 *    width : 128,
	 *    height : 128
	 * });
	 * 
	 * oQRCode.clear(); // Clear the QRCode.
	 * oQRCode.makeCode("http://map.naver.com"); // Re-create the QRCode.
	 *
	 * @param {HTMLElement|String} el target element or 'id' attribute of element.
	 * @param {Object|String} vOption
	 * @param {String} vOption.text QRCode link data
	 * @param {Number} [vOption.width=256]
	 * @param {Number} [vOption.height=256]
	 * @param {String} [vOption.colorDark="#000000"]
	 * @param {String} [vOption.colorLight="#ffffff"]
	 * @param {QRCode.CorrectLevel} [vOption.correctLevel=QRCode.CorrectLevel.H] [L|M|Q|H] 
	 */
	QRCode = function (el, vOption) {
		this._htOption = {
			width : 256, 
			height : 256,
			typeNumber : 4,
			colorDark : "#000000",
			colorLight : "#ffffff",
			correctLevel : QRErrorCorrectLevel.H
		};
		
		if (typeof vOption === 'string') {
			vOption	= {
				text : vOption
			};
		}
		
		// Overwrites options
		if (vOption) {
			for (var i in vOption) {
				this._htOption[i] = vOption[i];
			}
		}
		
		if (typeof el == "string") {
			el = document.getElementById(el);
		}
		
		this._android = _getAndroid();
		this._el = el;
		this._oQRCode = null;
		this._oDrawing = new Drawing(this._el, this._htOption);
		
		if (this._htOption.text) {
			this.makeCode(this._htOption.text);	
		}
	};
	
	/**
	 * Make the QRCode
	 * 
	 * @param {String} sText link data
	 */
	QRCode.prototype.makeCode = function (sText) {
		this._oQRCode = new QRCodeModel(_getTypeNumber(sText, this._htOption.correctLevel), this._htOption.correctLevel);
		this._oQRCode.addData(sText);
		this._oQRCode.make();
		this._el.title = sText;
		this._oDrawing.draw(this._oQRCode);			
		this.makeImage();
	};
	
	/**
	 * Make the Image from Canvas element
	 * - It occurs automatically
	 * - Android below 3 doesn't support Data-URI spec.
	 * 
	 * @private
	 */
	QRCode.prototype.makeImage = function () {
		if (typeof this._oDrawing.makeImage == "function" && (!this._android || this._android >= 3)) {
			this._oDrawing.makeImage();
		}
	};
	
	/**
	 * Clear the QRCode
	 */
	QRCode.prototype.clear = function () {
		this._oDrawing.clear();
	};
	
	/**
	 * @name QRCode.CorrectLevel
	 */
	QRCode.CorrectLevel = QRErrorCorrectLevel;
})();
/*! Cookies.js - 0.4.0; Copyright (c) 2014, Scott Hamper; http://www.opensource.org/licenses/MIT */

(function(e){"use strict";var b=function(a,d,c){return 1===arguments.length?b.get(a):b.set(a,d,c)};b._document=document;b._navigator=navigator;b.defaults={path:"/"};b.get=function(a){b._cachedDocumentCookie!==b._document.cookie&&b._renewCache();return b._cache[a]};b.set=function(a,d,c){c=b._getExtendedOptions(c);c.expires=b._getExpiresDate(d===e?-1:c.expires);b._document.cookie=b._generateCookieString(a,d,c);return b};b.expire=function(a,d){return b.set(a,e,d)};b._getExtendedOptions=function(a){return{path:a&& a.path||b.defaults.path,domain:a&&a.domain||b.defaults.domain,expires:a&&a.expires||b.defaults.expires,secure:a&&a.secure!==e?a.secure:b.defaults.secure}};b._isValidDate=function(a){return"[object Date]"===Object.prototype.toString.call(a)&&!isNaN(a.getTime())};b._getExpiresDate=function(a,d){d=d||new Date;switch(typeof a){case "number":a=new Date(d.getTime()+1E3*a);break;case "string":a=new Date(a)}if(a&&!b._isValidDate(a))throw Error("`expires` parameter cannot be converted to a valid Date instance"); return a};b._generateCookieString=function(a,b,c){a=a.replace(/[^#$&+\^`|]/g,encodeURIComponent);a=a.replace(/\(/g,"%28").replace(/\)/g,"%29");b=(b+"").replace(/[^!#$&-+\--:<-\[\]-~]/g,encodeURIComponent);c=c||{};a=a+"="+b+(c.path?";path="+c.path:"");a+=c.domain?";domain="+c.domain:"";a+=c.expires?";expires="+c.expires.toUTCString():"";return a+=c.secure?";secure":""};b._getCookieObjectFromString=function(a){var d={};a=a?a.split("; "):[];for(var c=0;c<a.length;c++){var f=b._getKeyValuePairFromCookieString(a[c]); d[f.key]===e&&(d[f.key]=f.value)}return d};b._getKeyValuePairFromCookieString=function(a){var b=a.indexOf("="),b=0>b?a.length:b;return{key:decodeURIComponent(a.substr(0,b)),value:decodeURIComponent(a.substr(b+1))}};b._renewCache=function(){b._cache=b._getCookieObjectFromString(b._document.cookie);b._cachedDocumentCookie=b._document.cookie};b._areEnabled=function(){var a="1"===b.set("cookies.js",1).get("cookies.js");b.expire("cookies.js");return a};b.enabled=b._areEnabled();"function"===typeof define&& define.amd?define(function(){return b}):"undefined"!==typeof exports?("undefined"!==typeof module&&module.exports&&(exports=module.exports=b),exports.Cookies=b):window.Cookies=b})();
(function() {
  var Notifier,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Notifier = (function() {
    function Notifier() {
      this["switch"] = __bind(this["switch"], this);
      this.checkOrRequirePermission = __bind(this.checkOrRequirePermission, this);
      if (!window.Notification) {
        this.removeSwitch();
      }
      this.getState();
      this.checkOrRequirePermission();
      $('input[name="notification-checkbox"]').bootstrapSwitch({
        labelText: gon.i18n["switch"].notification,
        state: this.switchOn(),
        onSwitchChange: this["switch"]
      });
    }

    Notifier.prototype.checkOrRequirePermission = function() {
      if (this.switchOn()) {
        if (Notification.permission === 'default') {
          return this.requestPermission(this.checkOrRequirePermission);
        } else if (Notification.permission === 'denied') {
          this.setStatus(false);
          return this.removeSwitch();
        }
      }
    };

    Notifier.prototype.removeSwitch = function() {
      return $('.desktop-real-notification').remove();
    };

    Notifier.prototype.setState = function(status) {
      this.enableNotification = status;
      return Cookies.set('notification', status, 30);
    };

    Notifier.prototype.getState = function() {
      return this.enableNotification = Cookies.get('notification');
    };

    Notifier.prototype.requestPermission = function(callback) {
      return Notification.requestPermission(callback);
    };

    Notifier.prototype["switch"] = function(event, state) {
      if (state) {
        this.setState(true);
        return this.checkOrRequirePermission();
      } else {
        return this.setState(false);
      }
    };

    Notifier.prototype.switchOn = function() {
      if (this.getState() === "true") {
        return true;
      } else {
        return false;
      }
    };

    Notifier.prototype.notify = function(title, content, logo) {
      var popup;
      if (logo == null) {
        logo = '/peatio-notification-logo.png';
      }
      if (this.enableNotification === true || this.enableNotification === "true") {
        if (window.Notification) {
          popup = new Notification(title, {
            'body': content,
            'onclick': onclick,
            'icon': logo
          });
        } else {
          popup = window.webkitNotifications.createNotification(avatar, title, content);
        }
        return setTimeout(((function(_this) {
          return function() {
            return popup.close();
          };
        })(this)), 8000);
      }
    };

    return Notifier;

  })();

  window.Notifier = Notifier;

}).call(this);
(function() {
  var pusher;

  pusher = new Pusher(gon.pusher.key, {
    encrypted: gon.pusher.encrypted,
    wsHost: gon.pusher.wsHost,
    wsPort: gon.pusher.wsPort,
    wssPort: gon.pusher.wssPort
  });

  window.pusher = pusher;

}).call(this);
/*
 * jQuery Tiny Pub/Sub
 * https://github.com/cowboy/jquery-tiny-pubsub
 *
 * Copyright (c) 2013 "Cowboy" Ben Alman
 * Licensed under the MIT license.
 */


(function($) {

  var o = $({});

  $.subscribe = function() {
    o.on.apply(o, arguments);
  };

  $.unsubscribe = function() {
    o.off.apply(o, arguments);
  };

  $.publish = function() {
    o.trigger.apply(o, arguments);
  };

}(jQuery));
/**
 * @license Highcharts JS v5aaca1890988fc7073f112a2ff1556645b8dda5e (2018-01-26)
 *
 * (c) 2009-2016 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
'use strict';
(function (root, factory) {
if (typeof module === 'object' && module.exports) {
module.exports = root.document ?
factory(root) : 
factory;
} else {
root.Highcharts = factory(root);
}
}(typeof window !== 'undefined' ? window : this, function (win) {
var Highcharts = (function () {
/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
/* global win, window */

// glob is a temporary fix to allow our es-modules to work.
var glob = typeof win === 'undefined' ? window : win,
	doc = glob.document,
	SVG_NS = 'http://www.w3.org/2000/svg',
	userAgent = (glob.navigator && glob.navigator.userAgent) || '',
	svg = doc && doc.createElementNS && !!doc.createElementNS(SVG_NS, 'svg').createSVGRect,
	isMS = /(edge|msie|trident)/i.test(userAgent) && !glob.opera,
	isFirefox = /Firefox/.test(userAgent),
	hasBidiBug = isFirefox && parseInt(userAgent.split('Firefox/')[1], 10) < 4; // issue #38;

var Highcharts = glob.Highcharts ? glob.Highcharts.error(16, true) : {
	product: 'Highcharts',
	version: '5aaca1890988fc7073f112a2ff1556645b8dda5e',
	deg2rad: Math.PI * 2 / 360,
	doc: doc,
	hasBidiBug: hasBidiBug,
	hasTouch: doc && doc.documentElement.ontouchstart !== undefined,
	isMS: isMS,
	isWebKit: /AppleWebKit/.test(userAgent),
	isFirefox: isFirefox,
	isTouchDevice: /(Mobile|Android|Windows Phone)/.test(userAgent),
	SVG_NS: SVG_NS,
	chartCount: 0,
	seriesTypes: {},
	symbolSizes: {},
	svg: svg,
	win: glob,
	marginNames: ['plotTop', 'marginRight', 'marginBottom', 'plotLeft'],
	noop: function () {
		return undefined;
	},
	/**
	 * An array containing the current chart objects in the page. A chart's
	 * position in the array is preserved throughout the page's lifetime. When
	 * a chart is destroyed, the array item becomes `undefined`.
	 * @type {Array.<Highcharts.Chart>}
	 * @memberOf Highcharts
	 */
	charts: []
};
return Highcharts;
}());
(function (H) {
/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
/* eslint max-len: ["warn", 80, 4] */

/**
 * The Highcharts object is the placeholder for all other members, and various
 * utility functions. The most important member of the namespace would be the
 * chart constructor.
 *
 * @example
 * var chart = Highcharts.chart('container', { ... });
 * 
 * @namespace Highcharts
 */

H.timers = [];

var charts = H.charts,
	doc = H.doc,
	win = H.win;

/**
 * Provide error messages for debugging, with links to online explanation. This
 * function can be overridden to provide custom error handling.
 *
 * @function #error
 * @memberOf Highcharts
 * @param {Number|String} code - The error code. See [errors.xml]{@link 
 *     https://github.com/highcharts/highcharts/blob/master/errors/errors.xml}
 *     for available codes. If it is a string, the error message is printed
 *     directly in the console.
 * @param {Boolean} [stop=false] - Whether to throw an error or just log a 
 *     warning in the console.
 *
 * @sample highcharts/chart/highcharts-error/ Custom error handler
 */
H.error = function (code, stop) {
	var msg = H.isNumber(code) ?
		'Highcharts error #' + code + ': www.highcharts.com/errors/' + code :
		code;
	if (stop) {
		throw new Error(msg);
	}
	// else ...
	if (win.console) {
		console.log(msg); // eslint-disable-line no-console
	}
};

/**
 * An animator object used internally. One instance applies to one property
 * (attribute or style prop) on one element. Animation is always initiated
 * through {@link SVGElement#animate}.
 *
 * @constructor Fx
 * @memberOf Highcharts
 * @param {HTMLDOMElement|SVGElement} elem - The element to animate.
 * @param {AnimationOptions} options - Animation options.
 * @param {string} prop - The single attribute or CSS property to animate.
 * @private
 *
 * @example
 * var rect = renderer.rect(0, 0, 10, 10).add();
 * rect.animate({ width: 100 });
 */
H.Fx = function (elem, options, prop) {
	this.options = options;
	this.elem = elem;
	this.prop = prop;
};
H.Fx.prototype = {
	
	/**
	 * Set the current step of a path definition on SVGElement.
	 *
	 * @function #dSetter
	 * @memberOf Highcharts.Fx
	 */
	dSetter: function () {
		var start = this.paths[0],
			end = this.paths[1],
			ret = [],
			now = this.now,
			i = start.length,
			startVal;

		// Land on the final path without adjustment points appended in the ends
		if (now === 1) {
			ret = this.toD;

		} else if (i === end.length && now < 1) {
			while (i--) {
				startVal = parseFloat(start[i]);
				ret[i] =
					isNaN(startVal) ? // a letter instruction like M or L
							end[i] :
							now * (parseFloat(end[i] - startVal)) + startVal;

			}
		// If animation is finished or length not matching, land on right value
		} else {
			ret = end;
		}
		this.elem.attr('d', ret, null, true);
	},

	/**
	 * Update the element with the current animation step.
	 *
	 * @function #update
	 * @memberOf Highcharts.Fx
	 */
	update: function () {
		var elem = this.elem,
			prop = this.prop, // if destroyed, it is null
			now = this.now,
			step = this.options.step;

		// Animation setter defined from outside
		if (this[prop + 'Setter']) {
			this[prop + 'Setter']();

		// Other animations on SVGElement
		} else if (elem.attr) {
			if (elem.element) {
				elem.attr(prop, now, null, true);
			}

		// HTML styles, raw HTML content like container size
		} else {
			elem.style[prop] = now + this.unit;
		}
		
		if (step) {
			step.call(elem, now, this);
		}

	},

	/**
	 * Run an animation.
	 *
	 * @function #run
	 * @memberOf Highcharts.Fx
	 * @param {Number} from - The current value, value to start from.
	 * @param {Number} to - The end value, value to land on.
	 * @param {String} [unit] - The property unit, for example `px`.
	 * 
	 */
	run: function (from, to, unit) {
		var self = this,
			options = self.options,
			timer = function (gotoEnd) {
				return timer.stopped ? false : self.step(gotoEnd);
			},
			requestAnimationFrame =
				win.requestAnimationFrame ||
				function (step) {
					setTimeout(step, 13);
				},
			step = function () {
				for (var i = 0; i < H.timers.length; i++) {
					if (!H.timers[i]()) {
						H.timers.splice(i--, 1);
					}
				}

				if (H.timers.length) {
					requestAnimationFrame(step);
				}
			};

		if (from === to) {
			delete options.curAnim[this.prop];
			if (options.complete && H.keys(options.curAnim).length === 0) {
				options.complete.call(this.elem);
			}
		} else { // #7166
			this.startTime = +new Date();
			this.start = from;
			this.end = to;
			this.unit = unit;
			this.now = this.start;
			this.pos = 0;

			timer.elem = this.elem;
			timer.prop = this.prop;

			if (timer() && H.timers.push(timer) === 1) {
				requestAnimationFrame(step);
			}
		}
	},
	
	/**
	 * Run a single step in the animation.
	 *
	 * @function #step
	 * @memberOf Highcharts.Fx
	 * @param   {Boolean} [gotoEnd] - Whether to go to the endpoint of the
	 *     animation after abort.
	 * @returns {Boolean} Returns `true` if animation continues.
	 */
	step: function (gotoEnd) {
		var t = +new Date(),
			ret,
			done,
			options = this.options,
			elem = this.elem,
			complete = options.complete,
			duration = options.duration,
			curAnim = options.curAnim;

		if (elem.attr && !elem.element) { // #2616, element is destroyed
			ret = false;

		} else if (gotoEnd || t >= duration + this.startTime) {
			this.now = this.end;
			this.pos = 1;
			this.update();

			curAnim[this.prop] = true;

			done = true;
			
			H.objectEach(curAnim, function (val) {
				if (val !== true) {
					done = false;
				}
			});

			if (done && complete) {
				complete.call(elem);
			}
			ret = false;

		} else {
			this.pos = options.easing((t - this.startTime) / duration);
			this.now = this.start + ((this.end - this.start) * this.pos);
			this.update();
			ret = true;
		}
		return ret;
	},

	/**
	 * Prepare start and end values so that the path can be animated one to one.
	 *
	 * @function #initPath
	 * @memberOf Highcharts.Fx
	 * @param {SVGElement} elem - The SVGElement item.
	 * @param {String} fromD - Starting path definition.
	 * @param {Array} toD - Ending path definition.
	 * @returns {Array} An array containing start and end paths in array form
	 * so that they can be animated in parallel.
	 */
	initPath: function (elem, fromD, toD) {
		fromD = fromD || '';
		var shift,
			startX = elem.startX,
			endX = elem.endX,
			bezier = fromD.indexOf('C') > -1,
			numParams = bezier ? 7 : 3,
			fullLength,
			slice,
			i,
			start = fromD.split(' '),
			end = toD.slice(), // copy
			isArea = elem.isArea,
			positionFactor = isArea ? 2 : 1,
			reverse;

		/**
		 * In splines make moveTo and lineTo points have six parameters like
		 * bezier curves, to allow animation one-to-one.
		 */
		function sixify(arr) {
			var isOperator,
				nextIsOperator;
			i = arr.length;
			while (i--) {

				// Fill in dummy coordinates only if the next operator comes
				// three places behind (#5788)
				isOperator = arr[i] === 'M' || arr[i] === 'L';
				nextIsOperator = /[a-zA-Z]/.test(arr[i + 3]);
				if (isOperator && nextIsOperator) {
					arr.splice(
						i + 1, 0,
						arr[i + 1], arr[i + 2],
						arr[i + 1], arr[i + 2]
					);
				}
			}
		}

		/**
		 * Insert an array at the given position of another array
		 */
		function insertSlice(arr, subArr, index) {
			[].splice.apply(
				arr,
				[index, 0].concat(subArr)
			);
		}

		/**
		 * If shifting points, prepend a dummy point to the end path. 
		 */
		function prepend(arr, other) {
			while (arr.length < fullLength) {
				
				// Move to, line to or curve to?
				arr[0] = other[fullLength - arr.length];

				// Prepend a copy of the first point
				insertSlice(arr, arr.slice(0, numParams), 0);	

				// For areas, the bottom path goes back again to the left, so we
				// need to append a copy of the last point.
				if (isArea) {
					insertSlice(
						arr,
						arr.slice(arr.length - numParams), arr.length
					);
					i--;
				}
			}
			arr[0] = 'M';
		}

		/**
		 * Copy and append last point until the length matches the end length
		 */
		function append(arr, other) {
			var i = (fullLength - arr.length) / numParams;
			while (i > 0 && i--) {

				// Pull out the slice that is going to be appended or inserted.
				// In a line graph, the positionFactor is 1, and the last point
				// is sliced out. In an area graph, the positionFactor is 2,
				// causing the middle two points to be sliced out, since an area
				// path starts at left, follows the upper path then turns and
				// follows the bottom back. 
				slice = arr.slice().splice(
					(arr.length / positionFactor) - numParams, 
					numParams * positionFactor
				);

				// Move to, line to or curve to?
				slice[0] = other[fullLength - numParams - (i * numParams)];
				
				// Disable first control point
				if (bezier) {
					slice[numParams - 6] = slice[numParams - 2];
					slice[numParams - 5] = slice[numParams - 1];
				}
				
				// Now insert the slice, either in the middle (for areas) or at
				// the end (for lines)
				insertSlice(arr, slice, arr.length / positionFactor);

				if (isArea) {
					i--;
				}
			}
		}

		if (bezier) {
			sixify(start);
			sixify(end);
		}

		// For sideways animation, find out how much we need to shift to get the
		// start path Xs to match the end path Xs.
		if (startX && endX) {
			for (i = 0; i < startX.length; i++) {
				// Moving left, new points coming in on right
				if (startX[i] === endX[0]) {
					shift = i;
					break;
				// Moving right
				} else if (startX[0] ===
						endX[endX.length - startX.length + i]) {
					shift = i;
					reverse = true;
					break;
				}
			}
			if (shift === undefined) {
				start = [];
			}
		}

		if (start.length && H.isNumber(shift)) {

			// The common target length for the start and end array, where both 
			// arrays are padded in opposite ends
			fullLength = end.length + shift * positionFactor * numParams;
			
			if (!reverse) {
				prepend(end, start);
				append(start, end);
			} else {
				prepend(start, end);
				append(end, start);
			}
		}

		return [start, end];
	}
}; // End of Fx prototype

/**
 * Handle animation of the color attributes directly.
 */
H.Fx.prototype.fillSetter = 
H.Fx.prototype.strokeSetter = function () {
	this.elem.attr(
		this.prop,
		H.color(this.start).tweenTo(H.color(this.end), this.pos),
		null,
		true
	);
};


/**
 * Utility function to deep merge two or more objects and return a third object.
 * If the first argument is true, the contents of the second object is copied
 * into the first object. The merge function can also be used with a single 
 * object argument to create a deep copy of an object.
 *
 * @function #merge
 * @memberOf Highcharts
 * @param {Boolean} [extend] - Whether to extend the left-side object (a) or
		  return a whole new object.
 * @param {Object} a - The first object to extend. When only this is given, the
		  function returns a deep copy.
 * @param {...Object} [n] - An object to merge into the previous one.
 * @returns {Object} - The merged object. If the first argument is true, the 
 * return is the same as the second argument.
 */
H.merge = function () {
	var i,
		args = arguments,
		len,
		ret = {},
		doCopy = function (copy, original) {
			// An object is replacing a primitive
			if (typeof copy !== 'object') {
				copy = {};
			}

			H.objectEach(original, function (value, key) {
				
				// Copy the contents of objects, but not arrays or DOM nodes
				if (
						H.isObject(value, true) &&
						!H.isClass(value) &&
						!H.isDOMElement(value)
				) {
					copy[key] = doCopy(copy[key] || {}, value);

				// Primitives and arrays are copied over directly
				} else {
					copy[key] = original[key];
				}
			});
			return copy;
		};

	// If first argument is true, copy into the existing object. Used in
	// setOptions.
	if (args[0] === true) {
		ret = args[1];
		args = Array.prototype.slice.call(args, 2);
	}

	// For each argument, extend the return
	len = args.length;
	for (i = 0; i < len; i++) {
		ret = doCopy(ret, args[i]);
	}

	return ret;
};

/**
 * Shortcut for parseInt
 * @ignore
 * @param {Object} s
 * @param {Number} mag Magnitude
 */
H.pInt = function (s, mag) {
	return parseInt(s, mag || 10);
};

/**
 * Utility function to check for string type.
 *
 * @function #isString
 * @memberOf Highcharts
 * @param {Object} s - The item to check.
 * @returns {Boolean} - True if the argument is a string.
 */
H.isString = function (s) {
	return typeof s === 'string';
};

/**
 * Utility function to check if an item is an array.
 *
 * @function #isArray
 * @memberOf Highcharts
 * @param {Object} obj - The item to check.
 * @returns {Boolean} - True if the argument is an array.
 */
H.isArray = function (obj) {
	var str = Object.prototype.toString.call(obj);
	return str === '[object Array]' || str === '[object Array Iterator]';
};

/**
 * Utility function to check if an item is of type object.
 *
 * @function #isObject
 * @memberOf Highcharts
 * @param {Object} obj - The item to check.
 * @param {Boolean} [strict=false] - Also checks that the object is not an
 *    array.
 * @returns {Boolean} - True if the argument is an object.
 */
H.isObject = function (obj, strict) {
	return !!obj && typeof obj === 'object' && (!strict || !H.isArray(obj));
};

/**
 * Utility function to check if an Object is a HTML Element.
 *
 * @function #isDOMElement
 * @memberOf Highcharts
 * @param {Object} obj - The item to check.
 * @returns {Boolean} - True if the argument is a HTML Element.
 */
H.isDOMElement = function (obj) {
	return H.isObject(obj) && typeof obj.nodeType === 'number';
};

/**
 * Utility function to check if an Object is an class.
 *
 * @function #isClass
 * @memberOf Highcharts
 * @param {Object} obj - The item to check.
 * @returns {Boolean} - True if the argument is an class.
 */
H.isClass = function (obj) {
	var c = obj && obj.constructor;
	return !!(
		H.isObject(obj, true) &&
		!H.isDOMElement(obj) &&
		(c && c.name && c.name !== 'Object')
	);
};

/**
 * Utility function to check if an item is a number and it is finite (not NaN,
 * Infinity or -Infinity).
 *
 * @function #isNumber
 * @memberOf Highcharts
 * @param  {Object} n
 *         The item to check.
 * @return {Boolean}
 *         True if the item is a finite number
 */
H.isNumber = function (n) {
	return typeof n === 'number' && !isNaN(n) && n < Infinity && n > -Infinity;
};

/**
 * Remove the last occurence of an item from an array.
 *
 * @function #erase
 * @memberOf Highcharts
 * @param {Array} arr - The array.
 * @param {*} item - The item to remove.
 */
H.erase = function (arr, item) {
	var i = arr.length;
	while (i--) {
		if (arr[i] === item) {
			arr.splice(i, 1);
			break;
		}
	}
};

/**
 * Check if an object is null or undefined.
 *
 * @function #defined
 * @memberOf Highcharts
 * @param {Object} obj - The object to check.
 * @returns {Boolean} - False if the object is null or undefined, otherwise
 *        true.
 */
H.defined = function (obj) {
	return obj !== undefined && obj !== null;
};

/**
 * Set or get an attribute or an object of attributes. To use as a setter, pass
 * a key and a value, or let the second argument be a collection of keys and
 * values. To use as a getter, pass only a string as the second argument.
 *
 * @function #attr
 * @memberOf Highcharts
 * @param {Object} elem - The DOM element to receive the attribute(s).
 * @param {String|Object} [prop] - The property or an object of key-value pairs.
 * @param {String} [value] - The value if a single property is set.
 * @returns {*} When used as a getter, return the value.
 */
H.attr = function (elem, prop, value) {
	var ret;

	// if the prop is a string
	if (H.isString(prop)) {
		// set the value
		if (H.defined(value)) {
			elem.setAttribute(prop, value);

		// get the value
		} else if (elem && elem.getAttribute) {
			ret = elem.getAttribute(prop);
		}

	// else if prop is defined, it is a hash of key/value pairs
	} else if (H.defined(prop) && H.isObject(prop)) {
		H.objectEach(prop, function (val, key) {
			elem.setAttribute(key, val);
		});
	}
	return ret;
};

/**
 * Check if an element is an array, and if not, make it into an array.
 *
 * @function #splat
 * @memberOf Highcharts
 * @param obj {*} - The object to splat.
 * @returns {Array} The produced or original array.
 */
H.splat = function (obj) {
	return H.isArray(obj) ? obj : [obj];
};

/**
 * Set a timeout if the delay is given, otherwise perform the function
 * synchronously.
 *
 * @function #syncTimeout
 * @memberOf Highcharts
 * @param   {Function} fn - The function callback.
 * @param   {Number}   delay - Delay in milliseconds.
 * @param   {Object}   [context] - The context.
 * @returns {Number} An identifier for the timeout that can later be cleared
 * with clearTimeout.
 */
H.syncTimeout = function (fn, delay, context) {
	if (delay) {
		return setTimeout(fn, delay, context);
	}
	fn.call(0, context);
};


/**
 * Utility function to extend an object with the members of another.
 *
 * @function #extend
 * @memberOf Highcharts
 * @param {Object} a - The object to be extended.
 * @param {Object} b - The object to add to the first one.
 * @returns {Object} Object a, the original object.
 */
H.extend = function (a, b) {
	var n;
	if (!a) {
		a = {};
	}
	for (n in b) {
		a[n] = b[n];
	}
	return a;
};


/**
 * Return the first value that is not null or undefined.
 *
 * @function #pick
 * @memberOf Highcharts
 * @param {...*} items - Variable number of arguments to inspect.
 * @returns {*} The value of the first argument that is not null or undefined.
 */
H.pick = function () {
	var args = arguments,
		i,
		arg,
		length = args.length;
	for (i = 0; i < length; i++) {
		arg = args[i];
		if (arg !== undefined && arg !== null) {
			return arg;
		}
	}
};

/**
 * @typedef {Object} CSSObject - A style object with camel case property names.
 * The properties can be whatever styles are supported on the given SVG or HTML
 * element.
 * @example
 * {
 *    fontFamily: 'monospace',
 *    fontSize: '1.2em'
 * }
 */
/**
 * Set CSS on a given element.
 *
 * @function #css
 * @memberOf Highcharts
 * @param {HTMLDOMElement} el - A HTML DOM element.
 * @param {CSSObject} styles - Style object with camel case property names.
 * 
 */
H.css = function (el, styles) {
	if (H.isMS && !H.svg) { // #2686
		if (styles && styles.opacity !== undefined) {
			styles.filter = 'alpha(opacity=' + (styles.opacity * 100) + ')';
		}
	}
	H.extend(el.style, styles);
};

/**
 * A HTML DOM element.
 * @typedef {Object} HTMLDOMElement
 */

/**
 * Utility function to create an HTML element with attributes and styles.
 *
 * @function #createElement
 * @memberOf Highcharts
 * @param {String} tag - The HTML tag.
 * @param {Object} [attribs] - Attributes as an object of key-value pairs.
 * @param {CSSObject} [styles] - Styles as an object of key-value pairs.
 * @param {Object} [parent] - The parent HTML object.
 * @param {Boolean} [nopad=false] - If true, remove all padding, border and
 *    margin.
 * @returns {HTMLDOMElement} The created DOM element.
 */
H.createElement = function (tag, attribs, styles, parent, nopad) {
	var el = doc.createElement(tag),
		css = H.css;
	if (attribs) {
		H.extend(el, attribs);
	}
	if (nopad) {
		css(el, { padding: 0, border: 'none', margin: 0 });
	}
	if (styles) {
		css(el, styles);
	}
	if (parent) {
		parent.appendChild(el);
	}
	return el;
};

/**
 * Extend a prototyped class by new members.
 *
 * @function #extendClass
 * @memberOf Highcharts
 * @param {Object} parent - The parent prototype to inherit.
 * @param {Object} members - A collection of prototype members to add or
 *        override compared to the parent prototype.
 * @returns {Object} A new prototype.
 */
H.extendClass = function (parent, members) {
	var object = function () {};
	object.prototype = new parent(); // eslint-disable-line new-cap
	H.extend(object.prototype, members);
	return object;
};

/**
 * Left-pad a string to a given length by adding a character repetetively.
 *
 * @function #pad
 * @memberOf Highcharts
 * @param {Number} number - The input string or number.
 * @param {Number} length - The desired string length.
 * @param {String} [padder=0] - The character to pad with.
 * @returns {String} The padded string.
 */
H.pad = function (number, length, padder) {
	return new Array((length || 2) + 1 -
		String(number).length).join(padder || 0) + number;
};

/**
 * @typedef {Number|String} RelativeSize - If a number is given, it defines the
 *    pixel length. If a percentage string is given, like for example `'50%'`,
 *    the setting defines a length relative to a base size, for example the size
 *    of a container.
 */
/**
 * Return a length based on either the integer value, or a percentage of a base.
 *
 * @function #relativeLength
 * @memberOf Highcharts
 * @param  {RelativeSize} value
 *         A percentage string or a number.
 * @param  {number} base
 *         The full length that represents 100%.
 * @param  {number} [offset=0]
 *         A pixel offset to apply for percentage values. Used internally in 
 *         axis positioning.
 * @return {number}
 *         The computed length.
 */
H.relativeLength = function (value, base, offset) {
	return (/%$/).test(value) ?
		(base * parseFloat(value) / 100) + (offset || 0) :
		parseFloat(value);
};

/**
 * Wrap a method with extended functionality, preserving the original function.
 *
 * @function #wrap
 * @memberOf Highcharts
 * @param {Object} obj - The context object that the method belongs to. In real
 *        cases, this is often a prototype.
 * @param {String} method - The name of the method to extend.
 * @param {Function} func - A wrapper function callback. This function is called
 *        with the same arguments as the original function, except that the
 *        original function is unshifted and passed as the first argument.
 * 
 */
H.wrap = function (obj, method, func) {
	var proceed = obj[method];
	obj[method] = function () {
		var args = Array.prototype.slice.call(arguments),
			outerArgs = arguments,
			ctx = this,
			ret;
		ctx.proceed = function () {
			proceed.apply(ctx, arguments.length ? arguments : outerArgs);
		};
		args.unshift(proceed);
		ret = func.apply(this, args);
		ctx.proceed = null;
		return ret;
	};
};



/**
 * Format a single variable. Similar to sprintf, without the % prefix.
 *
 * @example
 * formatSingle('.2f', 5); // => '5.00'.
 *
 * @function #formatSingle
 * @memberOf Highcharts
 * @param {String} format The format string.
 * @param {*} val The value.
 * @param {Time}   [time]
 *        A `Time` instance that determines the date formatting, for example for
 *        applying time zone corrections to the formatted date.
 
 * @returns {String} The formatted representation of the value.
 */
H.formatSingle = function (format, val, time) {
	var floatRegex = /f$/,
		decRegex = /\.([0-9])/,
		lang = H.defaultOptions.lang,
		decimals;

	if (floatRegex.test(format)) { // float
		decimals = format.match(decRegex);
		decimals = decimals ? decimals[1] : -1;
		if (val !== null) {
			val = H.numberFormat(
				val,
				decimals,
				lang.decimalPoint,
				format.indexOf(',') > -1 ? lang.thousandsSep : ''
			);
		}
	} else {
		val = (time || H.time).dateFormat(format, val);
	}
	return val;
};

/**
 * Format a string according to a subset of the rules of Python's String.format
 * method.
 *
 * @function #format
 * @memberOf Highcharts
 * @param {String} str
 *        The string to format.
 * @param {Object} ctx
 *        The context, a collection of key-value pairs where each key is
 *        replaced by its value.
 * @param {Time}   [time]
 *        A `Time` instance that determines the date formatting, for example for
 *        applying time zone corrections to the formatted date.
 * @returns {String} The formatted string.
 *
 * @example
 * var s = Highcharts.format(
 *     'The {color} fox was {len:.2f} feet long',
 *     { color: 'red', len: Math.PI }
 * );
 * // => The red fox was 3.14 feet long
 */
H.format = function (str, ctx, time) {
	var splitter = '{',
		isInside = false,
		segment,
		valueAndFormat,
		path,
		i,
		len,
		ret = [],
		val,
		index;

	while (str) {
		index = str.indexOf(splitter);
		if (index === -1) {
			break;
		}

		segment = str.slice(0, index);
		if (isInside) { // we're on the closing bracket looking back

			valueAndFormat = segment.split(':');
			path = valueAndFormat.shift().split('.'); // get first and leave
			len = path.length;
			val = ctx;

			// Assign deeper paths
			for (i = 0; i < len; i++) {
				if (val) {
					val = val[path[i]];
				}
			}

			// Format the replacement
			if (valueAndFormat.length) {
				val = H.formatSingle(valueAndFormat.join(':'), val, time);
			}

			// Push the result and advance the cursor
			ret.push(val);

		} else {
			ret.push(segment);

		}
		str = str.slice(index + 1); // the rest
		isInside = !isInside; // toggle
		splitter = isInside ? '}' : '{'; // now look for next matching bracket
	}
	ret.push(str);
	return ret.join('');
};

/**
 * Get the magnitude of a number.
 *
 * @function #getMagnitude
 * @memberOf Highcharts
 * @param {Number} number The number.
 * @returns {Number} The magnitude, where 1-9 are magnitude 1, 10-99 magnitude 2
 *        etc.
 */
H.getMagnitude = function (num) {
	return Math.pow(10, Math.floor(Math.log(num) / Math.LN10));
};

/**
 * Take an interval and normalize it to multiples of round numbers.
 *
 * @todo  Move this function to the Axis prototype. It is here only for
 *        historical reasons.
 * @function #normalizeTickInterval
 * @memberOf Highcharts
 * @param {Number} interval - The raw, un-rounded interval.
 * @param {Array} [multiples] - Allowed multiples.
 * @param {Number} [magnitude] - The magnitude of the number.
 * @param {Boolean} [allowDecimals] - Whether to allow decimals.
 * @param {Boolean} [hasTickAmount] - If it has tickAmount, avoid landing
 *        on tick intervals lower than original.
 * @returns {Number} The normalized interval.
 */
H.normalizeTickInterval = function (interval, multiples, magnitude,
		allowDecimals, hasTickAmount) {
	var normalized, 
		i,
		retInterval = interval;

	// round to a tenfold of 1, 2, 2.5 or 5
	magnitude = H.pick(magnitude, 1);
	normalized = interval / magnitude;

	// multiples for a linear scale
	if (!multiples) {
		multiples = hasTickAmount ? 
			// Finer grained ticks when the tick amount is hard set, including
			// when alignTicks is true on multiple axes (#4580).
			[1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] :

			// Else, let ticks fall on rounder numbers
			[1, 2, 2.5, 5, 10];


		// the allowDecimals option
		if (allowDecimals === false) {
			if (magnitude === 1) {
				multiples = H.grep(multiples, function (num) {
					return num % 1 === 0;
				});
			} else if (magnitude <= 0.1) {
				multiples = [1 / magnitude];
			}
		}
	}

	// normalize the interval to the nearest multiple
	for (i = 0; i < multiples.length; i++) {
		retInterval = multiples[i];
		// only allow tick amounts smaller than natural
		if ((hasTickAmount && retInterval * magnitude >= interval) || 
				(!hasTickAmount && (normalized <= (multiples[i] +
				(multiples[i + 1] || multiples[i])) / 2))) {
			break;
		}
	}

	// Multiply back to the correct magnitude. Correct floats to appropriate 
	// precision (#6085).
	retInterval = H.correctFloat(
		retInterval * magnitude,
		-Math.round(Math.log(0.001) / Math.LN10)
	);
	
	return retInterval;
};


/**
 * Sort an object array and keep the order of equal items. The ECMAScript
 * standard does not specify the behaviour when items are equal.
 *
 * @function #stableSort
 * @memberOf Highcharts
 * @param {Array} arr - The array to sort.
 * @param {Function} sortFunction - The function to sort it with, like with 
 *        regular Array.prototype.sort.
 * 
 */
H.stableSort = function (arr, sortFunction) {
	var length = arr.length,
		sortValue,
		i;

	// Add index to each item
	for (i = 0; i < length; i++) {
		arr[i].safeI = i; // stable sort index
	}

	arr.sort(function (a, b) {
		sortValue = sortFunction(a, b);
		return sortValue === 0 ? a.safeI - b.safeI : sortValue;
	});

	// Remove index from items
	for (i = 0; i < length; i++) {
		delete arr[i].safeI; // stable sort index
	}
};

/**
 * Non-recursive method to find the lowest member of an array. `Math.min` raises
 * a maximum call stack size exceeded error in Chrome when trying to apply more
 * than 150.000 points. This method is slightly slower, but safe.
 *
 * @function #arrayMin
 * @memberOf  Highcharts
 * @param {Array} data An array of numbers.
 * @returns {Number} The lowest number.
 */
H.arrayMin = function (data) {
	var i = data.length,
		min = data[0];

	while (i--) {
		if (data[i] < min) {
			min = data[i];
		}
	}
	return min;
};

/**
 * Non-recursive method to find the lowest member of an array. `Math.max` raises
 * a maximum call stack size exceeded error in Chrome when trying to apply more
 * than 150.000 points. This method is slightly slower, but safe.
 *
 * @function #arrayMax
 * @memberOf  Highcharts
 * @param {Array} data - An array of numbers.
 * @returns {Number} The highest number.
 */
H.arrayMax = function (data) {
	var i = data.length,
		max = data[0];

	while (i--) {
		if (data[i] > max) {
			max = data[i];
		}
	}
	return max;
};

/**
 * Utility method that destroys any SVGElement instances that are properties on
 * the given object. It loops all properties and invokes destroy if there is a
 * destroy method. The property is then delete.
 *
 * @function #destroyObjectProperties
 * @memberOf Highcharts
 * @param {Object} obj - The object to destroy properties on.
 * @param {Object} [except] - Exception, do not destroy this property, only
 *    delete it.
 * 
 */
H.destroyObjectProperties = function (obj, except) {
	H.objectEach(obj, function (val, n) {
		// If the object is non-null and destroy is defined
		if (val && val !== except && val.destroy) {
			// Invoke the destroy
			val.destroy();
		}
		
		// Delete the property from the object.
		delete obj[n];
	});
};


/**
 * Discard a HTML element by moving it to the bin and delete.
 *
 * @function #discardElement
 * @memberOf Highcharts
 * @param {HTMLDOMElement} element - The HTML node to discard.
 * 
 */
H.discardElement = function (element) {
	var garbageBin = H.garbageBin;
	// create a garbage bin element, not part of the DOM
	if (!garbageBin) {
		garbageBin = H.createElement('div');
	}

	// move the node and empty bin
	if (element) {
		garbageBin.appendChild(element);
	}
	garbageBin.innerHTML = '';
};

/**
 * Fix JS round off float errors.
 *
 * @function #correctFloat
 * @memberOf Highcharts
 * @param {Number} num - A float number to fix.
 * @param {Number} [prec=14] - The precision.
 * @returns {Number} The corrected float number.
 */
H.correctFloat = function (num, prec) {
	return parseFloat(
		num.toPrecision(prec || 14)
	);
};

/**
 * Set the global animation to either a given value, or fall back to the given
 * chart's animation option.
 *
 * @function #setAnimation
 * @memberOf Highcharts
 * @param {Boolean|Animation} animation - The animation object.
 * @param {Object} chart - The chart instance.
 * 
 * @todo This function always relates to a chart, and sets a property on the
 *        renderer, so it should be moved to the SVGRenderer.
 */
H.setAnimation = function (animation, chart) {
	chart.renderer.globalAnimation = H.pick(
		animation,
		chart.options.chart.animation,
		true
	);
};

/**
 * Get the animation in object form, where a disabled animation is always
 * returned as `{ duration: 0 }`.
 *
 * @function #animObject
 * @memberOf Highcharts
 * @param {Boolean|AnimationOptions} animation - An animation setting. Can be an
 *        object with duration, complete and easing properties, or a boolean to
 *        enable or disable.
 * @returns {AnimationOptions} An object with at least a duration property.
 */
H.animObject = function (animation) {
	return H.isObject(animation) ?
		H.merge(animation) :
		{ duration: animation ? 500 : 0 };
};

/**
 * The time unit lookup
 */
H.timeUnits = {
	millisecond: 1,
	second: 1000,
	minute: 60000,
	hour: 3600000,
	day: 24 * 3600000,
	week: 7 * 24 * 3600000,
	month: 28 * 24 * 3600000,
	year: 364 * 24 * 3600000
};

/**
 * Format a number and return a string based on input settings.
 *
 * @function #numberFormat
 * @memberOf Highcharts
 * @param {Number} number - The input number to format.
 * @param {Number} decimals - The amount of decimals. A value of -1 preserves
 *        the amount in the input number.
 * @param {String} [decimalPoint] - The decimal point, defaults to the one given
 *        in the lang options, or a dot.
 * @param {String} [thousandsSep] - The thousands separator, defaults to the one
 *        given in the lang options, or a space character.
 * @returns {String} The formatted number.
 *
 * @sample highcharts/members/highcharts-numberformat/ Custom number format
 */
H.numberFormat = function (number, decimals, decimalPoint, thousandsSep) {
	number = +number || 0;
	decimals = +decimals;

	var lang = H.defaultOptions.lang,
		origDec = (number.toString().split('.')[1] || '').split('e')[0].length,
		strinteger,
		thousands,
		ret,
		roundedNumber,
		exponent = number.toString().split('e'),
		fractionDigits;

	if (decimals === -1) {
		// Preserve decimals. Not huge numbers (#3793).
		decimals = Math.min(origDec, 20);
	} else if (!H.isNumber(decimals)) {
		decimals = 2;
	} else if (decimals && exponent[1] && exponent[1] < 0) {
		// Expose decimals from exponential notation (#7042)
		fractionDigits = decimals + +exponent[1];
		if (fractionDigits >= 0) {
			// remove too small part of the number while keeping the notation
			exponent[0] = (+exponent[0]).toExponential(fractionDigits)
				.split('e')[0];
			decimals = fractionDigits;
		} else {
			// fractionDigits < 0
			exponent[0] = exponent[0].split('.')[0] || 0;

			if (decimals < 20) {
				// use number instead of exponential notation (#7405)
				number = (exponent[0] * Math.pow(10, exponent[1]))
					.toFixed(decimals);
			} else {
				// or zero
				number = 0;
			}
			exponent[1] = 0;
		}
	}

	// Add another decimal to avoid rounding errors of float numbers. (#4573)
	// Then use toFixed to handle rounding.
	roundedNumber = (
		Math.abs(exponent[1] ? exponent[0] : number) +
		Math.pow(10, -Math.max(decimals, origDec) - 1)
	).toFixed(decimals);

	// A string containing the positive integer component of the number
	strinteger = String(H.pInt(roundedNumber));

	// Leftover after grouping into thousands. Can be 0, 1 or 3.
	thousands = strinteger.length > 3 ? strinteger.length % 3 : 0;

	// Language
	decimalPoint = H.pick(decimalPoint, lang.decimalPoint);
	thousandsSep = H.pick(thousandsSep, lang.thousandsSep);

	// Start building the return
	ret = number < 0 ? '-' : '';

	// Add the leftover after grouping into thousands. For example, in the
	// number 42 000 000, this line adds 42.
	ret += thousands ? strinteger.substr(0, thousands) + thousandsSep : '';

	// Add the remaining thousands groups, joined by the thousands separator
	ret += strinteger
		.substr(thousands)
		.replace(/(\d{3})(?=\d)/g, '$1' + thousandsSep);

	// Add the decimal point and the decimal component
	if (decimals) {
		// Get the decimal component
		ret += decimalPoint + roundedNumber.slice(-decimals);
	}

	if (exponent[1] && +ret !== 0) {
		ret += 'e' + exponent[1];
	}

	return ret;
};

/**
 * Easing definition
 * @ignore
 * @param   {Number} pos Current position, ranging from 0 to 1.
 */
Math.easeInOutSine = function (pos) {
	return -0.5 * (Math.cos(Math.PI * pos) - 1);
};

/**
 * Get the computed CSS value for given element and property, only for numerical
 * properties. For width and height, the dimension of the inner box (excluding
 * padding) is returned. Used for fitting the chart within the container.
 *
 * @function #getStyle
 * @memberOf Highcharts
 * @param {HTMLDOMElement} el - A HTML element.
 * @param {String} prop - The property name.
 * @param {Boolean} [toInt=true] - Parse to integer.
 * @returns {Number} - The numeric value.
 */
H.getStyle = function (el, prop, toInt) {

	var style;

	// For width and height, return the actual inner pixel size (#4913)
	if (prop === 'width') {
		return Math.min(el.offsetWidth, el.scrollWidth) -
			H.getStyle(el, 'padding-left') -
			H.getStyle(el, 'padding-right');
	} else if (prop === 'height') {
		return Math.min(el.offsetHeight, el.scrollHeight) -
			H.getStyle(el, 'padding-top') -
			H.getStyle(el, 'padding-bottom');
	}

	if (!win.getComputedStyle) {
		// SVG not supported, forgot to load oldie.js?
		H.error(27, true);
	}

	// Otherwise, get the computed style
	style = win.getComputedStyle(el, undefined);
	if (style) {
		style = style.getPropertyValue(prop);
		if (H.pick(toInt, prop !== 'opacity')) {
			style = H.pInt(style);
		}
	}
	return style;
};

/**
 * Search for an item in an array.
 *
 * @function #inArray
 * @memberOf Highcharts
 * @param {*} item - The item to search for.
 * @param {arr} arr - The array or node collection to search in.
 * @returns {Number} - The index within the array, or -1 if not found.
 */
H.inArray = function (item, arr) {
	return (H.indexOfPolyfill || Array.prototype.indexOf).call(arr, item);
};

/**
 * Filter an array by a callback.
 *
 * @function #grep
 * @memberOf Highcharts
 * @param {Array} arr - The array to filter.
 * @param {Function} callback - The callback function. The function receives the
 *        item as the first argument. Return `true` if the item is to be
 *        preserved.
 * @returns {Array} - A new, filtered array.
 */
H.grep = function (arr, callback) {
	return (H.filterPolyfill || Array.prototype.filter).call(arr, callback);
};

/**
 * Return the value of the first element in the array that satisfies the 
 * provided testing function.
 *
 * @function #find
 * @memberOf Highcharts
 * @param {Array} arr - The array to test.
 * @param {Function} callback - The callback function. The function receives the
 *        item as the first argument. Return `true` if this item satisfies the
 *        condition.
 * @returns {Mixed} - The value of the element.
 */
H.find = Array.prototype.find ?
	function (arr, callback) {
		return arr.find(callback);
	} :
	// Legacy implementation. PhantomJS, IE <= 11 etc. #7223.
	function (arr, fn) {
		var i,
			length = arr.length;

		for (i = 0; i < length; i++) {
			if (fn(arr[i], i)) {
				return arr[i];
			}
		}
	};

/**
 * Map an array by a callback.
 *
 * @function #map
 * @memberOf Highcharts
 * @param {Array} arr - The array to map.
 * @param {Function} fn - The callback function. Return the new value for the 
 *        new array.
 * @returns {Array} - A new array item with modified items.
 */
H.map = function (arr, fn) {
	var results = [],
		i = 0,
		len = arr.length;

	for (; i < len; i++) {
		results[i] = fn.call(arr[i], arr[i], i, arr);
	}

	return results;
};

/**
 * Returns an array of a given object's own properties.
 *
 * @function #keys
 * @memberOf highcharts
 * @param {Object} obj - The object of which the properties are to be returned.
 * @returns {Array} - An array of strings that represents all the properties.
 */
H.keys = function (obj) {
	return (H.keysPolyfill || Object.keys).call(undefined, obj);
};

/**
 * Reduce an array to a single value.
 *
 * @function #reduce
 * @memberOf Highcharts
 * @param {Array} arr - The array to reduce.
 * @param {Function} fn - The callback function. Return the reduced value. 
 *  Receives 4 arguments: Accumulated/reduced value, current value, current 
 *  array index, and the array.
 * @param {Mixed} initialValue - The initial value of the accumulator.
 * @returns {Mixed} - The reduced value.
 */
H.reduce = function (arr, func, initialValue) {
	return (H.reducePolyfill || Array.prototype.reduce).call(
		arr,
		func,
		initialValue
	);
};

/**
 * Get the element's offset position, corrected for `overflow: auto`.
 *
 * @function #offset
 * @memberOf Highcharts
 * @param {HTMLDOMElement} el - The HTML element.
 * @returns {Object} An object containing `left` and `top` properties for the
 * position in the page.
 */
H.offset = function (el) {
	var docElem = doc.documentElement,
		box = el.parentElement ? // IE11 throws Unspecified error in test suite
			el.getBoundingClientRect() :
			{ top: 0, left: 0 };

	return {
		top: box.top  + (win.pageYOffset || docElem.scrollTop) -
			(docElem.clientTop  || 0),
		left: box.left + (win.pageXOffset || docElem.scrollLeft) -
			(docElem.clientLeft || 0)
	};
};

/**
 * Stop running animation.
 *
 * @todo A possible extension to this would be to stop a single property, when
 * we want to continue animating others. Then assign the prop to the timer
 * in the Fx.run method, and check for the prop here. This would be an
 * improvement in all cases where we stop the animation from .attr. Instead of
 * stopping everything, we can just stop the actual attributes we're setting.
 *
 * @function #stop
 * @memberOf Highcharts
 * @param {SVGElement} el - The SVGElement to stop animation on.
 * @param {string} [prop] - The property to stop animating. If given, the stop
 *    method will stop a single property from animating, while others continue.
 * 
 */
H.stop = function (el, prop) {

	var i = H.timers.length;

	// Remove timers related to this element (#4519)
	while (i--) {
		if (H.timers[i].elem === el && (!prop || prop === H.timers[i].prop)) {
			H.timers[i].stopped = true; // #4667
		}
	}
};

/**
 * Iterate over an array.
 *
 * @function #each
 * @memberOf Highcharts
 * @param {Array} arr - The array to iterate over.
 * @param {Function} fn - The iterator callback. It passes three arguments:
 * * item - The array item.
 * * index - The item's index in the array.
 * * arr - The array that each is being applied to.
 * @param {Object} [ctx] The context.
 */
H.each = function (arr, fn, ctx) { // modern browsers
	return (H.forEachPolyfill || Array.prototype.forEach).call(arr, fn, ctx);
};

/**
 * Iterate over object key pairs in an object.
 *
 * @function #objectEach
 * @memberOf Highcharts
 * @param  {Object}   obj - The object to iterate over.
 * @param  {Function} fn  - The iterator callback. It passes three arguments:
 * * value - The property value.
 * * key - The property key.
 * * obj - The object that objectEach is being applied to.
 * @param  {Object}   ctx The context
 */
H.objectEach = function (obj, fn, ctx) {
	for (var key in obj) {
		if (obj.hasOwnProperty(key)) {
			fn.call(ctx, obj[key], key, obj);
		}
	}
};

/**
 * Add an event listener.
 *
 * @function #addEvent
 * @memberOf Highcharts
 * @param {Object} el - The element or object to add a listener to. It can be a
 *        {@link HTMLDOMElement}, an {@link SVGElement} or any other object.
 * @param {String} type - The event type.
 * @param {Function} fn - The function callback to execute when the event is 
 *        fired.
 * @returns {Function} A callback function to remove the added event.
 */
H.addEvent = function (el, type, fn) {

	var events,
		itemEvents,
		addEventListener = el.addEventListener || H.addEventListenerPolyfill;

	// If events are previously set directly on the prototype, pick them up 
	// and copy them over to the instance. Otherwise instance handlers would
	// be set on the prototype and apply to multiple charts in the page.
	if (
		el.hcEvents &&
		// IE8, window and document don't have hasOwnProperty
		!Object.prototype.hasOwnProperty.call(el, 'hcEvents')
	) {
		itemEvents = {};
		H.objectEach(el.hcEvents, function (handlers, eventType) {
			itemEvents[eventType] = handlers.slice(0);
		});
		el.hcEvents = itemEvents;
	}

	events = el.hcEvents = el.hcEvents || {};

	// Handle DOM events
	if (addEventListener) {
		addEventListener.call(el, type, fn, false);
	}

	if (!events[type]) {
		events[type] = [];
	}

	events[type].push(fn);

	// Return a function that can be called to remove this event.
	return function () {
		H.removeEvent(el, type, fn);
	};
};

/**
 * Remove an event that was added with {@link Highcharts#addEvent}.
 *
 * @function #removeEvent
 * @memberOf Highcharts
 * @param {Object} el - The element to remove events on.
 * @param {String} [type] - The type of events to remove. If undefined, all
 *        events are removed from the element.
 * @param {Function} [fn] - The specific callback to remove. If undefined, all
 *        events that match the element and optionally the type are removed.
 * 
 */
H.removeEvent = function (el, type, fn) {
	
	var events,
		hcEvents = el.hcEvents,
		index;

	function removeOneEvent(type, fn) {
		var removeEventListener =
			el.removeEventListener || H.removeEventListenerPolyfill;
		
		if (removeEventListener) {
			removeEventListener.call(el, type, fn, false);
		}
	}

	function removeAllEvents() {
		var types,
			len;

		if (!el.nodeName) {
			return; // break on non-DOM events
		}

		if (type) {
			types = {};
			types[type] = true;
		} else {
			types = hcEvents;
		}

		H.objectEach(types, function (val, n) {
			if (hcEvents[n]) {
				len = hcEvents[n].length;
				while (len--) {
					removeOneEvent(n, hcEvents[n][len]);
				}
			}
		});
	}

	if (hcEvents) {
		if (type) {
			events = hcEvents[type] || [];
			if (fn) {
				index = H.inArray(fn, events);
				if (index > -1) {
					events.splice(index, 1);
					hcEvents[type] = events;
				}
				removeOneEvent(type, fn);

			} else {
				removeAllEvents();
				hcEvents[type] = [];
			}
		} else {
			removeAllEvents();
			el.hcEvents = {};
		}
	}
};

/**
 * Fire an event that was registered with {@link Highcharts#addEvent}.
 *
 * @function #fireEvent
 * @memberOf Highcharts
 * @param {Object} el - The object to fire the event on. It can be a
 *        {@link HTMLDOMElement}, an {@link SVGElement} or any other object.
 * @param {String} type - The type of event.
 * @param {Object} [eventArguments] - Custom event arguments that are passed on
 *        as an argument to the event handler.
 * @param {Function} [defaultFunction] - The default function to execute if the 
 *        other listeners haven't returned false.
 * 
 */
H.fireEvent = function (el, type, eventArguments, defaultFunction) {
	var e,
		hcEvents = el.hcEvents,
		events,
		len,
		i,
		fn;

	eventArguments = eventArguments || {};

	if (doc.createEvent && (el.dispatchEvent || el.fireEvent)) {
		e = doc.createEvent('Events');
		e.initEvent(type, true, true);
		
		H.extend(e, eventArguments);

		if (el.dispatchEvent) {
			el.dispatchEvent(e);
		} else {
			el.fireEvent(type, e);
		}

	} else if (hcEvents) {
		
		events = hcEvents[type] || [];
		len = events.length;

		if (!eventArguments.target) { // We're running a custom event

			H.extend(eventArguments, {
				// Attach a simple preventDefault function to skip default
				// handler if called. The built-in defaultPrevented property is
				// not overwritable (#5112)
				preventDefault: function () {
					eventArguments.defaultPrevented = true;
				},
				// Setting target to native events fails with clicking the
				// zoom-out button in Chrome.
				target: el,
				// If the type is not set, we're running a custom event (#2297).
				// If it is set, we're running a browser event, and setting it
				// will cause en error in IE8 (#2465).		
				type: type
			});
		}

		
		for (i = 0; i < len; i++) {
			fn = events[i];

			// If the event handler return false, prevent the default handler
			// from executing
			if (fn && fn.call(el, eventArguments) === false) {
				eventArguments.preventDefault();
			}
		}
	}
			
	// Run the default if not prevented
	if (defaultFunction && !eventArguments.defaultPrevented) {
		defaultFunction(eventArguments);
	}
};

/**
 * An animation configuration. Animation configurations can also be defined as
 * booleans, where `false` turns off animation and `true` defaults to a duration
 * of 500ms.
 * @typedef {Object} AnimationOptions
 * @property {Number} duration - The animation duration in milliseconds.
 * @property {String} [easing] - The name of an easing function as defined on
 *     the `Math` object.
 * @property {Function} [complete] - A callback function to exectute when the
 *     animation finishes.
 * @property {Function} [step] - A callback function to execute on each step of
 *     each attribute or CSS property that's being animated. The first argument
 *     contains information about the animation and progress.
 */


/**
 * The global animate method, which uses Fx to create individual animators.
 *
 * @function #animate
 * @memberOf Highcharts
 * @param {HTMLDOMElement|SVGElement} el - The element to animate.
 * @param {Object} params - An object containing key-value pairs of the
 *        properties to animate. Supports numeric as pixel-based CSS properties
 *        for HTML objects and attributes for SVGElements.
 * @param {AnimationOptions} [opt] - Animation options.
 */
H.animate = function (el, params, opt) {
	var start,
		unit = '',
		end,
		fx,
		args;

	if (!H.isObject(opt)) { // Number or undefined/null
		args = arguments;
		opt = {
			duration: args[2],
			easing: args[3],
			complete: args[4]
		};
	}
	if (!H.isNumber(opt.duration)) {
		opt.duration = 400;
	}
	opt.easing = typeof opt.easing === 'function' ?
		opt.easing :
		(Math[opt.easing] || Math.easeInOutSine);
	opt.curAnim = H.merge(params);

	H.objectEach(params, function (val, prop) {
		// Stop current running animation of this property
		H.stop(el, prop);
		
		fx = new H.Fx(el, opt, prop);
		end = null;
		
		if (prop === 'd') {
			fx.paths = fx.initPath(
				el,
				el.d,
				params.d
			);
			fx.toD = params.d;
			start = 0;
			end = 1;
		} else if (el.attr) {
			start = el.attr(prop);
		} else {
			start = parseFloat(H.getStyle(el, prop)) || 0;
			if (prop !== 'opacity') {
				unit = 'px';
			}
		}
		
		if (!end) {
			end = val;
		}
		if (end && end.match && end.match('px')) {
			end = end.replace(/px/g, ''); // #4351
		}
		fx.run(start, end, unit);
	});
};

/**
 * Factory to create new series prototypes.
 *
 * @function #seriesType
 * @memberOf Highcharts
 *
 * @param {String} type - The series type name.
 * @param {String} parent - The parent series type name. Use `line` to inherit
 *        from the basic {@link Series} object.
 * @param {Object} options - The additional default options that is merged with
 *        the parent's options.
 * @param {Object} props - The properties (functions and primitives) to set on
 *        the new prototype.
 * @param {Object} [pointProps] - Members for a series-specific extension of the
 *        {@link Point} prototype if needed.
 * @returns {*} - The newly created prototype as extended from {@link Series}
 * or its derivatives.
 */
// docs: add to API + extending Highcharts
H.seriesType = function (type, parent, options, props, pointProps) {
	var defaultOptions = H.getOptions(),
		seriesTypes = H.seriesTypes;

	// Merge the options
	defaultOptions.plotOptions[type] = H.merge(
		defaultOptions.plotOptions[parent], 
		options
	);
	
	// Create the class
	seriesTypes[type] = H.extendClass(seriesTypes[parent] ||
		function () {}, props);
	seriesTypes[type].prototype.type = type;

	// Create the point class if needed
	if (pointProps) {
		seriesTypes[type].prototype.pointClass =
			H.extendClass(H.Point, pointProps);
	}

	return seriesTypes[type];
};

/**
 * Get a unique key for using in internal element id's and pointers. The key
 * is composed of a random hash specific to this Highcharts instance, and a 
 * counter.
 * @function #uniqueKey
 * @memberOf Highcharts
 * @return {string} The key.
 * @example
 * var id = H.uniqueKey(); // => 'highcharts-x45f6hp-0'
 */
H.uniqueKey = (function () {
	
	var uniqueKeyHash = Math.random().toString(36).substring(2, 9),
		idCounter = 0;

	return function () {
		return 'highcharts-' + uniqueKeyHash + '-' + idCounter++;
	};
}());

/**
 * Register Highcharts as a plugin in jQuery
 */
if (win.jQuery) {
	win.jQuery.fn.highcharts = function () {
		var args = [].slice.call(arguments);

		if (this[0]) { // this[0] is the renderTo div

			// Create the chart
			if (args[0]) {
				new H[ // eslint-disable-line no-new
					// Constructor defaults to Chart
					H.isString(args[0]) ? args.shift() : 'Chart'
				](this[0], args[0], args[1]);
				return this;
			}

			// When called without parameters or with the return argument,
			// return an existing chart
			return charts[H.attr(this[0], 'data-highcharts-chart')];
		}
	};
}

}(Highcharts));
(function (H) {
/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var each = H.each,
	isNumber = H.isNumber,
	map = H.map,
	merge = H.merge,
	pInt = H.pInt;

/**
 * @typedef {string} ColorString
 * A valid color to be parsed and handled by Highcharts. Highcharts internally 
 * supports hex colors like `#ffffff`, rgb colors like `rgb(255,255,255)` and
 * rgba colors like `rgba(255,255,255,1)`. Other colors may be supported by the
 * browsers and displayed correctly, but Highcharts is not able to process them
 * and apply concepts like opacity and brightening.
 */
/**
 * Handle color operations. The object methods are chainable.
 * @param {String} input The input color in either rbga or hex format
 */
H.Color = function (input) {
	// Backwards compatibility, allow instanciation without new
	if (!(this instanceof H.Color)) {
		return new H.Color(input);
	}
    // Initialize
	this.init(input);
};
H.Color.prototype = {

	// Collection of parsers. This can be extended from the outside by pushing parsers
	// to Highcharts.Color.prototype.parsers.
	parsers: [{
		// RGBA color
		regex: /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,
		parse: function (result) {
			return [pInt(result[1]), pInt(result[2]), pInt(result[3]), parseFloat(result[4], 10)];
		}
	}, {
		// RGB color
		regex: /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/,
		parse: function (result) {
			return [pInt(result[1]), pInt(result[2]), pInt(result[3]), 1];
		}
	}],

	// Collection of named colors. Can be extended from the outside by adding
	// colors to Highcharts.Color.prototype.names.
	names: {
		none: 'rgba(255,255,255,0)',
		white: '#ffffff',
		black: '#000000'
	},

	/**
	 * Parse the input color to rgba array
	 * @param {String} input
	 */
	init: function (input) {
		var result,
			rgba,
			i,
			parser,
			len;

		this.input = input = this.names[
								input && input.toLowerCase ?
									input.toLowerCase() :
									''
							] || input;

		// Gradients
		if (input && input.stops) {
			this.stops = map(input.stops, function (stop) {
				return new H.Color(stop[1]);
			});

		// Solid colors
		} else {

			// Bitmasking as input[0] is not working for legacy IE.
			if (input && input.charAt && input.charAt() === '#') {

				len = input.length;
				input = parseInt(input.substr(1), 16);

				// Handle long-form, e.g. #AABBCC
				if (len === 7) {
					
					rgba = [
						(input & 0xFF0000) >> 16,
						(input & 0xFF00) >> 8,
						(input & 0xFF),
						1
					];				

				// Handle short-form, e.g. #ABC
				// In short form, the value is assumed to be the same 
				// for both nibbles for each component. e.g. #ABC = #AABBCC
				} else if (len === 4) {

					rgba = [
						((input & 0xF00) >> 4) | (input & 0xF00) >> 8,
						((input & 0xF0) >> 4) | (input & 0xF0),
						((input & 0xF) << 4) | (input & 0xF),
						1
					];
				}				
			}

			// Otherwise, check regex parsers
			if (!rgba) {
				i = this.parsers.length;
				while (i-- && !rgba) {
					parser = this.parsers[i];
					result = parser.regex.exec(input);
					if (result) {
						rgba = parser.parse(result);
					}
				}
			}
		}
		this.rgba = rgba || [];
	},

	/**
	 * Return the color a specified format
	 * @param {String} format
	 */
	get: function (format) {
		var input = this.input,
			rgba = this.rgba,
			ret;

		if (this.stops) {
			ret = merge(input);
			ret.stops = [].concat(ret.stops);
			each(this.stops, function (stop, i) {
				ret.stops[i] = [ret.stops[i][0], stop.get(format)];
			});

		// it's NaN if gradient colors on a column chart
		} else if (rgba && isNumber(rgba[0])) {
			if (format === 'rgb' || (!format && rgba[3] === 1)) {
				ret = 'rgb(' + rgba[0] + ',' + rgba[1] + ',' + rgba[2] + ')';
			} else if (format === 'a') {
				ret = rgba[3];
			} else {
				ret = 'rgba(' + rgba.join(',') + ')';
			}
		} else {
			ret = input;
		}
		return ret;
	},

	/**
	 * Brighten the color
	 * @param {Number} alpha
	 */
	brighten: function (alpha) {
		var i, 
			rgba = this.rgba;

		if (this.stops) {
			each(this.stops, function (stop) {
				stop.brighten(alpha);
			});

		} else if (isNumber(alpha) && alpha !== 0) {
			for (i = 0; i < 3; i++) {
				rgba[i] += pInt(alpha * 255);

				if (rgba[i] < 0) {
					rgba[i] = 0;
				}
				if (rgba[i] > 255) {
					rgba[i] = 255;
				}
			}
		}
		return this;
	},

	/**
	 * Set the color's opacity to a given alpha value
	 * @param {Number} alpha
	 */
	setOpacity: function (alpha) {
		this.rgba[3] = alpha;
		return this;
	},

	/*
	 * Return an intermediate color between two colors.
	 *
	 * @param  {Highcharts.Color} to
	 *         The color object to tween to.
	 * @param  {Number} pos
	 *         The intermediate position, where 0 is the from color (current
	 *         color item), and 1 is the `to` color.
	 *
	 * @return {String}
	 *         The intermediate color in rgba notation.
	 */
	tweenTo: function (to, pos) {
		// Check for has alpha, because rgba colors perform worse due to lack of
		// support in WebKit.
		var fromRgba = this.rgba,
			toRgba = to.rgba,
			hasAlpha,
			ret;

		// Unsupported color, return to-color (#3920, #7034)
		if (!toRgba.length || !fromRgba || !fromRgba.length) {
			ret = to.input || 'none';

		// Interpolate
		} else {
			hasAlpha = (toRgba[3] !== 1 || fromRgba[3] !== 1);
			ret = (hasAlpha ? 'rgba(' : 'rgb(') +
				Math.round(toRgba[0] + (fromRgba[0] - toRgba[0]) * (1 - pos)) +
				',' +
				Math.round(toRgba[1] + (fromRgba[1] - toRgba[1]) * (1 - pos)) +
				',' +
				Math.round(toRgba[2] + (fromRgba[2] - toRgba[2]) * (1 - pos)) +
				(
					hasAlpha ?
						(
							',' +
							(toRgba[3] + (fromRgba[3] - toRgba[3]) * (1 - pos))
						) :
						''
				) +
				')';
		}
		return ret;
	}
};
H.color = function (input) {
	return new H.Color(input);
};

}(Highcharts));
(function (H) {
/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var SVGElement,
	SVGRenderer,

	addEvent = H.addEvent,
	animate = H.animate,
	attr = H.attr,
	charts = H.charts,
	color = H.color,
	css = H.css,
	createElement = H.createElement,
	defined = H.defined,
	deg2rad = H.deg2rad,
	destroyObjectProperties = H.destroyObjectProperties,
	doc = H.doc,
	each = H.each,
	extend = H.extend,
	erase = H.erase,
	grep = H.grep,
	hasTouch = H.hasTouch,
	inArray = H.inArray,
	isArray = H.isArray,
	isFirefox = H.isFirefox,
	isMS = H.isMS,
	isObject = H.isObject,
	isString = H.isString,
	isWebKit = H.isWebKit,
	merge = H.merge,
	noop = H.noop,
	objectEach = H.objectEach,
	pick = H.pick,
	pInt = H.pInt,
	removeEvent = H.removeEvent,
	splat = H.splat,
	stop = H.stop,
	svg = H.svg,
	SVG_NS = H.SVG_NS,
	symbolSizes = H.symbolSizes,
	win = H.win;

/**
 * @typedef {Object} SVGDOMElement - An SVG DOM element.
 */
/**
 * The SVGElement prototype is a JavaScript wrapper for SVG elements used in the
 * rendering layer of Highcharts. Combined with the {@link
 * Highcharts.SVGRenderer} object, these prototypes allow freeform annotation
 * in the charts or even in HTML pages without instanciating a chart. The
 * SVGElement can also wrap HTML labels, when `text` or `label` elements are
 * created with the `useHTML` parameter.
 *
 * The SVGElement instances are created through factory functions on the 
 * {@link Highcharts.SVGRenderer} object, like
 * [rect]{@link Highcharts.SVGRenderer#rect}, [path]{@link
 * Highcharts.SVGRenderer#path}, [text]{@link Highcharts.SVGRenderer#text},
 * [label]{@link Highcharts.SVGRenderer#label}, [g]{@link
 * Highcharts.SVGRenderer#g} and more.
 *
 * @class Highcharts.SVGElement
 */
SVGElement = H.SVGElement = function () {
	return this;
};
extend(SVGElement.prototype, /** @lends Highcharts.SVGElement.prototype */ {

	// Default base for animation
	opacity: 1,
	SVG_NS: SVG_NS,

	/**
	 * For labels, these CSS properties are applied to the `text` node directly.
	 *
	 * @private
	 * @type {Array.<string>}
	 */
	textProps: ['direction', 'fontSize', 'fontWeight', 'fontFamily',
		'fontStyle', 'color', 'lineHeight', 'width', 'textAlign',
		'textDecoration', 'textOverflow', 'textOutline'],

	/**
	 * Initialize the SVG element. This function only exists to make the
	 * initiation process overridable. It should not be called directly.
	 *
	 * @param  {SVGRenderer} renderer
	 *         The SVGRenderer instance to initialize to.
	 * @param  {String} nodeName
	 *         The SVG node name.
	 * 
	 */
	init: function (renderer, nodeName) {

		/** 
		 * The primary DOM node. Each `SVGElement` instance wraps a main DOM
		 * node, but may also represent more nodes.
		 *
		 * @name  element
		 * @memberOf SVGElement
		 * @type {SVGDOMNode|HTMLDOMNode}
		 */
		this.element = nodeName === 'span' ?
			createElement(nodeName) :
			doc.createElementNS(this.SVG_NS, nodeName);

		/**
		 * The renderer that the SVGElement belongs to.
		 *
		 * @name renderer
		 * @memberOf SVGElement
		 * @type {SVGRenderer}
		 */
		this.renderer = renderer;
	},

	/**
	 * Animate to given attributes or CSS properties.
	 * 
	 * @param {SVGAttributes} params SVG attributes or CSS to animate.
	 * @param {AnimationOptions} [options] Animation options.
	 * @param {Function} [complete] Function to perform at the end of animation.
	 *
	 * @sample highcharts/members/element-on/
	 *         Setting some attributes by animation
	 * 
	 * @returns {SVGElement} Returns the SVGElement for chaining.
	 */
	animate: function (params, options, complete) {
		var animOptions = H.animObject(
			pick(options, this.renderer.globalAnimation, true)
		);
		if (animOptions.duration !== 0) {
			// allows using a callback with the global animation without
			// overwriting it
			if (complete) {
				animOptions.complete = complete;
			}
			animate(this, params, animOptions);
		} else {
			this.attr(params, null, complete);
			if (animOptions.step) {
				animOptions.step.call(this);
			}
		}
		return this;
	},

	/**
	 * @typedef {Object} GradientOptions
	 * @property {Object} linearGradient Holds an object that defines the start
	 *    position and the end position relative to the shape.
	 * @property {Number} linearGradient.x1 Start horizontal position of the
	 *    gradient. Ranges 0-1.
	 * @property {Number} linearGradient.x2 End horizontal position of the
	 *    gradient. Ranges 0-1.
	 * @property {Number} linearGradient.y1 Start vertical position of the
	 *    gradient. Ranges 0-1.
	 * @property {Number} linearGradient.y2 End vertical position of the
	 *    gradient. Ranges 0-1.
	 * @property {Object} radialGradient Holds an object that defines the center
	 *    position and the radius.
	 * @property {Number} radialGradient.cx Center horizontal position relative
	 *    to the shape. Ranges 0-1.
	 * @property {Number} radialGradient.cy Center vertical position relative
	 *    to the shape. Ranges 0-1.
	 * @property {Number} radialGradient.r Radius relative to the shape. Ranges
	 *    0-1.
	 * @property {Array.<Array>} stops The first item in each tuple is the
	 *    position in the gradient, where 0 is the start of the gradient and 1
	 *    is the end of the gradient. Multiple stops can be applied. The second
	 *    item is the color for each stop. This color can also be given in the
	 *    rgba format.
	 *
	 * @example
	 * // Linear gradient used as a color option
	 * color: {
	 *     linearGradient: { x1: 0, x2: 0, y1: 0, y2: 1 },
	 *         stops: [
	 *             [0, '#003399'], // start
	 *             [0.5, '#ffffff'], // middle
	 *             [1, '#3366AA'] // end
	 *         ]
	 *     }
	 * }
	 */
	/**
	 * Build and apply an SVG gradient out of a common JavaScript configuration
	 * object. This function is called from the attribute setters.
	 *
	 * @private
	 * @param {GradientOptions} color The gradient options structure.
	 * @param {string} prop The property to apply, can either be `fill` or
	 * `stroke`. 
	 * @param {SVGDOMElement} elem SVG DOM element to apply the gradient on.
	 */
	colorGradient: function (color, prop, elem) {
		var renderer = this.renderer,
			colorObject,
			gradName,
			gradAttr,
			radAttr,
			gradients,
			gradientObject,
			stops,
			stopColor,
			stopOpacity,
			radialReference,
			id,
			key = [],
			value;

		// Apply linear or radial gradients
		if (color.radialGradient) {
			gradName = 'radialGradient';
		} else if (color.linearGradient) {
			gradName = 'linearGradient';
		}

		if (gradName) {
			gradAttr = color[gradName];
			gradients = renderer.gradients;
			stops = color.stops;
			radialReference = elem.radialReference;

			// Keep < 2.2 kompatibility
			if (isArray(gradAttr)) {
				color[gradName] = gradAttr = {
					x1: gradAttr[0],
					y1: gradAttr[1],
					x2: gradAttr[2],
					y2: gradAttr[3],
					gradientUnits: 'userSpaceOnUse'
				};
			}

			// Correct the radial gradient for the radial reference system
			if (
				gradName === 'radialGradient' &&
				radialReference &&
				!defined(gradAttr.gradientUnits)
			) {
				radAttr = gradAttr; // Save the radial attributes for updating
				gradAttr = merge(
					gradAttr,
					renderer.getRadialAttr(radialReference, radAttr),
					{ gradientUnits: 'userSpaceOnUse' }
				);
			}

			// Build the unique key to detect whether we need to create a new
			// element (#1282)
			objectEach(gradAttr, function (val, n) {
				if (n !== 'id') {
					key.push(n, val);
				}
			});
			objectEach(stops, function (val) {
				key.push(val);
			});
			key = key.join(',');

			// Check if a gradient object with the same config object is created
			// within this renderer
			if (gradients[key]) {
				id = gradients[key].attr('id');

			} else {

				// Set the id and create the element
				gradAttr.id = id = H.uniqueKey();
				gradients[key] = gradientObject =
					renderer.createElement(gradName)
						.attr(gradAttr)
						.add(renderer.defs);

				gradientObject.radAttr = radAttr;

				// The gradient needs to keep a list of stops to be able to
				// destroy them
				gradientObject.stops = [];
				each(stops, function (stop) {
					var stopObject;
					if (stop[1].indexOf('rgba') === 0) {
						colorObject = H.color(stop[1]);
						stopColor = colorObject.get('rgb');
						stopOpacity = colorObject.get('a');
					} else {
						stopColor = stop[1];
						stopOpacity = 1;
					}
					stopObject = renderer.createElement('stop').attr({
						offset: stop[0],
						'stop-color': stopColor,
						'stop-opacity': stopOpacity
					}).add(gradientObject);

					// Add the stop element to the gradient
					gradientObject.stops.push(stopObject);
				});
			}

			// Set the reference to the gradient object
			value = 'url(' + renderer.url + '#' + id + ')';
			elem.setAttribute(prop, value);
			elem.gradient = key;

			// Allow the color to be concatenated into tooltips formatters etc.
			// (#2995)
			color.toString = function () {
				return value;
			};
		}
	},

	/**
	 * Apply a text outline through a custom CSS property, by copying the text
	 * element and apply stroke to the copy. Used internally. Contrast checks
	 * at http://jsfiddle.net/highcharts/43soe9m1/2/ .
	 *
	 * @private
	 * @param {String} textOutline A custom CSS `text-outline` setting, defined
	 *    by `width color`. 
	 * @example
	 * // Specific color
	 * text.css({
	 *    textOutline: '1px black'
	 * });
	 * // Automatic contrast
	 * text.css({
	 *    color: '#000000', // black text
	 *    textOutline: '1px contrast' // => white outline
	 * });
	 */
	applyTextOutline: function (textOutline) {
		var elem = this.element,
			tspans,
			tspan,
			hasContrast = textOutline.indexOf('contrast') !== -1,
			styles = {},
			color,
			strokeWidth,
			firstRealChild,
			i;

		// When the text shadow is set to contrast, use dark stroke for light
		// text and vice versa.
		if (hasContrast) {
			styles.textOutline = textOutline = textOutline.replace(
				/contrast/g,
				this.renderer.getContrast(elem.style.fill)
			);
		}

		// Extract the stroke width and color
		textOutline = textOutline.split(' ');
		color = textOutline[textOutline.length - 1];
		strokeWidth = textOutline[0];

		if (strokeWidth && strokeWidth !== 'none' && H.svg) {

			this.fakeTS = true; // Fake text shadow

			tspans = [].slice.call(elem.getElementsByTagName('tspan'));

			// In order to get the right y position of the clone,
			// copy over the y setter
			this.ySetter = this.xSetter;

			// Since the stroke is applied on center of the actual outline, we
			// need to double it to get the correct stroke-width outside the 
			// glyphs.
			strokeWidth = strokeWidth.replace(
				/(^[\d\.]+)(.*?)$/g,
				function (match, digit, unit) {
					return (2 * digit) + unit;
				}
			);
			
			// Remove shadows from previous runs. Iterate from the end to
			// support removing items inside the cycle (#6472).
			i = tspans.length;
			while (i--) {
				tspan = tspans[i];
				if (tspan.getAttribute('class') === 'highcharts-text-outline') {
					// Remove then erase
					erase(tspans, elem.removeChild(tspan));
				}
			}

			// For each of the tspans, create a stroked copy behind it.
			firstRealChild = elem.firstChild;
			each(tspans, function (tspan, y) {
				var clone;

				// Let the first line start at the correct X position
				if (y === 0) {
					tspan.setAttribute('x', elem.getAttribute('x'));
					y = elem.getAttribute('y');
					tspan.setAttribute('y', y || 0);
					if (y === null) {
						elem.setAttribute('y', 0);
					}
				}

				// Create the clone and apply outline properties
				clone = tspan.cloneNode(1);
				attr(clone, {
					'class': 'highcharts-text-outline',
					'fill': color,
					'stroke': color,
					'stroke-width': strokeWidth,
					'stroke-linejoin': 'round'
				});
				elem.insertBefore(clone, firstRealChild);
			});
		}
	},

	/**
	 *
	 * @typedef {Object} SVGAttributes An object of key-value pairs for SVG
	 *   attributes. Attributes in Highcharts elements for the most parts
	 *   correspond to SVG, but some are specific to Highcharts, like `zIndex`,
	 *   `rotation`, `rotationOriginX`, `rotationOriginY`, `translateX`,
	 *   `translateY`, `scaleX` and `scaleY`. SVG attributes containing a hyphen
	 *   are _not_ camel-cased, they should be quoted to preserve the hyphen.
	 *   
	 * @example
	 * {
	 *     'stroke': '#ff0000', // basic
	 *     'stroke-width': 2, // hyphenated
	 *     'rotation': 45 // custom
	 *     'd': ['M', 10, 10, 'L', 30, 30, 'z'] // path definition, note format
	 * }
	 */
	/**
	 * Apply native and custom attributes to the SVG elements.
	 * 
	 * In order to set the rotation center for rotation, set x and y to 0 and
	 * use `translateX` and `translateY` attributes to position the element
	 * instead.
	 *
	 * Attributes frequently used in Highcharts are `fill`, `stroke`,
	 * `stroke-width`.
	 *
	 * @param {SVGAttributes|String} hash - The native and custom SVG
	 *    attributes. 
	 * @param {string} [val] - If the type of the first argument is `string`, 
	 *    the second can be a value, which will serve as a single attribute
	 *    setter. If the first argument is a string and the second is undefined,
	 *    the function serves as a getter and the current value of the property
	 *    is returned.
	 * @param {Function} [complete] - A callback function to execute after
	 *    setting the attributes. This makes the function compliant and
	 *    interchangeable with the {@link SVGElement#animate} function.
	 * @param {boolean} [continueAnimation=true] Used internally when `.attr` is
	 *    called as part of an animation step. Otherwise, calling `.attr` for an
	 *    attribute will stop animation for that attribute.
	 *    
	 * @returns {SVGElement|string|number} If used as a setter, it returns the 
	 *    current {@link SVGElement} so the calls can be chained. If used as a 
	 *    getter, the current value of the attribute is returned.
	 *
	 * @sample highcharts/members/renderer-rect/
	 *         Setting some attributes
	 * 
	 * @example
	 * // Set multiple attributes
	 * element.attr({
	 *     stroke: 'red',
	 *     fill: 'blue',
	 *     x: 10,
	 *     y: 10
	 * });
	 *
	 * // Set a single attribute
	 * element.attr('stroke', 'red');
	 *
	 * // Get an attribute
	 * element.attr('stroke'); // => 'red'
	 * 
	 */
	attr: function (hash, val, complete, continueAnimation) {
		var key,
			element = this.element,
			hasSetSymbolSize,
			ret = this,
			skipAttr,
			setter;

		// single key-value pair
		if (typeof hash === 'string' && val !== undefined) {
			key = hash;
			hash = {};
			hash[key] = val;
		}

		// used as a getter: first argument is a string, second is undefined
		if (typeof hash === 'string') {
			ret = (this[hash + 'Getter'] || this._defaultGetter).call(
				this,
				hash,
				element
			);

		// setter
		} else {

			objectEach(hash, function eachAttribute(val, key) {
				skipAttr = false;
				
				// Unless .attr is from the animator update, stop current
				// running animation of this property
				if (!continueAnimation) {
					stop(this, key);
				}
				
				// Special handling of symbol attributes
				if (
					this.symbolName &&
					/^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)$/
					.test(key)
				) {
					if (!hasSetSymbolSize) {
						this.symbolAttr(hash);
						hasSetSymbolSize = true;
					}
					skipAttr = true;
				}
				
				if (this.rotation && (key === 'x' || key === 'y')) {
					this.doTransform = true;
				}
				
				if (!skipAttr) {
					setter = this[key + 'Setter'] || this._defaultSetter;
					setter.call(this, val, key, element);
					
					
					// Let the shadow follow the main element
					if (
						this.shadows &&
						/^(width|height|visibility|x|y|d|transform|cx|cy|r)$/
							.test(key)
					) {
						this.updateShadows(key, val, setter);
					}
					
				}
			}, this);

			this.afterSetters();
		}

		// In accordance with animate, run a complete callback
		if (complete) {
			complete();
		}

		return ret;
	},

	/**
	 * This method is executed in the end of `attr()`, after setting all
	 * attributes in the hash. In can be used to efficiently consolidate
	 * multiple attributes in one SVG property -- e.g., translate, rotate and
	 * scale are merged in one "transform" attribute in the SVG node.
	 *
	 * @private
	 */
	afterSetters: function () {
		// Update transform. Do this outside the loop to prevent redundant
		// updating for batch setting of attributes.
		if (this.doTransform) {
			this.updateTransform();
			this.doTransform = false;
		}
	},

	
	/**
	 * Update the shadow elements with new attributes.
	 *
	 * @private
	 * @param {String} key - The attribute name.
	 * @param {String|Number} value - The value of the attribute.
	 * @param {Function} setter - The setter function, inherited from the
	 *   parent wrapper
	 * 
	 */
	updateShadows: function (key, value, setter) {
		var shadows = this.shadows,
			i = shadows.length;

		while (i--) {
			setter.call(
				shadows[i], 
				key === 'height' ?
					Math.max(value - (shadows[i].cutHeight || 0), 0) :
					key === 'd' ? this.d : value, 
				key, 
				shadows[i]
			);
		}
	},
	

	/**
	 * Add a class name to an element.
	 *
	 * @param {string} className - The new class name to add.
	 * @param {boolean} [replace=false] - When true, the existing class name(s)
	 *    will be overwritten with the new one. When false, the new one is
	 *    added.
	 * @returns {SVGElement} Return the SVG element for chainability.
	 */
	addClass: function (className, replace) {
		var currentClassName = this.attr('class') || '';
		if (currentClassName.indexOf(className) === -1) {
			if (!replace) {
				className = 
					(currentClassName + (currentClassName ? ' ' : '') +
					className).replace('  ', ' ');
			}
			this.attr('class', className);
		}

		return this;
	},

	/**
	 * Check if an element has the given class name.
	 * @param  {string} className
	 *         The class name to check for.
	 * @return {Boolean}
	 *         Whether the class name is found.
	 */
	hasClass: function (className) {
		return inArray(
			className,
			(this.attr('class') || '').split(' ')
		) !== -1;
	},

	/**
	 * Remove a class name from the element.
	 * @param  {String|RegExp} className The class name to remove.
	 * @return {SVGElement} Returns the SVG element for chainability.
	 */
	removeClass: function (className) {
		return this.attr(
			'class',
			(this.attr('class') || '').replace(className, '')
		);
	},

	/**
	 * If one of the symbol size affecting parameters are changed,
	 * check all the others only once for each call to an element's
	 * .attr() method
	 * @param {Object} hash - The attributes to set.
	 * @private
	 */
	symbolAttr: function (hash) {
		var wrapper = this;

		each([
			'x',
			'y',
			'r',
			'start',
			'end',
			'width',
			'height',
			'innerR',
			'anchorX',
			'anchorY'
		], function (key) {
			wrapper[key] = pick(hash[key], wrapper[key]);
		});

		wrapper.attr({
			d: wrapper.renderer.symbols[wrapper.symbolName](
				wrapper.x,
				wrapper.y,
				wrapper.width,
				wrapper.height,
				wrapper
			)
		});
	},

	/**
	 * Apply a clipping rectangle to this element.
	 * 
	 * @param {ClipRect} [clipRect] - The clipping rectangle. If skipped, the
	 *    current clip is removed.
	 * @returns {SVGElement} Returns the SVG element to allow chaining.
	 */
	clip: function (clipRect) {
		return this.attr(
			'clip-path',
			clipRect ?
				'url(' + this.renderer.url + '#' + clipRect.id + ')' :
				'none'
		);
	},

	/**
	 * Calculate the coordinates needed for drawing a rectangle crisply and
	 * return the calculated attributes.
	 * 
	 * @param {Object} rect - A rectangle.
	 * @param {number} rect.x - The x position.
	 * @param {number} rect.y - The y position.
	 * @param {number} rect.width - The width.
	 * @param {number} rect.height - The height.
	 * @param {number} [strokeWidth] - The stroke width to consider when
	 *    computing crisp positioning. It can also be set directly on the rect
	 *    parameter.
	 *
	 * @returns {{x: Number, y: Number, width: Number, height: Number}} The
	 *    modified rectangle arguments.
	 */
	crisp: function (rect, strokeWidth) {

		var wrapper = this,
			normalizer;

		strokeWidth = strokeWidth || rect.strokeWidth || 0;
		// Math.round because strokeWidth can sometimes have roundoff errors
		normalizer = Math.round(strokeWidth) % 2 / 2;

		// normalize for crisp edges
		rect.x = Math.floor(rect.x || wrapper.x || 0) + normalizer;
		rect.y = Math.floor(rect.y || wrapper.y || 0) + normalizer;
		rect.width = Math.floor(
			(rect.width || wrapper.width || 0) - 2 * normalizer
		);
		rect.height = Math.floor(
			(rect.height || wrapper.height || 0) - 2 * normalizer
		);
		if (defined(rect.strokeWidth)) {
			rect.strokeWidth = strokeWidth;
		}
		return rect;
	},

	/**
	 * Set styles for the element. In addition to CSS styles supported by 
	 * native SVG and HTML elements, there are also some custom made for 
	 * Highcharts, like `width`, `ellipsis` and `textOverflow` for SVG text
	 * elements.
	 * @param {CSSObject} styles The new CSS styles.
	 * @returns {SVGElement} Return the SVG element for chaining.
	 *
	 * @sample highcharts/members/renderer-text-on-chart/
	 *         Styled text
	 */
	css: function (styles) {
		var oldStyles = this.styles,
			newStyles = {},
			elem = this.element,
			textWidth,
			serializedCss = '',
			hyphenate,
			hasNew = !oldStyles,
			// These CSS properties are interpreted internally by the SVG
			// renderer, but are not supported by SVG and should not be added to
			// the DOM. In styled mode, no CSS should find its way to the DOM
			// whatsoever (#6173, #6474).
			svgPseudoProps = ['textOutline', 'textOverflow', 'width'];

		// convert legacy
		if (styles && styles.color) {
			styles.fill = styles.color;
		}

		// Filter out existing styles to increase performance (#2640)
		if (oldStyles) {
			objectEach(styles, function (style, n) {
				if (style !== oldStyles[n]) {
					newStyles[n] = style;
					hasNew = true;
				}
			});
		}
		if (hasNew) {

			// Merge the new styles with the old ones
			if (oldStyles) {
				styles = extend(
					oldStyles,
					newStyles
				);
			}

			// Get the text width from style
			textWidth = this.textWidth = (
				styles &&
				styles.width &&
				styles.width !== 'auto' &&
				elem.nodeName.toLowerCase() === 'text' &&
				pInt(styles.width)
			);

			// store object
			this.styles = styles;

			if (textWidth && (!svg && this.renderer.forExport)) {
				delete styles.width;
			}

			// serialize and set style attribute
			if (isMS && !svg) {
				css(this.element, styles);
			} else {
				hyphenate = function (a, b) {
					return '-' + b.toLowerCase();
				};
				objectEach(styles, function (style, n) {
					if (inArray(n, svgPseudoProps) === -1) {
						serializedCss +=
						n.replace(/([A-Z])/g, hyphenate) + ':' +
						style + ';';
					}
				});
				if (serializedCss) {
					attr(elem, 'style', serializedCss); // #1881
				}
			}


			if (this.added) {

				// Rebuild text after added. Cache mechanisms in the buildText
				// will prevent building if there are no significant changes.
				if (this.element.nodeName === 'text') {
					this.renderer.buildText(this);
				}

				// Apply text outline after added
				if (styles && styles.textOutline) {
					this.applyTextOutline(styles.textOutline);
				}
			}
		}

		return this;
	},

	
	/**
	 * Get the current stroke width. In classic mode, the setter registers it 
	 * directly on the element.
	 * @returns {number} The stroke width in pixels.
	 * @ignore
	 */
	strokeWidth: function () {
		return this['stroke-width'] || 0;
	},

	
	/**
	 * Add an event listener. This is a simple setter that replaces all other
	 * events of the same type, opposed to the {@link Highcharts#addEvent}
	 * function.
	 * @param {string} eventType - The event type. If the type is `click`, 
	 *    Highcharts will internally translate it to a `touchstart` event on 
	 *    touch devices, to prevent the browser from waiting for a click event
	 *    from firing.
	 * @param {Function} handler - The handler callback.
	 * @returns {SVGElement} The SVGElement for chaining.
	 *
	 * @sample highcharts/members/element-on/
	 *         A clickable rectangle
	 */
	on: function (eventType, handler) {
		var svgElement = this,
			element = svgElement.element;

		// touch
		if (hasTouch && eventType === 'click') {
			element.ontouchstart = function (e) {
				svgElement.touchEventFired = Date.now(); // #2269
				e.preventDefault();
				handler.call(element, e);
			};
			element.onclick = function (e) {
				if (win.navigator.userAgent.indexOf('Android') === -1 ||
						Date.now() - (svgElement.touchEventFired || 0) > 1100) {
					handler.call(element, e);
				}
			};
		} else {
			// simplest possible event model for internal use
			element['on' + eventType] = handler;
		}
		return this;
	},

	/**
	 * Set the coordinates needed to draw a consistent radial gradient across
	 * a shape regardless of positioning inside the chart. Used on pie slices
	 * to make all the slices have the same radial reference point.
	 *
	 * @param {Array} coordinates The center reference. The format is
	 *    `[centerX, centerY, diameter]` in pixels.
	 * @returns {SVGElement} Returns the SVGElement for chaining.
	 */
	setRadialReference: function (coordinates) {
		var existingGradient = this.renderer.gradients[this.element.gradient];

		this.element.radialReference = coordinates;

		// On redrawing objects with an existing gradient, the gradient needs
		// to be repositioned (#3801)
		if (existingGradient && existingGradient.radAttr) {
			existingGradient.animate(
				this.renderer.getRadialAttr(
					coordinates,
					existingGradient.radAttr
				)
			);
		}

		return this;
	},

	/**
	 * Move an object and its children by x and y values.
	 * 
	 * @param {number} x - The x value.
	 * @param {number} y - The y value.
	 */
	translate: function (x, y) {
		return this.attr({
			translateX: x,
			translateY: y
		});
	},

	/**
	 * Invert a group, rotate and flip. This is used internally on inverted 
	 * charts, where the points and graphs are drawn as if not inverted, then
	 * the series group elements are inverted.
	 *
	 * @param  {boolean} inverted
	 *         Whether to invert or not. An inverted shape can be un-inverted by
	 *         setting it to false.
	 * @return {SVGElement}
	 *         Return the SVGElement for chaining.
	 */
	invert: function (inverted) {
		var wrapper = this;
		wrapper.inverted = inverted;
		wrapper.updateTransform();
		return wrapper;
	},

	/**
	 * Update the transform attribute based on internal properties. Deals with
	 * the custom `translateX`, `translateY`, `rotation`, `scaleX` and `scaleY`
	 * attributes and updates the SVG `transform` attribute.
	 * @private
	 * 
	 */
	updateTransform: function () {
		var wrapper = this,
			translateX = wrapper.translateX || 0,
			translateY = wrapper.translateY || 0,
			scaleX = wrapper.scaleX,
			scaleY = wrapper.scaleY,
			inverted = wrapper.inverted,
			rotation = wrapper.rotation,
			matrix = wrapper.matrix,
			element = wrapper.element,
			transform;

		// Flipping affects translate as adjustment for flipping around the
		// group's axis
		if (inverted) {
			translateX += wrapper.width;
			translateY += wrapper.height;
		}

		// Apply translate. Nearly all transformed elements have translation,
		// so instead of checking for translate = 0, do it always (#1767,
		// #1846).
		transform = ['translate(' + translateX + ',' + translateY + ')'];

		// apply matrix
		if (defined(matrix)) {
			transform.push(
				'matrix(' + matrix.join(',') + ')'
			);
		}
		
		// apply rotation
		if (inverted) {
			transform.push('rotate(90) scale(-1,1)');
		} else if (rotation) { // text rotation
			transform.push(
				'rotate(' + rotation + ' ' +
				pick(this.rotationOriginX, element.getAttribute('x'), 0) +
				' ' +
				pick(this.rotationOriginY, element.getAttribute('y') || 0) + ')'
			);
		}

		// apply scale
		if (defined(scaleX) || defined(scaleY)) {
			transform.push(
				'scale(' + pick(scaleX, 1) + ' ' + pick(scaleY, 1) + ')'
			);
		}

		if (transform.length) {
			element.setAttribute('transform', transform.join(' '));
		}
	},

	/**
	 * Bring the element to the front. Alternatively, a new zIndex can be set.
	 *
	 * @returns {SVGElement} Returns the SVGElement for chaining.
	 *
	 * @sample highcharts/members/element-tofront/
	 *         Click an element to bring it to front
	 */
	toFront: function () {
		var element = this.element;
		element.parentNode.appendChild(element);
		return this;
	},


	/**
	 * Align the element relative to the chart or another box.
	 * 
	 * @param {Object} [alignOptions] The alignment options. The function can be
	 *   called without this parameter in order to re-align an element after the
	 *   box has been updated.
	 * @param {string} [alignOptions.align=left] Horizontal alignment. Can be
	 *   one of `left`, `center` and `right`.
	 * @param {string} [alignOptions.verticalAlign=top] Vertical alignment. Can
	 *   be one of `top`, `middle` and `bottom`.
	 * @param {number} [alignOptions.x=0] Horizontal pixel offset from
	 *   alignment.
	 * @param {number} [alignOptions.y=0] Vertical pixel offset from alignment.
	 * @param {Boolean} [alignByTranslate=false] Use the `transform` attribute
	 *   with translateX and translateY custom attributes to align this elements
	 *   rather than `x` and `y` attributes.
	 * @param {String|Object} box The box to align to, needs a width and height.
	 *   When the box is a string, it refers to an object in the Renderer. For
	 *   example, when box is `spacingBox`, it refers to `Renderer.spacingBox`
	 *   which holds `width`, `height`, `x` and `y` properties.
	 * @returns {SVGElement} Returns the SVGElement for chaining.
	 */
	align: function (alignOptions, alignByTranslate, box) {
		var align,
			vAlign,
			x,
			y,
			attribs = {},
			alignTo,
			renderer = this.renderer,
			alignedObjects = renderer.alignedObjects,
			alignFactor,
			vAlignFactor;

		// First call on instanciate
		if (alignOptions) {
			this.alignOptions = alignOptions;
			this.alignByTranslate = alignByTranslate;
			if (!box || isString(box)) {
				this.alignTo = alignTo = box || 'renderer';
				// prevent duplicates, like legendGroup after resize
				erase(alignedObjects, this);
				alignedObjects.push(this);
				box = null; // reassign it below
			}

		// When called on resize, no arguments are supplied
		} else {
			alignOptions = this.alignOptions;
			alignByTranslate = this.alignByTranslate;
			alignTo = this.alignTo;
		}

		box = pick(box, renderer[alignTo], renderer);

		// Assign variables
		align = alignOptions.align;
		vAlign = alignOptions.verticalAlign;
		x = (box.x || 0) + (alignOptions.x || 0); // default: left align
		y = (box.y || 0) + (alignOptions.y || 0); // default: top align

		// Align
		if (align === 'right') {
			alignFactor = 1;
		} else if (align === 'center') {
			alignFactor = 2;
		}
		if (alignFactor) {
			x += (box.width - (alignOptions.width || 0)) / alignFactor;
		}
		attribs[alignByTranslate ? 'translateX' : 'x'] = Math.round(x);


		// Vertical align
		if (vAlign === 'bottom') {
			vAlignFactor = 1;
		} else if (vAlign === 'middle') {
			vAlignFactor = 2;
		}
		if (vAlignFactor) {
			y += (box.height - (alignOptions.height || 0)) / vAlignFactor;
		}
		attribs[alignByTranslate ? 'translateY' : 'y'] = Math.round(y);

		// Animate only if already placed
		this[this.placed ? 'animate' : 'attr'](attribs);
		this.placed = true;
		this.alignAttr = attribs;

		return this;
	},

	/**
	 * Get the bounding box (width, height, x and y) for the element. Generally
	 * used to get rendered text size. Since this is called a lot in charts,
	 * the results are cached based on text properties, in order to save DOM
	 * traffic. The returned bounding box includes the rotation, so for example
	 * a single text line of rotation 90 will report a greater height, and a
	 * width corresponding to the line-height.
	 *
	 * @param {boolean} [reload] Skip the cache and get the updated DOM bouding
	 *   box.
	 * @param {number} [rot] Override the element's rotation. This is internally
	 *   used on axis labels with a value of 0 to find out what the bounding box
	 *   would be have been if it were not rotated.
	 * @returns {Object} The bounding box with `x`, `y`, `width` and `height`
	 * properties.
	 *
	 * @sample highcharts/members/renderer-on-chart/
	 *         Draw a rectangle based on a text's bounding box
	 */
	getBBox: function (reload, rot) {
		var wrapper = this,
			bBox, // = wrapper.bBox,
			renderer = wrapper.renderer,
			width,
			height,
			rotation,
			rad,
			element = wrapper.element,
			styles = wrapper.styles,
			fontSize,
			textStr = wrapper.textStr,
			toggleTextShadowShim,
			cache = renderer.cache,
			cacheKeys = renderer.cacheKeys,
			cacheKey;

		rotation = pick(rot, wrapper.rotation);
		rad = rotation * deg2rad;

		
		fontSize = styles && styles.fontSize;
		

		// Avoid undefined and null (#7316)
		if (defined(textStr)) {

			cacheKey = textStr.toString();
			
			// Since numbers are monospaced, and numerical labels appear a lot
			// in a chart, we assume that a label of n characters has the same
			// bounding box as others of the same length. Unless there is inner
			// HTML in the label. In that case, leave the numbers as is (#5899).
			if (cacheKey.indexOf('<') === -1) {
				cacheKey = cacheKey.replace(/[0-9]/g, '0');
			}

			// Properties that affect bounding box
			cacheKey += [
				'',
				rotation || 0,
				fontSize,
				styles && styles.width,
				styles && styles.textOverflow // #5968
			]
			.join(',');

		}

		if (cacheKey && !reload) {
			bBox = cache[cacheKey];
		}

		// No cache found
		if (!bBox) {

			// SVG elements
			if (element.namespaceURI === wrapper.SVG_NS || renderer.forExport) {
				try { // Fails in Firefox if the container has display: none.

					// When the text shadow shim is used, we need to hide the
					// fake shadows to get the correct bounding box (#3872)
					toggleTextShadowShim = this.fakeTS && function (display) {
						each(
							element.querySelectorAll(
								'.highcharts-text-outline'
							),
							function (tspan) {
								tspan.style.display = display;
							}
						);
					};

					// Workaround for #3842, Firefox reporting wrong bounding
					// box for shadows
					if (toggleTextShadowShim) {
						toggleTextShadowShim('none');
					}

					bBox = element.getBBox ?
						// SVG: use extend because IE9 is not allowed to change
						// width and height in case of rotation (below)
						extend({}, element.getBBox()) : {

							// Legacy IE in export mode
							width: element.offsetWidth,
							height: element.offsetHeight
						};

					// #3842
					if (toggleTextShadowShim) {
						toggleTextShadowShim('');
					}
				} catch (e) {}

				// If the bBox is not set, the try-catch block above failed. The
				// other condition is for Opera that returns a width of
				// -Infinity on hidden elements.
				if (!bBox || bBox.width < 0) {
					bBox = { width: 0, height: 0 };
				}


			// VML Renderer or useHTML within SVG
			} else {

				bBox = wrapper.htmlGetBBox();

			}

			// True SVG elements as well as HTML elements in modern browsers
			// using the .useHTML option need to compensated for rotation
			if (renderer.isSVG) {
				width = bBox.width;
				height = bBox.height;

				// Workaround for wrong bounding box in IE, Edge and Chrome on
				// Windows. With Highcharts' default font, IE and Edge report
				// a box height of 16.899 and Chrome rounds it to 17. If this 
				// stands uncorrected, it results in more padding added below
				// the text than above when adding a label border or background.
				// Also vertical positioning is affected.
				// http://jsfiddle.net/highcharts/em37nvuj/
				// (#1101, #1505, #1669, #2568, #6213).
				if (
					styles &&
					styles.fontSize === '11px' &&
					Math.round(height) === 17
				) {
					bBox.height = height = 14;
				}

				// Adjust for rotated text
				if (rotation) {
					bBox.width = Math.abs(height * Math.sin(rad)) +
						Math.abs(width * Math.cos(rad));
					bBox.height = Math.abs(height * Math.cos(rad)) +
						Math.abs(width * Math.sin(rad));
				}
			}

			// Cache it. When loading a chart in a hidden iframe in Firefox and
			// IE/Edge, the bounding box height is 0, so don't cache it (#5620).
			if (cacheKey && bBox.height > 0) {

				// Rotate (#4681)
				while (cacheKeys.length > 250) {
					delete cache[cacheKeys.shift()];
				}

				if (!cache[cacheKey]) {
					cacheKeys.push(cacheKey);
				}
				cache[cacheKey] = bBox;
			}
		}
		return bBox;
	},

	/**
	 * Show the element after it has been hidden. 
	 *
	 * @param {boolean} [inherit=false] Set the visibility attribute to
	 * `inherit` rather than `visible`. The difference is that an element with
	 * `visibility="visible"` will be visible even if the parent is hidden.
	 *
	 * @returns {SVGElement} Returns the SVGElement for chaining.
	 */
	show: function (inherit) {
		return this.attr({ visibility: inherit ? 'inherit' : 'visible' });
	},

	/**
	 * Hide the element, equivalent to setting the `visibility` attribute to
	 * `hidden`.
	 *
	 * @returns {SVGElement} Returns the SVGElement for chaining.
	 */
	hide: function () {
		return this.attr({ visibility: 'hidden' });
	},

	/**
	 * Fade out an element by animating its opacity down to 0, and hide it on
	 * complete. Used internally for the tooltip.
	 * 
	 * @param {number} [duration=150] The fade duration in milliseconds.
	 */
	fadeOut: function (duration) {
		var elemWrapper = this;
		elemWrapper.animate({
			opacity: 0
		}, {
			duration: duration || 150,
			complete: function () {
				// #3088, assuming we're only using this for tooltips
				elemWrapper.attr({ y: -9999 });
			}
		});
	},

	/**
	 * Add the element to the DOM. All elements must be added this way.
	 * 
	 * @param {SVGElement|SVGDOMElement} [parent] The parent item to add it to.
	 *   If undefined, the element is added to the {@link
	 *   Highcharts.SVGRenderer.box}.
	 *
	 * @returns {SVGElement} Returns the SVGElement for chaining.
	 *
	 * @sample highcharts/members/renderer-g - Elements added to a group
	 */
	add: function (parent) {

		var renderer = this.renderer,
			element = this.element,
			inserted;

		if (parent) {
			this.parentGroup = parent;
		}

		// mark as inverted
		this.parentInverted = parent && parent.inverted;

		// build formatted text
		if (this.textStr !== undefined) {
			renderer.buildText(this);
		}

		// Mark as added
		this.added = true;

		// If we're adding to renderer root, or other elements in the group
		// have a z index, we need to handle it
		if (!parent || parent.handleZ || this.zIndex) {
			inserted = this.zIndexSetter();
		}

		// If zIndex is not handled, append at the end
		if (!inserted) {
			(parent ? parent.element : renderer.box).appendChild(element);
		}

		// fire an event for internal hooks
		if (this.onAdd) {
			this.onAdd();
		}

		return this;
	},

	/**
	 * Removes an element from the DOM.
	 *
	 * @private
	 * @param {SVGDOMElement|HTMLDOMElement} element The DOM node to remove.
	 */
	safeRemoveChild: function (element) {
		var parentNode = element.parentNode;
		if (parentNode) {
			parentNode.removeChild(element);
		}
	},

	/**
	 * Destroy the element and element wrapper and clear up the DOM and event
	 * hooks.
	 *
	 * 
	 */
	destroy: function () {
		var wrapper = this,
			element = wrapper.element || {},
			parentToClean =
				wrapper.renderer.isSVG &&
				element.nodeName === 'SPAN' &&
				wrapper.parentGroup,
			grandParent,
			ownerSVGElement = element.ownerSVGElement,
			i;

		// remove events
		element.onclick = element.onmouseout = element.onmouseover =
			element.onmousemove = element.point = null;
		stop(wrapper); // stop running animations

		if (wrapper.clipPath && ownerSVGElement) {
			// Look for existing references to this clipPath and remove them
			// before destroying the element (#6196).
			each(
				// The upper case version is for Edge
				ownerSVGElement.querySelectorAll('[clip-path],[CLIP-PATH]'),
				function (el) {
					// Include the closing paranthesis in the test to rule out
					// id's from 10 and above (#6550)
					if (el
						.getAttribute('clip-path')
						.match(RegExp(
							// Edge puts quotes inside the url, others not
							'[\("]#' + wrapper.clipPath.element.id + '[\)"]'
						))
					) {
						el.removeAttribute('clip-path');
					}
				}
			);
			wrapper.clipPath = wrapper.clipPath.destroy();
		}

		// Destroy stops in case this is a gradient object
		if (wrapper.stops) {
			for (i = 0; i < wrapper.stops.length; i++) {
				wrapper.stops[i] = wrapper.stops[i].destroy();
			}
			wrapper.stops = null;
		}

		// remove element
		wrapper.safeRemoveChild(element);

		
		wrapper.destroyShadows();
		

		// In case of useHTML, clean up empty containers emulating SVG groups
		// (#1960, #2393, #2697).
		while (
			parentToClean &&
			parentToClean.div &&
			parentToClean.div.childNodes.length === 0
		) {
			grandParent = parentToClean.parentGroup;
			wrapper.safeRemoveChild(parentToClean.div);
			delete parentToClean.div;
			parentToClean = grandParent;
		}

		// remove from alignObjects
		if (wrapper.alignTo) {
			erase(wrapper.renderer.alignedObjects, wrapper);
		}

		objectEach(wrapper, function (val, key) {
			delete wrapper[key];
		});

		return null;
	},

	
	/**
	 * @typedef {Object} ShadowOptions
	 * @property {string} [color=#000000] The shadow color.
	 * @property {number} [offsetX=1] The horizontal offset from the element.
	 * @property {number} [offsetY=1] The vertical offset from the element.
	 * @property {number} [opacity=0.15] The shadow opacity.
	 * @property {number} [width=3] The shadow width or distance from the
	 *    element.
	 */
	/**
	 * Add a shadow to the element. Must be called after the element is added to
	 * the DOM. In styled mode, this method is not used, instead use `defs` and
	 * filters.
	 * 
	 * @param {boolean|ShadowOptions} shadowOptions The shadow options. If
	 *    `true`, the default options are applied. If `false`, the current
	 *    shadow will be removed.
	 * @param {SVGElement} [group] The SVG group element where the shadows will 
	 *    be applied. The default is to add it to the same parent as the current
	 *    element. Internally, this is ised for pie slices, where all the
	 *    shadows are added to an element behind all the slices.
	 * @param {boolean} [cutOff] Used internally for column shadows.
	 *
	 * @returns {SVGElement} Returns the SVGElement for chaining.
	 *
	 * @example
	 * renderer.rect(10, 100, 100, 100)
	 *     .attr({ fill: 'red' })
	 *     .shadow(true);
	 */
	shadow: function (shadowOptions, group, cutOff) {
		var shadows = [],
			i,
			shadow,
			element = this.element,
			strokeWidth,
			shadowWidth,
			shadowElementOpacity,

			// compensate for inverted plot area
			transform;

		if (!shadowOptions) {
			this.destroyShadows();
		
		} else if (!this.shadows) {
			shadowWidth = pick(shadowOptions.width, 3);
			shadowElementOpacity = (shadowOptions.opacity || 0.15) /
				shadowWidth;
			transform = this.parentInverted ?
					'(-1,-1)' :
					'(' + pick(shadowOptions.offsetX, 1) + ', ' +
						pick(shadowOptions.offsetY, 1) + ')';
			for (i = 1; i <= shadowWidth; i++) {
				shadow = element.cloneNode(0);
				strokeWidth = (shadowWidth * 2) + 1 - (2 * i);
				attr(shadow, {
					'isShadow': 'true',
					'stroke':
						shadowOptions.color || '#000000',
					'stroke-opacity': shadowElementOpacity * i,
					'stroke-width': strokeWidth,
					'transform': 'translate' + transform,
					'fill': 'none'
				});
				if (cutOff) {
					attr(
						shadow,
						'height',
						Math.max(attr(shadow, 'height') - strokeWidth, 0)
					);
					shadow.cutHeight = strokeWidth;
				}

				if (group) {
					group.element.appendChild(shadow);
				} else if (element.parentNode) {
					element.parentNode.insertBefore(shadow, element);
				}

				shadows.push(shadow);
			}

			this.shadows = shadows;
		}
		return this;

	},

	/**
	 * Destroy shadows on the element.
	 * @private
	 */
	destroyShadows: function () {
		each(this.shadows || [], function (shadow) {
			this.safeRemoveChild(shadow);
		}, this);
		this.shadows = undefined;
	},

	

	xGetter: function (key) {
		if (this.element.nodeName === 'circle') {
			if (key === 'x') {
				key = 'cx';
			} else if (key === 'y') {
				key = 'cy';
			}
		}
		return this._defaultGetter(key);
	},

	/**
	 * Get the current value of an attribute or pseudo attribute, used mainly
	 * for animation. Called internally from the {@link
	 * Highcharts.SVGRenderer#attr}
	 * function.
	 *
	 * @private
	 */
	_defaultGetter: function (key) {
		var ret = pick(
			this[key + 'Value'], // align getter
			this[key],
			this.element ? this.element.getAttribute(key) : null,
			0
		);

		if (/^[\-0-9\.]+$/.test(ret)) { // is numerical
			ret = parseFloat(ret);
		}
		return ret;
	},


	dSetter: function (value, key, element) {
		if (value && value.join) { // join path
			value = value.join(' ');
		}
		if (/(NaN| {2}|^$)/.test(value)) {
			value = 'M 0 0';
		}

		// Check for cache before resetting. Resetting causes disturbance in the
		// DOM, causing flickering in some cases in Edge/IE (#6747). Also
		// possible performance gain.
		if (this[key] !== value) {
			element.setAttribute(key, value);
			this[key] = value;
		}		

	},
	
	dashstyleSetter: function (value) {
		var i,
			strokeWidth = this['stroke-width'];
		
		// If "inherit", like maps in IE, assume 1 (#4981). With HC5 and the new
		// strokeWidth function, we should be able to use that instead.
		if (strokeWidth === 'inherit') {
			strokeWidth = 1;
		}
		value = value && value.toLowerCase();
		if (value) {
			value = value
				.replace('shortdashdotdot', '3,1,1,1,1,1,')
				.replace('shortdashdot', '3,1,1,1')
				.replace('shortdot', '1,1,')
				.replace('shortdash', '3,1,')
				.replace('longdash', '8,3,')
				.replace(/dot/g, '1,3,')
				.replace('dash', '4,3,')
				.replace(/,$/, '')
				.split(','); // ending comma

			i = value.length;
			while (i--) {
				value[i] = pInt(value[i]) * strokeWidth;
			}
			value = value.join(',')
				.replace(/NaN/g, 'none'); // #3226
			this.element.setAttribute('stroke-dasharray', value);
		}
	},
	
	alignSetter: function (value) {
		var convert = { left: 'start', center: 'middle', right: 'end' };
		this.alignValue = value;
		this.element.setAttribute('text-anchor', convert[value]);
	},
	opacitySetter: function (value, key, element) {		
		this[key] = value;		
		element.setAttribute(key, value);		
	},
	titleSetter: function (value) {
		var titleNode = this.element.getElementsByTagName('title')[0];
		if (!titleNode) {
			titleNode = doc.createElementNS(this.SVG_NS, 'title');
			this.element.appendChild(titleNode);
		}

		// Remove text content if it exists
		if (titleNode.firstChild) {
			titleNode.removeChild(titleNode.firstChild);
		}

		titleNode.appendChild(
			doc.createTextNode(
				// #3276, #3895
				(String(pick(value), '')).replace(/<[^>]*>/g, '')
			)
		);
	},
	textSetter: function (value) {
		if (value !== this.textStr) {
			// Delete bBox memo when the text changes
			delete this.bBox;

			this.textStr = value;
			if (this.added) {
				this.renderer.buildText(this);
			}
		}
	},
	fillSetter: function (value, key, element) {
		if (typeof value === 'string') {
			element.setAttribute(key, value);
		} else if (value) {
			this.colorGradient(value, key, element);
		}
	},
	visibilitySetter: function (value, key, element) {
		// IE9-11 doesn't handle visibilty:inherit well, so we remove the
		// attribute instead (#2881, #3909)
		if (value === 'inherit') {
			element.removeAttribute(key);
		} else if (this[key] !== value) { // #6747
			element.setAttribute(key, value);
		}
		this[key] = value;
	},
	zIndexSetter: function (value, key) {
		var renderer = this.renderer,
			parentGroup = this.parentGroup,
			parentWrapper = parentGroup || renderer,
			parentNode = parentWrapper.element || renderer.box,
			childNodes,
			otherElement,
			otherZIndex,
			element = this.element,
			inserted,
			undefinedOtherZIndex,
			svgParent = parentNode === renderer.box,
			run = this.added,
			i;

		if (defined(value)) {
			// So we can read it for other elements in the group
			element.zIndex = value;

			value = +value;
			if (this[key] === value) { // Only update when needed (#3865)
				run = false;
			}
			this[key] = value;
		}

		// Insert according to this and other elements' zIndex. Before .add() is
		// called, nothing is done. Then on add, or by later calls to
		// zIndexSetter, the node is placed on the right place in the DOM.
		if (run) {
			value = this.zIndex;

			if (value && parentGroup) {
				parentGroup.handleZ = true;
			}

			childNodes = parentNode.childNodes;
			for (i = childNodes.length - 1; i >= 0 && !inserted; i--) {
				otherElement = childNodes[i];
				otherZIndex = otherElement.zIndex;
				undefinedOtherZIndex = !defined(otherZIndex);

				if (otherElement !== element) {
					if (
						// Negative zIndex versus no zIndex:
						// On all levels except the highest. If the parent is <svg>,
						// then we don't want to put items before <desc> or <defs>
						(value < 0 && undefinedOtherZIndex && !svgParent && !i)
					) {
						parentNode.insertBefore(element, childNodes[i]);
						inserted = true;
					} else if (
						// Insert after the first element with a lower zIndex
						pInt(otherZIndex) <= value ||
						// If negative zIndex, add this before first undefined zIndex element
						(undefinedOtherZIndex && (!defined(value) || value >= 0))
					) {
						parentNode.insertBefore(
							element,
							childNodes[i + 1] || null // null for oldIE export
						);
						inserted = true;
					}
				}
			}

			if (!inserted) {
				parentNode.insertBefore(
					element,
					childNodes[svgParent ? 3 : 0] || null // null for oldIE
				);
				inserted = true;
			}
		}
		return inserted;
	},
	_defaultSetter: function (value, key, element) {
		element.setAttribute(key, value);
	}
});

// Some shared setters and getters
SVGElement.prototype.yGetter =
SVGElement.prototype.xGetter;
SVGElement.prototype.translateXSetter =
SVGElement.prototype.translateYSetter =
SVGElement.prototype.rotationSetter =
SVGElement.prototype.verticalAlignSetter =
SVGElement.prototype.rotationOriginXSetter =
SVGElement.prototype.rotationOriginYSetter = 
SVGElement.prototype.scaleXSetter =
SVGElement.prototype.scaleYSetter = 
SVGElement.prototype.matrixSetter = function (value, key) {
	this[key] = value;
	this.doTransform = true;
};


// WebKit and Batik have problems with a stroke-width of zero, so in this case
// we remove the stroke attribute altogether. #1270, #1369, #3065, #3072.
SVGElement.prototype['stroke-widthSetter'] =
SVGElement.prototype.strokeSetter = function (value, key, element) {
	this[key] = value;
	// Only apply the stroke attribute if the stroke width is defined and larger
	// than 0
	if (this.stroke && this['stroke-width']) {
		// Use prototype as instance may be overridden
		SVGElement.prototype.fillSetter.call(
			this,
			this.stroke,
			'stroke',
			element
		);
		
		element.setAttribute('stroke-width', this['stroke-width']);
		this.hasStroke = true;
	} else if (key === 'stroke-width' && value === 0 && this.hasStroke) {
		element.removeAttribute('stroke');
		this.hasStroke = false;
	}
};


/**
 * Allows direct access to the Highcharts rendering layer in order to draw
 * primitive shapes like circles, rectangles, paths or text directly on a chart,
 * or independent from any chart. The SVGRenderer represents a wrapper object
 * for SVG in modern browsers. Through the VMLRenderer, part of the `oldie.js`
 * module, it also brings vector graphics to IE <= 8.
 *
 * An existing chart's renderer can be accessed through {@link Chart.renderer}.
 * The renderer can also be used completely decoupled from a chart.
 *
 * @param {HTMLDOMElement} container - Where to put the SVG in the web page.
 * @param {number} width - The width of the SVG.
 * @param {number} height - The height of the SVG.
 * @param {boolean} [forExport=false] - Whether the rendered content is intended
 *   for export.
 * @param {boolean} [allowHTML=true] - Whether the renderer is allowed to
 *   include HTML text, which will be projected on top of the SVG.
 *
 * @example
 * // Use directly without a chart object.
 * var renderer = new Highcharts.Renderer(parentNode, 600, 400);
 *
 * @sample highcharts/members/renderer-on-chart
 *         Annotating a chart programmatically.
 * @sample highcharts/members/renderer-basic
 *         Independent SVG drawing.
 *
 * @class Highcharts.SVGRenderer
 */
SVGRenderer = H.SVGRenderer = function () {
	this.init.apply(this, arguments);
};
extend(SVGRenderer.prototype, /** @lends Highcharts.SVGRenderer.prototype */ {
	/**
	 * A pointer to the renderer's associated Element class. The VMLRenderer
	 * will have a pointer to VMLElement here.
	 * @type {SVGElement}
	 */
	Element: SVGElement,
	SVG_NS: SVG_NS,
	/**
	 * Initialize the SVGRenderer. Overridable initiator function that takes
	 * the same parameters as the constructor.
	 */
	init: function (container, width, height, style, forExport, allowHTML) {
		var renderer = this,
			boxWrapper,
			element,
			desc;

		boxWrapper = renderer.createElement('svg')
			.attr({
				'version': '1.1',
				'class': 'highcharts-root'
			})
			
			.css(this.getStyle(style))
			;
		element = boxWrapper.element;
		container.appendChild(element);

		// Always use ltr on the container, otherwise text-anchor will be
		// flipped and text appear outside labels, buttons, tooltip etc (#3482)
		attr(container, 'dir', 'ltr');

		// For browsers other than IE, add the namespace attribute (#1978)
		if (container.innerHTML.indexOf('xmlns') === -1) {
			attr(element, 'xmlns', this.SVG_NS);
		}

		// object properties
		renderer.isSVG = true;

		/** 
		 * The root `svg` node of the renderer.
		 * @name box
		 * @memberOf SVGRenderer
		 * @type {SVGDOMElement}
		 */
		this.box = element;
		/** 
		 * The wrapper for the root `svg` node of the renderer.
		 *
		 * @name boxWrapper
		 * @memberOf SVGRenderer
		 * @type {SVGElement}
		 */
		this.boxWrapper = boxWrapper;
		renderer.alignedObjects = [];

		/**
		 * Page url used for internal references.
		 * @type {string}
		 */
		// #24, #672, #1070
		this.url = (
				(isFirefox || isWebKit) &&
				doc.getElementsByTagName('base').length
			) ?
				win.location.href
					.replace(/#.*?$/, '') // remove the hash
					.replace(/<[^>]*>/g, '') // wing cut HTML
					// escape parantheses and quotes
					.replace(/([\('\)])/g, '\\$1')
					// replace spaces (needed for Safari only)
					.replace(/ /g, '%20') :
				'';

		// Add description
		desc = this.createElement('desc').add();
		desc.element.appendChild(
			doc.createTextNode('Created with Highcharts 5aaca1890988fc7073f112a2ff1556645b8dda5e')
		);

		/**
		 * A pointer to the `defs` node of the root SVG.
		 * @type {SVGElement}
		 * @name defs
		 * @memberOf SVGRenderer
		 */
		renderer.defs = this.createElement('defs').add();
		renderer.allowHTML = allowHTML;
		renderer.forExport = forExport;
		renderer.gradients = {}; // Object where gradient SvgElements are stored
		renderer.cache = {}; // Cache for numerical bounding boxes
		renderer.cacheKeys = [];
		renderer.imgCount = 0;

		renderer.setSize(width, height, false);

		

		// Issue 110 workaround:
		// In Firefox, if a div is positioned by percentage, its pixel position
		// may land between pixels. The container itself doesn't display this,
		// but an SVG element inside this container will be drawn at subpixel
		// precision. In order to draw sharp lines, this must be compensated
		// for. This doesn't seem to work inside iframes though (like in
		// jsFiddle).
		var subPixelFix, rect;
		if (isFirefox && container.getBoundingClientRect) {
			subPixelFix = function () {
				css(container, { left: 0, top: 0 });
				rect = container.getBoundingClientRect();
				css(container, {
					left: (Math.ceil(rect.left) - rect.left) + 'px',
					top: (Math.ceil(rect.top) - rect.top) + 'px'
				});
			};

			// run the fix now
			subPixelFix();

			// run it on resize
			renderer.unSubPixelFix = addEvent(win, 'resize', subPixelFix);
		}
	},
	

	
	/**
	 * Get the global style setting for the renderer.
	 * @private
	 * @param  {CSSObject} style - Style settings.
	 * @return {CSSObject} The style settings mixed with defaults.
	 */
	getStyle: function (style) {
		this.style = extend({
			
			fontFamily: '"Lucida Grande", "Lucida Sans Unicode", ' +
				'Arial, Helvetica, sans-serif',
			fontSize: '12px'

		}, style);
		return this.style;
	},
	/**
	 * Apply the global style on the renderer, mixed with the default styles.
	 * 
	 * @param {CSSObject} style - CSS to apply.
	 */
	setStyle: function (style) {
		this.boxWrapper.css(this.getStyle(style));
	},
	

	/**
	 * Detect whether the renderer is hidden. This happens when one of the
	 * parent elements has `display: none`. Used internally to detect when we
	 * needto render preliminarily in another div to get the text bounding boxes
	 * right.
	 *
	 * @returns {boolean} True if it is hidden.
	 */
	isHidden: function () { // #608
		return !this.boxWrapper.getBBox().width;
	},

	/**
	 * Destroys the renderer and its allocated members.
	 */
	destroy: function () {
		var renderer = this,
			rendererDefs = renderer.defs;
		renderer.box = null;
		renderer.boxWrapper = renderer.boxWrapper.destroy();

		// Call destroy on all gradient elements
		destroyObjectProperties(renderer.gradients || {});
		renderer.gradients = null;

		// Defs are null in VMLRenderer
		// Otherwise, destroy them here.
		if (rendererDefs) {
			renderer.defs = rendererDefs.destroy();
		}

		// Remove sub pixel fix handler (#982)
		if (renderer.unSubPixelFix) {
			renderer.unSubPixelFix();
		}

		renderer.alignedObjects = null;

		return null;
	},

	/**
	 * Create a wrapper for an SVG element. Serves as a factory for 
	 * {@link SVGElement}, but this function is itself mostly called from 
	 * primitive factories like {@link SVGRenderer#path}, {@link
	 * SVGRenderer#rect} or {@link SVGRenderer#text}.
	 * 
	 * @param {string} nodeName - The node name, for example `rect`, `g` etc.
	 * @returns {SVGElement} The generated SVGElement.
	 */
	createElement: function (nodeName) {
		var wrapper = new this.Element();
		wrapper.init(this, nodeName);
		return wrapper;
	},

	/**
	 * Dummy function for plugins, called every time the renderer is updated.
	 * Prior to Highcharts 5, this was used for the canvg renderer.
	 * @function
	 */
	draw: noop,

	/**
	 * Get converted radial gradient attributes according to the radial
	 * reference. Used internally from the {@link SVGElement#colorGradient}
	 * function.
	 *
	 * @private
	 */
	getRadialAttr: function (radialReference, gradAttr) {
		return {
			cx: (radialReference[0] - radialReference[2] / 2) +
				gradAttr.cx * radialReference[2],
			cy: (radialReference[1] - radialReference[2] / 2) +
				gradAttr.cy * radialReference[2],
			r: gradAttr.r * radialReference[2]
		};
	},
	
	/**
	 * Extendable function to measure the tspan width.
	 *
	 * @private
	 */
	getSpanWidth: function (wrapper) {
		return wrapper.getBBox(true).width;
	},
	
	applyEllipsis: function (wrapper, tspan, text, width) {
		var renderer = this,
			rotation = wrapper.rotation,
			str = text,
			currentIndex,
			minIndex = 0,
			maxIndex = text.length,
			updateTSpan = function (s) {
				tspan.removeChild(tspan.firstChild);
				if (s) {
					tspan.appendChild(doc.createTextNode(s));
				}
			},
			actualWidth,
			wasTooLong;
		wrapper.rotation = 0; // discard rotation when computing box
		actualWidth = renderer.getSpanWidth(wrapper, tspan);
		wasTooLong = actualWidth > width;
		if (wasTooLong) {
			while (minIndex <= maxIndex) {
				currentIndex = Math.ceil((minIndex + maxIndex) / 2);
				str = text.substring(0, currentIndex) + '\u2026';
				updateTSpan(str);
				actualWidth = renderer.getSpanWidth(wrapper, tspan);
				if (minIndex === maxIndex) {
					// Complete
					minIndex = maxIndex + 1;
				} else if (actualWidth > width) {
					// Too large. Set max index to current.
					maxIndex = currentIndex - 1;
				} else {
					// Within width. Set min index to current.
					minIndex = currentIndex;
				}
			}
			// If max index was 0 it means just ellipsis was also to large.
			if (maxIndex === 0) {
				// Remove ellipses.
				updateTSpan('');
			}
		}
		wrapper.rotation = rotation; // Apply rotation again.
		return wasTooLong;
	},

	/**
	 * A collection of characters mapped to HTML entities. When `useHTML` on an
	 * element is true, these entities will be rendered correctly by HTML. In 
	 * the SVG pseudo-HTML, they need to be unescaped back to simple characters,
	 * so for example `&lt;` will render as `<`.
	 *
	 * @example
	 * // Add support for unescaping quotes
	 * Highcharts.SVGRenderer.prototype.escapes['"'] = '&quot;';
	 * 
	 * @type {Object}
	 */
	escapes: {
		'&': '&amp;',
		'<': '&lt;',
		'>': '&gt;',
		"'": '&#39;', // eslint-disable-line quotes
		'"': '&quot;'
	},

	/**
	 * Parse a simple HTML string into SVG tspans. Called internally when text
	 *   is set on an SVGElement. The function supports a subset of HTML tags,
	 *   CSS text features like `width`, `text-overflow`, `white-space`, and
	 *   also attributes like `href` and `style`.
	 * @private
	 * @param {SVGElement} wrapper The parent SVGElement.
	 */
	buildText: function (wrapper) {
		var textNode = wrapper.element,
			renderer = this,
			forExport = renderer.forExport,
			textStr = pick(wrapper.textStr, '').toString(),
			hasMarkup = textStr.indexOf('<') !== -1,
			lines,
			childNodes = textNode.childNodes,
			clsRegex,
			styleRegex,
			hrefRegex,
			wasTooLong,
			parentX = attr(textNode, 'x'),
			textStyles = wrapper.styles,
			width = wrapper.textWidth,
			textLineHeight = textStyles && textStyles.lineHeight,
			textOutline = textStyles && textStyles.textOutline,
			ellipsis = textStyles && textStyles.textOverflow === 'ellipsis',
			noWrap = textStyles && textStyles.whiteSpace === 'nowrap',
			fontSize = textStyles && textStyles.fontSize,
			textCache,
			isSubsequentLine,
			i = childNodes.length,
			tempParent = width && !wrapper.added && this.box,
			getLineHeight = function (tspan) {
				var fontSizeStyle;
				
				fontSizeStyle = /(px|em)$/.test(tspan && tspan.style.fontSize) ?
					tspan.style.fontSize :
					(fontSize || renderer.style.fontSize || 12);
				

				return textLineHeight ? 
					pInt(textLineHeight) :
					renderer.fontMetrics(
						fontSizeStyle,
						// Get the computed size from parent if not explicit
						tspan.getAttribute('style') ? tspan : textNode
					).h;
			},
			unescapeEntities = function (inputStr) {
				objectEach(renderer.escapes, function (value, key) {
					inputStr = inputStr.replace(
						new RegExp(value, 'g'),
						key
					);
				});
				return inputStr;
			};

		// The buildText code is quite heavy, so if we're not changing something
		// that affects the text, skip it (#6113).
		textCache = [
			textStr,
			ellipsis,
			noWrap,
			textLineHeight,
			textOutline,
			fontSize,
			width
		].join(',');
		if (textCache === wrapper.textCache) {
			return;
		}
		wrapper.textCache = textCache;

		// Remove old text
		while (i--) {
			textNode.removeChild(childNodes[i]);
		}

		// Skip tspans, add text directly to text node. The forceTSpan is a hook
		// used in text outline hack.
		if (
			!hasMarkup &&
			!textOutline &&
			!ellipsis &&
			!width &&
			textStr.indexOf(' ') === -1
		) {
			textNode.appendChild(doc.createTextNode(unescapeEntities(textStr)));

		// Complex strings, add more logic
		} else {

			clsRegex = /<.*class="([^"]+)".*>/;
			styleRegex = /<.*style="([^"]+)".*>/;
			hrefRegex = /<.*href="([^"]+)".*>/;

			if (tempParent) {
				// attach it to the DOM to read offset width
				tempParent.appendChild(textNode);
			}

			if (hasMarkup) {
				lines = textStr
					
					.replace(/<(b|strong)>/g, '<span style="font-weight:bold">')
					.replace(/<(i|em)>/g, '<span style="font-style:italic">')
					
					.replace(/<a/g, '<span')
					.replace(/<\/(b|strong|i|em|a)>/g, '</span>')
					.split(/<br.*?>/g);

			} else {
				lines = [textStr];
			}


			// Trim empty lines (#5261)
			lines = grep(lines, function (line) {
				return line !== '';
			});


			// build the lines
			each(lines, function buildTextLines(line, lineNo) {
				var spans,
					spanNo = 0;
				line = line
					// Trim to prevent useless/costly process on the spaces
					// (#5258)
					.replace(/^\s+|\s+$/g, '')
					.replace(/<span/g, '|||<span')
					.replace(/<\/span>/g, '</span>|||');
				spans = line.split('|||');

				each(spans, function buildTextSpans(span) {
					if (span !== '' || spans.length === 1) {
						var attributes = {},
							tspan = doc.createElementNS(
								renderer.SVG_NS,
								'tspan'
							),
							spanCls,
							spanStyle; // #390
						if (clsRegex.test(span)) {
							spanCls = span.match(clsRegex)[1];
							attr(tspan, 'class', spanCls);
						}
						if (styleRegex.test(span)) {
							spanStyle = span.match(styleRegex)[1].replace(
								/(;| |^)color([ :])/,
								'$1fill$2'
							);
							attr(tspan, 'style', spanStyle);
						}

						// Not for export - #1529
						if (hrefRegex.test(span) && !forExport) {
							attr(
								tspan,
								'onclick',
								'location.href=\"' +
									span.match(hrefRegex)[1] + '\"'
							);
							attr(tspan, 'class', 'highcharts-anchor');
							
							css(tspan, { cursor: 'pointer' });
							
						}

						// Strip away unsupported HTML tags (#7126)
						span = unescapeEntities(
							span.replace(/<[a-zA-Z\/](.|\n)*?>/g, '') || ' '
						);

						// Nested tags aren't supported, and cause crash in
						// Safari (#1596)
						if (span !== ' ') {

							// add the text node
							tspan.appendChild(doc.createTextNode(span));

							// First span in a line, align it to the left
							if (!spanNo) {
								if (lineNo && parentX !== null) {
									attributes.x = parentX;
								}
							} else {
								attributes.dx = 0; // #16
							}

							// add attributes
							attr(tspan, attributes);

							// Append it
							textNode.appendChild(tspan);

							// first span on subsequent line, add the line
							// height
							if (!spanNo && isSubsequentLine) {

								// allow getting the right offset height in
								// exporting in IE
								if (!svg && forExport) {
									css(tspan, { display: 'block' });
								}

								// Set the line height based on the font size of
								// either the text element or the tspan element
								attr(
									tspan,
									'dy',
									getLineHeight(tspan)
								);
							}

							/*
							// Experimental text wrapping based on
							// getSubstringLength
							if (width) {
								var spans = renderer.breakText(wrapper, width);

								each(spans, function (span) {

									var dy = getLineHeight(tspan);
									tspan = doc.createElementNS(
										SVG_NS,
										'tspan'
									);
									tspan.appendChild(
										doc.createTextNode(span)
									);
									attr(tspan, {
										dy: dy,
										x: parentX
									});
									if (spanStyle) { // #390
										attr(tspan, 'style', spanStyle);
									}
									textNode.appendChild(tspan);
								});

							}
							// */

							// Check width and apply soft breaks or ellipsis
							if (width) {
								var words = span.replace(
										/([^\^])-/g,
										'$1- '
									).split(' '), // #1273
									hasWhiteSpace = (
										spans.length > 1 ||
										lineNo ||
										(words.length > 1 && !noWrap)
									),
									tooLong,
									rest = [],
									actualWidth,
									dy = getLineHeight(tspan),
									rotation = wrapper.rotation;

								if (ellipsis) {
									wasTooLong = renderer.applyEllipsis(
										wrapper,
										tspan,
										span,
										width
									);
								}

								while (
									!ellipsis &&
									hasWhiteSpace &&
									(words.length || rest.length)
								) {
									// discard rotation when computing box
									wrapper.rotation = 0; 
									actualWidth = renderer.getSpanWidth(
										wrapper,
										tspan
									);
									tooLong = actualWidth > width;

									// For ellipsis, do a binary search for the 
									// correct string length
									if (wasTooLong === undefined) {
										wasTooLong = tooLong; // First time
									}

									// Looping down, this is the first word
									// sequence that is not too long, so we can
									// move on to build the next line.
									if (!tooLong || words.length === 1) {
										words = rest;
										rest = [];

										if (words.length && !noWrap) {
											tspan = doc.createElementNS(
												SVG_NS,
												'tspan'
											);
											attr(tspan, {
												dy: dy,
												x: parentX
											});
											if (spanStyle) { // #390
												attr(tspan, 'style', spanStyle);
											}
											textNode.appendChild(tspan);
										}

										// a single word is pressing it out
										if (actualWidth > width) {
											width = actualWidth;
										}
									} else { // append to existing line tspan
										tspan.removeChild(tspan.firstChild);
										rest.unshift(words.pop());
									}
									if (words.length) {
										tspan.appendChild(
											doc.createTextNode(
												words.join(' ')
													.replace(/- /g, '-')
											)
										);
									}
								}
								wrapper.rotation = rotation;
							}

							spanNo++;
							// */
						}
					}
				});
				// To avoid beginning lines that doesn't add to the textNode
				// (#6144)
				isSubsequentLine = (
					isSubsequentLine ||
					textNode.childNodes.length
				);
			});

			if (wasTooLong) {
				wrapper.attr(
					'title',
					unescapeEntities(wrapper.textStr) // #7179
				);
			}
			if (tempParent) {
				tempParent.removeChild(textNode);
			}

			// Apply the text outline
			if (textOutline && wrapper.applyTextOutline) {
				wrapper.applyTextOutline(textOutline);
			}
		}
	},



	/*
	breakText: function (wrapper, width) {
		var bBox = wrapper.getBBox(),
			node = wrapper.element,
			charnum = node.textContent.length,
			stringWidth,
			// try this position first, based on average character width
			guessedLineCharLength = Math.round(width * charnum / bBox.width),
			pos = guessedLineCharLength,
			spans = [],
			increment = 0,
			startPos = 0,
			endPos,
			safe = 0;

		if (bBox.width > width) {
			while (startPos < charnum && safe < 100) {

				while (endPos === undefined && safe < 100) {
					stringWidth = node.getSubStringLength(
						startPos,
						pos - startPos
					);

					if (stringWidth <= width) {
						if (increment === -1) {
							endPos = pos;
						} else {
							increment = 1;
						}
					} else {
						if (increment === 1) {
							endPos = pos - 1;
						} else {
							increment = -1;
						}
					}
					pos += increment;
					safe++;
				}

				spans.push(node.textContent.substr(startPos, endPos - startPos));

				startPos = endPos;
				pos = startPos + guessedLineCharLength;
				endPos = undefined;			
			}
		}

		return spans;
	},
	// */

	/**
	 * Returns white for dark colors and black for bright colors.
	 *
	 * @param {ColorString} rgba - The color to get the contrast for.
	 * @returns {string} The contrast color, either `#000000` or `#FFFFFF`.
	 */
	getContrast: function (rgba) {
		rgba = color(rgba).rgba;

		// The threshold may be discussed. Here's a proposal for adding
		// different weight to the color channels (#6216)
		/*
        rgba[0] *= 1; // red
        rgba[1] *= 1.2; // green
        rgba[2] *= 0.7; // blue
        */

		return rgba[0] + rgba[1] + rgba[2] > 2 * 255 ? '#000000' : '#FFFFFF';
	},

	/**
	 * Create a button with preset states.
	 * @param {string} text - The text or HTML to draw.
	 * @param {number} x - The x position of the button's left side.
	 * @param {number} y - The y position of the button's top side.
	 * @param {Function} callback - The function to execute on button click or 
	 *    touch.
	 * @param {SVGAttributes} [normalState] - SVG attributes for the normal
	 *    state.
	 * @param {SVGAttributes} [hoverState] - SVG attributes for the hover state.
	 * @param {SVGAttributes} [pressedState] - SVG attributes for the pressed
	 *    state.
	 * @param {SVGAttributes} [disabledState] - SVG attributes for the disabled
	 *    state.
	 * @param {Symbol} [shape=rect] - The shape type.
	 * @returns {SVGRenderer} The button element.
	 */
	button: function (
		text, 
		x,
		y,
		callback,
		normalState,
		hoverState,
		pressedState,
		disabledState,
		shape
	) {
		var label = this.label(
				text,
				x,
				y,
				shape, 
				null,
				null,
				null,
				null,
				'button'
			),
			curState = 0;

		// Default, non-stylable attributes
		label.attr(merge({
			'padding': 8,
			'r': 2
		}, normalState));

		
		// Presentational
		var normalStyle,
			hoverStyle,
			pressedStyle,
			disabledStyle;

		// Normal state - prepare the attributes
		normalState = merge({
			fill: '#f7f7f7',
			stroke: '#cccccc',
			'stroke-width': 1,
			style: {
				color: '#333333',
				cursor: 'pointer',
				fontWeight: 'normal'
			}
		}, normalState);
		normalStyle = normalState.style;
		delete normalState.style;

		// Hover state
		hoverState = merge(normalState, {
			fill: '#e6e6e6'
		}, hoverState);
		hoverStyle = hoverState.style;
		delete hoverState.style;

		// Pressed state
		pressedState = merge(normalState, {
			fill: '#e6ebf5',
			style: {
				color: '#000000',
				fontWeight: 'bold'
			}
		}, pressedState);
		pressedStyle = pressedState.style;
		delete pressedState.style;

		// Disabled state
		disabledState = merge(normalState, {
			style: {
				color: '#cccccc'
			}
		}, disabledState);
		disabledStyle = disabledState.style;
		delete disabledState.style;
		

		// Add the events. IE9 and IE10 need mouseover and mouseout to funciton
		// (#667).
		addEvent(label.element, isMS ? 'mouseover' : 'mouseenter', function () {
			if (curState !== 3) {
				label.setState(1);
			}
		});
		addEvent(label.element, isMS ? 'mouseout' : 'mouseleave', function () {
			if (curState !== 3) {
				label.setState(curState);
			}
		});

		label.setState = function (state) {
			// Hover state is temporary, don't record it
			if (state !== 1) {
				label.state = curState = state;
			}
			// Update visuals
			label.removeClass(
					/highcharts-button-(normal|hover|pressed|disabled)/
				)
				.addClass(
					'highcharts-button-' +
					['normal', 'hover', 'pressed', 'disabled'][state || 0]
				);
			
			
			label.attr([
				normalState,
				hoverState,
				pressedState,
				disabledState
			][state || 0])
			.css([
				normalStyle,
				hoverStyle,
				pressedStyle,
				disabledStyle
			][state || 0]);
			
		};


		
		// Presentational attributes
		label
			.attr(normalState)
			.css(extend({ cursor: 'default' }, normalStyle));
		

		return label
			.on('click', function (e) {
				if (curState !== 3) {
					callback.call(label, e);
				}
			});
	},

	/**
	 * Make a straight line crisper by not spilling out to neighbour pixels.
	 * 
	 * @param {Array} points - The original points on the format `['M', 0, 0,
	 *    'L', 100, 0]`.
	 * @param {number} width - The width of the line.
	 * @returns {Array} The original points array, but modified to render
	 * crisply.
	 */
	crispLine: function (points, width) {
		// normalize to a crisp line
		if (points[1] === points[4]) {
			// Substract due to #1129. Now bottom and left axis gridlines behave
			// the same.
			points[1] = points[4] = Math.round(points[1]) - (width % 2 / 2);
		}
		if (points[2] === points[5]) {
			points[2] = points[5] = Math.round(points[2]) + (width % 2 / 2);
		}
		return points;
	},


	/**
	 * Draw a path, wraps the SVG `path` element.
	 * 
	 * @param {Array} [path] An SVG path definition in array form.
	 * 
	 * @example
	 * var path = renderer.path(['M', 10, 10, 'L', 30, 30, 'z'])
	 *     .attr({ stroke: '#ff00ff' })
	 *     .add();
	 * @returns {SVGElement} The generated wrapper element.
	 *
	 * @sample highcharts/members/renderer-path-on-chart/
	 *         Draw a path in a chart
	 * @sample highcharts/members/renderer-path/
	 *         Draw a path independent from a chart
	 *
	 *//**
	 * Draw a path, wraps the SVG `path` element.
	 * 
	 * @param {SVGAttributes} [attribs] The initial attributes.
	 * @returns {SVGElement} The generated wrapper element.
	 */
	path: function (path) {
		var attribs = {
			
			fill: 'none'
			
		};
		if (isArray(path)) {
			attribs.d = path;
		} else if (isObject(path)) { // attributes
			extend(attribs, path);
		}
		return this.createElement('path').attr(attribs);
	},

	/**
	 * Draw a circle, wraps the SVG `circle` element.
	 * 
	 * @param {number} [x] The center x position.
	 * @param {number} [y] The center y position.
	 * @param {number} [r] The radius.
	 * @returns {SVGElement} The generated wrapper element.
	 *
	 * @sample highcharts/members/renderer-circle/ Drawing a circle
	 *//**
	 * Draw a circle, wraps the SVG `circle` element.
	 * 
	 * @param {SVGAttributes} [attribs] The initial attributes.
	 * @returns {SVGElement} The generated wrapper element.
	 */
	circle: function (x, y, r) {
		var attribs = isObject(x) ? x : { x: x, y: y, r: r },
			wrapper = this.createElement('circle');

		// Setting x or y translates to cx and cy
		wrapper.xSetter = wrapper.ySetter = function (value, key, element) {
			element.setAttribute('c' + key, value);
		};

		return wrapper.attr(attribs);
	},

	/**
	 * Draw and return an arc.
	 * @param {number} [x=0] Center X position.
	 * @param {number} [y=0] Center Y position.
	 * @param {number} [r=0] The outer radius of the arc.
	 * @param {number} [innerR=0] Inner radius like used in donut charts.
	 * @param {number} [start=0] The starting angle of the arc in radians, where
	 *    0 is to the right and `-Math.PI/2` is up.
	 * @param {number} [end=0] The ending angle of the arc in radians, where 0
	 *    is to the right and `-Math.PI/2` is up.
	 * @returns {SVGElement} The generated wrapper element.
	 *
	 * @sample highcharts/members/renderer-arc/
	 *         Drawing an arc
	 *//**
	 * Draw and return an arc. Overloaded function that takes arguments object.
	 * @param {SVGAttributes} attribs Initial SVG attributes.
	 * @returns {SVGElement} The generated wrapper element.
	 */
	arc: function (x, y, r, innerR, start, end) {
		var arc,
			options;

		if (isObject(x)) {
			options = x;
			y = options.y;
			r = options.r;
			innerR = options.innerR;
			start = options.start;
			end = options.end;
			x = options.x;
		} else {
			options = {
				innerR: innerR,
				start: start,
				end: end
			};
		}

		// Arcs are defined as symbols for the ability to set
		// attributes in attr and animate
		arc = this.symbol('arc', x, y, r, r, options);
		arc.r = r; // #959
		return arc;
	},

	/**
	 * Draw and return a rectangle.
	 * @param {number} [x] Left position.
	 * @param {number} [y] Top position.
	 * @param {number} [width] Width of the rectangle.
	 * @param {number} [height] Height of the rectangle.
	 * @param {number} [r] Border corner radius.
	 * @param {number} [strokeWidth] A stroke width can be supplied to allow
	 *    crisp drawing.
	 * @returns {SVGElement} The generated wrapper element.
	 *//**
	 * Draw and return a rectangle.
	 * @param  {SVGAttributes} [attributes]
	 *         General SVG attributes for the rectangle.
	 * @return {SVGElement}
	 *         The generated wrapper element.
	 *
	 * @sample highcharts/members/renderer-rect-on-chart/
	 *         Draw a rectangle in a chart
	 * @sample highcharts/members/renderer-rect/
	 *         Draw a rectangle independent from a chart
	 */
	rect: function (x, y, width, height, r, strokeWidth) {

		r = isObject(x) ? x.r : r;

		var wrapper = this.createElement('rect'),
			attribs = isObject(x) ? x : x === undefined ? {} : {
				x: x,
				y: y,
				width: Math.max(width, 0),
				height: Math.max(height, 0)
			};

		
		if (strokeWidth !== undefined) {
			attribs.strokeWidth = strokeWidth;
			attribs = wrapper.crisp(attribs);
		}
		attribs.fill = 'none';
		

		if (r) {
			attribs.r = r;
		}

		wrapper.rSetter = function (value, key, element) {
			attr(element, {
				rx: value,
				ry: value
			});
		};

		return wrapper.attr(attribs);
	},

	/**
	 * Resize the {@link SVGRenderer#box} and re-align all aligned child
	 * elements.
	 * @param  {number} width
	 *         The new pixel width.
	 * @param  {number} height
	 *         The new pixel height.
	 * @param  {Boolean|AnimationOptions} [animate=true]
	 *         Whether and how to animate.
	 */
	setSize: function (width, height, animate) {
		var renderer = this,
			alignedObjects = renderer.alignedObjects,
			i = alignedObjects.length;

		renderer.width = width;
		renderer.height = height;

		renderer.boxWrapper.animate({
			width: width,
			height: height
		}, {
			step: function () {
				this.attr({
					viewBox: '0 0 ' + this.attr('width') + ' ' +
						this.attr('height')
				});
			},
			duration: pick(animate, true) ? undefined : 0
		});

		while (i--) {
			alignedObjects[i].align();
		}
	},

	/**
	 * Create and return an svg group element. Child
	 * {@link Highcharts.SVGElement} objects are added to the group by using the
	 * group as the first parameter
	 * in {@link Highcharts.SVGElement#add|add()}.
	 * 
	 * @param {string} [name] The group will be given a class name of
	 * `highcharts-{name}`. This can be used for styling and scripting.
	 * @returns {SVGElement} The generated wrapper element.
	 *
	 * @sample highcharts/members/renderer-g/
	 *         Show and hide grouped objects
	 */
	g: function (name) {
		var elem = this.createElement('g');
		return name ? elem.attr({ 'class': 'highcharts-' + name }) : elem;
	},

	/**
	 * Display an image.
	 * @param {string} src The image source.
	 * @param {number} [x] The X position.
	 * @param {number} [y] The Y position.
	 * @param {number} [width] The image width. If omitted, it defaults to the 
	 *    image file width.
	 * @param {number} [height] The image height. If omitted it defaults to the
	 *    image file height.
	 * @returns {SVGElement} The generated wrapper element.
	 *
	 * @sample highcharts/members/renderer-image-on-chart/
	 *         Add an image in a chart
	 * @sample highcharts/members/renderer-image/
	 *         Add an image independent of a chart
	 */
	image: function (src, x, y, width, height) {
		var attribs = {
				preserveAspectRatio: 'none'
			},
			elemWrapper;

		// optional properties
		if (arguments.length > 1) {
			extend(attribs, {
				x: x,
				y: y,
				width: width,
				height: height
			});
		}

		elemWrapper = this.createElement('image').attr(attribs);

		// set the href in the xlink namespace
		if (elemWrapper.element.setAttributeNS) {
			elemWrapper.element.setAttributeNS('http://www.w3.org/1999/xlink',
				'href', src);
		} else {
			// could be exporting in IE
			// using href throws "not supported" in ie7 and under, requries
			// regex shim to fix later
			elemWrapper.element.setAttribute('hc-svg-href', src);
		}
		return elemWrapper;
	},

	/**
	 * Draw a symbol out of pre-defined shape paths from
	 * {@link SVGRenderer#symbols}.
	 * It is used in Highcharts for point makers, which cake a `symbol` option,
	 * and label and button backgrounds like in the tooltip and stock flags.
	 *
	 * @param {Symbol} symbol - The symbol name.
	 * @param {number} x - The X coordinate for the top left position.
	 * @param {number} y - The Y coordinate for the top left position.
	 * @param {number} width - The pixel width.
	 * @param {number} height - The pixel height.
	 * @param {Object} [options] - Additional options, depending on the actual
	 *    symbol drawn. 
	 * @param {number} [options.anchorX] - The anchor X position for the
	 *    `callout` symbol. This is where the chevron points to.
	 * @param {number} [options.anchorY] - The anchor Y position for the
	 *    `callout` symbol. This is where the chevron points to.
	 * @param {number} [options.end] - The end angle of an `arc` symbol.
	 * @param {boolean} [options.open] - Whether to draw `arc` symbol open or
	 *    closed.
	 * @param {number} [options.r] - The radius of an `arc` symbol, or the
	 *    border radius for the `callout` symbol.
	 * @param {number} [options.start] - The start angle of an `arc` symbol.
	 */
	symbol: function (symbol, x, y, width, height, options) {

		var ren = this,
			obj,
			imageRegex = /^url\((.*?)\)$/,
			isImage = imageRegex.test(symbol),
			sym = !isImage && (this.symbols[symbol] ? symbol : 'circle'),
			

			// get the symbol definition function
			symbolFn = sym && this.symbols[sym],

			// check if there's a path defined for this symbol
			path = defined(x) && symbolFn && symbolFn.call(
				this.symbols,
				Math.round(x),
				Math.round(y),
				width,
				height,
				options
			),
			imageSrc,
			centerImage;

		if (symbolFn) {
			obj = this.path(path);

			
			obj.attr('fill', 'none');
			
			
			// expando properties for use in animate and attr
			extend(obj, {
				symbolName: sym,
				x: x,
				y: y,
				width: width,
				height: height
			});
			if (options) {
				extend(obj, options);
			}


		// Image symbols
		} else if (isImage) {

			
			imageSrc = symbol.match(imageRegex)[1];

			// Create the image synchronously, add attribs async
			obj = this.image(imageSrc);

			// The image width is not always the same as the symbol width. The
			// image may be centered within the symbol, as is the case when
			// image shapes are used as label backgrounds, for example in flags.
			obj.imgwidth = pick(
				symbolSizes[imageSrc] && symbolSizes[imageSrc].width,
				options && options.width
			);
			obj.imgheight = pick(
				symbolSizes[imageSrc] && symbolSizes[imageSrc].height,
				options && options.height
			);
			/**
			 * Set the size and position
			 */
			centerImage = function () {
				obj.attr({
					width: obj.width,
					height: obj.height
				});
			};

			/**
			 * Width and height setters that take both the image's physical size
			 * and the label size into consideration, and translates the image
			 * to center within the label.
			 */
			each(['width', 'height'], function (key) {
				obj[key + 'Setter'] = function (value, key) {
					var attribs = {},
						imgSize = this['img' + key],
						trans = key === 'width' ? 'translateX' : 'translateY';
					this[key] = value;
					if (defined(imgSize)) {
						if (this.element) {
							this.element.setAttribute(key, imgSize);
						}
						if (!this.alignByTranslate) {
							attribs[trans] = ((this[key] || 0) - imgSize) / 2;
							this.attr(attribs);
						}
					}
				};
			});
			

			if (defined(x)) {
				obj.attr({
					x: x,
					y: y
				});
			}
			obj.isImg = true;

			if (defined(obj.imgwidth) && defined(obj.imgheight)) {
				centerImage();
			} else {
				// Initialize image to be 0 size so export will still function
				// if there's no cached sizes.
				obj.attr({ width: 0, height: 0 });

				// Create a dummy JavaScript image to get the width and height. 
				createElement('img', {
					onload: function () {

						var chart = charts[ren.chartIndex];

						// Special case for SVGs on IE11, the width is not
						// accessible until the image is part of the DOM
						// (#2854).
						if (this.width === 0) {
							css(this, {
								position: 'absolute',
								top: '-999em'
							});
							doc.body.appendChild(this);
						}

						// Center the image
						symbolSizes[imageSrc] = { // Cache for next	
							width: this.width,
							height: this.height
						};
						obj.imgwidth = this.width;
						obj.imgheight = this.height;
						
						if (obj.element) {
							centerImage();
						}

						// Clean up after #2854 workaround.
						if (this.parentNode) {
							this.parentNode.removeChild(this);
						}

						// Fire the load event when all external images are
						// loaded
						ren.imgCount--;
						if (!ren.imgCount && chart && chart.onload) {
							chart.onload();
						}
					},
					src: imageSrc
				});
				this.imgCount++;
			}
		}

		return obj;
	},

	/**
	 * @typedef {string} Symbol
	 * 
	 * Can be one of `arc`, `callout`, `circle`, `diamond`, `square`,
	 * `triangle`, `triangle-down`. Symbols are used internally for point
	 * markers, button and label borders and backgrounds, or custom shapes.
	 * Extendable by adding to {@link SVGRenderer#symbols}.
	 */
	/**
	 * An extendable collection of functions for defining symbol paths.
	 */
	symbols: {
		'circle': function (x, y, w, h) {
			// Return a full arc
			return this.arc(x + w / 2, y + h / 2, w / 2, h / 2, {
				start: 0,
				end: Math.PI * 2,
				open: false
			});
		},

		'square': function (x, y, w, h) {
			return [
				'M', x, y,
				'L', x + w, y,
				x + w, y + h,
				x, y + h,
				'Z'
			];
		},

		'triangle': function (x, y, w, h) {
			return [
				'M', x + w / 2, y,
				'L', x + w, y + h,
				x, y + h,
				'Z'
			];
		},

		'triangle-down': function (x, y, w, h) {
			return [
				'M', x, y,
				'L', x + w, y,
				x + w / 2, y + h,
				'Z'
			];
		},
		'diamond': function (x, y, w, h) {
			return [
				'M', x + w / 2, y,
				'L', x + w, y + h / 2,
				x + w / 2, y + h,
				x, y + h / 2,
				'Z'
			];
		},
		'arc': function (x, y, w, h, options) {
			var start = options.start,
				rx = options.r || w,
				ry = options.r || h || w,
				proximity = 0.001,
				fullCircle = 
					Math.abs(options.end - options.start - 2 * Math.PI) <
					proximity,
				// Substract a small number to prevent cos and sin of start and
				// end from becoming equal on 360 arcs (related: #1561)
				end = options.end - proximity, 
				innerRadius = options.innerR,
				open = pick(options.open, fullCircle),
				cosStart = Math.cos(start),
				sinStart = Math.sin(start),
				cosEnd = Math.cos(end),
				sinEnd = Math.sin(end),
				// Proximity takes care of rounding errors around PI (#6971)
				longArc = options.end - start - Math.PI < proximity ? 0 : 1,
				arc;

			arc = [
				'M',
				x + rx * cosStart,
				y + ry * sinStart,
				'A', // arcTo
				rx, // x radius
				ry, // y radius
				0, // slanting
				longArc, // long or short arc
				1, // clockwise
				x + rx * cosEnd,
				y + ry * sinEnd
			];

			if (defined(innerRadius)) {
				arc.push(
					open ? 'M' : 'L',
					x + innerRadius * cosEnd,
					y + innerRadius * sinEnd,
					'A', // arcTo
					innerRadius, // x radius
					innerRadius, // y radius
					0, // slanting
					longArc, // long or short arc
					0, // clockwise
					x + innerRadius * cosStart,
					y + innerRadius * sinStart
				);
			}

			arc.push(open ? '' : 'Z'); // close
			return arc;
		},

		/**
		 * Callout shape used for default tooltips, also used for rounded
		 * rectangles in VML
		 */
		callout: function (x, y, w, h, options) {
			var arrowLength = 6,
				halfDistance = 6,
				r = Math.min((options && options.r) || 0, w, h),
				safeDistance = r + halfDistance,
				anchorX = options && options.anchorX,
				anchorY = options && options.anchorY,
				path;

			path = [
				'M', x + r, y,
				'L', x + w - r, y, // top side
				'C', x + w, y, x + w, y, x + w, y + r, // top-right corner
				'L', x + w, y + h - r, // right side
				'C', x + w, y + h, x + w, y + h, x + w - r, y + h, // bottom-rgt
				'L', x + r, y + h, // bottom side
				'C', x, y + h, x, y + h, x, y + h - r, // bottom-left corner
				'L', x, y + r, // left side
				'C', x, y, x, y, x + r, y // top-left corner
			];

			// Anchor on right side
			if (anchorX && anchorX > w) {

				// Chevron
				if (
					anchorY > y + safeDistance &&
					anchorY < y + h - safeDistance
				) {
					path.splice(13, 3,
						'L', x + w, anchorY - halfDistance,
						x + w + arrowLength, anchorY,
						x + w, anchorY + halfDistance,
						x + w, y + h - r
					);

				// Simple connector
				} else {
					path.splice(13, 3,
						'L', x + w, h / 2,
						anchorX, anchorY,
						x + w, h / 2,
						x + w, y + h - r
					);
				}

			// Anchor on left side
			} else if (anchorX && anchorX < 0) {

				// Chevron
				if (
					anchorY > y + safeDistance &&
					anchorY < y + h - safeDistance
				) {
					path.splice(33, 3,
						'L', x, anchorY + halfDistance,
						x - arrowLength, anchorY,
						x, anchorY - halfDistance,
						x, y + r
					);

				// Simple connector
				} else {
					path.splice(33, 3,
						'L', x, h / 2,
						anchorX, anchorY,
						x, h / 2,
						x, y + r
					);
				}
				
			} else if ( // replace bottom
				anchorY &&
				anchorY > h &&
				anchorX > x + safeDistance &&
				anchorX < x + w - safeDistance
			) { 
				path.splice(23, 3,
					'L', anchorX + halfDistance, y + h,
					anchorX, y + h + arrowLength,
					anchorX - halfDistance, y + h,
					x + r, y + h
					);

			} else if ( // replace top
				anchorY &&
				anchorY < 0 &&
				anchorX > x + safeDistance &&
				anchorX < x + w - safeDistance
			) {
				path.splice(3, 3,
					'L', anchorX - halfDistance, y,
					anchorX, y - arrowLength,
					anchorX + halfDistance, y,
					w - r, y
				);
			}
			
			return path;
		}
	},

	/**
	 * @typedef {SVGElement} ClipRect - A clipping rectangle that can be applied
	 * to one or more {@link SVGElement} instances. It is instanciated with the
	 * {@link SVGRenderer#clipRect} function and applied with the {@link 
	 * SVGElement#clip} function.
	 *
	 * @example
	 * var circle = renderer.circle(100, 100, 100)
	 *     .attr({ fill: 'red' })
	 *     .add();
	 * var clipRect = renderer.clipRect(100, 100, 100, 100);
	 *
	 * // Leave only the lower right quarter visible
	 * circle.clip(clipRect);
	 */
	/**
	 * Define a clipping rectangle. The clipping rectangle is later applied
	 * to {@link SVGElement} objects through the {@link SVGElement#clip}
	 * function.
	 * 
	 * @param {String} id
	 * @param {number} x
	 * @param {number} y
	 * @param {number} width
	 * @param {number} height
	 * @returns {ClipRect} A clipping rectangle.
	 *
	 * @example
	 * var circle = renderer.circle(100, 100, 100)
	 *     .attr({ fill: 'red' })
	 *     .add();
	 * var clipRect = renderer.clipRect(100, 100, 100, 100);
	 *
	 * // Leave only the lower right quarter visible
	 * circle.clip(clipRect);
	 */
	clipRect: function (x, y, width, height) {
		var wrapper,
			id = H.uniqueKey(),

			clipPath = this.createElement('clipPath').attr({
				id: id
			}).add(this.defs);

		wrapper = this.rect(x, y, width, height, 0).add(clipPath);
		wrapper.id = id;
		wrapper.clipPath = clipPath;
		wrapper.count = 0;

		return wrapper;
	},





	/**
	 * Draw text. The text can contain a subset of HTML, like spans and anchors
	 * and some basic text styling of these. For more advanced features like
	 * border and background, use {@link Highcharts.SVGRenderer#label} instead.
	 * To update the text after render, run `text.attr({ text: 'New text' })`.
	 * @param  {String} str
	 *         The text of (subset) HTML to draw.
	 * @param  {number} x
	 *         The x position of the text's lower left corner.
	 * @param  {number} y
	 *         The y position of the text's lower left corner.
	 * @param  {Boolean} [useHTML=false]
	 *         Use HTML to render the text.
	 *
	 * @return {SVGElement} The text object.
	 *
	 * @sample highcharts/members/renderer-text-on-chart/
	 *         Annotate the chart freely
	 * @sample highcharts/members/renderer-on-chart/
	 *         Annotate with a border and in response to the data
	 * @sample highcharts/members/renderer-text/
	 *         Formatted text
	 */
	text: function (str, x, y, useHTML) {

		// declare variables
		var renderer = this,
			wrapper,
			attribs = {};

		if (useHTML && (renderer.allowHTML || !renderer.forExport)) {
			return renderer.html(str, x, y);
		}

		attribs.x = Math.round(x || 0); // X always needed for line-wrap logic
		if (y) {
			attribs.y = Math.round(y);
		}
		if (str || str === 0) {
			attribs.text = str;
		}

		wrapper = renderer.createElement('text')
			.attr(attribs);

		if (!useHTML) {
			wrapper.xSetter = function (value, key, element) {
				var tspans = element.getElementsByTagName('tspan'),
					tspan,
					parentVal = element.getAttribute(key),
					i;
				for (i = 0; i < tspans.length; i++) {
					tspan = tspans[i];
					// If the x values are equal, the tspan represents a
					// linebreak
					if (tspan.getAttribute(key) === parentVal) {
						tspan.setAttribute(key, value);
					}
				}
				element.setAttribute(key, value);
			};
		}

		return wrapper;
	},

	/**
	 * Utility to return the baseline offset and total line height from the font
	 * size.
	 *
	 * @param {?string} fontSize The current font size to inspect. If not given,
	 *   the font size will be found from the DOM element.
	 * @param {SVGElement|SVGDOMElement} [elem] The element to inspect for a
	 *   current font size.
	 * @returns {Object} An object containing `h`: the line height, `b`: the
	 * baseline relative to the top of the box, and `f`: the font size.
	 */
	fontMetrics: function (fontSize, elem) {
		var lineHeight,
			baseline;

		
		fontSize = fontSize ||
			// When the elem is a DOM element (#5932)
			(elem && elem.style && elem.style.fontSize) ||
			// Fall back on the renderer style default
			(this.style && this.style.fontSize);

		

		// Handle different units
		if (/px/.test(fontSize)) {
			fontSize = pInt(fontSize);
		} else if (/em/.test(fontSize)) {
			// The em unit depends on parent items
			fontSize = parseFloat(fontSize) *
				(elem ? this.fontMetrics(null, elem.parentNode).f : 16);
		} else {
			fontSize = 12;
		}

		// Empirical values found by comparing font size and bounding box
		// height. Applies to the default font family.
		// http://jsfiddle.net/highcharts/7xvn7/
		lineHeight = fontSize < 24 ? fontSize + 3 : Math.round(fontSize * 1.2);
		baseline = Math.round(lineHeight * 0.8);

		return {
			h: lineHeight,
			b: baseline,
			f: fontSize
		};
	},

	/**
	 * Correct X and Y positioning of a label for rotation (#1764).
	 *
	 * @private
	 */
	rotCorr: function (baseline, rotation, alterY) {
		var y = baseline;
		if (rotation && alterY) {
			y = Math.max(y * Math.cos(rotation * deg2rad), 4);
		}
		return {
			x: (-baseline / 3) * Math.sin(rotation * deg2rad),
			y: y
		};
	},

	/**
	 * Draw a label, which is an extended text element with support for border
	 * and background. Highcharts creates a `g` element with a text and a `path`
	 * or `rect` inside, to make it behave somewhat like a HTML div. Border and
	 * background are set through `stroke`, `stroke-width` and `fill` attributes
	 * using the {@link Highcharts.SVGElement#attr|attr} method. To update the
	 * text after render, run `label.attr({ text: 'New text' })`.
	 * 
	 * @param  {string} str
	 *         The initial text string or (subset) HTML to render.
	 * @param  {number} x
	 *         The x position of the label's left side.
	 * @param  {number} y
	 *         The y position of the label's top side or baseline, depending on
	 *         the `baseline` parameter.
	 * @param  {String} shape
	 *         The shape of the label's border/background, if any. Defaults to
	 *         `rect`. Other possible values are `callout` or other shapes
	 *         defined in {@link Highcharts.SVGRenderer#symbols}.
	 * @param  {number} anchorX
	 *         In case the `shape` has a pointer, like a flag, this is the
	 *         coordinates it should be pinned to.
	 * @param  {number} anchorY
	 *         In case the `shape` has a pointer, like a flag, this is the
	 *         coordinates it should be pinned to.
	 * @param  {Boolean} baseline
	 *         Whether to position the label relative to the text baseline,
	 *	       like {@link Highcharts.SVGRenderer#text|renderer.text}, or to the
	 *	       upper border of the rectangle.
	 * @param  {String} className
	 *         Class name for the group.
	 *
	 * @return {SVGElement}
	 *         The generated label.
	 *
	 * @sample highcharts/members/renderer-label-on-chart/
	 *         A label on the chart
	 */
	label: function (
		str,
		x,
		y,
		shape,
		anchorX,
		anchorY,
		useHTML,
		baseline,
		className
	) {

		var renderer = this,
			wrapper = renderer.g(className !== 'button' && 'label'),
			text = wrapper.text = renderer.text('', 0, 0, useHTML)
				.attr({
					zIndex: 1
				}),
			box,
			bBox,
			alignFactor = 0,
			padding = 3,
			paddingLeft = 0,
			width,
			height,
			wrapperX,
			wrapperY,
			textAlign,
			deferredAttr = {},
			strokeWidth,
			baselineOffset,
			hasBGImage = /^url\((.*?)\)$/.test(shape),
			needsBox = hasBGImage,
			getCrispAdjust,
			updateBoxSize,
			updateTextPadding,
			boxAttr;

		if (className) {
			wrapper.addClass('highcharts-' + className);
		}

		
		needsBox = hasBGImage;
		getCrispAdjust = function () {
			return (strokeWidth || 0) % 2 / 2;
		};

		

		/**
		 * This function runs after the label is added to the DOM (when the
		 * bounding box is available), and after the text of the label is
		 * updated to detect the new bounding box and reflect it in the border
		 * box.
		 */
		updateBoxSize = function () {
			var style = text.element.style,
				crispAdjust,
				attribs = {};

			bBox = (
				(width === undefined || height === undefined || textAlign) &&
				defined(text.textStr) &&
				text.getBBox()
			); // #3295 && 3514 box failure when string equals 0
			wrapper.width = (
				(width || bBox.width || 0) +
				2 * padding +
				paddingLeft
			);
			wrapper.height = (height || bBox.height || 0) + 2 * padding;

			// Update the label-scoped y offset
			baselineOffset = padding +
				renderer.fontMetrics(style && style.fontSize, text).b;


			if (needsBox) {

				// Create the border box if it is not already present
				if (!box) {
					// Symbol definition exists (#5324)
					wrapper.box = box = renderer.symbols[shape] || hasBGImage ? 
						renderer.symbol(shape) :
						renderer.rect();
					
					box.addClass( // Don't use label className for buttons
						(className === 'button' ? '' : 'highcharts-label-box') +
						(className ? ' highcharts-' + className + '-box' : '')
					);

					box.add(wrapper);

					crispAdjust = getCrispAdjust();
					attribs.x = crispAdjust;
					attribs.y = (baseline ? -baselineOffset : 0) + crispAdjust;
				}

				// Apply the box attributes
				attribs.width = Math.round(wrapper.width);
				attribs.height = Math.round(wrapper.height);
				
				box.attr(extend(attribs, deferredAttr));
				deferredAttr = {};
			}
		};

		/**
		 * This function runs after setting text or padding, but only if padding
		 * is changed
		 */
		updateTextPadding = function () {
			var textX = paddingLeft + padding,
				textY;

			// determin y based on the baseline
			textY = baseline ? 0 : baselineOffset;

			// compensate for alignment
			if (
				defined(width) &&
				bBox &&
				(textAlign === 'center' || textAlign === 'right')
			) {
				textX += { center: 0.5, right: 1 }[textAlign] *
					(width - bBox.width);
			}

			// update if anything changed
			if (textX !== text.x || textY !== text.y) {
				text.attr('x', textX);
				if (textY !== undefined) {
					text.attr('y', textY);
				}
			}

			// record current values
			text.x = textX;
			text.y = textY;
		};

		/**
		 * Set a box attribute, or defer it if the box is not yet created
		 * @param {Object} key
		 * @param {Object} value
		 */
		boxAttr = function (key, value) {
			if (box) {
				box.attr(key, value);
			} else {
				deferredAttr[key] = value;
			}
		};

		/**
		 * After the text element is added, get the desired size of the border
		 * box and add it before the text in the DOM.
		 */
		wrapper.onAdd = function () {
			text.add(wrapper);
			wrapper.attr({
				// Alignment is available now  (#3295, 0 not rendered if given
				// as a value)
				text: (str || str === 0) ? str : '',
				x: x,
				y: y
			});

			if (box && defined(anchorX)) {
				wrapper.attr({
					anchorX: anchorX,
					anchorY: anchorY
				});
			}
		};

		/*
		 * Add specific attribute setters.
		 */

		// only change local variables
		wrapper.widthSetter = function (value) {
			width = H.isNumber(value) ? value : null; // width:auto => null
		};
		wrapper.heightSetter = function (value) {
			height = value;
		};
		wrapper['text-alignSetter'] = function (value) {
			textAlign = value;
		};
		wrapper.paddingSetter =  function (value) {
			if (defined(value) && value !== padding) {
				padding = wrapper.padding = value;
				updateTextPadding();
			}
		};
		wrapper.paddingLeftSetter =  function (value) {
			if (defined(value) && value !== paddingLeft) {
				paddingLeft = value;
				updateTextPadding();
			}
		};


		// change local variable and prevent setting attribute on the group
		wrapper.alignSetter = function (value) {
			value = { left: 0, center: 0.5, right: 1 }[value];
			if (value !== alignFactor) {
				alignFactor = value;
				// Bounding box exists, means we're dynamically changing
				if (bBox) {
					wrapper.attr({ x: wrapperX }); // #5134
				}
			}
		};

		// apply these to the box and the text alike
		wrapper.textSetter = function (value) {
			if (value !== undefined) {
				text.textSetter(value);
			}
			updateBoxSize();
			updateTextPadding();
		};

		// apply these to the box but not to the text
		wrapper['stroke-widthSetter'] = function (value, key) {
			if (value) {
				needsBox = true;
			}
			strokeWidth = this['stroke-width'] = value;
			boxAttr(key, value);
		};
		
		wrapper.strokeSetter =
		wrapper.fillSetter =
		wrapper.rSetter = function (value, key) {
			if (key !== 'r') {
				if (key === 'fill' && value) {
					needsBox = true;
				}
				// for animation getter (#6776)
				wrapper[key] = value;
			}
			boxAttr(key, value);
		};
		
		wrapper.anchorXSetter = function (value, key) {
			anchorX = wrapper.anchorX = value;
			boxAttr(key, Math.round(value) - getCrispAdjust() - wrapperX);
		};
		wrapper.anchorYSetter = function (value, key) {
			anchorY = wrapper.anchorY = value;
			boxAttr(key, value - wrapperY);
		};

		// rename attributes
		wrapper.xSetter = function (value) {
			wrapper.x = value; // for animation getter
			if (alignFactor) {
				value -= alignFactor * ((width || bBox.width) + 2 * padding);
			}
			wrapperX = Math.round(value);
			wrapper.attr('translateX', wrapperX);
		};
		wrapper.ySetter = function (value) {
			wrapperY = wrapper.y = Math.round(value);
			wrapper.attr('translateY', wrapperY);
		};

		// Redirect certain methods to either the box or the text
		var baseCss = wrapper.css;
		return extend(wrapper, {
			/**
			 * Pick up some properties and apply them to the text instead of the
			 * wrapper.
			 * @ignore
			 */
			css: function (styles) {
				if (styles) {
					var textStyles = {};
					// Create a copy to avoid altering the original object
					// (#537)
					styles = merge(styles); 
					each(wrapper.textProps, function (prop) {
						if (styles[prop] !== undefined) {
							textStyles[prop] = styles[prop];
							delete styles[prop];
						}
					});
					text.css(textStyles);
				}
				return baseCss.call(wrapper, styles);
			},
			/**
			 * Return the bounding box of the box, not the group.
			 * @ignore
			 */
			getBBox: function () {
				return {
					width: bBox.width + 2 * padding,
					height: bBox.height + 2 * padding,
					x: bBox.x - padding,
					y: bBox.y - padding
				};
			},
			
			/**
			 * Apply the shadow to the box.
			 * @ignore
			 */
			shadow: function (b) {
				if (b) {
					updateBoxSize();
					if (box) {
						box.shadow(b);
					}
				}
				return wrapper;
			},
			
			/**
			 * Destroy and release memory.
			 * @ignore
			 */
			destroy: function () {
				
				// Added by button implementation
				removeEvent(wrapper.element, 'mouseenter');
				removeEvent(wrapper.element, 'mouseleave');

				if (text) {
					text = text.destroy();
				}
				if (box) {
					box = box.destroy();
				}
				// Call base implementation to destroy the rest
				SVGElement.prototype.destroy.call(wrapper);

				// Release local pointers (#1298)
				wrapper =
				renderer =
				updateBoxSize =
				updateTextPadding =
				boxAttr = null;
			}
		});
	}
}); // end SVGRenderer


// general renderer
H.Renderer = SVGRenderer;

}(Highcharts));
(function (H) {
/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
/* eslint max-len: ["warn", 80, 4] */
var attr = H.attr,
	createElement = H.createElement,
	css = H.css,
	defined = H.defined,
	each = H.each,
	extend = H.extend,
	isFirefox = H.isFirefox,
	isMS = H.isMS,
	isWebKit = H.isWebKit,
	pick = H.pick,
	pInt = H.pInt,
	SVGElement = H.SVGElement,
	SVGRenderer = H.SVGRenderer,
	win = H.win,
	wrap = H.wrap;

// Extend SvgElement for useHTML option
extend(SVGElement.prototype, /** @lends SVGElement.prototype */ {
	/**
	 * Apply CSS to HTML elements. This is used in text within SVG rendering and
	 * by the VML renderer
	 */
	htmlCss: function (styles) {
		var wrapper = this,
			element = wrapper.element,
			textWidth = styles && element.tagName === 'SPAN' && styles.width;

		if (textWidth) {
			delete styles.width;
			wrapper.textWidth = textWidth;
			wrapper.updateTransform();
		}
		if (styles && styles.textOverflow === 'ellipsis') {
			styles.whiteSpace = 'nowrap';
			styles.overflow = 'hidden';
		}
		wrapper.styles = extend(wrapper.styles, styles);
		css(wrapper.element, styles);

		return wrapper;
	},

	/**
	 * VML and useHTML method for calculating the bounding box based on offsets
	 * @param {Boolean} refresh Whether to force a fresh value from the DOM or
	 * to use the cached value.
	 *
	 * @return {Object} A hash containing values for x, y, width and height
	 */

	htmlGetBBox: function () {
		var wrapper = this,
			element = wrapper.element;

		return {
			x: element.offsetLeft,
			y: element.offsetTop,
			width: element.offsetWidth,
			height: element.offsetHeight
		};
	},

	/**
	 * VML override private method to update elements based on internal
	 * properties based on SVG transform
	 */
	htmlUpdateTransform: function () {
		// aligning non added elements is expensive
		if (!this.added) {
			this.alignOnAdd = true;
			return;
		}

		var wrapper = this,
			renderer = wrapper.renderer,
			elem = wrapper.element,
			translateX = wrapper.translateX || 0,
			translateY = wrapper.translateY || 0,
			x = wrapper.x || 0,
			y = wrapper.y || 0,
			align = wrapper.textAlign || 'left',
			alignCorrection = { left: 0, center: 0.5, right: 1 }[align],
			styles = wrapper.styles;

		// apply translate
		css(elem, {
			marginLeft: translateX,
			marginTop: translateY
		});

		
		if (wrapper.shadows) { // used in labels/tooltip
			each(wrapper.shadows, function (shadow) {
				css(shadow, {
					marginLeft: translateX + 1,
					marginTop: translateY + 1
				});
			});
		}
		

		// apply inversion
		if (wrapper.inverted) { // wrapper is a group
			each(elem.childNodes, function (child) {
				renderer.invertChild(child, elem);
			});
		}

		if (elem.tagName === 'SPAN') {

			var rotation = wrapper.rotation,
				baseline,
				textWidth = pInt(wrapper.textWidth),
				whiteSpace = styles && styles.whiteSpace,
				currentTextTransform = [
					rotation,
					align,
					elem.innerHTML,
					wrapper.textWidth,
					wrapper.textAlign
				].join(',');

			// Do the calculations and DOM access only if properties changed
			if (currentTextTransform !== wrapper.cTT) {


				baseline = renderer.fontMetrics(elem.style.fontSize).b;

				// Renderer specific handling of span rotation
				if (defined(rotation)) {
					wrapper.setSpanRotation(
						rotation,
						alignCorrection,
						baseline
					);
				}

				// Reset multiline/ellipsis in order to read width (#4928,
				// #5417)
				css(elem, {
					width: '',
					whiteSpace: whiteSpace || 'nowrap'
				});

				// Update textWidth
				if (
					elem.offsetWidth > textWidth &&
					/[ \-]/.test(elem.textContent || elem.innerText)
				) { // #983, #1254
					css(elem, {
						width: textWidth + 'px',
						display: 'block',
						whiteSpace: whiteSpace || 'normal' // #3331
					});
				}


				wrapper.getSpanCorrection(
					elem.offsetWidth,
					baseline,
					alignCorrection,
					rotation,
					align
				);
			}

			// apply position with correction
			css(elem, {
				left: (x + (wrapper.xCorr || 0)) + 'px',
				top: (y + (wrapper.yCorr || 0)) + 'px'
			});

			// Force reflow in webkit to apply the left and top on useHTML
			// element (#1249)
			if (isWebKit) {
				// Assigned to baseline for lint purpose
				baseline = elem.offsetHeight;
			}

			// record current text transform
			wrapper.cTT = currentTextTransform;
		}
	},

	/**
	 * Set the rotation of an individual HTML span
	 */
	setSpanRotation: function (rotation, alignCorrection, baseline) {
		var rotationStyle = {},
			cssTransformKey = this.renderer.getTransformKey();

		rotationStyle[cssTransformKey] = rotationStyle.transform =
			'rotate(' + rotation + 'deg)';
		rotationStyle[cssTransformKey + (isFirefox ? 'Origin' : '-origin')] =
		rotationStyle.transformOrigin =
			(alignCorrection * 100) + '% ' + baseline + 'px';
		css(this.element, rotationStyle);
	},

	/**
	 * Get the correction in X and Y positioning as the element is rotated.
	 */
	getSpanCorrection: function (width, baseline, alignCorrection) {
		this.xCorr = -width * alignCorrection;
		this.yCorr = -baseline;
	}
});

// Extend SvgRenderer for useHTML option.
extend(SVGRenderer.prototype, /** @lends SVGRenderer.prototype */ {

	getTransformKey: function () {
		return isMS && !/Edge/.test(win.navigator.userAgent) ?
			'-ms-transform' :
			isWebKit ?
				'-webkit-transform' :
				isFirefox ?
					'MozTransform' :
					win.opera ?
						'-o-transform' :
						'';
	},

	/**
	 * Create HTML text node. This is used by the VML renderer as well as the
	 * SVG renderer through the useHTML option.
	 *
	 * @param {String} str
	 * @param {Number} x
	 * @param {Number} y
	 */
	html: function (str, x, y) {
		var wrapper = this.createElement('span'),
			element = wrapper.element,
			renderer = wrapper.renderer,
			isSVG = renderer.isSVG,
			addSetters = function (element, style) {
				// These properties are set as attributes on the SVG group, and
				// as identical CSS properties on the div. (#3542)
				each(['opacity', 'visibility'], function (prop) {
					wrap(element, prop + 'Setter', function (
						proceed,
						value,
						key,
						elem
					) {
						proceed.call(this, value, key, elem);
						style[key] = value;
					});
				});				
			};

		// Text setter
		wrapper.textSetter = function (value) {
			if (value !== element.innerHTML) {
				delete this.bBox;
			}
			this.textStr = value;
			element.innerHTML = pick(value, '');
			wrapper.htmlUpdateTransform();
		};

		// Add setters for the element itself (#4938)
		if (isSVG) { // #4938, only for HTML within SVG
			addSetters(wrapper, wrapper.element.style);
		}

		// Various setters which rely on update transform
		wrapper.xSetter =
		wrapper.ySetter =
		wrapper.alignSetter =
		wrapper.rotationSetter =
		function (value, key) {
			if (key === 'align') {
				// Do not overwrite the SVGElement.align method. Same as VML.
				key = 'textAlign';
			}
			wrapper[key] = value;
			wrapper.htmlUpdateTransform();
		};

		// Set the default attributes
		wrapper
			.attr({
				text: str,
				x: Math.round(x),
				y: Math.round(y)
			})
			.css({
				
				fontFamily: this.style.fontFamily,
				fontSize: this.style.fontSize,
				
				position: 'absolute'
			});

		// Keep the whiteSpace style outside the wrapper.styles collection
		element.style.whiteSpace = 'nowrap';

		// Use the HTML specific .css method
		wrapper.css = wrapper.htmlCss;

		// This is specific for HTML within SVG
		if (isSVG) {
			wrapper.add = function (svgGroupWrapper) {

				var htmlGroup,
					container = renderer.box.parentNode,
					parentGroup,
					parents = [];

				this.parentGroup = svgGroupWrapper;

				// Create a mock group to hold the HTML elements
				if (svgGroupWrapper) {
					htmlGroup = svgGroupWrapper.div;
					if (!htmlGroup) {

						// Read the parent chain into an array and read from top
						// down
						parentGroup = svgGroupWrapper;
						while (parentGroup) {

							parents.push(parentGroup);

							// Move up to the next parent group
							parentGroup = parentGroup.parentGroup;
						}

						// Ensure dynamically updating position when any parent
						// is translated
						each(parents.reverse(), function (parentGroup) {
							var htmlGroupStyle,
								cls = attr(parentGroup.element, 'class');

							// Common translate setter for X and Y on the HTML
							// group. Reverted the fix for #6957 du to
							// positioning problems and offline export (#7254,
							// #7280, #7529)
							function translateSetter(value, key) {
								parentGroup[key] = value;

								if (key === 'translateX') {
									htmlGroupStyle.left = value + 'px';
								} else {
									htmlGroupStyle.top = value + 'px';
								}
								
								parentGroup.doTransform = true;
							}

							if (cls) {
								cls = { className: cls };
							} // else null

							// Create a HTML div and append it to the parent div
							// to emulate the SVG group structure
							htmlGroup =
							parentGroup.div =
							parentGroup.div || createElement('div', cls, {
								position: 'absolute',
								left: (parentGroup.translateX || 0) + 'px',
								top: (parentGroup.translateY || 0) + 'px',
								display: parentGroup.display,
								opacity: parentGroup.opacity, // #5075
								pointerEvents: (
									parentGroup.styles &&
									parentGroup.styles.pointerEvents
								) // #5595

							// the top group is appended to container
							}, htmlGroup || container);

							// Shortcut
							htmlGroupStyle = htmlGroup.style;

							// Set listeners to update the HTML div's position
							// whenever the SVG group position is changed.
							extend(parentGroup, {
								// (#7287) Pass htmlGroup to use
								// the related group 
								classSetter: (function (htmlGroup) {
									return function (value) {
										this.element.setAttribute(
											'class',
											value
										);
										htmlGroup.className = value;
									};
								}(htmlGroup)),
								on: function () {
									if (parents[0].div) { // #6418
										wrapper.on.apply(
											{ element: parents[0].div },
											arguments
										);
									}
									return parentGroup;
								},
								translateXSetter: translateSetter,
								translateYSetter: translateSetter
							});
							addSetters(parentGroup, htmlGroupStyle);
						});

					}
				} else {
					htmlGroup = container;
				}

				htmlGroup.appendChild(element);

				// Shared with VML:
				wrapper.added = true;
				if (wrapper.alignOnAdd) {
					wrapper.htmlUpdateTransform();
				}

				return wrapper;
			};
		}
		return wrapper;
	}
});

}(Highcharts));
(function (Highcharts) {
/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
/* eslint max-len: ["warn", { "ignoreUrls": true}] */

var H = Highcharts,

	merge = H.merge,
	pick = H.pick,
	win = H.win;

/**
 * The Time class. Time settings are applied in general for each page using
 * `Highcharts.setOptions`, or individually for each Chart item through the
 * [time](https://api.highcharts.com/highcharts/time) options set.
 *
 * The Time object is available from
 * [Chart.time](http://api.highcharts.com/class-reference/Highcharts.Chart#.time),
 * which refers to  `Highcharts.time` if no individual time settings are
 * applied.
 *
 * @example
 * // Apply time settings globally
 * Highcharts.setOptions({
 *     time: {
 *         timezone: 'Europe/London'
 *     }
 * });
 * 
 * // Apply time settings by instance
 * var chart = Highcharts.chart('container', {
 *     time: {
 *         timezone: 'America/New_York'
 *     },
 *     series: [{
 *         data: [1, 4, 3, 5]
 *     }]
 * });
 *
 * // Use the Time object
 * console.log(
 * 	   'Current time in New York',
 *	    chart.time.dateFormat('%Y-%m-%d %H:%M:%S', Date.now())
 * );
 *
 * @param  chart {Chart}
 *         The chart instance. The `Time` instance reads its config options from
 *         [chart.options.time](/highcharts/time). If omitted, it reads from
 *         `Highcharts.defaultOptions.time`.
 * @since  6.0.5
 * @class
 */
Highcharts.Time = function (chart) {
	this.init(chart);
};

Highcharts.Time.prototype = {

	init: function (chart) {
		this.chart = chart;
		this.update(
			chart ?
				chart.options.time :
				merge(H.defaultOptions.global, H.defaultOptions.time),
			false
		);
	},

	/**
	 * Time options that can apply globally or to individual charts. These
	 * settings affect how `datetime` axes are laid out, how tooltips are
	 * formatted, how series
	 * [pointIntervalUnit](#plotOptions.series.pointIntervalUnit) works and how
	 * the Highstock range selector handles time.
	 * 
	 * The common use case is that all charts in the same Highcharts object
	 * share the same time settings, in which case the global settings are set
	 * using `setOptions`.
	 * 
	 * ```js
	 * // Apply time settings globally
	 * Highcharts.setOptions({
	 *     time: {
	 *         timezone: 'Europe/London'
	 *     }
	 * });
	 * // Apply time settings by instance
	 * var chart = Highcharts.chart('container', {
	 *     time: {
	 *         timezone: 'America/New_York'
	 *     },
	 *     series: [{
	 *         data: [1, 4, 3, 5]
	 *     }]
	 * });
	 *
	 * // Use the Time object
	 * console.log(
	 * 	   'Current time in New York',
	 *	    chart.time.dateFormat('%Y-%m-%d %H:%M:%S', Date.now())
	 * );
	 * ```
	 *
	 * Since v6.0.5, the time options were moved from the `global` obect to the
	 * `time` object, and time options can be set on each individual chart.
	 *
	 * @sample {highcharts|highstock}
	 *         highcharts/time/timezone/
	 *         Set the timezone globally
	 * @sample {highcharts}
	 *         highcharts/time/individual/
	 *         Set the timezone per chart instance
	 * @sample {highstock}
	 *         stock/time/individual/
	 *         Set the timezone per chart instance
	 * @since 6.0.5
	 * @apioption time
	 */
	defaultOptions: {
		/**
		 * Whether to use UTC time for axis scaling, tickmark placement and
		 * time display in `Highcharts.dateFormat`. Advantages of using UTC
		 * is that the time displays equally regardless of the user agent's
		 * time zone settings. Local time can be used when the data is loaded
		 * in real time or when correct Daylight Saving Time transitions are
		 * required.
		 * 
		 * @type {Boolean}
		 * @sample {highcharts} highcharts/time/useutc-true/ True by default
		 * @sample {highcharts} highcharts/time/useutc-false/ False
		 * @apioption time.useUTC
		 * @default true
		 */

		/**
		 * A custom `Date` class for advanced date handling. For example,
		 * [JDate](https://githubcom/tahajahangir/jdate) can be hooked in to
		 * handle Jalali dates.
		 * 
		 * @type {Object}
		 * @since 4.0.4
		 * @product highcharts highstock
		 * @apioption time.Date
		 */

		/**
		 * A callback to return the time zone offset for a given datetime. It
		 * takes the timestamp in terms of milliseconds since January 1 1970,
		 * and returns the timezone offset in minutes. This provides a hook
		 * for drawing time based charts in specific time zones using their
		 * local DST crossover dates, with the help of external libraries.
		 * 
		 * @type {Function}
		 * @see [global.timezoneOffset](#global.timezoneOffset)
		 * @sample {highcharts|highstock}
		 *         highcharts/time/gettimezoneoffset/
		 *         Use moment.js to draw Oslo time regardless of browser locale
		 * @since 4.1.0
		 * @product highcharts highstock
		 * @apioption time.getTimezoneOffset
		 */

		/**
		 * Requires [moment.js](http://momentjs.com/). If the timezone option
		 * is specified, it creates a default
		 * [getTimezoneOffset](#time.getTimezoneOffset) function that looks
		 * up the specified timezone in moment.js. If moment.js is not included,
		 * this throws a Highcharts error in the console, but does not crash the
		 * chart.
		 * 
		 * @type {String}
		 * @see [getTimezoneOffset](#time.getTimezoneOffset)
		 * @sample {highcharts|highstock}
		 *         highcharts/time/timezone/
		 *         Europe/Oslo
		 * @default undefined
		 * @since 5.0.7
		 * @product highcharts highstock
		 * @apioption time.timezone
		 */		

		/**
		 * The timezone offset in minutes. Positive values are west, negative
		 * values are east of UTC, as in the ECMAScript
		 * [getTimezoneOffset](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getTimezoneOffset)
		 * method. Use this to display UTC based data in a predefined time zone.
		 * 
		 * @type {Number}
		 * @see [time.getTimezoneOffset](#time.getTimezoneOffset)
		 * @sample {highcharts|highstock}
		 *         highcharts/time/timezoneoffset/
		 *         Timezone offset
		 * @default 0
		 * @since 3.0.8
		 * @product highcharts highstock
		 * @apioption time.timezoneOffset
		 */

	},

	/**
	 * Update the Time object with current options. It is called internally on
	 * initiating Highcharts, after running `Highcharts.setOptions` and on
	 * `Chart.update`.
	 *
	 * @private
	 */
	update: function (options) {
		var useUTC = pick(options.useUTC, true),
			getters = ['Minutes', 'Hours', 'Day', 'Date', 'Month', 'FullYear'],
			setters = getters.concat(['Milliseconds', 'Seconds']),
			n;

		this.options = merge(true, this.options || {}, options);

		// Allow using a different Date class
		this.Date = options.Date || win.Date;

		this.useUTC = useUTC;
		this.timezoneOffset = useUTC && options.timezoneOffset;

		/**
		 * Get the time zone offset based on the current timezone information as
		 * set in the global options.
		 *
		 * @function #getTimezoneOffset
		 * @memberOf Highcharts.Time
		 * @param  {Number} timestamp
		 *         The JavaScript timestamp to inspect.
		 * @return {Number}
		 *         The timezone offset in minutes compared to UTC.
		 */
		this.getTimezoneOffset = this.timezoneOffsetFunction();

		/*
		 * The time object has options allowing for variable time zones, meaning
		 * the axis ticks or series data needs to consider this.
		 */
		this.variableTimezone = !!(
			options.getTimezoneOffset ||
			options.timezone
		);

		// Dynamically set setters and getters. Sets strings pointing to the
		// appropriate Date function to use depending on useUTC. Use `for` loop,
		// H.each is not yet overridden in oldIE.
		for (n = 0; n < getters.length; n++) {
			this['get' + getters[n]] = (useUTC ? 'getUTC' : 'get') + getters[n];
		}
		for (n = 0; n < setters.length; n++) {
			this['set' + setters[n]] = (useUTC ? 'setUTC' : 'set') + setters[n];
		}

	},

	/**
	 * Make a time and returns milliseconds. Interprets the inputs as UTC time,
	 * local time or a specific timezone time depending on the current time
	 * settings.
	 * 
	 * @param  {Number} year
	 *         The year
	 * @param  {Number} month
	 *         The month. Zero-based, so January is 0.
	 * @param  {Number} date
	 *         The day of the month
	 * @param  {Number} hours
	 *         The hour of the day, 0-23.
	 * @param  {Number} minutes
	 *         The minutes
	 * @param  {Number} seconds
	 *         The seconds
	 *
	 * @return {Number}
	 *         The time in milliseconds since January 1st 1970.
	 */
	makeTime: function (year, month, date, hours, minutes, seconds) {
		var d;
		if (this.useUTC) {
			d = this.Date.UTC.apply(0, arguments);
			d += this.getTimezoneOffset(d);
		} else {
			d = new this.Date(
				year,
				month,
				pick(date, 1),
				pick(hours, 0),
				pick(minutes, 0),
				pick(seconds, 0)
			).getTime();
		}
		return d;
	},

	/**
	 * Sets the getTimezoneOffset function. If the `timezone` option is set, a
	 * default getTimezoneOffset function with that timezone is returned. If
	 * a `getTimezoneOffset` option is defined, it is returned. If neither are
	 * specified, the function using the `timezoneOffset` option or 0 offset is
	 * returned.
	 *
	 * @private
	 * @return {Function} A getTimezoneOffset function
	 */
	timezoneOffsetFunction: function () {
		var time = this,
			options = this.options,
			moment = win.moment;

		if (options.timezone) {
			if (!moment) {
				// getTimezoneOffset-function stays undefined because it depends
				// on Moment.js
				H.error(25);
				
			} else {
				return function (timestamp) {
					return -moment.tz(
						timestamp,
						options.timezone
					).utcOffset() * 60000;
				};
			}
		}

		// If not timezone is set, look for the getTimezoneOffset callback
		if (this.useUTC && options.getTimezoneOffset) {
			return function (timestamp) {
				return options.getTimezoneOffset(timestamp) * 60000;
			};
		}

		// Last, use the `timezoneOffset` option if set
		return function () {
			return (time.timezoneOffset || 0) * 60000;
		};
	},

	/**
	 * Formats a JavaScript date timestamp (milliseconds since Jan 1st 1970)
	 * into a human readable date string. The format is a subset of the formats
	 * for PHP's [strftime](http://www.php.net/manual/en/function.strftime.php)
	 * function. Additional formats can be given in the
	 * {@link Highcharts.dateFormats} hook.
	 *
	 * @param {String} format
	 *        The desired format where various time
	 *        representations are prefixed with %.
	 * @param {Number} timestamp
	 *        The JavaScript timestamp.
	 * @param {Boolean} [capitalize=false]
	 *        Upper case first letter in the return.
	 * @returns {String} The formatted date.
	 */
	dateFormat: function (format, timestamp, capitalize) {
		if (!H.defined(timestamp) || isNaN(timestamp)) {
			return H.defaultOptions.lang.invalidDate || '';
		}
		format = H.pick(format, '%Y-%m-%d %H:%M:%S');

		var time = this,
			D = this.Date,
			date = new D(timestamp - this.getTimezoneOffset(timestamp)),
			// get the basic time values
			hours = date[this.getHours](),
			day = date[this.getDay](),
			dayOfMonth = date[this.getDate](),
			month = date[this.getMonth](),
			fullYear = date[this.getFullYear](),
			lang = H.defaultOptions.lang,
			langWeekdays = lang.weekdays,
			shortWeekdays = lang.shortWeekdays,
			pad = H.pad,

			// List all format keys. Custom formats can be added from the
			// outside. 
			replacements = H.extend(
				{

					// Day
					// Short weekday, like 'Mon'
					'a': shortWeekdays ?
						shortWeekdays[day] :
						langWeekdays[day].substr(0, 3),
					// Long weekday, like 'Monday'
					'A': langWeekdays[day],
					// Two digit day of the month, 01 to 31
					'd': pad(dayOfMonth),
					// Day of the month, 1 through 31
					'e': pad(dayOfMonth, 2, ' '),
					'w': day,

					// Week (none implemented)
					// 'W': weekNumber(),

					// Month
					// Short month, like 'Jan'
					'b': lang.shortMonths[month],
					// Long month, like 'January'
					'B': lang.months[month],
					// Two digit month number, 01 through 12
					'm': pad(month + 1),

					// Year
					// Two digits year, like 09 for 2009
					'y': fullYear.toString().substr(2, 2),
					// Four digits year, like 2009
					'Y': fullYear,

					// Time
					// Two digits hours in 24h format, 00 through 23
					'H': pad(hours),
					// Hours in 24h format, 0 through 23
					'k': hours,
					// Two digits hours in 12h format, 00 through 11
					'I': pad((hours % 12) || 12),
					// Hours in 12h format, 1 through 12
					'l': (hours % 12) || 12,
					// Two digits minutes, 00 through 59
					'M': pad(date[this.getMinutes]()),
					// Upper case AM or PM
					'p': hours < 12 ? 'AM' : 'PM',
					// Lower case AM or PM
					'P': hours < 12 ? 'am' : 'pm',
					// Two digits seconds, 00 through  59
					'S': pad(date.getSeconds()),
					// Milliseconds (naming from Ruby)
					'L': pad(Math.round(timestamp % 1000), 3)
				},
				
				/**
				 * A hook for defining additional date format specifiers. New
				 * specifiers are defined as key-value pairs by using the
				 * specifier as key, and a function which takes the timestamp as
				 * value. This function returns the formatted portion of the
				 * date.
				 *
				 * @type {Object}
				 * @name dateFormats
				 * @memberOf Highcharts
				 * @sample highcharts/global/dateformats/
				 *         Adding support for week
				 * number
				 */
				H.dateFormats
			);


		// Do the replaces
		H.objectEach(replacements, function (val, key) {
			// Regex would do it in one line, but this is faster
			while (format.indexOf('%' + key) !== -1) {
				format = format.replace(
					'%' + key,
					typeof val === 'function' ? val.call(time, timestamp) : val
				);
			}
			
		});

		// Optionally capitalize the string and return
		return capitalize ?
			format.substr(0, 1).toUpperCase() + format.substr(1) :
			format;
	}

}; // end of Time


}(Highcharts));
(function (H) {
/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */

var color = H.color,
	isTouchDevice = H.isTouchDevice,
	merge = H.merge,
	svg = H.svg;
		
/* ****************************************************************************
 * Handle the options                                                         *
 *****************************************************************************/
/** 	 
 * @optionparent
 */
H.defaultOptions = {
	

	/**
	 * An array containing the default colors for the chart's series. When
	 * all colors are used, new colors are pulled from the start again.
	 * 
	 * Default colors can also be set on a series or series.type basis,
	 * see [column.colors](#plotOptions.column.colors), [pie.colors](#plotOptions.
	 * pie.colors).
	 * 
	 * In styled mode, the colors option doesn't exist. Instead, colors
	 * are defined in CSS and applied either through series or point class
	 * names, or through the [chart.colorCount](#chart.colorCount) option.
	 * 
	 * 
	 * ### Legacy
	 * 
	 * In Highcharts 3.x, the default colors were:
	 * 
	 * <pre>colors: ['#2f7ed8', '#0d233a', '#8bbc21', '#910000', '#1aadce', 
	 *     '#492970', '#f28f43', '#77a1e5', '#c42525', '#a6c96a']</pre> 
	 * 
	 * In Highcharts 2.x, the default colors were:
	 * 
	 * <pre>colors: ['#4572A7', '#AA4643', '#89A54E', '#80699B', '#3D96AE', 
	 *    '#DB843D', '#92A8CD', '#A47D7C', '#B5CA92']</pre>
	 * 
	 * @type {Array<Color>}
	 * @sample {highcharts} highcharts/chart/colors/ Assign a global color theme
	 * @default ["#7cb5ec", "#434348", "#90ed7d", "#f7a35c", "#8085e9",
	 *          "#f15c80", "#e4d354", "#2b908f", "#f45b5b", "#91e8e1"]
	 */
	colors: '#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1'.split(' '),
	

	
	/**
	 * Styled mode only. Configuration object for adding SVG definitions for
	 * reusable elements. See [gradients, shadows and patterns](http://www.
	 * highcharts.com/docs/chart-design-and-style/gradients-shadows-and-
	 * patterns) for more information and code examples.
	 * 
	 * @type {Object}
	 * @since 5.0.0
	 * @apioption defs
	 */

	/**
	 * @ignore
	 */
	symbols: ['circle', 'diamond', 'square', 'triangle', 'triangle-down'],
	lang: {

		/**
		 * The loading text that appears when the chart is set into the loading
		 * state following a call to `chart.showLoading`.
		 * 
		 * @type {String}
		 * @default Loading...
		 */
		loading: 'Loading...',

		/**
		 * An array containing the months names. Corresponds to the `%B` format
		 * in `Highcharts.dateFormat()`.
		 * 
		 * @type {Array<String>}
		 * @default [ "January" , "February" , "March" , "April" , "May" ,
		 *          "June" , "July" , "August" , "September" , "October" ,
		 *          "November" , "December"]
		 */
		months: [
			'January', 'February', 'March', 'April', 'May', 'June', 'July',
			'August', 'September', 'October', 'November', 'December'
		],

		/**
		 * An array containing the months names in abbreviated form. Corresponds
		 * to the `%b` format in `Highcharts.dateFormat()`.
		 * 
		 * @type {Array<String>}
		 * @default [ "Jan" , "Feb" , "Mar" , "Apr" , "May" , "Jun" ,
		 *          "Jul" , "Aug" , "Sep" , "Oct" , "Nov" , "Dec"]
		 */
		shortMonths: [
			'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul',
			'Aug', 'Sep', 'Oct', 'Nov', 'Dec'
		],

		/**
		 * An array containing the weekday names.
		 * 
		 * @type {Array<String>}
		 * @default ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday",
		 *          "Friday", "Saturday"]
		 */
		weekdays: [
			'Sunday', 'Monday', 'Tuesday', 'Wednesday',
			'Thursday', 'Friday', 'Saturday'
		],

		/**
		 * Short week days, starting Sunday. If not specified, Highcharts uses
		 * the first three letters of the `lang.weekdays` option.
		 * 
		 * @type {Array<String>}
		 * @sample highcharts/lang/shortweekdays/
		 *         Finnish two-letter abbreviations
		 * @since 4.2.4
		 * @apioption lang.shortWeekdays
		 */
		
		/**
		 * What to show in a date field for invalid dates. Defaults to an empty
		 * string.
		 * 
		 * @type {String}
		 * @since 4.1.8
		 * @product highcharts highstock
		 * @apioption lang.invalidDate
		 */

		/**
		 * The default decimal point used in the `Highcharts.numberFormat`
		 * method unless otherwise specified in the function arguments.
		 * 
		 * @type {String}
		 * @default .
		 * @since 1.2.2
		 */
		decimalPoint: '.',

		/**
		 * [Metric prefixes](http://en.wikipedia.org/wiki/Metric_prefix) used
		 * to shorten high numbers in axis labels. Replacing any of the positions
		 * with `null` causes the full number to be written. Setting `numericSymbols`
		 * to `null` disables shortening altogether.
		 * 
		 * @type {Array<String>}
		 * @sample {highcharts} highcharts/lang/numericsymbols/
		 *         Replacing the symbols with text
		 * @sample {highstock} highcharts/lang/numericsymbols/
		 *         Replacing the symbols with text
		 * @default [ "k" , "M" , "G" , "T" , "P" , "E"]
		 * @since 2.3.0
		 */
		numericSymbols: ['k', 'M', 'G', 'T', 'P', 'E'],

		/**
		 * The magnitude of [numericSymbols](#lang.numericSymbol) replacements.
		 * Use 10000 for Japanese, Korean and various Chinese locales, which
		 * use symbols for 10^4, 10^8 and 10^12.
		 * 
		 * @type {Number}
		 * @sample highcharts/lang/numericsymbolmagnitude/
		 *         10000 magnitude for Japanese
		 * @default 1000
		 * @since 5.0.3
		 * @apioption lang.numericSymbolMagnitude
		 */

		/**
		 * The text for the label appearing when a chart is zoomed.
		 * 
		 * @type {String}
		 * @default Reset zoom
		 * @since 1.2.4
		 */
		resetZoom: 'Reset zoom',

		/**
		 * The tooltip title for the label appearing when a chart is zoomed.
		 * 
		 * @type {String}
		 * @default Reset zoom level 1:1
		 * @since 1.2.4
		 */
		resetZoomTitle: 'Reset zoom level 1:1',

		/**
		 * The default thousands separator used in the `Highcharts.numberFormat`
		 * method unless otherwise specified in the function arguments. Since
		 * Highcharts 4.1 it defaults to a single space character, which is
		 * compatible with ISO and works across Anglo-American and continental
		 * European languages.
		 * 
		 * The default is a single space.
		 * 
		 * @type {String}
		 * @default  
		 * @since 1.2.2
		 */
		thousandsSep: ' '
	},

	/**
	 * Global options that don't apply to each chart. These options, like
	 * the `lang` options, must be set using the `Highcharts.setOptions`
	 * method.
	 * 
	 * <pre>Highcharts.setOptions({
	 *     global: {
	 *         useUTC: false
	 *     }
	 * });</pre>
	 *
	 */
	global: {

		/**
		 * _Canvg rendering for Android 2.x is removed as of Highcharts 5.0\.
		 * Use the [libURL](#exporting.libURL) option to configure exporting._
		 * 
		 * The URL to the additional file to lazy load for Android 2.x devices.
		 * These devices don't support SVG, so we download a helper file that
		 * contains [canvg](http://code.google.com/p/canvg/), its dependency
		 * rbcolor, and our own CanVG Renderer class. To avoid hotlinking to
		 * our site, you can install canvas-tools.js on your own server and
		 * change this option accordingly.
		 * 
		 * @type {String}
		 * @deprecated
		 * @default http://code.highcharts.com/{version}/modules/canvas-tools.js
		 * @product highcharts highmaps
		 * @apioption global.canvasToolsURL
		 */

		/**
		 * This option is deprecated since v6.0.5. Instead, use
		 * [time.useUTC](#time.useUTC) that supports individual time settings
		 * per chart.
		 * 
		 * @deprecated
		 * @apioption global.useUTC
		 */

		/**
		 * This option is deprecated since v6.0.5. Instead, use
		 * [time.Date](#time.Date) that supports individual time settings
		 * per chart.
		 * 
		 * @deprecated
		 * @product highcharts highstock
		 * @apioption global.Date
		 */

		/**
		 * This option is deprecated since v6.0.5. Instead, use
		 * [time.getTimezoneOffset](#time.getTimezoneOffset) that supports
		 * individual time settings per chart.
		 * 
		 * @deprecated
		 * @product highcharts highstock
		 * @apioption global.getTimezoneOffset
		 */

		/**
		 * This option is deprecated since v6.0.5. Instead, use
		 * [time.timezone](#time.timezone) that supports individual time
		 * settings per chart.
		 * 
		 * @deprecated
		 * @product highcharts highstock
		 * @apioption global.timezone
		 */

		/**
		 * This option is deprecated since v6.0.5. Instead, use
		 * [time.timezoneOffset](#time.timezoneOffset) that supports individual
		 * time settings per chart.
		 * 
		 * @deprecated
		 * @product highcharts highstock
		 * @apioption global.timezoneOffset
		 */
	},


	time: H.Time.prototype.defaultOptions,
	chart: {

		/**
		 * When using multiple axis, the ticks of two or more opposite axes
		 * will automatically be aligned by adding ticks to the axis or axes
		 * with the least ticks, as if `tickAmount` were specified.
		 * 
		 * This can be prevented by setting `alignTicks` to false. If the grid
		 * lines look messy, it's a good idea to hide them for the secondary
		 * axis by setting `gridLineWidth` to 0.
		 * 
		 * @type {Boolean}
		 * @sample {highcharts} highcharts/chart/alignticks-true/ True by default
		 * @sample {highcharts} highcharts/chart/alignticks-false/ False
		 * @sample {highstock} stock/chart/alignticks-true/
		 *         True by default
		 * @sample {highstock} stock/chart/alignticks-false/
		 *         False
		 * @default true
		 * @product highcharts highstock
		 * @apioption chart.alignTicks
		 */
		

		/**
		 * Set the overall animation for all chart updating. Animation can be
		 * disabled throughout the chart by setting it to false here. It can
		 * be overridden for each individual API method as a function parameter.
		 * The only animation not affected by this option is the initial series
		 * animation, see [plotOptions.series.animation](#plotOptions.series.
		 * animation).
		 * 
		 * The animation can either be set as a boolean or a configuration
		 * object. If `true`, it will use the 'swing' jQuery easing and a
		 * duration of 500 ms. If used as a configuration object, the following
		 * properties are supported:
		 * 
		 * <dl>
		 * 
		 * <dt>duration</dt>
		 * 
		 * <dd>The duration of the animation in milliseconds.</dd>
		 * 
		 * <dt>easing</dt>
		 * 
		 * <dd>A string reference to an easing function set on the `Math` object.
		 * See [the easing demo](http://jsfiddle.net/gh/get/library/pure/
		 * highcharts/highcharts/tree/master/samples/highcharts/plotoptions/
		 * series-animation-easing/).</dd>
		 * 
		 * </dl>
		 * 
		 * @type {Boolean|Object}
		 * @sample {highcharts} highcharts/chart/animation-none/
		 *         Updating with no animation
		 * @sample {highcharts} highcharts/chart/animation-duration/
		 *         With a longer duration
		 * @sample {highcharts} highcharts/chart/animation-easing/
		 *         With a jQuery UI easing
		 * @sample {highmaps} maps/chart/animation-none/
		 *         Updating with no animation
		 * @sample {highmaps} maps/chart/animation-duration/
		 *         With a longer duration
		 * @default true
		 * @apioption chart.animation
		 */
		
		/**
		 * A CSS class name to apply to the charts container `div`, allowing
		 * unique CSS styling for each chart.
		 * 
		 * @type {String}
		 * @apioption chart.className
		 */
		
		/**
		 * Event listeners for the chart.
		 * 
		 * @apioption chart.events
		 */
		
		/**
		 * Fires when a series is added to the chart after load time, using
		 * the `addSeries` method. One parameter, `event`, is passed to the
		 * function, containing common event information.
		 * Through `event.options` you can access the series options that was
		 * passed to the `addSeries` method. Returning false prevents the series
		 * from being added.
		 * 
		 * @type {Function}
		 * @context Chart
		 * @sample {highcharts} highcharts/chart/events-addseries/ Alert on add series
		 * @sample {highstock} stock/chart/events-addseries/ Alert on add series
		 * @since 1.2.0
		 * @apioption chart.events.addSeries
		 */

		/**
		 * Fires when clicking on the plot background. One parameter, `event`,
		 * is passed to the function, containing common event information.
		 * 
		 * Information on the clicked spot can be found through `event.xAxis`
		 * and `event.yAxis`, which are arrays containing the axes of each dimension
		 * and each axis' value at the clicked spot. The primary axes are `event.
		 * xAxis[0]` and `event.yAxis[0]`. Remember the unit of a datetime axis
		 * is milliseconds since 1970-01-01 00:00:00.
		 * 
		 * <pre>click: function(e) {
		 *     console.log(
		 *         Highcharts.dateFormat('%Y-%m-%d %H:%M:%S', e.xAxis[0].value),
		 *         e.yAxis[0].value
		 *     )
		 * }</pre>
		 * 
		 * @type {Function}
		 * @context Chart
		 * @sample {highcharts} highcharts/chart/events-click/
		 *         Alert coordinates on click
		 * @sample {highcharts} highcharts/chart/events-container/
		 *         Alternatively, attach event to container
		 * @sample {highstock} stock/chart/events-click/
		 *         Alert coordinates on click
		 * @sample {highstock} highcharts/chart/events-container/
		 *         Alternatively, attach event to container
		 * @sample {highmaps} maps/chart/events-click/
		 *         Record coordinates on click
		 * @sample {highmaps} highcharts/chart/events-container/
		 *         Alternatively, attach event to container
		 * @since 1.2.0
		 * @apioption chart.events.click
		 */


		/**
		 * Fires when the chart is finished loading. Since v4.2.2, it also waits
		 * for images to be loaded, for example from point markers. One parameter,
		 * `event`, is passed to the function, containing common event information.
		 * 
		 * There is also a second parameter to the chart constructor where a
		 * callback function can be passed to be executed on chart.load.
		 * 
		 * @type {Function}
		 * @context Chart
		 * @sample {highcharts} highcharts/chart/events-load/
		 *         Alert on chart load
		 * @sample {highstock} stock/chart/events-load/
		 *         Alert on chart load
		 * @sample {highmaps} maps/chart/events-load/
		 *         Add series on chart load
		 * @apioption chart.events.load
		 */

		/**
		 * Fires when the chart is redrawn, either after a call to chart.redraw()
		 * or after an axis, series or point is modified with the `redraw` option
		 * set to true. One parameter, `event`, is passed to the function, containing common event information.
		 * 
		 * @type {Function}
		 * @context Chart
		 * @sample {highcharts} highcharts/chart/events-redraw/
		 *         Alert on chart redraw
		 * @sample {highstock} stock/chart/events-redraw/
		 *         Alert on chart redraw when adding a series or moving the
		 *         zoomed range
		 * @sample {highmaps} maps/chart/events-redraw/
		 *         Set subtitle on chart redraw
		 * @since 1.2.0
		 * @apioption chart.events.redraw
		 */

		/**
		 * Fires after initial load of the chart (directly after the `load`
		 * event), and after each redraw (directly after the `redraw` event).
		 * 
		 * @type {Function}
		 * @context Chart
		 * @since 5.0.7
		 * @apioption chart.events.render
		 */

		/**
		 * Fires when an area of the chart has been selected. Selection is enabled
		 * by setting the chart's zoomType. One parameter, `event`, is passed
		 * to the function, containing common event information. The default action for the selection event is to
		 * zoom the chart to the selected area. It can be prevented by calling
		 * `event.preventDefault()`.
		 * 
		 * Information on the selected area can be found through `event.xAxis`
		 * and `event.yAxis`, which are arrays containing the axes of each dimension
		 * and each axis' min and max values. The primary axes are `event.xAxis[0]`
		 * and `event.yAxis[0]`. Remember the unit of a datetime axis is milliseconds
		 * since 1970-01-01 00:00:00.
		 * 
		 * <pre>selection: function(event) {
		 *     // log the min and max of the primary, datetime x-axis
		 *     console.log(
		 *         Highcharts.dateFormat('%Y-%m-%d %H:%M:%S', event.xAxis[0].min),
		 *         Highcharts.dateFormat('%Y-%m-%d %H:%M:%S', event.xAxis[0].max)
		 *     );
		 *     // log the min and max of the y axis
		 *     console.log(event.yAxis[0].min, event.yAxis[0].max);
		 * }</pre>
		 * 
		 * @type {Function}
		 * @sample {highcharts} highcharts/chart/events-selection/
		 *         Report on selection and reset
		 * @sample {highcharts} highcharts/chart/events-selection-points/
		 *         Select a range of points through a drag selection
		 * @sample {highstock} stock/chart/events-selection/
		 *         Report on selection and reset
		 * @sample {highstock} highcharts/chart/events-selection-points/
		 *         Select a range of points through a drag selection (Highcharts)
		 * @apioption chart.events.selection
		 */
		
		/**
		 * The margin between the outer edge of the chart and the plot area.
		 * The numbers in the array designate top, right, bottom and left
		 * respectively. Use the options `marginTop`, `marginRight`,
		 * `marginBottom` and `marginLeft` for shorthand setting of one option.
		 * 
		 * By default there is no margin. The actual space is dynamically calculated
		 * from the offset of axis labels, axis title, title, subtitle and legend
		 * in addition to the `spacingTop`, `spacingRight`, `spacingBottom`
		 * and `spacingLeft` options.
		 * 
		 * @type {Array}
		 * @sample {highcharts} highcharts/chart/margins-zero/
		 *         Zero margins
		 * @sample {highstock} stock/chart/margin-zero/
		 *         Zero margins
		 *
		 * @defaults {all} null
		 * @apioption chart.margin
		 */

		/**
		 * The margin between the bottom outer edge of the chart and the plot
		 * area. Use this to set a fixed pixel value for the margin as opposed
		 * to the default dynamic margin. See also `spacingBottom`.
		 * 
		 * @type {Number}
		 * @sample {highcharts} highcharts/chart/marginbottom/
		 *         100px bottom margin
		 * @sample {highstock} stock/chart/marginbottom/
		 *         100px bottom margin
		 * @sample {highmaps} maps/chart/margin/
		 *         100px margins
		 * @since 2.0
		 * @apioption chart.marginBottom
		 */

		/**
		 * The margin between the left outer edge of the chart and the plot
		 * area. Use this to set a fixed pixel value for the margin as opposed
		 * to the default dynamic margin. See also `spacingLeft`.
		 * 
		 * @type {Number}
		 * @sample {highcharts} highcharts/chart/marginleft/
		 *         150px left margin
		 * @sample {highstock} stock/chart/marginleft/
		 *         150px left margin
		 * @sample {highmaps} maps/chart/margin/
		 *         100px margins
		 * @default null
		 * @since 2.0
		 * @apioption chart.marginLeft
		 */

		/**
		 * The margin between the right outer edge of the chart and the plot
		 * area. Use this to set a fixed pixel value for the margin as opposed
		 * to the default dynamic margin. See also `spacingRight`.
		 * 
		 * @type {Number}
		 * @sample {highcharts} highcharts/chart/marginright/
		 *         100px right margin
		 * @sample {highstock} stock/chart/marginright/
		 *         100px right margin
		 * @sample {highmaps} maps/chart/margin/
		 *         100px margins
		 * @default null
		 * @since 2.0
		 * @apioption chart.marginRight
		 */

		/**
		 * The margin between the top outer edge of the chart and the plot area.
		 * Use this to set a fixed pixel value for the margin as opposed to
		 * the default dynamic margin. See also `spacingTop`.
		 * 
		 * @type {Number}
		 * @sample {highcharts} highcharts/chart/margintop/ 100px top margin
		 * @sample {highstock} stock/chart/margintop/
		 *         100px top margin
		 * @sample {highmaps} maps/chart/margin/
		 *         100px margins
		 * @default null
		 * @since 2.0
		 * @apioption chart.marginTop
		 */
		
		/**
		 * Allows setting a key to switch between zooming and panning. Can be
		 * one of `alt`, `ctrl`, `meta` (the command key on Mac and Windows
		 * key on Windows) or `shift`. The keys are mapped directly to the key
		 * properties of the click event argument (`event.altKey`, `event.ctrlKey`,
		 * `event.metaKey` and `event.shiftKey`).
		 * 
		 * @validvalue [null, "alt", "ctrl", "meta", "shift"]
		 * @type {String}
		 * @since 4.0.3
		 * @product highcharts
		 * @apioption chart.panKey
		 */

		/**
		 * Allow panning in a chart. Best used with [panKey](#chart.panKey)
		 * to combine zooming and panning.
		 * 
		 * On touch devices, when the [tooltip.followTouchMove](#tooltip.followTouchMove)
		 * option is `true` (default), panning requires two fingers. To allow
		 * panning with one finger, set `followTouchMove` to `false`.
		 * 
		 * @type {Boolean}
		 * @sample {highcharts} highcharts/chart/pankey/ Zooming and panning
		 * @default {highcharts} false
		 * @default {highstock} true
		 * @since 4.0.3
		 * @product highcharts highstock
		 * @apioption chart.panning
		 */
		

		/**
		 * Equivalent to [zoomType](#chart.zoomType), but for multitouch gestures
		 * only. By default, the `pinchType` is the same as the `zoomType` setting.
		 * However, pinching can be enabled separately in some cases, for example
		 * in stock charts where a mouse drag pans the chart, while pinching
		 * is enabled. When [tooltip.followTouchMove](#tooltip.followTouchMove)
		 * is true, pinchType only applies to two-finger touches.
		 * 
		 * @validvalue ["x", "y", "xy"]
		 * @type {String}
		 * @default {highcharts} null
		 * @default {highstock} x
		 * @since 3.0
		 * @product highcharts highstock
		 * @apioption chart.pinchType
		 */

		/**
		 * The corner radius of the outer chart border.
		 * 
		 * @type {Number}
		 * @sample {highcharts} highcharts/chart/borderradius/ 20px radius
		 * @sample {highstock} stock/chart/border/ 10px radius
		 * @sample {highmaps} maps/chart/border/ Border options
		 * @default 0
		 */
		borderRadius: 0,
		

		/**
		 * Alias of `type`.
		 * 
		 * @validvalue ["line", "spline", "column", "area", "areaspline", "pie"]
		 * @type {String}
		 * @deprecated
		 * @sample {highcharts} highcharts/chart/defaultseriestype/ Bar
		 * @default line
		 * @product highcharts
		 */
		defaultSeriesType: 'line',

		/**
		 * If true, the axes will scale to the remaining visible series once
		 * one series is hidden. If false, hiding and showing a series will
		 * not affect the axes or the other series. For stacks, once one series
		 * within the stack is hidden, the rest of the stack will close in
		 * around it even if the axis is not affected.
		 * 
		 * @type {Boolean}
		 * @sample {highcharts} highcharts/chart/ignorehiddenseries-true/
		 *         True by default
		 * @sample {highcharts} highcharts/chart/ignorehiddenseries-false/
		 *         False
		 * @sample {highcharts} highcharts/chart/ignorehiddenseries-true-stacked/
		 *         True with stack
		 * @sample {highstock} stock/chart/ignorehiddenseries-true/
		 *         True by default
		 * @sample {highstock} stock/chart/ignorehiddenseries-false/
		 *         False
		 * @default true
		 * @since 1.2.0
		 * @product highcharts highstock
		 */
		ignoreHiddenSeries: true,
		

		/**
		 * Whether to invert the axes so that the x axis is vertical and y axis
		 * is horizontal. When `true`, the x axis is [reversed](#xAxis.reversed)
		 * by default.
		 *
		 * @productdesc {highcharts}
		 * If a bar series is present in the chart, it will be inverted
		 * automatically. Inverting the chart doesn't have an effect if there
		 * are no cartesian series in the chart, or if the chart is
		 * [polar](#chart.polar).
		 * 
		 * @type {Boolean}
		 * @sample {highcharts} highcharts/chart/inverted/
		 *         Inverted line
		 * @sample {highstock} stock/navigator/inverted/
		 *         Inverted stock chart
		 * @default false
		 * @product highcharts highstock
		 * @apioption chart.inverted
		 */

		/**
		 * The distance between the outer edge of the chart and the content,
		 * like title or legend, or axis title and labels if present. The
		 * numbers in the array designate top, right, bottom and left respectively.
		 * Use the options spacingTop, spacingRight, spacingBottom and spacingLeft
		 * options for shorthand setting of one option.
		 * 
		 * @type {Array<Number>}
		 * @see [chart.margin](#chart.margin)
		 * @default [10, 10, 15, 10]
		 * @since 3.0.6
		 */
		spacing: [10, 10, 15, 10],

		/**
		 * The button that appears after a selection zoom, allowing the user
		 * to reset zoom.
		 *
		 */
		resetZoomButton: {

			/**
			 * A collection of attributes for the button. The object takes SVG
			 * attributes like `fill`, `stroke`, `stroke-width` or `r`, the border
			 * radius. The theme also supports `style`, a collection of CSS properties
			 * for the text. Equivalent attributes for the hover state are given
			 * in `theme.states.hover`.
			 * 
			 * @type {Object}
			 * @sample {highcharts} highcharts/chart/resetzoombutton-theme/
			 *         Theming the button
			 * @sample {highstock} highcharts/chart/resetzoombutton-theme/
			 *         Theming the button
			 * @since 2.2
			 */
			theme: {

				/**
				 * The Z index for the reset zoom button. The default value 
				 * places it below the tooltip that has Z index 7.
				 */
				zIndex: 6
			},

			/**
			 * The position of the button.
			 * 
			 * @type {Object}
			 * @sample {highcharts} highcharts/chart/resetzoombutton-position/
			 *         Above the plot area
			 * @sample {highstock} highcharts/chart/resetzoombutton-position/
			 *         Above the plot area
			 * @sample {highmaps} highcharts/chart/resetzoombutton-position/
			 *         Above the plot area
			 * @since 2.2
			 */
			position: {

				/**
				 * The horizontal alignment of the button.
				 * 
				 * @type {String}
				 */
				align: 'right',

				/**
				 * The horizontal offset of the button.
				 * 
				 * @type {Number}
				 */
				x: -10,

				/**
				 * The vertical alignment of the button.
				 * 
				 * @validvalue ["top", "middle", "bottom"]
				 * @type {String}
				 * @default top
				 * @apioption chart.resetZoomButton.position.verticalAlign
				 */

				/**
				 * The vertical offset of the button.
				 * 
				 * @type {Number}
				 */
				y: 10
			}
			
			/**
			 * What frame the button should be placed related to. Can be either
			 * `plot` or `chart`
			 * 
			 * @validvalue ["plot", "chart"]
			 * @type {String}
			 * @sample {highcharts} highcharts/chart/resetzoombutton-relativeto/
			 *         Relative to the chart
			 * @sample {highstock} highcharts/chart/resetzoombutton-relativeto/
			 *         Relative to the chart
			 * @default plot
			 * @since 2.2
			 * @apioption chart.resetZoomButton.relativeTo
			 */
		},

		/**
		 * An explicit width for the chart. By default (when `null`) the width
		 * is calculated from the offset width of the containing element.
		 * 
		 * @type {Number}
		 * @sample {highcharts} highcharts/chart/width/ 800px wide
		 * @sample {highstock} stock/chart/width/ 800px wide
		 * @sample {highmaps} maps/chart/size/ Chart with explicit size
		 * @default null
		 */
		width: null,

		/**
		 * An explicit height for the chart. If a _number_, the height is
		 * given in pixels. If given a _percentage string_ (for example `'56%'`),
		 * the height is given as the percentage of the actual chart width.
		 * This allows for preserving the aspect ratio across responsive
		 * sizes.
		 * 
		 * By default (when `null`) the height is calculated from the offset
		 * height of the containing element, or 400 pixels if the containing
		 * element's height is 0.
		 * 
		 * @type {Number|String}
		 * @sample {highcharts} highcharts/chart/height/
		 *         500px height
		 * @sample {highstock} stock/chart/height/
		 *         300px height
		 * @sample {highmaps} maps/chart/size/
		 *         Chart with explicit size
		 * @sample highcharts/chart/height-percent/
		 *         Highcharts with percentage height
		 * @default null
		 */
		height: null,
		
		

		/**
		 * The color of the outer chart border.
		 * 
		 * @type {Color}
		 * @see In styled mode, the stroke is set with the `.highcharts-background`
		 * class.
		 * @sample {highcharts} highcharts/chart/bordercolor/ Brown border
		 * @sample {highstock} stock/chart/border/ Brown border
		 * @sample {highmaps} maps/chart/border/ Border options
		 * @default #335cad
		 */
		borderColor: '#335cad',
		
		/**
		 * The pixel width of the outer chart border.
		 * 
		 * @type {Number}
		 * @see In styled mode, the stroke is set with the `.highcharts-background`
		 * class.
		 * @sample {highcharts} highcharts/chart/borderwidth/ 5px border
		 * @sample {highstock} stock/chart/border/
		 *         2px border
		 * @sample {highmaps} maps/chart/border/
		 *         Border options
		 * @default 0
		 * @apioption chart.borderWidth
		 */

		/**
		 * The background color or gradient for the outer chart area.
		 * 
		 * @type {Color}
		 * @see In styled mode, the background is set with the `.highcharts-background` class.
		 * @sample {highcharts} highcharts/chart/backgroundcolor-color/ Color
		 * @sample {highcharts} highcharts/chart/backgroundcolor-gradient/ Gradient
		 * @sample {highstock} stock/chart/backgroundcolor-color/
		 *         Color
		 * @sample {highstock} stock/chart/backgroundcolor-gradient/
		 *         Gradient
		 * @sample {highmaps} maps/chart/backgroundcolor-color/
		 *         Color
		 * @sample {highmaps} maps/chart/backgroundcolor-gradient/
		 *         Gradient
		 * @default #FFFFFF
		 */
		backgroundColor: '#ffffff',
		
		/**
		 * The background color or gradient for the plot area.
		 * 
		 * @type {Color}
		 * @see In styled mode, the plot background is set with the `.highcharts-plot-background` class.
		 * @sample {highcharts} highcharts/chart/plotbackgroundcolor-color/
		 *         Color
		 * @sample {highcharts} highcharts/chart/plotbackgroundcolor-gradient/
		 *         Gradient
		 * @sample {highstock} stock/chart/plotbackgroundcolor-color/
		 *         Color
		 * @sample {highstock} stock/chart/plotbackgroundcolor-gradient/
		 *         Gradient
		 * @sample {highmaps} maps/chart/plotbackgroundcolor-color/
		 *         Color
		 * @sample {highmaps} maps/chart/plotbackgroundcolor-gradient/
		 *         Gradient
		 * @default null
		 * @apioption chart.plotBackgroundColor
		 */
				

		/**
		 * The URL for an image to use as the plot background. To set an image
		 * as the background for the entire chart, set a CSS background image
		 * to the container element. Note that for the image to be applied to
		 * exported charts, its URL needs to be accessible by the export server.
		 * 
		 * @type {String}
		 * @see In styled mode, a plot background image can be set with the
		 * `.highcharts-plot-background` class and a [custom pattern](http://www.
		 * highcharts.com/docs/chart-design-and-style/gradients-shadows-and-
		 * patterns).
		 * @sample {highcharts} highcharts/chart/plotbackgroundimage/ Skies
		 * @sample {highstock} stock/chart/plotbackgroundimage/ Skies
		 * @default null
		 * @apioption chart.plotBackgroundImage
		 */

		/**
		 * The color of the inner chart or plot area border.
		 * 
		 * @type {Color}
		 * @see In styled mode, a plot border stroke can be set with the `.
		 * highcharts-plot-border` class.
		 * @sample {highcharts} highcharts/chart/plotbordercolor/ Blue border
		 * @sample {highstock} stock/chart/plotborder/ Blue border
		 * @sample {highmaps} maps/chart/plotborder/ Plot border options
		 * @default #cccccc
		 */
		plotBorderColor: '#cccccc'
		

		/**
		 * The pixel width of the plot area border.
		 * 
		 * @type {Number}
		 * @sample {highcharts} highcharts/chart/plotborderwidth/ 1px border
		 * @sample {highstock} stock/chart/plotborder/
		 *         2px border
		 * @sample {highmaps} maps/chart/plotborder/
		 *         Plot border options
		 * @default 0
		 * @apioption chart.plotBorderWidth
		 */

		/**
		 * Whether to apply a drop shadow to the plot area. Requires that
		 * plotBackgroundColor be set. The shadow can be an object configuration
		 * containing `color`, `offsetX`, `offsetY`, `opacity` and `width`.
		 * 
		 * @type {Boolean|Object}
		 * @sample {highcharts} highcharts/chart/plotshadow/ Plot shadow
		 * @sample {highstock} stock/chart/plotshadow/
		 *         Plot shadow
		 * @sample {highmaps} maps/chart/plotborder/
		 *         Plot border options
		 * @default false
		 * @apioption chart.plotShadow
		 */

		/**
		 * When true, cartesian charts like line, spline, area and column are
		 * transformed into the polar coordinate system. Requires `highcharts-
		 * more.js`.
		 * 
		 * @type {Boolean}
		 * @default false
		 * @since 2.3.0
		 * @product highcharts
		 * @apioption chart.polar
		 */

		/**
		 * Whether to reflow the chart to fit the width of the container div
		 * on resizing the window.
		 * 
		 * @type {Boolean}
		 * @sample {highcharts} highcharts/chart/reflow-true/ True by default
		 * @sample {highcharts} highcharts/chart/reflow-false/ False
		 * @sample {highstock} stock/chart/reflow-true/
		 *         True by default
		 * @sample {highstock} stock/chart/reflow-false/
		 *         False
		 * @sample {highmaps} maps/chart/reflow-true/
		 *         True by default
		 * @sample {highmaps} maps/chart/reflow-false/
		 *         False
		 * @default true
		 * @since 2.1
		 * @apioption chart.reflow
		 */
		



		/**
		 * The HTML element where the chart will be rendered. If it is a string,
		 * the element by that id is used. The HTML element can also be passed
		 * by direct reference, or as the first argument of the chart constructor,
		 *  in which case the option is not needed.
		 * 
		 * @type {String|Object}
		 * @sample {highcharts} highcharts/chart/reflow-true/
		 *         String
		 * @sample {highcharts} highcharts/chart/renderto-object/
		 *         Object reference
		 * @sample {highcharts} highcharts/chart/renderto-jquery/
		 *         Object reference through jQuery
		 * @sample {highstock} stock/chart/renderto-string/
		 *         String
		 * @sample {highstock} stock/chart/renderto-object/
		 *         Object reference
		 * @sample {highstock} stock/chart/renderto-jquery/
		 *         Object reference through jQuery
		 * @apioption chart.renderTo
		 */

		/**
		 * The background color of the marker square when selecting (zooming
		 * in on) an area of the chart.
		 * 
		 * @type {Color}
		 * @see In styled mode, the selection marker fill is set with the
		 * `.highcharts-selection-marker` class.
		 * @default rgba(51,92,173,0.25)
		 * @since 2.1.7
		 * @apioption chart.selectionMarkerFill
		 */

		/**
		 * Whether to apply a drop shadow to the outer chart area. Requires
		 * that backgroundColor be set. The shadow can be an object configuration
		 * containing `color`, `offsetX`, `offsetY`, `opacity` and `width`.
		 * 
		 * @type {Boolean|Object}
		 * @sample {highcharts} highcharts/chart/shadow/ Shadow
		 * @sample {highstock} stock/chart/shadow/
		 *         Shadow
		 * @sample {highmaps} maps/chart/border/
		 *         Chart border and shadow
		 * @default false
		 * @apioption chart.shadow
		 */

		/**
		 * Whether to show the axes initially. This only applies to empty charts
		 * where series are added dynamically, as axes are automatically added
		 * to cartesian series.
		 * 
		 * @type {Boolean}
		 * @sample {highcharts} highcharts/chart/showaxes-false/ False by default
		 * @sample {highcharts} highcharts/chart/showaxes-true/ True
		 * @since 1.2.5
		 * @product highcharts
		 * @apioption chart.showAxes
		 */

		/**
		 * The space between the bottom edge of the chart and the content (plot
		 * area, axis title and labels, title, subtitle or legend in top position).
		 * 
		 * @type {Number}
		 * @sample {highcharts} highcharts/chart/spacingbottom/
		 *         Spacing bottom set to 100
		 * @sample {highstock} stock/chart/spacingbottom/
		 *         Spacing bottom set to 100
		 * @sample {highmaps} maps/chart/spacing/
		 *         Spacing 100 all around
		 * @default 15
		 * @since 2.1
		 * @apioption chart.spacingBottom
		 */

		/**
		 * The space between the left edge of the chart and the content (plot
		 * area, axis title and labels, title, subtitle or legend in top position).
		 * 
		 * @type {Number}
		 * @sample {highcharts} highcharts/chart/spacingleft/
		 *         Spacing left set to 100
		 * @sample {highstock} stock/chart/spacingleft/
		 *         Spacing left set to 100
		 * @sample {highmaps} maps/chart/spacing/
		 *         Spacing 100 all around
		 * @default 10
		 * @since 2.1
		 * @apioption chart.spacingLeft
		 */

		/**
		 * The space between the right edge of the chart and the content (plot
		 * area, axis title and labels, title, subtitle or legend in top
		 * position).
		 * 
		 * @type {Number}
		 * @sample {highcharts} highcharts/chart/spacingright-100/
		 *         Spacing set to 100
		 * @sample {highcharts} highcharts/chart/spacingright-legend/
		 *         Legend in right position with default spacing
		 * @sample {highstock} stock/chart/spacingright/
		 *         Spacing set to 100
		 * @sample {highmaps} maps/chart/spacing/
		 *         Spacing 100 all around
		 * @default 10
		 * @since 2.1
		 * @apioption chart.spacingRight
		 */

		/**
		 * The space between the top edge of the chart and the content (plot
		 * area, axis title and labels, title, subtitle or legend in top
		 * position).
		 * 
		 * @type {Number}
		 * @sample {highcharts} highcharts/chart/spacingtop-100/
		 *         A top spacing of 100
		 * @sample {highcharts} highcharts/chart/spacingtop-10/
		 *         Floating chart title makes the plot area align to the default
		 *         spacingTop of 10.
		 * @sample {highstock} stock/chart/spacingtop/
		 *         A top spacing of 100
		 * @sample {highmaps} maps/chart/spacing/
		 *         Spacing 100 all around
		 * @default 10
		 * @since 2.1
		 * @apioption chart.spacingTop
		 */

		/**
		 * Additional CSS styles to apply inline to the container `div`. Note
		 * that since the default font styles are applied in the renderer, it
		 * is ignorant of the individual chart options and must be set globally.
		 * 
		 * @type {CSSObject}
		 * @see In styled mode, general chart styles can be set with the `.highcharts-root` class.
		 * @sample {highcharts} highcharts/chart/style-serif-font/
		 *         Using a serif type font
		 * @sample {highcharts} highcharts/css/em/
		 *         Styled mode with relative font sizes
		 * @sample {highstock} stock/chart/style/
		 *         Using a serif type font
		 * @sample {highmaps} maps/chart/style-serif-font/
		 *         Using a serif type font
		 * @default {"fontFamily":"\"Lucida Grande\", \"Lucida Sans Unicode\", Verdana, Arial, Helvetica, sans-serif","fontSize":"12px"}
		 * @apioption chart.style
		 */

		/**
		 * The default series type for the chart. Can be any of the chart types
		 * listed under [plotOptions](#plotOptions).
		 * 
		 * @validvalue ["line", "spline", "column", "bar", "area", "areaspline", "pie", "arearange", "areasplinerange", "boxplot", "bubble", "columnrange", "errorbar", "funnel", "gauge", "heatmap", "polygon", "pyramid", "scatter", "solidgauge", "treemap", "waterfall"]
		 * @type {String}
		 * @sample {highcharts} highcharts/chart/type-bar/ Bar
		 * @sample {highstock} stock/chart/type/
		 *         Areaspline
		 * @sample {highmaps} maps/chart/type-mapline/
		 *         Mapline
		 * @default {highcharts} line
		 * @default {highstock} line
		 * @default {highmaps} map
		 * @since 2.1.0
		 * @apioption chart.type
		 */
		
		/**
		 * Decides in what dimensions the user can zoom by dragging the mouse.
		 * Can be one of `x`, `y` or `xy`.
		 * 
		 * @validvalue [null, "x", "y", "xy"]
		 * @type {String}
		 * @see [panKey](#chart.panKey)
		 * @sample {highcharts} highcharts/chart/zoomtype-none/ None by default
		 * @sample {highcharts} highcharts/chart/zoomtype-x/ X
		 * @sample {highcharts} highcharts/chart/zoomtype-y/ Y
		 * @sample {highcharts} highcharts/chart/zoomtype-xy/ Xy
		 * @sample {highstock} stock/demo/basic-line/ None by default
		 * @sample {highstock} stock/chart/zoomtype-x/ X
		 * @sample {highstock} stock/chart/zoomtype-y/ Y
		 * @sample {highstock} stock/chart/zoomtype-xy/ Xy
		 * @product highcharts highstock
		 * @apioption chart.zoomType
		 */
	},

	/**
	 * The chart's main title.
	 * 
	 * @sample {highmaps} maps/title/title/ Title options demonstrated
	 */
	title: {

		/**
		 * The title of the chart. To disable the title, set the `text` to
		 * `null`.
		 * 
		 * @type {String}
		 * @sample {highcharts} highcharts/title/text/ Custom title
		 * @sample {highstock} stock/chart/title-text/ Custom title
		 * @default {highcharts|highmaps} Chart title
		 * @default {highstock} null
		 */
		text: 'Chart title',

		/**
		 * The horizontal alignment of the title. Can be one of "left", "center"
		 * and "right".
		 * 
		 * @validvalue ["left", "center", "right"]
		 * @type {String}
		 * @sample {highcharts} highcharts/title/align/ Aligned to the plot area (x = 70px     = margin left - spacing left)
		 * @sample {highstock} stock/chart/title-align/ Aligned to the plot area (x = 50px     = margin left - spacing left)
		 * @default center
		 * @since 2.0
		 */
		align: 'center',

		/**
		 * The margin between the title and the plot area, or if a subtitle
		 * is present, the margin between the subtitle and the plot area.
		 * 
		 * @type {Number}
		 * @sample {highcharts} highcharts/title/margin-50/ A chart title margin of 50
		 * @sample {highcharts} highcharts/title/margin-subtitle/ The same margin applied with a subtitle
		 * @sample {highstock} stock/chart/title-margin/ A chart title margin of 50
		 * @default 15
		 * @since 2.1
		 */
		margin: 15,

		/**
		 * Adjustment made to the title width, normally to reserve space for
		 * the exporting burger menu.
		 * 
		 * @type {Number}
		 * @sample {highcharts} highcharts/title/widthadjust/ Wider menu, greater padding
		 * @sample {highstock} highcharts/title/widthadjust/ Wider menu, greater padding
		 * @sample {highmaps} highcharts/title/widthadjust/ Wider menu, greater padding
		 * @default -44
		 * @since 4.2.5
		 */
		widthAdjust: -44

		/**
		 * When the title is floating, the plot area will not move to make space
		 * for it.
		 * 
		 * @type {Boolean}
		 * @sample {highcharts} highcharts/chart/zoomtype-none/ False by default
		 * @sample {highcharts} highcharts/title/floating/
		 *         True - title on top of the plot area
		 * @sample {highstock} stock/chart/title-floating/
		 *         True - title on top of the plot area
		 * @default false
		 * @since 2.1
		 * @apioption title.floating
		 */

		/**
		 * CSS styles for the title. Use this for font styling, but use `align`,
		 * `x` and `y` for text alignment.
		 * 
		 * In styled mode, the title style is given in the `.highcharts-title` class.
		 * 
		 * @type {CSSObject}
		 * @sample {highcharts} highcharts/title/style/ Custom color and weight
		 * @sample {highstock} stock/chart/title-style/ Custom color and weight
		 * @sample highcharts/css/titles/ Styled mode
		 * @default {highcharts|highmaps} { "color": "#333333", "fontSize": "18px" }
		 * @default {highstock} { "color": "#333333", "fontSize": "16px" }
		 * @apioption title.style
		 */

		/**
		 * Whether to [use HTML](http://www.highcharts.com/docs/chart-concepts/labels-
		 * and-string-formatting#html) to render the text.
		 * 
		 * @type {Boolean}
		 * @default false
		 * @apioption title.useHTML
		 */

		/**
		 * The vertical alignment of the title. Can be one of `"top"`, `"middle"`
		 * and `"bottom"`. When a value is given, the title behaves as if [floating](#title.
		 * floating) were `true`.
		 * 
		 * @validvalue ["top", "middle", "bottom"]
		 * @type {String}
		 * @sample {highcharts} highcharts/title/verticalalign/
		 *         Chart title in bottom right corner
		 * @sample {highstock} stock/chart/title-verticalalign/
		 *         Chart title in bottom right corner
		 * @since 2.1
		 * @apioption title.verticalAlign
		 */

		/**
		 * The x position of the title relative to the alignment within chart.
		 * spacingLeft and chart.spacingRight.
		 * 
		 * @type {Number}
		 * @sample {highcharts} highcharts/title/align/
		 *         Aligned to the plot area (x = 70px = margin left - spacing left)
		 * @sample {highstock} stock/chart/title-align/
		 *         Aligned to the plot area (x = 50px = margin left - spacing left)
		 * @default 0
		 * @since 2.0
		 * @apioption title.x
		 */

		/**
		 * The y position of the title relative to the alignment within [chart.
		 * spacingTop](#chart.spacingTop) and [chart.spacingBottom](#chart.spacingBottom).
		 *  By default it depends on the font size.
		 * 
		 * @type {Number}
		 * @sample {highcharts} highcharts/title/y/
		 *         Title inside the plot area
		 * @sample {highstock} stock/chart/title-verticalalign/
		 *         Chart title in bottom right corner
		 * @since 2.0
		 * @apioption title.y
		 */

	},

	/**
	 * The chart's subtitle. This can be used both to display a subtitle below
	 * the main title, and to display random text anywhere in the chart. The
	 * subtitle can be updated after chart initialization through the 
	 * `Chart.setTitle` method.
	 * 
	 * @sample {highmaps} maps/title/subtitle/ Subtitle options demonstrated
	 */
	subtitle: {

		/**
		 * The subtitle of the chart.
		 * 
		 * @type {String}
		 * @sample {highcharts} highcharts/subtitle/text/ Custom subtitle
		 * @sample {highcharts} highcharts/subtitle/text-formatted/ Formatted and linked text.
		 * @sample {highstock} stock/chart/subtitle-text Custom subtitle
		 * @sample {highstock} stock/chart/subtitle-text-formatted Formatted and linked text.
		 */
		text: '',

		/**
		 * The horizontal alignment of the subtitle. Can be one of "left",
		 *  "center" and "right".
		 * 
		 * @validvalue ["left", "center", "right"]
		 * @type {String}
		 * @sample {highcharts} highcharts/subtitle/align/ Footnote at right of plot area
		 * @sample {highstock} stock/chart/subtitle-footnote Footnote at bottom right of plot area
		 * @default center
		 * @since 2.0
		 */
		align: 'center',

		/**
		 * Adjustment made to the subtitle width, normally to reserve space
		 * for the exporting burger menu.
		 * 
		 * @type {Number}
		 * @see [title.widthAdjust](#title.widthAdjust)
		 * @sample {highcharts} highcharts/title/widthadjust/ Wider menu, greater padding
		 * @sample {highstock} highcharts/title/widthadjust/ Wider menu, greater padding
		 * @sample {highmaps} highcharts/title/widthadjust/ Wider menu, greater padding
		 * @default -44
		 * @since 4.2.5
		 */
		widthAdjust: -44

		/**
		 * When the subtitle is floating, the plot area will not move to make
		 * space for it.
		 * 
		 * @type {Boolean}
		 * @sample {highcharts} highcharts/subtitle/floating/
		 *         Floating title and subtitle
		 * @sample {highstock} stock/chart/subtitle-footnote
		 *         Footnote floating at bottom right of plot area
		 * @default false
		 * @since 2.1
		 * @apioption subtitle.floating
		 */

		/**
		 * CSS styles for the title.
		 * 
		 * In styled mode, the subtitle style is given in the `.highcharts-subtitle` class.
		 * 
		 * @type {CSSObject}
		 * @sample {highcharts} highcharts/subtitle/style/
		 *         Custom color and weight
		 * @sample {highcharts} highcharts/css/titles/
		 *         Styled mode
		 * @sample {highstock} stock/chart/subtitle-style
		 *         Custom color and weight
		 * @sample {highstock} highcharts/css/titles/
		 *         Styled mode
		 * @sample {highmaps} highcharts/css/titles/
		 *         Styled mode
		 * @default { "color": "#666666" }
		 * @apioption subtitle.style
		 */

		/**
		 * Whether to [use HTML](http://www.highcharts.com/docs/chart-concepts/labels-
		 * and-string-formatting#html) to render the text.
		 * 
		 * @type {Boolean}
		 * @default false
		 * @apioption subtitle.useHTML
		 */

		/**
		 * The vertical alignment of the title. Can be one of "top", "middle"
		 * and "bottom". When a value is given, the title behaves as floating.
		 * 
		 * @validvalue ["top", "middle", "bottom"]
		 * @type {String}
		 * @sample {highcharts} highcharts/subtitle/verticalalign/
		 *         Footnote at the bottom right of plot area
		 * @sample {highstock} stock/chart/subtitle-footnote
		 *         Footnote at the bottom right of plot area
		 * @default  
		 * @since 2.1
		 * @apioption subtitle.verticalAlign
		 */

		/**
		 * The x position of the subtitle relative to the alignment within chart.
		 * spacingLeft and chart.spacingRight.
		 * 
		 * @type {Number}
		 * @sample {highcharts} highcharts/subtitle/align/
		 *         Footnote at right of plot area
		 * @sample {highstock} stock/chart/subtitle-footnote
		 *         Footnote at the bottom right of plot area
		 * @default 0
		 * @since 2.0
		 * @apioption subtitle.x
		 */

		/**
		 * The y position of the subtitle relative to the alignment within chart.
		 * spacingTop and chart.spacingBottom. By default the subtitle is laid
		 * out below the title unless the title is floating.
		 * 
		 * @type {Number}
		 * @sample {highcharts} highcharts/subtitle/verticalalign/
		 *         Footnote at the bottom right of plot area
		 * @sample {highstock} stock/chart/subtitle-footnote
		 *         Footnote at the bottom right of plot area
		 * @default {highcharts}  null
		 * @default {highstock}  null
		 * @default {highmaps}  
		 * @since 2.0
		 * @apioption subtitle.y
		 */
	},

	/**
	 * The plotOptions is a wrapper object for config objects for each series
	 * type. The config objects for each series can also be overridden for
	 * each series item as given in the series array.
	 * 
	 * Configuration options for the series are given in three levels. Options
	 * for all series in a chart are given in the [plotOptions.series](#plotOptions.
	 * series) object. Then options for all series of a specific type are
	 * given in the plotOptions of that type, for example plotOptions.line.
	 * Next, options for one single series are given in [the series array](#series).
	 *
	 */
	plotOptions: {},

	/**
	 * HTML labels that can be positioned anywhere in the chart area.
	 *
	 */
	labels: {

		/**
		 * A HTML label that can be positioned anywhere in the chart area.
		 * 
		 * @type {Array<Object>}
		 * @apioption labels.items
		 */
		
		/**
		 * Inner HTML or text for the label.
		 * 
		 * @type {String}
		 * @apioption labels.items.html
		 */
		
		/**
		 * CSS styles for each label. To position the label, use left and top
		 * like this:
		 * 
		 * <pre>style: {
		 *     left: '100px',
		 *     top: '100px'
		 * }</pre>
		 * 
		 * @type {CSSObject}
		 * @apioption labels.items.style
		 */

		/**
		 * Shared CSS styles for all labels.
		 * 
		 * @type {CSSObject}
		 * @default { "color": "#333333" }
		 */
		style: {
			position: 'absolute',
			color: '#333333'
		}
	},

	/**
	 * The legend is a box containing a symbol and name for each series
	 * item or point item in the chart. Each series (or points in case
	 * of pie charts) is represented by a symbol and its name in the legend.
	 *  
	 * It is possible to override the symbol creator function and
	 * create [custom legend symbols](http://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/studies/legend-
	 * custom-symbol/).
	 * 
	 * @productdesc {highmaps}
	 * A Highmaps legend by default contains one legend item per series, but if
	 * a `colorAxis` is defined, the axis will be displayed in the legend.
	 * Either as a gradient, or as multiple legend items for `dataClasses`.
	 */
	legend: {

		/**
		 * The background color of the legend.
		 * 
		 * @type {Color}
		 * @see In styled mode, the legend background fill can be applied with
		 * the `.highcharts-legend-box` class.
		 * @sample {highcharts} highcharts/legend/backgroundcolor/ Yellowish background
		 * @sample {highstock} stock/legend/align/ Various legend options
		 * @sample {highmaps} maps/legend/border-background/ Border and background options
		 * @apioption legend.backgroundColor
		 */

		/**
		 * The width of the drawn border around the legend.
		 * 
		 * @type {Number}
		 * @see In styled mode, the legend border stroke width can be applied
		 * with the `.highcharts-legend-box` class.
		 * @sample {highcharts} highcharts/legend/borderwidth/ 2px border width
		 * @sample {highstock} stock/legend/align/ Various legend options
		 * @sample {highmaps} maps/legend/border-background/ Border and background options
		 * @default 0
		 * @apioption legend.borderWidth
		 */
		
		/**
		 * Enable or disable the legend.
		 * 
		 * @type {Boolean}
		 * @sample {highcharts} highcharts/legend/enabled-false/ Legend disabled
		 * @sample {highstock} stock/legend/align/ Various legend options
		 * @sample {highmaps} maps/legend/enabled-false/ Legend disabled
		 * @default {highstock} false
		 * @default {highmaps} true
		 */
		enabled: true,

		/**
		 * The horizontal alignment of the legend box within the chart area.
		 * Valid values are `left`, `center` and `right`.
		 * 
		 * In the case that the legend is aligned in a corner position, the
		 * `layout` option will determine whether to place it above/below
		 * or on the side of the plot area.
		 * 
		 * @validvalue ["left", "center", "right"]
		 * @type {String}
		 * @sample {highcharts} highcharts/legend/align/
		 *         Legend at the right of the chart
		 * @sample {highstock} stock/legend/align/
		 *         Various legend options
		 * @sample {highmaps} maps/legend/alignment/
		 *         Legend alignment
		 * @since 2.0
		 */
		align: 'center',
		
		/**
		 * When the legend is floating, the plot area ignores it and is allowed
		 * to be placed below it.
		 * 
		 * @type {Boolean}
		 * @sample {highcharts} highcharts/legend/floating-false/ False by default
		 * @sample {highcharts} highcharts/legend/floating-true/ True
		 * @sample {highmaps} maps/legend/alignment/ Floating legend
		 * @default false
		 * @since 2.1
		 * @apioption legend.floating
		 */

		/**
		 * The layout of the legend items. Can be one of "horizontal" or "vertical".
		 * 
		 * @validvalue ["horizontal", "vertical"]
		 * @type {String}
		 * @sample {highcharts} highcharts/legend/layout-horizontal/ Horizontal by default
		 * @sample {highcharts} highcharts/legend/layout-vertical/ Vertical
		 * @sample {highstock} stock/legend/layout-horizontal/ Horizontal by default
		 * @sample {highmaps} maps/legend/padding-itemmargin/ Vertical with data classes
		 * @sample {highmaps} maps/legend/layout-vertical/ Vertical with color axis gradient
		 * @default horizontal
		 */
		layout: 'horizontal',

		/**
		 * In a legend with horizontal layout, the itemDistance defines the
		 * pixel distance between each item.
		 * 
		 * @type {Number}
		 * @sample {highcharts} highcharts/legend/layout-horizontal/ 50px item distance
		 * @sample {highstock} highcharts/legend/layout-horizontal/ 50px item distance
		 * @default {highcharts} 20
		 * @default {highstock} 20
		 * @default {highmaps} 8
		 * @since 3.0.3
		 * @apioption legend.itemDistance
		 */

		/**
		 * The pixel bottom margin for each legend item.
		 * 
		 * @type {Number}
		 * @sample {highcharts} highcharts/legend/padding-itemmargin/ Padding and item margins demonstrated
		 * @sample {highstock} highcharts/legend/padding-itemmargin/ Padding and item margins demonstrated
		 * @sample {highmaps} maps/legend/padding-itemmargin/ Padding and item margins demonstrated
		 * @default 0
		 * @since 2.2.0
		 * @apioption legend.itemMarginBottom
		 */

		/**
		 * The pixel top margin for each legend item.
		 * 
		 * @type {Number}
		 * @sample {highcharts} highcharts/legend/padding-itemmargin/ Padding and item margins demonstrated
		 * @sample {highstock} highcharts/legend/padding-itemmargin/ Padding and item margins demonstrated
		 * @sample {highmaps} maps/legend/padding-itemmargin/ Padding and item margins demonstrated
		 * @default 0
		 * @since 2.2.0
		 * @apioption legend.itemMarginTop
		 */

		/**
		 * The width for each legend item. This is useful in a horizontal layout
		 * with many items when you want the items to align vertically. .
		 * 
		 * @type {Number}
		 * @sample {highcharts} highcharts/legend/itemwidth-default/ Null by default
		 * @sample {highcharts} highcharts/legend/itemwidth-80/ 80 for aligned legend items
		 * @default null
		 * @since 2.0
		 * @apioption legend.itemWidth
		 */

		/**
		 * A [format string](http://www.highcharts.com/docs/chart-concepts/labels-
		 * and-string-formatting) for each legend label. Available variables
		 * relates to properties on the series, or the point in case of pies.
		 * 
		 * @type {String}
		 * @default {name}
		 * @since 1.3
		 * @apioption legend.labelFormat
		 */
		
		/**
		 * Callback function to format each of the series' labels. The `this`
		 * keyword refers to the series object, or the point object in case
		 * of pie charts. By default the series or point name is printed.
		 *
		 * @productdesc {highmaps}
		 *              In Highmaps the context can also be a data class in case
		 *              of a `colorAxis`.
		 * 
		 * @type {Function}
		 * @sample {highcharts} highcharts/legend/labelformatter/ Add text
		 * @sample {highmaps} maps/legend/labelformatter/ Data classes with label formatter
		 * @context {Series|Point}
		 */
		labelFormatter: function () {
			return this.name;
		},

		/**
		 * Line height for the legend items. Deprecated as of 2.1\. Instead,
		 * the line height for each item can be set using itemStyle.lineHeight,
		 * and the padding between items using itemMarginTop and itemMarginBottom.
		 * 
		 * @type {Number}
		 * @sample {highcharts} highcharts/legend/lineheight/ Setting padding
		 * @default 16
		 * @since 2.0
		 * @product highcharts
		 * @apioption legend.lineHeight
		 */

		/**
		 * If the plot area sized is calculated automatically and the legend
		 * is not floating, the legend margin is the space between the legend
		 * and the axis labels or plot area.
		 * 
		 * @type {Number}
		 * @sample {highcharts} highcharts/legend/margin-default/ 12 pixels by default
		 * @sample {highcharts} highcharts/legend/margin-30/ 30 pixels
		 * @default 12
		 * @since 2.1
		 * @apioption legend.margin
		 */

		/**
		 * Maximum pixel height for the legend. When the maximum height is extended,
		 *  navigation will show.
		 * 
		 * @type {Number}
		 * @default undefined
		 * @since 2.3.0
		 * @apioption legend.maxHeight
		 */

		/**
		 * The color of the drawn border around the legend.
		 * 
		 * @type {Color}
		 * @see In styled mode, the legend border stroke can be applied with
		 * the `.highcharts-legend-box` class.
		 * @sample {highcharts} highcharts/legend/bordercolor/ Brown border
		 * @sample {highstock} stock/legend/align/ Various legend options
		 * @sample {highmaps} maps/legend/border-background/ Border and background options
		 * @default #999999
		 */
		borderColor: '#999999',

		/**
		 * The border corner radius of the legend.
		 * 
		 * @type {Number}
		 * @sample {highcharts} highcharts/legend/borderradius-default/ Square by default
		 * @sample {highcharts} highcharts/legend/borderradius-round/ 5px rounded
		 * @sample {highmaps} maps/legend/border-background/ Border and background options
		 * @default 0
		 */
		borderRadius: 0,

		/**
		 * Options for the paging or navigation appearing when the legend
		 * is overflown. Navigation works well on screen, but not in static
		 * exported images. One way of working around that is to [increase
		 * the chart height in export](http://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/legend/navigation-
		 * enabled-false/).
		 *
		 */
		navigation: {
			

			/**
			 * The color for the active up or down arrow in the legend page navigation.
			 * 
			 * @type {Color}
			 * @see In styled mode, the active arrow be styled with the `.highcharts-legend-nav-active` class.
			 * @sample {highcharts} highcharts/legend/navigation/ Legend page navigation demonstrated
			 * @sample {highstock} highcharts/legend/navigation/ Legend page navigation demonstrated
			 * @default #003399
			 * @since 2.2.4
			 */
			activeColor: '#003399',

			/**
			 * The color of the inactive up or down arrow in the legend page
			 * navigation. .
			 * 
			 * @type {Color}
			 * @see In styled mode, the inactive arrow be styled with the
			 *      `.highcharts-legend-nav-inactive` class.
			 * @sample {highcharts} highcharts/legend/navigation/
			 *         Legend page navigation demonstrated
			 * @sample {highstock} highcharts/legend/navigation/
			 *         Legend page navigation demonstrated
			 * @default {highcharts} #cccccc
			 * @default {highstock} #cccccc
			 * @default {highmaps} ##cccccc
			 * @since 2.2.4
			 */
			inactiveColor: '#cccccc'
			

			/**
			 * How to animate the pages when navigating up or down. A value of `true`
			 * applies the default navigation given in the chart.animation option.
			 * Additional options can be given as an object containing values for
			 * easing and duration.
			 * 
			 * @type {Boolean|Object}
			 * @sample {highcharts} highcharts/legend/navigation/
			 *         Legend page navigation demonstrated
			 * @sample {highstock} highcharts/legend/navigation/
			 *         Legend page navigation demonstrated
			 * @default true
			 * @since 2.2.4
			 * @apioption legend.navigation.animation
			 */

			/**
			 * The pixel size of the up and down arrows in the legend paging
			 * navigation.
			 * 
			 * @type {Number}
			 * @sample {highcharts} highcharts/legend/navigation/
			 *         Legend page navigation demonstrated
			 * @sample {highstock} highcharts/legend/navigation/
			 *         Legend page navigation demonstrated
			 * @default 12
			 * @since 2.2.4
			 * @apioption legend.navigation.arrowSize
			 */

			/**
			 * Whether to enable the legend navigation. In most cases, disabling
			 * the navigation results in an unwanted overflow.
			 * 
			 * See also the [adapt chart to legend](http://www.highcharts.com/plugin-
			 * registry/single/8/Adapt-Chart-To-Legend) plugin for a solution to
			 * extend the chart height to make room for the legend, optionally in
			 * exported charts only.
			 * 
			 * @type {Boolean}
			 * @default true
			 * @since 4.2.4
			 * @apioption legend.navigation.enabled
			 */

			/**
			 * Text styles for the legend page navigation.
			 * 
			 * @type {CSSObject}
			 * @see In styled mode, the navigation items are styled with the
			 * `.highcharts-legend-navigation` class.
			 * @sample {highcharts} highcharts/legend/navigation/
			 *         Legend page navigation demonstrated
			 * @sample {highstock} highcharts/legend/navigation/
			 *         Legend page navigation demonstrated
			 * @since 2.2.4
			 * @apioption legend.navigation.style
			 */
		},
		
		/**
		 * The inner padding of the legend box.
		 * 
		 * @type {Number}
		 * @sample {highcharts} highcharts/legend/padding-itemmargin/
		 *         Padding and item margins demonstrated
		 * @sample {highstock} highcharts/legend/padding-itemmargin/
		 *         Padding and item margins demonstrated
		 * @sample {highmaps} maps/legend/padding-itemmargin/
		 *         Padding and item margins demonstrated
		 * @default 8
		 * @since 2.2.0
		 * @apioption legend.padding
		 */

		/**
		 * Whether to reverse the order of the legend items compared to the
		 * order of the series or points as defined in the configuration object.
		 * 
		 * @type {Boolean}
		 * @see [yAxis.reversedStacks](#yAxis.reversedStacks),
		 *      [series.legendIndex](#series.legendIndex)
		 * @sample {highcharts} highcharts/legend/reversed/
		 *         Stacked bar with reversed legend
		 * @default false
		 * @since 1.2.5
		 * @apioption legend.reversed
		 */

		/**
		 * Whether to show the symbol on the right side of the text rather than
		 * the left side. This is common in Arabic and Hebraic.
		 * 
		 * @type {Boolean}
		 * @sample {highcharts} highcharts/legend/rtl/ Symbol to the right
		 * @default false
		 * @since 2.2
		 * @apioption legend.rtl
		 */

		/**
		 * CSS styles for the legend area. In the 1.x versions the position
		 * of the legend area was determined by CSS. In 2.x, the position is
		 * determined by properties like `align`, `verticalAlign`, `x` and `y`,
		 *  but the styles are still parsed for backwards compatibility.
		 * 
		 * @type {CSSObject}
		 * @deprecated
		 * @product highcharts highstock
		 * @apioption legend.style
		 */

		

		/**
		 * CSS styles for each legend item. Only a subset of CSS is supported,
		 * notably those options related to text. The default `textOverflow`
		 * property makes long texts truncate. Set it to `null` to wrap text
		 * instead. A `width` property can be added to control the text width.
		 * 
		 * @type {CSSObject}
		 * @see In styled mode, the legend items can be styled with the `.
		 * highcharts-legend-item` class.
		 * @sample {highcharts} highcharts/legend/itemstyle/ Bold black text
		 * @sample {highmaps} maps/legend/itemstyle/ Item text styles
		 * @default { "color": "#333333", "cursor": "pointer", "fontSize": "12px", "fontWeight": "bold", "textOverflow": "ellipsis" }
		 */
		itemStyle: {
			color: '#333333',
			fontSize: '12px',
			fontWeight: 'bold',
			textOverflow: 'ellipsis'
		},

		/**
		 * CSS styles for each legend item in hover mode. Only a subset of
		 * CSS is supported, notably those options related to text. Properties
		 * are inherited from `style` unless overridden here.
		 * 
		 * @type {CSSObject}
		 * @see In styled mode, the hovered legend items can be styled with
		 * the `.highcharts-legend-item:hover` pesudo-class.
		 * @sample {highcharts} highcharts/legend/itemhoverstyle/ Red on hover
		 * @sample {highmaps} maps/legend/itemstyle/ Item text styles
		 * @default { "color": "#000000" }
		 */
		itemHoverStyle: {
			color: '#000000'
		},

		/**
		 * CSS styles for each legend item when the corresponding series or
		 * point is hidden. Only a subset of CSS is supported, notably those
		 * options related to text. Properties are inherited from `style`
		 * unless overridden here.
		 * 
		 * @type {CSSObject}
		 * @see In styled mode, the hidden legend items can be styled with
		 * the `.highcharts-legend-item-hidden` class.
		 * @sample {highcharts} highcharts/legend/itemhiddenstyle/ Darker gray color
		 * @default { "color": "#cccccc" }
		 */
		itemHiddenStyle: {
			color: '#cccccc'
		},

		/**
		 * Whether to apply a drop shadow to the legend. A `backgroundColor`
		 * also needs to be applied for this to take effect. The shadow can be
		 * an object configuration containing `color`, `offsetX`, `offsetY`,
		 * `opacity` and `width`.
		 * 
		 * @type {Boolean|Object}
		 * @sample {highcharts} highcharts/legend/shadow/
		 *         White background and drop shadow
		 * @sample {highstock} stock/legend/align/
		 *         Various legend options
		 * @sample {highmaps} maps/legend/border-background/
		 *         Border and background options
		 * @default false
		 */
		shadow: false,
		

		/**
		 * Default styling for the checkbox next to a legend item when
		 * `showCheckbox` is true.
		 */
		itemCheckboxStyle: {
			position: 'absolute',
			width: '13px', // for IE precision
			height: '13px'
		},
		// itemWidth: undefined,

		/**
		 * When this is true, the legend symbol width will be the same as
		 * the symbol height, which in turn defaults to the font size of the
		 * legend items.
		 * 
		 * @type {Boolean}
		 * @default true
		 * @since 5.0.0
		 */
		squareSymbol: true,

		/**
		 * The pixel height of the symbol for series types that use a rectangle
		 * in the legend. Defaults to the font size of legend items.
		 *
		 * @productdesc {highmaps}
		 * In Highmaps, when the symbol is the gradient of a vertical color
		 * axis, the height defaults to 200.
		 * 
		 * @type {Number}
		 * @sample {highmaps} maps/legend/layout-vertical-sized/
		 *         Sized vertical gradient
		 * @sample {highmaps} maps/legend/padding-itemmargin/
		 *         No distance between data classes
		 * @since 3.0.8
		 * @apioption legend.symbolHeight
		 */

		/**
		 * The border radius of the symbol for series types that use a rectangle
		 * in the legend. Defaults to half the `symbolHeight`.
		 * 
		 * @type {Number}
		 * @sample {highcharts} highcharts/legend/symbolradius/ Round symbols
		 * @sample {highstock} highcharts/legend/symbolradius/ Round symbols
		 * @sample {highmaps} highcharts/legend/symbolradius/ Round symbols
		 * @since 3.0.8
		 * @apioption legend.symbolRadius
		 */

		/**
		 * The pixel width of the legend item symbol. When the `squareSymbol`
		 * option is set, this defaults to the `symbolHeight`, otherwise 16.
		 * 
		 * @productdesc {highmaps}
		 * In Highmaps, when the symbol is the gradient of a horizontal color
		 * axis, the width defaults to 200.
		 * 
		 * @type {Number}
		 * @sample {highcharts} highcharts/legend/symbolwidth/
		 *         Greater symbol width and padding
		 * @sample {highmaps} maps/legend/padding-itemmargin/
		 *         Padding and item margins demonstrated
		 * @sample {highmaps} maps/legend/layout-vertical-sized/
		 *         Sized vertical gradient
		 * @apioption legend.symbolWidth
		 */

		/**
		 * Whether to [use HTML](http://www.highcharts.com/docs/chart-concepts/labels-
		 * and-string-formatting#html) to render the legend item texts. Prior
		 * to 4.1.7, when using HTML, [legend.navigation](#legend.navigation)
		 * was disabled.
		 * 
		 * @type {Boolean}
		 * @default false
		 * @apioption legend.useHTML
		 */

		/**
		 * The width of the legend box.
		 * 
		 * @type {Number}
		 * @sample {highcharts} highcharts/legend/width/ Aligned to the plot area
		 * @default null
		 * @since 2.0
		 * @apioption legend.width
		 */

		/**
		 * The pixel padding between the legend item symbol and the legend
		 * item text.
		 * 
		 * @type {Number}
		 * @sample {highcharts} highcharts/legend/symbolpadding/ Greater symbol width and padding
		 * @default 5
		 */
		symbolPadding: 5,

		/**
		 * The vertical alignment of the legend box. Can be one of `top`,
		 * `middle` or `bottom`. Vertical position can be further determined
		 * by the `y` option.
		 * 
		 * In the case that the legend is aligned in a corner position, the
		 * `layout` option will determine whether to place it above/below
		 * or on the side of the plot area.
		 * 
		 * @validvalue ["top", "middle", "bottom"]
		 * @type {String}
		 * @sample {highcharts} highcharts/legend/verticalalign/ Legend 100px from the top of the chart
		 * @sample {highstock} stock/legend/align/ Various legend options
		 * @sample {highmaps} maps/legend/alignment/ Legend alignment
		 * @default bottom
		 * @since 2.0
		 */
		verticalAlign: 'bottom',
		// width: undefined,

		/**
		 * The x offset of the legend relative to its horizontal alignment
		 * `align` within chart.spacingLeft and chart.spacingRight. Negative
		 * x moves it to the left, positive x moves it to the right.
		 * 
		 * @type {Number}
		 * @sample {highcharts} highcharts/legend/width/ Aligned to the plot area
		 * @default 0
		 * @since 2.0
		 */
		x: 0,

		/**
		 * The vertical offset of the legend relative to it's vertical alignment
		 * `verticalAlign` within chart.spacingTop and chart.spacingBottom.
		 *  Negative y moves it up, positive y moves it down.
		 * 
		 * @type {Number}
		 * @sample {highcharts} highcharts/legend/verticalalign/ Legend 100px from the top of the chart
		 * @sample {highstock} stock/legend/align/ Various legend options
		 * @sample {highmaps} maps/legend/alignment/ Legend alignment
		 * @default 0
		 * @since 2.0
		 */
		y: 0,

		/**
		 * A title to be added on top of the legend.
		 * 
		 * @sample {highcharts} highcharts/legend/title/ Legend title
		 * @sample {highmaps} maps/legend/alignment/ Legend with title
		 * @since 3.0
		 */
		title: {
			/**
			 * A text or HTML string for the title.
			 * 
			 * @type {String}
			 * @default null
			 * @since 3.0
			 * @apioption legend.title.text
			 */
			
			

			/**
			 * Generic CSS styles for the legend title.
			 * 
			 * @type {CSSObject}
			 * @see In styled mode, the legend title is styled with the
			 * `.highcharts-legend-title` class.
			 * @default {"fontWeight":"bold"}
			 * @since 3.0
			 */
			style: {
				fontWeight: 'bold'
			}
			
		}			
	},


	/**
	 * The loading options control the appearance of the loading screen
	 * that covers the plot area on chart operations. This screen only
	 * appears after an explicit call to `chart.showLoading()`. It is a
	 * utility for developers to communicate to the end user that something
	 * is going on, for example while retrieving new data via an XHR connection.
	 * The "Loading..." text itself is not part of this configuration
	 * object, but part of the `lang` object.
	 *
	 */
	loading: {

		/**
		 * The duration in milliseconds of the fade out effect.
		 * 
		 * @type {Number}
		 * @sample highcharts/loading/hideduration/ Fade in and out over a second
		 * @default 100
		 * @since 1.2.0
		 * @apioption loading.hideDuration
		 */

		/**
		 * The duration in milliseconds of the fade in effect.
		 * 
		 * @type {Number}
		 * @sample highcharts/loading/hideduration/ Fade in and out over a second
		 * @default 100
		 * @since 1.2.0
		 * @apioption loading.showDuration
		 */
		

		/**
		 * CSS styles for the loading label `span`.
		 * 
		 * @type {CSSObject}
		 * @see In styled mode, the loading label is styled with the
		 * `.highcharts-legend-loading-inner` class.
		 * @sample {highcharts|highmaps} highcharts/loading/labelstyle/ Vertically centered
		 * @sample {highstock} stock/loading/general/ Label styles
		 * @default { "fontWeight": "bold", "position": "relative", "top": "45%" }
		 * @since 1.2.0
		 */
		labelStyle: {
			fontWeight: 'bold',
			position: 'relative',
			top: '45%'
		},

		/**
		 * CSS styles for the loading screen that covers the plot area.
		 * 
		 * @type {CSSObject}
		 * @see In styled mode, the loading label is styled with the `.highcharts-legend-loading` class.
		 * @sample {highcharts|highmaps} highcharts/loading/style/ Gray plot area, white text
		 * @sample {highstock} stock/loading/general/ Gray plot area, white text
		 * @default { "position": "absolute", "backgroundColor": "#ffffff", "opacity": 0.5, "textAlign": "center" }
		 * @since 1.2.0
		 */
		style: {
			position: 'absolute',
			backgroundColor: '#ffffff',
			opacity: 0.5,
			textAlign: 'center'
		}
		
	},


	/**
	 * Options for the tooltip that appears when the user hovers over a
	 * series or point.
	 *
	 */
	tooltip: {

		/**
		 * Enable or disable the tooltip.
		 * 
		 * @type {Boolean}
		 * @sample {highcharts} highcharts/tooltip/enabled/ Disabled
		 * @sample {highcharts} highcharts/plotoptions/series-point-events-mouseover/ Disable tooltip and show values on chart instead
		 * @default true
		 */
		enabled: true,

		/**
		 * Enable or disable animation of the tooltip. In slow legacy IE browsers
		 * the animation is disabled by default.
		 * 
		 * @type {Boolean}
		 * @default true
		 * @since 2.3.0
		 */
		animation: svg,

		/**
		 * The radius of the rounded border corners.
		 * 
		 * @type {Number}
		 * @sample {highcharts} highcharts/tooltip/bordercolor-default/ 5px by default
		 * @sample {highcharts} highcharts/tooltip/borderradius-0/ Square borders
		 * @sample {highmaps} maps/tooltip/background-border/ Background and border demo
		 * @default 3
		 */
		borderRadius: 3,

		/**
		 * For series on a datetime axes, the date format in the tooltip's
		 * header will by default be guessed based on the closest data points.
		 * This member gives the default string representations used for
		 * each unit. For an overview of the replacement codes, see [dateFormat](#Highcharts.
		 * dateFormat).
		 * 
		 * Defaults to:
		 * 
		 * <pre>{
		 *     millisecond:"%A, %b %e, %H:%M:%S.%L",
		 *     second:"%A, %b %e, %H:%M:%S",
		 *     minute:"%A, %b %e, %H:%M",
		 *     hour:"%A, %b %e, %H:%M",
		 *     day:"%A, %b %e, %Y",
		 *     week:"Week from %A, %b %e, %Y",
		 *     month:"%B %Y",
		 *     year:"%Y"
		 * }</pre>
		 * 
		 * @type {Object}
		 * @see [xAxis.dateTimeLabelFormats](#xAxis.dateTimeLabelFormats)
		 * @product highcharts highstock
		 */
		dateTimeLabelFormats: {
			millisecond: '%A, %b %e, %H:%M:%S.%L',
			second: '%A, %b %e, %H:%M:%S',
			minute: '%A, %b %e, %H:%M',
			hour: '%A, %b %e, %H:%M',
			day: '%A, %b %e, %Y',
			week: 'Week from %A, %b %e, %Y',
			month: '%B %Y',
			year: '%Y'
		},

		/**
		 * A string to append to the tooltip format.
		 * 
		 * @sample {highcharts} highcharts/tooltip/footerformat/ A table for value alignment
		 * @sample {highmaps} maps/tooltip/format/ Format demo
		 * @since 2.2
		 */
		footerFormat: '',
		
		/**
		 * Padding inside the tooltip, in pixels.
		 * 
		 * @type {Number}
		 * @default 8
		 * @since 5.0.0
		 */
		padding: 8,

		/**
		 * Proximity snap for graphs or single points. It defaults to 10 for
		 * mouse-powered devices and 25 for touch devices.
		 * 
		 * Note that in most cases the whole plot area captures the mouse
		 * movement, and in these cases `tooltip.snap` doesn't make sense.
		 * This applies when [stickyTracking](#plotOptions.series.stickyTracking)
		 * is `true` (default) and when the tooltip is [shared](#tooltip.shared)
		 * or [split](#tooltip.split).
		 * 
		 * @type {Number}
		 * @sample {highcharts} highcharts/tooltip/bordercolor-default/ 10 px by default
		 * @sample {highcharts} highcharts/tooltip/snap-50/ 50 px on graph
		 * @default 10/25
		 * @since 1.2.0
		 * @product highcharts highstock
		 */
		snap: isTouchDevice ? 25 : 10,
		

		/**
		 * The background color or gradient for the tooltip.
		 * 
		 * In styled mode, the stroke width is set in the `.highcharts-tooltip-box` class.
		 * 
		 * @type {Color}
		 * @sample {highcharts} highcharts/tooltip/backgroundcolor-solid/ Yellowish background
		 * @sample {highcharts} highcharts/tooltip/backgroundcolor-gradient/ Gradient
		 * @sample {highcharts} highcharts/css/tooltip-border-background/ Tooltip in styled mode
		 * @sample {highstock} stock/tooltip/general/ Custom tooltip
		 * @sample {highstock} highcharts/css/tooltip-border-background/ Tooltip in styled mode
		 * @sample {highmaps} maps/tooltip/background-border/ Background and border demo
		 * @sample {highmaps} highcharts/css/tooltip-border-background/ Tooltip in styled mode
		 * @default rgba(247,247,247,0.85)
		 */
		backgroundColor: color('#f7f7f7').setOpacity(0.85).get(),

		/**
		 * The pixel width of the tooltip border.
		 * 
		 * In styled mode, the stroke width is set in the `.highcharts-tooltip-box` class.
		 * 
		 * @type {Number}
		 * @sample {highcharts} highcharts/tooltip/bordercolor-default/ 2px by default
		 * @sample {highcharts} highcharts/tooltip/borderwidth/ No border (shadow only)
		 * @sample {highcharts} highcharts/css/tooltip-border-background/ Tooltip in styled mode
		 * @sample {highstock} stock/tooltip/general/ Custom tooltip
		 * @sample {highstock} highcharts/css/tooltip-border-background/ Tooltip in styled mode
		 * @sample {highmaps} maps/tooltip/background-border/ Background and border demo
		 * @sample {highmaps} highcharts/css/tooltip-border-background/ Tooltip in styled mode
		 * @default 1
		 */
		borderWidth: 1,

		/**
		 * The HTML of the tooltip header line. Variables are enclosed by
		 * curly brackets. Available variables are `point.key`, `series.name`,
		 * `series.color` and other members from the `point` and `series`
		 * objects. The `point.key` variable contains the category name, x
		 * value or datetime string depending on the type of axis. For datetime
		 * axes, the `point.key` date format can be set using tooltip.xDateFormat.
		 * 
		 * @type {String}
		 * @sample {highcharts} highcharts/tooltip/footerformat/
		 *         A HTML table in the tooltip
		 * @sample {highstock} highcharts/tooltip/footerformat/
		 *         A HTML table in the tooltip
		 * @sample {highmaps} maps/tooltip/format/ Format demo
		 */
		headerFormat: '<span style="font-size: 10px">{point.key}</span><br/>',

		/**
		 * The HTML of the point's line in the tooltip. Variables are enclosed
		 * by curly brackets. Available variables are point.x, point.y, series.
		 * name and series.color and other properties on the same form. Furthermore,
		 * point.y can be extended by the `tooltip.valuePrefix` and `tooltip.
		 * valueSuffix` variables. This can also be overridden for each series,
		 * which makes it a good hook for displaying units.
		 * 
		 * In styled mode, the dot is colored by a class name rather
		 * than the point color.
		 * 
		 * @type {String}
		 * @sample {highcharts} highcharts/tooltip/pointformat/ A different point format with value suffix
		 * @sample {highmaps} maps/tooltip/format/ Format demo
		 * @default <span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.y}</b><br/>
		 * @since 2.2
		 */
		pointFormat: '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.y}</b><br/>',

		/**
		 * Whether to apply a drop shadow to the tooltip.
		 * 
		 * @type {Boolean}
		 * @sample {highcharts} highcharts/tooltip/bordercolor-default/ True by default
		 * @sample {highcharts} highcharts/tooltip/shadow/ False
		 * @sample {highmaps} maps/tooltip/positioner/ Fixed tooltip position, border and shadow disabled
		 * @default true
		 */
		shadow: true,

		/**
		 * CSS styles for the tooltip. The tooltip can also be styled through
		 * the CSS class `.highcharts-tooltip`.
		 * 
		 * @type {CSSObject}
		 * @sample {highcharts} highcharts/tooltip/style/ Greater padding, bold text
		 * @default { "color": "#333333", "cursor": "default", "fontSize": "12px", "pointerEvents": "none", "whiteSpace": "nowrap" }
		 */
		style: {
			color: '#333333',
			cursor: 'default',
			fontSize: '12px',
			pointerEvents: 'none', // #1686 http://caniuse.com/#feat=pointer-events
			whiteSpace: 'nowrap'
		}
		
		

		/**
		 * The color of the tooltip border. When `null`, the border takes the
		 * color of the corresponding series or point.
		 * 
		 * @type {Color}
		 * @sample {highcharts} highcharts/tooltip/bordercolor-default/
		 *         Follow series by default
		 * @sample {highcharts} highcharts/tooltip/bordercolor-black/
		 *         Black border
		 * @sample {highstock} stock/tooltip/general/
		 *         Styled tooltip
		 * @sample {highmaps} maps/tooltip/background-border/
		 *         Background and border demo
		 * @default null
		 * @apioption tooltip.borderColor
		 */

		/**
		 * Since 4.1, the crosshair definitions are moved to the Axis object
		 * in order for a better separation from the tooltip. See [xAxis.crosshair](#xAxis.
		 * crosshair)<a>.</a>
		 * 
		 * @type {Mixed}
		 * @deprecated
		 * @sample {highcharts} highcharts/tooltip/crosshairs-x/
		 *         Enable a crosshair for the x value
		 * @default true
		 * @apioption tooltip.crosshairs
		 */

		/**
		 * Whether the tooltip should follow the mouse as it moves across columns,
		 * pie slices and other point types with an extent. By default it behaves
		 * this way for scatter, bubble and pie series by override in the `plotOptions`
		 * for those series types.
		 * 
		 * For touch moves to behave the same way, [followTouchMove](#tooltip.
		 * followTouchMove) must be `true` also.
		 * 
		 * @type {Boolean}
		 * @default {highcharts} false
		 * @default {highstock} false
		 * @default {highmaps} true
		 * @since 3.0
		 * @apioption tooltip.followPointer
		 */

		/**
		 * Whether the tooltip should follow the finger as it moves on a touch
		 * device. If this is `true` and [chart.panning](#chart.panning) is
		 * set,`followTouchMove` will take over one-finger touches, so the user
		 * needs to use two fingers for zooming and panning.
		 * 
		 * @type {Boolean}
		 * @default {highcharts} true
		 * @default {highstock} true
		 * @default {highmaps} false
		 * @since 3.0.1
		 * @apioption tooltip.followTouchMove
		 */

		/**
		 * Callback function to format the text of the tooltip from scratch. Return
		 * `false` to disable tooltip for a specific point on series.
		 * 
		 * A subset of HTML is supported. Unless `useHTML` is true, the HTML of the
		 * tooltip is parsed and converted to SVG, therefore this isn't a complete HTML
		 * renderer. The following tags are supported: `<b>`, `<strong>`, `<i>`, `<em>`,
		 * `<br/>`, `<span>`. Spans can be styled with a `style` attribute,
		 * but only text-related CSS that is shared with SVG is handled.
		 * 
		 * Since version 2.1 the tooltip can be shared between multiple series
		 * through the `shared` option. The available data in the formatter
		 * differ a bit depending on whether the tooltip is shared or not. In
		 * a shared tooltip, all properties except `x`, which is common for
		 * all points, are kept in an array, `this.points`.
		 * 
		 * Available data are:
		 * 
		 * <dl>
		 * 
		 * <dt>this.percentage (not shared) / this.points[i].percentage (shared)</dt>
		 * 
		 * <dd>Stacked series and pies only. The point's percentage of the total.
		 * </dd>
		 * 
		 * <dt>this.point (not shared) / this.points[i].point (shared)</dt>
		 * 
		 * <dd>The point object. The point name, if defined, is available through
		 * `this.point.name`.</dd>
		 * 
		 * <dt>this.points</dt>
		 * 
		 * <dd>In a shared tooltip, this is an array containing all other properties
		 * for each point.</dd>
		 * 
		 * <dt>this.series (not shared) / this.points[i].series (shared)</dt>
		 * 
		 * <dd>The series object. The series name is available through
		 * `this.series.name`.</dd>
		 * 
		 * <dt>this.total (not shared) / this.points[i].total (shared)</dt>
		 * 
		 * <dd>Stacked series only. The total value at this point's x value.
		 * </dd>
		 * 
		 * <dt>this.x</dt>
		 * 
		 * <dd>The x value. This property is the same regardless of the tooltip
		 * being shared or not.</dd>
		 * 
		 * <dt>this.y (not shared) / this.points[i].y (shared)</dt>
		 * 
		 * <dd>The y value.</dd>
		 * 
		 * </dl>
		 * 
		 * @type {Function}
		 * @sample {highcharts} highcharts/tooltip/formatter-simple/
		 *         Simple string formatting
		 * @sample {highcharts} highcharts/tooltip/formatter-shared/
		 *         Formatting with shared tooltip
		 * @sample {highstock} stock/tooltip/formatter/
		 *         Formatting with shared tooltip
		 * @sample {highmaps} maps/tooltip/formatter/
		 *         String formatting
		 * @apioption tooltip.formatter
		 */

		/**
		 * The number of milliseconds to wait until the tooltip is hidden when
		 * mouse out from a point or chart.
		 * 
		 * @type {Number}
		 * @default 500
		 * @since 3.0
		 * @apioption tooltip.hideDelay
		 */

		/**
		 * A callback function for formatting the HTML output for a single point
		 * in the tooltip. Like the `pointFormat` string, but with more flexibility.
		 * 
		 * @type {Function}
		 * @context Point
		 * @since 4.1.0
		 * @apioption tooltip.pointFormatter
		 */

		/**
		 * A callback function to place the tooltip in a default position. The
		 * callback receives three parameters: `labelWidth`, `labelHeight` and
		 * `point`, where point contains values for `plotX` and `plotY` telling
		 * where the reference point is in the plot area. Add `chart.plotLeft`
		 * and `chart.plotTop` to get the full coordinates.
		 * 
		 * The return should be an object containing x and y values, for example
		 * `{ x: 100, y: 100 }`.
		 * 
		 * @type {Function}
		 * @sample {highcharts} highcharts/tooltip/positioner/ A fixed tooltip position
		 * @sample {highstock} stock/tooltip/positioner/ A fixed tooltip position on top of the chart
		 * @sample {highmaps} maps/tooltip/positioner/ A fixed tooltip position
		 * @since 2.2.4
		 * @apioption tooltip.positioner
		 */

		/**
		 * The name of a symbol to use for the border around the tooltip.
		 * 
		 * @type {String}
		 * @default callout
		 * @validvalue ["callout", "square"]
		 * @since 4.0
		 * @apioption tooltip.shape
		 */

		/**
		 * When the tooltip is shared, the entire plot area will capture mouse
		 * movement or touch events. Tooltip texts for series types with ordered
		 * data (not pie, scatter, flags etc) will be shown in a single bubble.
		 * This is recommended for single series charts and for tablet/mobile
		 * optimized charts.
		 * 
		 * See also [tooltip.split](#tooltip.split), that is better suited for
		 * charts with many series, especially line-type series.
		 * 
		 * @type {Boolean}
		 * @sample {highcharts} highcharts/tooltip/shared-false/ False by default
		 * @sample {highcharts} highcharts/tooltip/shared-true/ True
		 * @sample {highcharts} highcharts/tooltip/shared-x-crosshair/ True with x axis crosshair
		 * @sample {highcharts} highcharts/tooltip/shared-true-mixed-types/ True with mixed series types
		 * @default false
		 * @since 2.1
		 * @product highcharts highstock
		 * @apioption tooltip.shared
		 */

		/**
		 * Split the tooltip into one label per series, with the header close
		 * to the axis. This is recommended over [shared](#tooltip.shared) tooltips
		 * for charts with multiple line series, generally making them easier
		 * to read.
		 *
		 * @productdesc {highstock} In Highstock, tooltips are split by default
		 * since v6.0.0. Stock charts typically contain multi-dimension points
		 * and multiple panes, making split tooltips the preferred layout over
		 * the previous `shared` tooltip.
		 * 
		 * @type {Boolean}
		 * @sample {highcharts} highcharts/tooltip/split/ Split tooltip
		 * @sample {highstock} highcharts/tooltip/split/ Split tooltip
		 * @sample {highmaps} highcharts/tooltip/split/ Split tooltip
		 * @default {highcharts} false
		 * @default {highstock} true
		 * @product highcharts highstock
		 * @since 5.0.0
		 * @apioption tooltip.split
		 */

		/**
		 * Use HTML to render the contents of the tooltip instead of SVG. Using
		 * HTML allows advanced formatting like tables and images in the tooltip.
		 * It is also recommended for rtl languages as it works around rtl
		 * bugs in early Firefox.
		 * 
		 * @type {Boolean}
		 * @sample {highcharts} highcharts/tooltip/footerformat/ A table for value alignment
		 * @sample {highcharts} highcharts/tooltip/fullhtml/ Full HTML tooltip
		 * @sample {highstock} highcharts/tooltip/footerformat/ A table for value alignment
		 * @sample {highstock} highcharts/tooltip/fullhtml/ Full HTML tooltip
		 * @sample {highmaps} maps/tooltip/usehtml/ Pure HTML tooltip
		 * @default false
		 * @since 2.2
		 * @apioption tooltip.useHTML
		 */

		/**
		 * How many decimals to show in each series' y value. This is overridable
		 * in each series' tooltip options object. The default is to preserve
		 * all decimals.
		 * 
		 * @type {Number}
		 * @sample {highcharts} highcharts/tooltip/valuedecimals/ Set decimals, prefix and suffix for the value
		 * @sample {highstock} highcharts/tooltip/valuedecimals/ Set decimals, prefix and suffix for the value
		 * @sample {highmaps} maps/tooltip/valuedecimals/ Set decimals, prefix and suffix for the value
		 * @since 2.2
		 * @apioption tooltip.valueDecimals
		 */

		/**
		 * A string to prepend to each series' y value. Overridable in each
		 * series' tooltip options object.
		 * 
		 * @type {String}
		 * @sample {highcharts} highcharts/tooltip/valuedecimals/ Set decimals, prefix and suffix for the value
		 * @sample {highstock} highcharts/tooltip/valuedecimals/ Set decimals, prefix and suffix for the value
		 * @sample {highmaps} maps/tooltip/valuedecimals/ Set decimals, prefix and suffix for the value
		 * @since 2.2
		 * @apioption tooltip.valuePrefix
		 */

		/**
		 * A string to append to each series' y value. Overridable in each series'
		 * tooltip options object.
		 * 
		 * @type {String}
		 * @sample {highcharts} highcharts/tooltip/valuedecimals/ Set decimals, prefix and suffix for the value
		 * @sample {highstock} highcharts/tooltip/valuedecimals/ Set decimals, prefix and suffix for the value
		 * @sample {highmaps} maps/tooltip/valuedecimals/ Set decimals, prefix and suffix for the value
		 * @since 2.2
		 * @apioption tooltip.valueSuffix
		 */

		/**
		 * The format for the date in the tooltip header if the X axis is a
		 * datetime axis. The default is a best guess based on the smallest
		 * distance between points in the chart.
		 * 
		 * @type {String}
		 * @sample {highcharts} highcharts/tooltip/xdateformat/ A different format
		 * @product highcharts highstock
		 * @apioption tooltip.xDateFormat
		 */
	},


	/**
	 * Highchart by default puts a credits label in the lower right corner
	 * of the chart. This can be changed using these options.
	 */
	credits: {

		/**
		 * Whether to show the credits text.
		 * 
		 * @type {Boolean}
		 * @sample {highcharts} highcharts/credits/enabled-false/ Credits disabled
		 * @sample {highstock} stock/credits/enabled/ Credits disabled
		 * @sample {highmaps} maps/credits/enabled-false/ Credits disabled
		 * @default true
		 */
		enabled: true,

		/**
		 * The URL for the credits label.
		 * 
		 * @type {String}
		 * @sample {highcharts} highcharts/credits/href/ Custom URL and text
		 * @sample {highmaps} maps/credits/customized/ Custom URL and text
		 * @default {highcharts} http://www.highcharts.com
		 * @default {highstock} "http://www.highcharts.com"
		 * @default {highmaps} http://www.highcharts.com
		 */
		href: 'http://www.highcharts.com',

		/**
		 * Position configuration for the credits label.
		 * 
		 * @type {Object}
		 * @sample {highcharts} highcharts/credits/position-left/ Left aligned
		 * @sample {highcharts} highcharts/credits/position-left/ Left aligned
		 * @sample {highmaps} maps/credits/customized/ Left aligned
		 * @sample {highmaps} maps/credits/customized/ Left aligned
		 * @since 2.1
		 */
		position: {

			/**
			 * Horizontal alignment of the credits.
			 * 
			 * @validvalue ["left", "center", "right"]
			 * @type {String}
			 * @default right
			 */
			align: 'right',

			/**
			 * Horizontal pixel offset of the credits.
			 * 
			 * @type {Number}
			 * @default -10
			 */
			x: -10,

			/**
			 * Vertical alignment of the credits.
			 * 
			 * @validvalue ["top", "middle", "bottom"]
			 * @type {String}
			 * @default bottom
			 */
			verticalAlign: 'bottom',

			/**
			 * Vertical pixel offset of the credits.
			 * 
			 * @type {Number}
			 * @default -5
			 */
			y: -5
		},
		

		/**
		 * CSS styles for the credits label.
		 * 
		 * @type {CSSObject}
		 * @see In styled mode, credits styles can be set with the
		 * `.highcharts-credits` class.
		 * @default { "cursor": "pointer", "color": "#999999", "fontSize": "10px" }
		 */
		style: {

			cursor: 'pointer',
			color: '#999999',
			fontSize: '9px'
		},
		

		/**
		 * The text for the credits label.
		 *
		 * @productdesc {highmaps}
		 * If a map is loaded as GeoJSON, the text defaults to `Highcharts @
		 * {map-credits}`. Otherwise, it defaults to `Highcharts.com`.
		 * 
		 * @type {String}
		 * @sample {highcharts} highcharts/credits/href/ Custom URL and text
		 * @sample {highmaps} maps/credits/customized/ Custom URL and text
		 * @default {highcharts|highstock} Highcharts.com
		 */
		text: 'Highcharts.com'
	}
};

/**
 * Merge the default options with custom options and return the new options
 * structure. Commonly used for defining reusable templates.
 *
 * @function #setOptions
 * @memberOf  Highcharts
 * @sample highcharts/global/useutc-false Setting a global option
 * @sample highcharts/members/setoptions Applying a global theme
 * @param {Object} options The new custom chart options.
 * @returns {Object} Updated options.
 */
H.setOptions = function (options) {
	
	// Copy in the default options
	H.defaultOptions = merge(true, H.defaultOptions, options);
	
	// Re-initiate time
	H.time.init();

	return H.defaultOptions;
};

/**
 * Get the updated default options. Until 3.0.7, merely exposing defaultOptions for outside modules
 * wasn't enough because the setOptions method created a new object.
 */
H.getOptions = function () {
	return H.defaultOptions;
};


// Series defaults
H.defaultPlotOptions = H.defaultOptions.plotOptions;


// Time utilities
H.time = new H.Time();

/**
 * Formats a JavaScript date timestamp (milliseconds since Jan 1st 1970) into a
 * human readable date string. The format is a subset of the formats for PHP's
 * [strftime]{@link
 * http://www.php.net/manual/en/function.strftime.php} function. Additional
 * formats can be given in the {@link Highcharts.dateFormats} hook.
 *
 * Since v6.0.5, all internal dates are formatted through the
 * [Chart.time](Chart#time) instance to respect chart-level time settings. The
 * `Highcharts.dateFormat` function only reflects global time settings set with
 * `setOptions`.
 *
 * @function #dateFormat
 * @memberOf Highcharts
 * @param {String} format - The desired format where various time
 *        representations are prefixed with %.
 * @param {Number} timestamp - The JavaScript timestamp.
 * @param {Boolean} [capitalize=false] - Upper case first letter in the return.
 * @returns {String} The formatted date.
 */
H.dateFormat = function (format, timestamp, capitalize) {
	return H.time.dateFormat(format, timestamp, capitalize);
};

}(Highcharts));
(function (H) {
/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var correctFloat = H.correctFloat,
	defined = H.defined,
	destroyObjectProperties = H.destroyObjectProperties,
	isNumber = H.isNumber,
	merge = H.merge,
	pick = H.pick,
	deg2rad = H.deg2rad;

/**
 * The Tick class
 */
H.Tick = function (axis, pos, type, noLabel) {
	this.axis = axis;
	this.pos = pos;
	this.type = type || '';
	this.isNew = true;
	this.isNewLabel = true;

	if (!type && !noLabel) {
		this.addLabel();
	}
};

H.Tick.prototype = {
	/**
	 * Write the tick label
	 */
	addLabel: function () {
		var tick = this,
			axis = tick.axis,
			options = axis.options,
			chart = axis.chart,
			categories = axis.categories,
			names = axis.names,
			pos = tick.pos,
			labelOptions = options.labels,
			str,
			tickPositions = axis.tickPositions,
			isFirst = pos === tickPositions[0],
			isLast = pos === tickPositions[tickPositions.length - 1],
			value = categories ?
				pick(categories[pos], names[pos], pos) :
				pos,
			label = tick.label,
			tickPositionInfo = tickPositions.info,
			dateTimeLabelFormat;

		// Set the datetime label format. If a higher rank is set for this
		// position, use that. If not, use the general format.
		if (axis.isDatetimeAxis && tickPositionInfo) {
			dateTimeLabelFormat =
				options.dateTimeLabelFormats[
					tickPositionInfo.higherRanks[pos] ||
					tickPositionInfo.unitName
				];
		}
		// set properties for access in render method
		tick.isFirst = isFirst;
		tick.isLast = isLast;

		// get the string
		str = axis.labelFormatter.call({
			axis: axis,
			chart: chart,
			isFirst: isFirst,
			isLast: isLast,
			dateTimeLabelFormat: dateTimeLabelFormat,
			value: axis.isLog ? correctFloat(axis.lin2log(value)) : value,
			pos: pos
		});

		// first call
		if (!defined(label)) {

			tick.label = label =
				defined(str) && labelOptions.enabled ?
					chart.renderer.text(
							str,
							0,
							0,
							labelOptions.useHTML
						)
						
						// without position absolute, IE export sometimes is
						// wrong.
						.css(merge(labelOptions.style))
						
						.add(axis.labelGroup) :
					null;

			// Un-rotated length
			tick.labelLength = label && label.getBBox().width;
			// Base value to detect change for new calls to getBBox
			tick.rotation = 0;

		// update
		} else if (label) {
			label.attr({ text: str });
		}
	},

	/**
	 * Get the offset height or width of the label
	 */
	getLabelSize: function () {
		return this.label ?
			this.label.getBBox()[this.axis.horiz ? 'height' : 'width'] :
			0;
	},

	/**
	 * Handle the label overflow by adjusting the labels to the left and right
	 * edge, or hide them if they collide into the neighbour label.
	 */
	handleOverflow: function (xy) {
		var axis = this.axis,
			labelOptions = axis.options.labels,
			pxPos = xy.x,
			chartWidth = axis.chart.chartWidth,
			spacing = axis.chart.spacing,
			leftBound = pick(axis.labelLeft, Math.min(axis.pos, spacing[3])),
			rightBound = pick(
				axis.labelRight,
				Math.max(
					!axis.isRadial ? axis.pos + axis.len : 0,
					chartWidth - spacing[1]
				)
			),
			label = this.label,
			rotation = this.rotation,
			factor = { left: 0, center: 0.5, right: 1 }[
				axis.labelAlign || label.attr('align')
			],
			labelWidth = label.getBBox().width,
			slotWidth = axis.getSlotWidth(),
			modifiedSlotWidth = slotWidth,
			xCorrection = factor,
			goRight = 1,
			leftPos,
			rightPos,
			textWidth,
			css = {};

		// Check if the label overshoots the chart spacing box. If it does, move
		// it. If it now overshoots the slotWidth, add ellipsis.
		if (!rotation && labelOptions.overflow !== false) {
			leftPos = pxPos - factor * labelWidth;
			rightPos = pxPos + (1 - factor) * labelWidth;

			if (leftPos < leftBound) {
				modifiedSlotWidth = xy.x + modifiedSlotWidth * (1 - factor) - leftBound;
			} else if (rightPos > rightBound) {
				modifiedSlotWidth =
					rightBound - xy.x + modifiedSlotWidth * factor;
				goRight = -1;
			}

			modifiedSlotWidth = Math.min(slotWidth, modifiedSlotWidth); // #4177
			if (modifiedSlotWidth < slotWidth && axis.labelAlign === 'center') {
				xy.x += (
					goRight *
					(
						slotWidth -
						modifiedSlotWidth -
						xCorrection * (
							slotWidth - Math.min(labelWidth, modifiedSlotWidth)
						)
					)
				);
			}
			// If the label width exceeds the available space, set a text width
			// to be picked up below. Also, if a width has been set before, we
			// need to set a new one because the reported labelWidth will be
			// limited by the box (#3938).
			if (
				labelWidth > modifiedSlotWidth ||
				(axis.autoRotation && (label.styles || {}).width)
			) {
				textWidth = modifiedSlotWidth;
			}

		// Add ellipsis to prevent rotated labels to be clipped against the edge
		// of the chart
		} else if (rotation < 0 && pxPos - factor * labelWidth < leftBound) {
			textWidth = Math.round(
				pxPos / Math.cos(rotation * deg2rad) - leftBound
			);
		} else if (rotation > 0 && pxPos + factor * labelWidth > rightBound) {
			textWidth = Math.round(
				(chartWidth - pxPos) / Math.cos(rotation * deg2rad)
			);
		}

		if (textWidth) {
			css.width = textWidth;
			if (!(labelOptions.style || {}).textOverflow) {
				css.textOverflow = 'ellipsis';
			}
			label.css(css);
		}
	},

	/**
	 * Get the x and y position for ticks and labels
	 */
	getPosition: function (horiz, pos, tickmarkOffset, old) {
		var axis = this.axis,
			chart = axis.chart,
			cHeight = (old && chart.oldChartHeight) || chart.chartHeight;

		return {
			x: horiz ?
				(
					axis.translate(pos + tickmarkOffset, null, null, old) +
					axis.transB
				) :
				(
					axis.left +
					axis.offset +
					(
						axis.opposite ?
							(
								(
									(old && chart.oldChartWidth) ||
									chart.chartWidth
								) -
								axis.right -
								axis.left
							) :
							0
					)
				),

			y: horiz ?
				(
					cHeight -
					axis.bottom +
					axis.offset -
					(axis.opposite ? axis.height : 0)
				) :
				(
					cHeight -
					axis.translate(pos + tickmarkOffset, null, null, old) -
					axis.transB
				)
		};

	},

	/**
	 * Get the x, y position of the tick label
	 */
	getLabelPosition: function (
		x,
		y,
		label,
		horiz,
		labelOptions,
		tickmarkOffset,
		index,
		step
	) {
		var axis = this.axis,
			transA = axis.transA,
			reversed = axis.reversed,
			staggerLines = axis.staggerLines,
			rotCorr = axis.tickRotCorr || { x: 0, y: 0 },
			yOffset = labelOptions.y,

			// Adjust for label alignment if we use reserveSpace: true (#5286)
			labelOffsetCorrection = (
				!horiz && !axis.reserveSpaceDefault ?
					-axis.labelOffset * (
						axis.labelAlign === 'center' ? 0.5 : 1
					) :
					0
			),
			line;

		if (!defined(yOffset)) {
			if (axis.side === 0) {
				yOffset = label.rotation ? -8 : -label.getBBox().height;
			} else if (axis.side === 2) {
				yOffset = rotCorr.y + 8;
			} else {
				// #3140, #3140
				yOffset = Math.cos(label.rotation * deg2rad) *
					(rotCorr.y - label.getBBox(false, 0).height / 2);
			}
		}

		x = x +
			labelOptions.x +
			labelOffsetCorrection +
			rotCorr.x -
			(
				tickmarkOffset && horiz ?
					tickmarkOffset * transA * (reversed ? -1 : 1) :
					0
			);
		y = y + yOffset - (tickmarkOffset && !horiz ?
			tickmarkOffset * transA * (reversed ? 1 : -1) : 0);

		// Correct for staggered labels
		if (staggerLines) {
			line = (index / (step || 1) % staggerLines);
			if (axis.opposite) {
				line = staggerLines - line - 1;
			}
			y += line * (axis.labelOffset / staggerLines);
		}

		return {
			x: x,
			y: Math.round(y)
		};
	},

	/**
	 * Extendible method to return the path of the marker
	 */
	getMarkPath: function (x, y, tickLength, tickWidth, horiz, renderer) {
		return renderer.crispLine([
			'M',
			x,
			y,
			'L',
			x + (horiz ? 0 : -tickLength),
			y + (horiz ? tickLength : 0)
		], tickWidth);
	},

	/**
	 * Renders the gridLine.
	 * @param  {Boolean} old         Whether or not the tick is old
	 * @param  {number} opacity      The opacity of the grid line
	 * @param  {number} reverseCrisp Modifier for avoiding overlapping 1 or -1
	 * @return {undefined}
	 */
	renderGridLine: function (old, opacity, reverseCrisp) {
		var tick = this,
			axis = tick.axis,
			options = axis.options,
			gridLine = tick.gridLine,
			gridLinePath,
			attribs = {},
			pos = tick.pos,
			type = tick.type,
			tickmarkOffset = axis.tickmarkOffset,
			renderer = axis.chart.renderer;

		
		var gridPrefix = type ? type + 'Grid' : 'grid',
			gridLineWidth = options[gridPrefix + 'LineWidth'],
			gridLineColor = options[gridPrefix + 'LineColor'],
			dashStyle = options[gridPrefix + 'LineDashStyle'];
		

		if (!gridLine) {
			
			attribs.stroke = gridLineColor;
			attribs['stroke-width'] = gridLineWidth;
			if (dashStyle) {
				attribs.dashstyle = dashStyle;
			}
			
			if (!type) {
				attribs.zIndex = 1;
			}
			if (old) {
				attribs.opacity = 0;
			}
			tick.gridLine = gridLine = renderer.path()
				.attr(attribs)
				.addClass(
					'highcharts-' + (type ? type + '-' : '') + 'grid-line'
				)
				.add(axis.gridGroup);
		}

		// If the parameter 'old' is set, the current call will be followed
		// by another call, therefore do not do any animations this time
		if (!old && gridLine) {
			gridLinePath = axis.getPlotLinePath(
				pos + tickmarkOffset,
				gridLine.strokeWidth() * reverseCrisp,
				old, true
			);
			if (gridLinePath) {
				gridLine[tick.isNew ? 'attr' : 'animate']({
					d: gridLinePath,
					opacity: opacity
				});
			}
		}
	},

	/**
	 * Renders the tick mark.
	 * @param  {Object} xy           The position vector of the mark
	 * @param  {number} xy.x         The x position of the mark
	 * @param  {number} xy.y         The y position of the mark
	 * @param  {number} opacity      The opacity of the mark
	 * @param  {number} reverseCrisp Modifier for avoiding overlapping 1 or -1
	 * @return {undefined}
	 */
	renderMark: function (xy, opacity, reverseCrisp) {
		var tick = this,
			axis = tick.axis,
			options = axis.options,
			renderer = axis.chart.renderer,
			type = tick.type,
			tickPrefix = type ? type + 'Tick' : 'tick',
			tickSize = axis.tickSize(tickPrefix),
			mark = tick.mark,
			isNewMark = !mark,
			x = xy.x,
			y = xy.y;

		
		var tickWidth = pick(
				options[tickPrefix + 'Width'],
				!type && axis.isXAxis ? 1 : 0
			), // X axis defaults to 1
			tickColor = options[tickPrefix + 'Color'];
		

		if (tickSize) {

			// negate the length
			if (axis.opposite) {
				tickSize[0] = -tickSize[0];
			}

			// First time, create it
			if (isNewMark) {
				tick.mark = mark = renderer.path()
					.addClass('highcharts-' + (type ? type + '-' : '') + 'tick')
					.add(axis.axisGroup);

				
				mark.attr({
					stroke: tickColor,
					'stroke-width': tickWidth
				});
				
			}
			mark[isNewMark ? 'attr' : 'animate']({
				d: tick.getMarkPath(
					x,
					y,
					tickSize[0],
					mark.strokeWidth() * reverseCrisp,
					axis.horiz,
					renderer),
				opacity: opacity
			});

		}
	},

	/**
	 * Renders the tick label.
	 * Note: The label should already be created in init(), so it should only
	 * have to be moved into place.
	 * @param  {Object} xy      The position vector of the label
	 * @param  {number} xy.x    The x position of the label
	 * @param  {number} xy.y    The y position of the label
	 * @param  {Boolean} old    Whether or not the tick is old
	 * @param  {number} opacity The opacity of the label
	 * @param  {number} index   The index of the tick
	 * @return {undefined}
	 */
	renderLabel: function (xy, old, opacity, index) {
		var tick = this,
			axis = tick.axis,
			horiz = axis.horiz,
			options = axis.options,
			label = tick.label,
			labelOptions = options.labels,
			step = labelOptions.step,
			tickmarkOffset = axis.tickmarkOffset,
			show = true,
			x = xy.x,
			y = xy.y;
		if (label && isNumber(x)) {
			label.xy = xy = tick.getLabelPosition(
				x,
				y,
				label,
				horiz,
				labelOptions,
				tickmarkOffset,
				index,
				step
			);

			// Apply show first and show last. If the tick is both first and
			// last, it is a single centered tick, in which case we show the
			// label anyway (#2100).
			if (
				(
					tick.isFirst &&
					!tick.isLast &&
					!pick(options.showFirstLabel, 1)
				) ||
				(
					tick.isLast &&
					!tick.isFirst &&
					!pick(options.showLastLabel, 1)
				)
			) {
				show = false;

			// Handle label overflow and show or hide accordingly
			} else if (
				horiz &&
				!labelOptions.step &&
				!labelOptions.rotation &&
				!old &&
				opacity !== 0
			) {
				tick.handleOverflow(xy);
			}

			// apply step
			if (step && index % step) {
				// show those indices dividable by step
				show = false;
			}

			// Set the new position, and show or hide
			if (show && isNumber(xy.y)) {
				xy.opacity = opacity;
				label[tick.isNewLabel ? 'attr' : 'animate'](xy);
				tick.isNewLabel = false;
			} else {
				label.attr('y', -9999); // #1338
				tick.isNewLabel = true;
			}
		}
	},

	/**
	 * Put everything in place
	 *
	 * @param index {Number}
	 * @param old {Boolean} Use old coordinates to prepare an animation into new
	 *                      position
	 */
	render: function (index, old, opacity) {
		var tick = this,
			axis = tick.axis,
			horiz = axis.horiz,
			pos = tick.pos,
			tickmarkOffset = axis.tickmarkOffset,
			xy = tick.getPosition(horiz, pos, tickmarkOffset, old),
			x = xy.x,
			y = xy.y,
			reverseCrisp = ((horiz && x === axis.pos + axis.len) ||
				(!horiz && y === axis.pos)) ? -1 : 1; // #1480, #1687

		opacity = pick(opacity, 1);
		this.isActive = true;

		// Create the grid line
		this.renderGridLine(old, opacity, reverseCrisp);

		// create the tick mark
		this.renderMark(xy, opacity, reverseCrisp);

		// the label is created on init - now move it into place
		this.renderLabel(xy, old, opacity, index);

		tick.isNew = false;
	},

	/**
	 * Destructor for the tick prototype
	 */
	destroy: function () {
		destroyObjectProperties(this, this.axis);
	}
};

}(Highcharts));
var Axis = (function (H) {
/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */

var addEvent = H.addEvent,
	animObject = H.animObject,
	arrayMax = H.arrayMax,
	arrayMin = H.arrayMin,
	color = H.color,
	correctFloat = H.correctFloat,
	defaultOptions = H.defaultOptions,
	defined = H.defined,
	deg2rad = H.deg2rad,
	destroyObjectProperties = H.destroyObjectProperties,
	each = H.each,
	extend = H.extend,
	fireEvent = H.fireEvent,
	format = H.format,
	getMagnitude = H.getMagnitude,
	grep = H.grep,
	inArray = H.inArray,
	isArray = H.isArray,
	isNumber = H.isNumber,
	isString = H.isString,
	merge = H.merge,
	normalizeTickInterval = H.normalizeTickInterval,
	objectEach = H.objectEach,
	pick = H.pick,
	removeEvent = H.removeEvent,
	splat = H.splat,
	syncTimeout = H.syncTimeout,
	Tick = H.Tick;
	
/**
 * Create a new axis object. Called internally when instanciating a new chart or
 * adding axes by {@link Highcharts.Chart#addAxis}.
 *
 * A chart can have from 0 axes (pie chart) to multiples. In a normal, single
 * series cartesian chart, there is one X axis and one Y axis.
 * 
 * The X axis or axes are referenced by {@link Highcharts.Chart.xAxis}, which is
 * an array of Axis objects. If there is only one axis, it can be referenced
 * through `chart.xAxis[0]`, and multiple axes have increasing indices. The same
 * pattern goes for Y axes.
 * 
 * If you need to get the axes from a series object, use the `series.xAxis` and
 * `series.yAxis` properties. These are not arrays, as one series can only be
 * associated to one X and one Y axis.
 * 
 * A third way to reference the axis programmatically is by `id`. Add an `id` in
 * the axis configuration options, and get the axis by
 * {@link Highcharts.Chart#get}.
 * 
 * Configuration options for the axes are given in options.xAxis and
 * options.yAxis.
 * 
 * @class Highcharts.Axis
 * @memberOf Highcharts
 * @param {Highcharts.Chart} chart - The Chart instance to apply the axis on.
 * @param {Object} options - Axis options
 */
var Axis = function () {
	this.init.apply(this, arguments);
};

H.extend(Axis.prototype, /** @lends Highcharts.Axis.prototype */{

	/**
	 * The X axis or category axis. Normally this is the horizontal axis,
	 * though if the chart is inverted this is the vertical axis. In case of
	 * multiple axes, the xAxis node is an array of configuration objects.
	 * 
	 * See [the Axis object](#Axis) for programmatic access to the axis.
	 *
	 * @productdesc {highmaps}
	 * In Highmaps, the axis is hidden, but it is used behind the scenes to
	 * control features like zooming and panning. Zooming is in effect the same
	 * as setting the extremes of one of the exes.
	 * 
	 * @optionparent xAxis
	 */
	defaultOptions: {
		/**
		 * Whether to allow decimals in this axis' ticks. When counting
		 * integers, like persons or hits on a web page, decimals should
		 * be avoided in the labels.
		 *
		 * @type      {Boolean}
		 * @see       [minTickInterval](#xAxis.minTickInterval)
		 * @sample    {highcharts|highstock}
		 *            highcharts/yaxis/allowdecimals-true/
		 *            True by default
		 * @sample    {highcharts|highstock}
		 *            highcharts/yaxis/allowdecimals-false/
		 *            False
		 * @default   true
		 * @since     2.0
		 * @apioption xAxis.allowDecimals
		 */
		// allowDecimals: null,


		/**
		 * When using an alternate grid color, a band is painted across the
		 * plot area between every other grid line.
		 *
		 * @type      {Color}
		 * @sample    {highcharts} highcharts/yaxis/alternategridcolor/
		 *            Alternate grid color on the Y axis
		 * @sample    {highstock} stock/xaxis/alternategridcolor/
		 *            Alternate grid color on the Y axis
		 * @default   null
		 * @apioption xAxis.alternateGridColor
		 */
		// alternateGridColor: null,

		/**
		 * An array defining breaks in the axis, the sections defined will be
		 * left out and all the points shifted closer to each other.
		 *
		 * @productdesc {highcharts}
		 * Requires that the broken-axis.js module is loaded.
		 *
		 * @type      {Array}
		 * @sample    {highcharts}
		 *            highcharts/axisbreak/break-simple/
		 *            Simple break
		 * @sample    {highcharts|highstock}
		 *            highcharts/axisbreak/break-visualized/
		 *            Advanced with callback
		 * @sample    {highstock}
		 *            stock/demo/intraday-breaks/
		 *            Break on nights and weekends
		 * @since     4.1.0
		 * @product   highcharts highstock
		 * @apioption xAxis.breaks
		 */

		/**
		 * A number indicating how much space should be left between the start
		 * and the end of the break. The break size is given in axis units,
		 * so for instance on a `datetime` axis, a break size of 3600000 would
		 * indicate the equivalent of an hour.
		 *
		 * @type      {Number}
		 * @default   0
		 * @since     4.1.0
		 * @product   highcharts highstock
		 * @apioption xAxis.breaks.breakSize
		 */

		/**
		 * The point where the break starts.
		 *
		 * @type      {Number}
		 * @since     4.1.0
		 * @product   highcharts highstock
		 * @apioption xAxis.breaks.from
		 */

		/**
		 * Defines an interval after which the break appears again. By default
		 * the breaks do not repeat.
		 *
		 * @type      {Number}
		 * @default   0
		 * @since     4.1.0
		 * @product   highcharts highstock
		 * @apioption xAxis.breaks.repeat
		 */

		/**
		 * The point where the break ends.
		 *
		 * @type      {Number}
		 * @since     4.1.0
		 * @product   highcharts highstock
		 * @apioption xAxis.breaks.to
		 */

		/**
		 * If categories are present for the xAxis, names are used instead of
		 * numbers for that axis. Since Highcharts 3.0, categories can also
		 * be extracted by giving each point a [name](#series.data) and setting
		 * axis [type](#xAxis.type) to `category`. However, if you have multiple
		 * series, best practice remains defining the `categories` array.
		 *
		 * Example:
		 *
		 * <pre>categories: ['Apples', 'Bananas', 'Oranges']</pre>
		 *
		 * @type      {Array<String>}
		 * @sample    {highcharts} highcharts/chart/reflow-true/
		 *            With
		 * @sample    {highcharts} highcharts/xaxis/categories/
		 *            Without
		 * @product   highcharts
		 * @default   null
		 * @apioption xAxis.categories
		 */
		// categories: [],

		/**
		 * The highest allowed value for automatically computed axis extremes.
		 *
		 * @type      {Number}
		 * @see       [floor](#xAxis.floor)
		 * @sample    {highcharts|highstock} highcharts/yaxis/floor-ceiling/
		 *            Floor and ceiling
		 * @since     4.0
		 * @product   highcharts highstock
		 * @apioption xAxis.ceiling
		 */

		/**
		 * A class name that opens for styling the axis by CSS, especially in
		 * Highcharts styled mode. The class name is applied to group elements
		 * for the grid, axis elements and labels.
		 *
		 * @type      {String}
		 * @sample    {highcharts|highstock|highmaps}
		 *            highcharts/css/axis/
		 *            Multiple axes with separate styling
		 * @since     5.0.0
		 * @apioption xAxis.className
		 */

		/**
		 * Configure a crosshair that follows either the mouse pointer or the
		 * hovered point.
		 *
		 * In styled mode, the crosshairs are styled in the
		 * `.highcharts-crosshair`, `.highcharts-crosshair-thin` or
		 * `.highcharts-xaxis-category` classes.
		 *
		 * @productdesc {highstock}
		 * In Highstock, bu default, the crosshair is enabled on the X axis and
		 * disabled on the Y axis.
		 *
		 * @type      {Boolean|Object}
		 * @sample    {highcharts} highcharts/xaxis/crosshair-both/
		 *            Crosshair on both axes
		 * @sample    {highstock} stock/xaxis/crosshairs-xy/
		 *            Crosshair on both axes
		 * @sample    {highmaps} highcharts/xaxis/crosshair-both/
		 *            Crosshair on both axes
		 * @default   false
		 * @since     4.1
		 * @apioption xAxis.crosshair
		 */

		/**
		 * A class name for the crosshair, especially as a hook for styling.
		 *
		 * @type      {String}
		 * @since     5.0.0
		 * @apioption xAxis.crosshair.className
		 */

		/**
		 * The color of the crosshair. Defaults to `#cccccc` for numeric and
		 * datetime axes, and `rgba(204,214,235,0.25)` for category axes, where
		 * the crosshair by default highlights the whole category.
		 *
		 * @type      {Color}
		 * @sample    {highcharts|highstock|highmaps}
		 *            highcharts/xaxis/crosshair-customized/
		 *            Customized crosshairs
		 * @default   #cccccc
		 * @since     4.1
		 * @apioption xAxis.crosshair.color
		 */

		/**
		 * The dash style for the crosshair. See
		 * [series.dashStyle](#plotOptions.series.dashStyle)
		 * for possible values.
		 *
		 * @validvalue ["Solid", "ShortDash", "ShortDot", "ShortDashDot",
		 *              "ShortDashDotDot", "Dot", "Dash" ,"LongDash",
		 *              "DashDot", "LongDashDot", "LongDashDotDot"]
		 * @type       {String}
		 * @sample     {highcharts|highmaps} highcharts/xaxis/crosshair-dotted/
		 *             Dotted crosshair
		 * @sample     {highstock} stock/xaxis/crosshair-dashed/
		 *             Dashed X axis crosshair
		 * @default    Solid
		 * @since      4.1
		 * @apioption  xAxis.crosshair.dashStyle
		 */

		/**
		 * Whether the crosshair should snap to the point or follow the pointer
		 * independent of points.
		 *
		 * @type      {Boolean}
		 * @sample    {highcharts|highstock}
		 *            highcharts/xaxis/crosshair-snap-false/
		 *            True by default
		 * @sample    {highmaps}
		 *            maps/demo/latlon-advanced/
		 *            Snap is false
		 * @default   true
		 * @since     4.1
		 * @apioption xAxis.crosshair.snap
		 */

		/**
		 * The pixel width of the crosshair. Defaults to 1 for numeric or
		 * datetime axes, and for one category width for category axes.
		 *
		 * @type      {Number}
		 * @sample    {highcharts} highcharts/xaxis/crosshair-customized/
		 *            Customized crosshairs
		 * @sample    {highstock} highcharts/xaxis/crosshair-customized/
		 *            Customized crosshairs
		 * @sample    {highmaps} highcharts/xaxis/crosshair-customized/
		 *            Customized crosshairs
		 * @default   1
		 * @since     4.1
		 * @apioption xAxis.crosshair.width
		 */

		/**
		 * The Z index of the crosshair. Higher Z indices allow drawing the
		 * crosshair on top of the series or behind the grid lines.
		 *
		 * @type      {Number}
		 * @default   2
		 * @since     4.1
		 * @apioption xAxis.crosshair.zIndex
		 */

		/**
		 * For a datetime axis, the scale will automatically adjust to the
		 * appropriate unit. This member gives the default string
		 * representations used for each unit. For intermediate values,
		 * different units may be used, for example the `day` unit can be used
		 * on midnight and `hour` unit be used for intermediate values on the
		 * same axis. For an overview of the replacement codes, see
		 * [dateFormat](#Highcharts.dateFormat). Defaults to:
		 * 
		 * <pre>{
		 *     millisecond: '%H:%M:%S.%L',
		 *     second: '%H:%M:%S',
		 *     minute: '%H:%M',
		 *     hour: '%H:%M',
		 *     day: '%e. %b',
		 *     week: '%e. %b',
		 *     month: '%b \'%y',
		 *     year: '%Y'
		 * }</pre>
		 * 
		 * @type    {Object}
		 * @sample  {highcharts} highcharts/xaxis/datetimelabelformats/
		 *          Different day format on X axis
		 * @sample  {highstock} stock/xaxis/datetimelabelformats/
		 *          More information in x axis labels
		 * @product highcharts highstock
		 */
		dateTimeLabelFormats: {
			millisecond: '%H:%M:%S.%L',
			second: '%H:%M:%S',
			minute: '%H:%M',
			hour: '%H:%M',
			day: '%e. %b',
			week: '%e. %b',
			month: '%b \'%y',
			year: '%Y'
		},

		/**
		 * _Requires Accessibility module_
		 *
		 * Description of the axis to screen reader users.
		 *
		 * @type      {String}
		 * @default   undefined
		 * @since     5.0.0
		 * @apioption xAxis.description
		 */

		/**
		 * Whether to force the axis to end on a tick. Use this option with
		 * the `maxPadding` option to control the axis end.
		 *
		 * @productdesc {highstock}
		 * In Highstock, `endOnTick` is always false when the navigator is
		 * enabled, to prevent jumpy scrolling.
		 * 
		 * @sample {highcharts} highcharts/chart/reflow-true/
		 *         True by default
		 * @sample {highcharts} highcharts/yaxis/endontick/
		 *         False
		 * @sample {highstock} stock/demo/basic-line/
		 *         True by default
		 * @sample {highstock} stock/xaxis/endontick/
		 *         False
		 * @since  1.2.0
		 */
		endOnTick: false,

		/**
		 * Event handlers for the axis.
		 *
		 * @apioption xAxis.events
		 */

		/**
		 * An event fired after the breaks have rendered.
		 *
		 * @type      {Function}
		 * @see       [breaks](#xAxis.breaks)
		 * @sample    {highcharts} highcharts/axisbreak/break-event/
		 *            AfterBreak Event
		 * @since     4.1.0
		 * @product   highcharts
		 * @apioption xAxis.events.afterBreaks
		 */

		/**
		 * As opposed to the `setExtremes` event, this event fires after the
		 * final min and max values are computed and corrected for `minRange`.
		 *
		 *
		 * Fires when the minimum and maximum is set for the axis, either by
		 * calling the `.setExtremes()` method or by selecting an area in the
		 * chart. One parameter, `event`, is passed to the function, containing
		 * common event information.
		 *
		 * The new user set minimum and maximum values can be found by `event.
		 * min` and `event.max`. These reflect the axis minimum and maximum
		 * in axis values. The actual data extremes are found in `event.dataMin`
		 * and `event.dataMax`.
		 *
		 * @type      {Function}
		 * @context   Axis
		 * @since     2.3
		 * @apioption xAxis.events.afterSetExtremes
		 */

		/**
		 * An event fired when a break from this axis occurs on a point.
		 *
		 * @type      {Function}
		 * @see       [breaks](#xAxis.breaks)
		 * @context   Axis
		 * @sample    {highcharts} highcharts/axisbreak/break-visualized/
		 *            Visualization of a Break
		 * @since     4.1.0
		 * @product   highcharts
		 * @apioption xAxis.events.pointBreak
		 */

		/**
		 * An event fired when a point falls inside a break from this axis.
		 *
		 * @type      {Function}
		 * @context   Axis
		 * @product   highcharts highstock
		 * @apioption xAxis.events.pointInBreak
		 */

		/**
		 * Fires when the minimum and maximum is set for the axis, either by
		 * calling the `.setExtremes()` method or by selecting an area in the
		 * chart. One parameter, `event`, is passed to the function,
		 * containing common event information.
		 *
		 * The new user set minimum and maximum values can be found by `event.
		 * min` and `event.max`. These reflect the axis minimum and maximum
		 * in data values. When an axis is zoomed all the way out from the 
		 * "Reset zoom" button, `event.min` and `event.max` are null, and
		 * the new extremes are set based on `this.dataMin` and `this.dataMax`.
		 *
		 * @type      {Function}
		 * @context   Axis
		 * @sample    {highstock} stock/xaxis/events-setextremes/
		 *            Log new extremes on x axis
		 * @since     1.2.0
		 * @apioption xAxis.events.setExtremes
		 */

		/**
		 * The lowest allowed value for automatically computed axis extremes.
		 *
		 * @type      {Number}
		 * @see       [ceiling](#yAxis.ceiling)
		 * @sample    {highcharts} highcharts/yaxis/floor-ceiling/
		 *            Floor and ceiling
		 * @sample    {highstock} stock/demo/lazy-loading/
		 *            Prevent negative stock price on Y axis
		 * @default   null
		 * @since     4.0
		 * @product   highcharts highstock
		 * @apioption xAxis.floor
		 */

		/**
		 * The dash or dot style of the grid lines. For possible values, see
		 * [this demonstration](http://jsfiddle.net/gh/get/library/pure/
		 *highcharts/highcharts/tree/master/samples/highcharts/plotoptions/
		 *series-dashstyle-all/).
		 *
		 * @validvalue ["Solid", "ShortDash", "ShortDot", "ShortDashDot",
		 *              "ShortDashDotDot", "Dot", "Dash" ,"LongDash",
		 *              "DashDot", "LongDashDot", "LongDashDotDot"]
		 * @type       {String}
		 * @sample     {highcharts} highcharts/yaxis/gridlinedashstyle/
		 *             Long dashes
		 * @sample     {highstock} stock/xaxis/gridlinedashstyle/
		 *             Long dashes
		 * @default    Solid
		 * @since      1.2
		 * @apioption  xAxis.gridLineDashStyle
		 */

		/**
		 * The Z index of the grid lines.
		 *
		 * @type      {Number}
		 * @sample    {highcharts|highstock} highcharts/xaxis/gridzindex/
		 *            A Z index of 4 renders the grid above the graph
		 * @default   1
		 * @product   highcharts highstock
		 * @apioption xAxis.gridZIndex
		 */

		/**
		 * An id for the axis. This can be used after render time to get
		 * a pointer to the axis object through `chart.get()`.
		 *
		 * @type      {String}
		 * @sample    {highcharts} highcharts/xaxis/id/
		 *            Get the object
		 * @sample    {highstock} stock/xaxis/id/
		 *            Get the object
		 * @default   null
		 * @since     1.2.0
		 * @apioption xAxis.id
		 */

		/**
		 * The axis labels show the number or category for each tick.
		 *
		 * @productdesc {highmaps}
		 * X and Y axis labels are by default disabled in Highmaps, but the
		 * functionality is inherited from Highcharts and used on `colorAxis`,
		 * and can be enabled on X and Y axes too.
		 */
		labels: {
			/**
			 * What part of the string the given position is anchored to.
			 * If `left`, the left side of the string is at the axis position.
			 * Can be one of `"left"`, `"center"` or `"right"`. Defaults to
			 * an intelligent guess based on which side of the chart the axis
			 * is on and the rotation of the label.
			 *
			 * @validvalue ["left", "center", "right"]
			 * @type       {String}
			 * @sample     {highcharts} highcharts/xaxis/labels-align-left/
			 *             Left
			 * @sample     {highcharts} highcharts/xaxis/labels-align-right/
			 *             Right
			 * @sample     {highcharts}
			 *             highcharts/xaxis/labels-reservespace-true/
			 *             Left-aligned labels on a vertical category axis
			 * @see        [reserveSpace](#xAxis.labels.reserveSpace)
			 * @apioption  xAxis.labels.align
			 */
			// align: 'center',

			/**
			 * For horizontal axes, the allowed degrees of label rotation
			 * to prevent overlapping labels. If there is enough space,
			 * labels are not rotated. As the chart gets narrower, it
			 * will start rotating the labels -45 degrees, then remove
			 * every second label and try again with rotations 0 and -45 etc.
			 * Set it to `false` to disable rotation, which will
			 * cause the labels to word-wrap if possible.
			 *
			 * @type      {Array<Number>}
			 * @sample    {highcharts|highstock}
			 *            highcharts/xaxis/labels-autorotation-default/
			 *            Default auto rotation of 0 or -45
			 * @sample    {highcharts|highstock}
			 *            highcharts/xaxis/labels-autorotation-0-90/
			 *            Custom graded auto rotation
			 * @default   [-45]
			 * @since     4.1.0
			 * @product   highcharts highstock
			 * @apioption xAxis.labels.autoRotation
			 */

			/**
			 * When each category width is more than this many pixels, we don't
			 * apply auto rotation. Instead, we lay out the axis label with word
			 * wrap. A lower limit makes sense when the label contains multiple
			 * short words that don't extend the available horizontal space for
			 * each label.
			 *
			 * @type      {Number}
			 * @sample    {highcharts}
			 *            highcharts/xaxis/labels-autorotationlimit/
			 *            Lower limit
			 * @default   80
			 * @since     4.1.5
			 * @product   highcharts
			 * @apioption xAxis.labels.autoRotationLimit
			 */

			/**
			 * Polar charts only. The label's pixel distance from the perimeter
			 * of the plot area.
			 *
			 * @type      {Number}
			 * @default   15
			 * @product   highcharts
			 * @apioption xAxis.labels.distance
			 */

			/**
			 * Enable or disable the axis labels.
			 * 
			 * @sample  {highcharts} highcharts/xaxis/labels-enabled/
			 *          X axis labels disabled
			 * @sample  {highstock} stock/xaxis/labels-enabled/
			 *          X axis labels disabled
			 * @default {highcharts|highstock} true
			 * @default {highmaps} false
			 */
			enabled: true,

			/**
			 * A [format string](http://www.highcharts.com/docs/chart-
			 * concepts/labels-and-string-formatting) for the axis label.
			 *
			 * @type      {String}
			 * @sample    {highcharts|highstock} highcharts/yaxis/labels-format/
			 *            Add units to Y axis label
			 * @default   {value}
			 * @since     3.0
			 * @apioption xAxis.labels.format
			 */

			/**
			 * Callback JavaScript function to format the label. The value
			 * is given by `this.value`. Additional properties for `this` are
			 * `axis`, `chart`, `isFirst` and `isLast`. The value of the default
			 * label formatter can be retrieved by calling
			 * `this.axis.defaultLabelFormatter.call(this)` within the function.
			 *
			 * Defaults to:
			 *
			 * <pre>function() {
			 *     return this.value;
			 * }</pre>
			 *
			 * @type      {Function}
			 * @sample    {highcharts}
			 *            highcharts/xaxis/labels-formatter-linked/
			 *            Linked category names
			 * @sample    {highcharts}
			 *            highcharts/xaxis/labels-formatter-extended/
			 *            Modified numeric labels
			 * @sample    {highstock}
			 *            stock/xaxis/labels-formatter/
			 *            Added units on Y axis
			 * @apioption xAxis.labels.formatter
			 */

			/**
			 * How to handle overflowing labels on horizontal axis. Can be
			 * undefined, `false` or `"justify"`. By default it aligns inside
			 * the chart area. If "justify", labels will not render outside
			 * the plot area. If `false`, it will not be aligned at all.
			 * If there is room to move it, it will be aligned to the edge,
			 * else it will be removed.
			 *
			 * @deprecated
			 * @validvalue [null, "justify"]
			 * @type       {String}
			 * @since      2.2.5
			 * @apioption  xAxis.labels.overflow
			 */

			/**
			 * The pixel padding for axis labels, to ensure white space between
			 * them.
			 *
			 * @type      {Number}
			 * @default   5
			 * @product   highcharts
			 * @apioption xAxis.labels.padding
			 */

			/**
			 * Whether to reserve space for the labels. By default, space is
			 * reserved for the labels in these cases:
			 * 
			 * * On all horizontal axes.
			 * * On vertical axes if `label.align` is `right` on a left-side
			 * axis or `left` on a right-side axis.
			 * * On vertical axes if `label.align` is `center`.
			 * 
			 * This can be turned off when for example the labels are rendered
			 * inside the plot area instead of outside.
			 *
			 * @type      {Boolean}
			 * @sample    {highcharts} highcharts/xaxis/labels-reservespace/
			 *            No reserved space, labels inside plot
			 * @sample    {highcharts}
			 *            highcharts/xaxis/labels-reservespace-true/
			 *            Left-aligned labels on a vertical category axis
			 * @see       [labels.align](#xAxis.labels.align)
			 * @default   null
			 * @since     4.1.10
			 * @product   highcharts
			 * @apioption xAxis.labels.reserveSpace
			 */

			/**
			 * Rotation of the labels in degrees.
			 *
			 * @type      {Number}
			 * @sample    {highcharts} highcharts/xaxis/labels-rotation/
			 *            X axis labels rotated 90
			 * @default   0
			 * @apioption xAxis.labels.rotation
			 */
			// rotation: 0,

			/**
			 * Horizontal axes only. The number of lines to spread the labels
			 * over to make room or tighter labels.
			 *
			 * @type      {Number}
			 * @sample    {highcharts} highcharts/xaxis/labels-staggerlines/
			 *            Show labels over two lines
			 * @sample    {highstock} stock/xaxis/labels-staggerlines/
			 *            Show labels over two lines
			 * @default   null
			 * @since     2.1
			 * @apioption xAxis.labels.staggerLines
			 */

			/**
			 * To show only every _n_'th label on the axis, set the step to _n_.
			 * Setting the step to 2 shows every other label.
			 *
			 * By default, the step is calculated automatically to avoid
			 * overlap. To prevent this, set it to 1\. This usually only
			 * happens on a category axis, and is often a sign that you have
			 * chosen the wrong axis type.
			 *
			 * Read more at
			 * [Axis docs](http://www.highcharts.com/docs/chart-concepts/axes)
			 * => What axis should I use?
			 *
			 * @type      {Number}
			 * @sample    {highcharts} highcharts/xaxis/labels-step/
			 *            Showing only every other axis label on a categorized
			 *            x axis
			 * @sample    {highcharts} highcharts/xaxis/labels-step-auto/
			 *            Auto steps on a category axis
			 * @default   null
			 * @since     2.1
			 * @apioption xAxis.labels.step
			 */
			// step: null,

			

			/**
			 * CSS styles for the label. Use `whiteSpace: 'nowrap'` to prevent
			 * wrapping of category labels. Use `textOverflow: 'none'` to
			 * prevent ellipsis (dots).
			 * 
			 * In styled mode, the labels are styled with the
			 * `.highcharts-axis-labels` class.
			 * 
			 * @type   {CSSObject}
			 * @sample {highcharts} highcharts/xaxis/labels-style/
			 *         Red X axis labels
			 */
			style: {
				color: '#666666',
				cursor: 'default',
				fontSize: '11px'
			},
			

			/**
			 * Whether to [use HTML](http://www.highcharts.com/docs/chart-
			 * concepts/labels-and-string-formatting#html) to render the labels.
			 *
			 * @type      {Boolean}
			 * @default   false
			 * @apioption xAxis.labels.useHTML
			 */

			/**
			 * The x position offset of the label relative to the tick position
			 * on the axis.
			 * 
			 * @sample {highcharts} highcharts/xaxis/labels-x/
			 *         Y axis labels placed on grid lines
			 */
			x: 0

			/**
			 * The y position offset of the label relative to the tick position
			 * on the axis. The default makes it adapt to the font size on
			 * bottom axis.
			 *
			 * @type      {Number}
			 * @sample    {highcharts} highcharts/xaxis/labels-x/
			 *            Y axis labels placed on grid lines
			 * @default   null
			 * @apioption xAxis.labels.y
			 */

			/**
			 * The Z index for the axis labels.
			 *
			 * @type {Number}
			 * @default 7
			 * @apioption xAxis.labels.zIndex
			 */
		},

		/**
		 * Index of another axis that this axis is linked to. When an axis is
		 * linked to a master axis, it will take the same extremes as
		 * the master, but as assigned by min or max or by setExtremes.
		 * It can be used to show additional info, or to ease reading the
		 * chart by duplicating the scales.
		 *
		 * @type      {Number}
		 * @sample    {highcharts} highcharts/xaxis/linkedto/
		 *            Different string formats of the same date
		 * @sample    {highcharts} highcharts/yaxis/linkedto/
		 *            Y values on both sides
		 * @default   null
		 * @since     2.0.2
		 * @product   highcharts highstock
		 * @apioption xAxis.linkedTo
		 */

		/**
		 * The maximum value of the axis. If `null`, the max value is
		 * automatically calculated.
		 *
		 * If the `endOnTick` option is true, the `max` value might
		 * be rounded up.
		 *
		 * If a [tickAmount](#yAxis.tickAmount) is set, the axis may be extended
		 * beyond the set max in order to reach the given number of ticks. The
		 * same may happen in a chart with multiple axes, determined by [chart.
		 * alignTicks](#chart), where a `tickAmount` is applied internally.
		 *
		 * @type      {Number}
		 * @sample    {highcharts} highcharts/yaxis/max-200/
		 *            Y axis max of 200
		 * @sample    {highcharts} highcharts/yaxis/max-logarithmic/
		 *            Y axis max on logarithmic axis
		 * @sample    {highstock} stock/xaxis/min-max/
		 *            Fixed min and max on X axis
		 * @sample    {highmaps} maps/axis/min-max/
		 *            Pre-zoomed to a specific area
		 * @apioption xAxis.max
		 */

		/**
		 * Padding of the max value relative to the length of the axis. A
		 * padding of 0.05 will make a 100px axis 5px longer. This is useful
		 * when you don't want the highest data value to appear on the edge
		 * of the plot area. When the axis' `max` option is set or a max extreme
		 * is set using `axis.setExtremes()`, the maxPadding will be ignored.
		 * 
		 * @sample  {highcharts} highcharts/yaxis/maxpadding/
		 *          Max padding of 0.25 on y axis
		 * @sample  {highstock} stock/xaxis/minpadding-maxpadding/
		 *          Greater min- and maxPadding
		 * @sample  {highmaps} maps/chart/plotbackgroundcolor-gradient/
		 *          Add some padding
		 * @default {highcharts} 0.01
		 * @default {highstock|highmaps} 0
		 * @since   1.2.0
		 */
		maxPadding: 0.01,

		/**
		 * Deprecated. Use `minRange` instead.
		 *
		 * @deprecated
		 * @type       {Number}
		 * @product    highcharts highstock
		 * @apioption  xAxis.maxZoom
		 */

		/**
		 * The minimum value of the axis. If `null` the min value is 
		 * automatically calculated.
		 *
		 * If the `startOnTick` option is true (default), the `min` value might
		 * be rounded down.
		 *
		 * The automatically calculated minimum value is also affected by
		 * [floor](#yAxis.floor), [softMin](#yAxis.softMin),
		 * [minPadding](#yAxis.minPadding), [minRange](#yAxis.minRange)
		 * as well as [series.threshold](#plotOptions.series.threshold)
		 * and [series.softThreshold](#plotOptions.series.softThreshold).
		 *
		 * @type      {Number}
		 * @sample    {highcharts} highcharts/yaxis/min-startontick-false/
		 *            -50 with startOnTick to false
		 * @sample    {highcharts} highcharts/yaxis/min-startontick-true/
		 *            -50 with startOnTick true by default
		 * @sample    {highstock} stock/xaxis/min-max/
		 *            Set min and max on X axis
		 * @sample    {highmaps} maps/axis/min-max/
		 *            Pre-zoomed to a specific area
		 * @apioption xAxis.min
		 */

		/**
		 * The dash or dot style of the minor grid lines. For possible values,
		 * see [this demonstration](http://jsfiddle.net/gh/get/library/pure/
		 * highcharts/highcharts/tree/master/samples/highcharts/plotoptions/
		 * series-dashstyle-all/).
		 *
		 * @validvalue ["Solid", "ShortDash", "ShortDot", "ShortDashDot",
		 *              "ShortDashDotDot", "Dot", "Dash" ,"LongDash",
		 *              "DashDot", "LongDashDot", "LongDashDotDot"]
		 * @type       {String}
		 * @sample     {highcharts} highcharts/yaxis/minorgridlinedashstyle/
		 *             Long dashes on minor grid lines
		 * @sample     {highstock} stock/xaxis/minorgridlinedashstyle/
		 *             Long dashes on minor grid lines
		 * @default    Solid
		 * @since      1.2
		 * @apioption  xAxis.minorGridLineDashStyle
		 */

		/**
		 * Specific tick interval in axis units for the minor ticks.
		 * On a linear axis, if `"auto"`, the minor tick interval is
		 * calculated as a fifth of the tickInterval. If `null`, minor
		 * ticks are not shown.
		 *
		 * On logarithmic axes, the unit is the power of the value. For example,
		 * setting the minorTickInterval to 1 puts one tick on each of 0.1,
		 * 1, 10, 100 etc. Setting the minorTickInterval to 0.1 produces 9
		 * ticks between 1 and 10, 10 and 100 etc.
		 *
		 * If user settings dictate minor ticks to become too dense, they don't
		 * make sense, and will be ignored to prevent performance problems.
		 *
		 * @type      {Number|String}
		 * @sample    {highcharts} highcharts/yaxis/minortickinterval-null/
		 *            Null by default
		 * @sample    {highcharts} highcharts/yaxis/minortickinterval-5/
		 *            5 units
		 * @sample    {highcharts} highcharts/yaxis/minortickinterval-log-auto/
		 *            "auto"
		 * @sample    {highcharts} highcharts/yaxis/minortickinterval-log/
		 *            0.1
		 * @sample    {highstock} stock/demo/basic-line/
		 *            Null by default
		 * @sample    {highstock} stock/xaxis/minortickinterval-auto/
		 *            "auto"
		 * @apioption xAxis.minorTickInterval
		 */

		/**
		 * The pixel length of the minor tick marks.
		 * 
		 * @sample {highcharts} highcharts/yaxis/minorticklength/
		 *         10px on Y axis
		 * @sample {highstock} stock/xaxis/minorticks/
		 *         10px on Y axis
		 */
		minorTickLength: 2,

		/**
		 * The position of the minor tick marks relative to the axis line.
		 *  Can be one of `inside` and `outside`.
		 * 
		 * @validvalue ["inside", "outside"]
		 * @sample     {highcharts} highcharts/yaxis/minortickposition-outside/
		 *             Outside by default
		 * @sample     {highcharts} highcharts/yaxis/minortickposition-inside/
		 *             Inside
		 * @sample     {highstock} stock/xaxis/minorticks/
		 *             Inside
		 */
		minorTickPosition: 'outside',

		/**
		 * Enable or disable minor ticks. Unless
		 * [minorTickInterval](#xAxis.minorTickInterval) is set, the tick
		 * interval is calculated as a fifth of the `tickInterval`.
		 *
		 * On a logarithmic axis, minor ticks are laid out based on a best
		 * guess, attempting to enter approximately 5 minor ticks between
		 * each major tick.
		 *
		 * Prior to v6.0.0, ticks were unabled in auto layout by setting
		 * `minorTickInterval` to `"auto"`.
		 *
		 * @productdesc {highcharts}
		 * On axes using [categories](#xAxis.categories), minor ticks are not
		 * supported.
		 *
		 * @type      {Boolean}
		 * @default   false
		 * @since     6.0.0
		 * @sample    {highcharts} highcharts/yaxis/minorticks-true/
		 *            Enabled on linear Y axis
		 * @apioption xAxis.minorTicks
		 */

		/**
		 * The pixel width of the minor tick mark.
		 *
		 * @type      {Number}
		 * @sample    {highcharts} highcharts/yaxis/minortickwidth/
		 *            3px width
		 * @sample    {highstock} stock/xaxis/minorticks/
		 *            1px width
		 * @default   0
		 * @apioption xAxis.minorTickWidth
		 */
		
		/**
		 * Padding of the min value relative to the length of the axis. A
		 * padding of 0.05 will make a 100px axis 5px longer. This is useful
		 * when you don't want the lowest data value to appear on the edge
		 * of the plot area. When the axis' `min` option is set or a min extreme
		 * is set using `axis.setExtremes()`, the minPadding will be ignored.
		 * 
		 * @sample  {highcharts} highcharts/yaxis/minpadding/
		 *          Min padding of 0.2
		 * @sample  {highstock} stock/xaxis/minpadding-maxpadding/
		 *          Greater min- and maxPadding
		 * @sample  {highmaps} maps/chart/plotbackgroundcolor-gradient/
		 *          Add some padding
		 * @default {highcharts} 0.01
		 * @default {highstock|highmaps} 0
		 * @since   1.2.0
		 */
		minPadding: 0.01,

		/**
		 * The minimum range to display on this axis. The entire axis will not
		 * be allowed to span over a smaller interval than this. For example,
		 * for a datetime axis the main unit is milliseconds. If minRange is
		 * set to 3600000, you can't zoom in more than to one hour.
		 *
		 * The default minRange for the x axis is five times the smallest
		 * interval between any of the data points.
		 *
		 * On a logarithmic axis, the unit for the minimum range is the power.
		 * So a minRange of 1 means that the axis can be zoomed to 10-100,
		 * 100-1000, 1000-10000 etc.
		 *
		 * Note that the `minPadding`, `maxPadding`, `startOnTick` and
		 * `endOnTick` settings also affect how the extremes of the axis
		 * are computed.
		 *
		 * @type      {Number}
		 * @sample    {highcharts} highcharts/xaxis/minrange/
		 *            Minimum range of 5
		 * @sample    {highstock} stock/xaxis/minrange/
		 *            Max zoom of 6 months overrides user selections
		 * @sample    {highmaps} maps/axis/minrange/
		 *            Minimum range of 1000
		 * @apioption xAxis.minRange
		 */

		/**
		 * The minimum tick interval allowed in axis values. For example on
		 * zooming in on an axis with daily data, this can be used to prevent
		 * the axis from showing hours. Defaults to the closest distance between
		 * two points on the axis.
		 *
		 * @type      {Number}
		 * @since     2.3.0
		 * @apioption xAxis.minTickInterval
		 */

		/**
		 * The distance in pixels from the plot area to the axis line.
		 * A positive offset moves the axis with it's line, labels and ticks
		 * away from the plot area. This is typically used when two or more
		 * axes are displayed on the same side of the plot. With multiple
		 * axes the offset is dynamically adjusted to avoid collision, this
		 * can be overridden by setting offset explicitly.
		 *
		 * @type      {Number}
		 * @sample    {highcharts} highcharts/yaxis/offset/
		 *            Y axis offset of 70
		 * @sample    {highcharts} highcharts/yaxis/offset-centered/
		 *            Axes positioned in the center of the plot
		 * @sample    {highstock} stock/xaxis/offset/
		 *            Y axis offset by 70 px
		 * @default   0
		 * @apioption xAxis.offset
		 */

		/**
		 * Whether to display the axis on the opposite side of the normal. The
		 * normal is on the left side for vertical axes and bottom for
		 * horizontal, so the opposite sides will be right and top respectively.
		 * This is typically used with dual or multiple axes.
		 *
		 * @type      {Boolean}
		 * @sample    {highcharts} highcharts/yaxis/opposite/
		 *            Secondary Y axis opposite
		 * @sample    {highstock} stock/xaxis/opposite/
		 *            Y axis on left side
		 * @default   false
		 * @apioption xAxis.opposite
		 */

		/**
		 * Refers to the index in the [panes](#panes) array. Used for circular
		 * gauges and polar charts. When the option is not set then first pane
		 * will be used.
		 *
		 * @type      {Number}
		 * @sample    highcharts/demo/gauge-vu-meter
		 *            Two gauges with different center
		 * @product   highcharts
		 * @apioption xAxis.pane
		 */
		
		/**
		 * Whether to reverse the axis so that the highest number is closest
		 * to the origin. If the chart is inverted, the x axis is reversed by
		 * default.
		 *
		 * @type      {Boolean}
		 * @sample    {highcharts} highcharts/yaxis/reversed/
		 *            Reversed Y axis
		 * @sample    {highstock} stock/xaxis/reversed/
		 *            Reversed Y axis
		 * @default   false
		 * @apioption xAxis.reversed
		 */
		// reversed: false,

		/**
		 * Whether to show the last tick label. Defaults to `true` on cartesian
		 * charts, and `false` on polar charts.
		 *
		 * @type      {Boolean}
		 * @sample    {highcharts} highcharts/xaxis/showlastlabel-true/
		 *            Set to true on X axis
		 * @sample    {highstock} stock/xaxis/showfirstlabel/
		 *            Labels below plot lines on Y axis
		 * @default   true
		 * @product   highcharts highstock
		 * @apioption xAxis.showLastLabel
		 */
		
		/**
		 * For datetime axes, this decides where to put the tick between weeks.
		 *  0 = Sunday, 1 = Monday.
		 * 
		 * @sample  {highcharts} highcharts/xaxis/startofweek-monday/
		 *          Monday by default
		 * @sample  {highcharts} highcharts/xaxis/startofweek-sunday/
		 *          Sunday
		 * @sample  {highstock} stock/xaxis/startofweek-1
		 *          Monday by default
		 * @sample  {highstock} stock/xaxis/startofweek-0
		 *          Sunday
		 * @product highcharts highstock
		 */
		startOfWeek: 1,

		/**
		 * Whether to force the axis to start on a tick. Use this option with
		 * the `minPadding` option to control the axis start.
		 *
		 * @productdesc {highstock}
		 * In Highstock, `startOnTick` is always false when the navigator is
		 * enabled, to prevent jumpy scrolling.
		 * 
		 * @sample  {highcharts} highcharts/xaxis/startontick-false/
		 *          False by default
		 * @sample  {highcharts} highcharts/xaxis/startontick-true/
		 *          True
		 * @sample  {highstock} stock/xaxis/endontick/
		 *          False for Y axis
		 * @since   1.2.0
		 */
		startOnTick: false,
		
		/**
		 * The pixel length of the main tick marks.
		 * 
		 * @sample {highcharts} highcharts/xaxis/ticklength/
		 *         20 px tick length on the X axis
		 * @sample {highstock} stock/xaxis/ticks/
		 *         Formatted ticks on X axis
		 */
		tickLength: 10,

		/**
		 * For categorized axes only. If `on` the tick mark is placed in the
		 * center of the category, if `between` the tick mark is placed between
		 * categories. The default is `between` if the `tickInterval` is 1,
		 *  else `on`.
		 * 
		 * @validvalue [null, "on", "between"]
		 * @sample     {highcharts} highcharts/xaxis/tickmarkplacement-between/
		 *             "between" by default
		 * @sample     {highcharts} highcharts/xaxis/tickmarkplacement-on/
		 *             "on"
		 * @product    highcharts
		 */
		tickmarkPlacement: 'between',

		/**
		 * If tickInterval is `null` this option sets the approximate pixel
		 * interval of the tick marks. Not applicable to categorized axis.
		 * 
		 * The tick interval is also influenced by the [minTickInterval](#xAxis.
		 * minTickInterval) option, that, by default prevents ticks from being
		 * denser than the data points.
		 * 
		 * @see    [tickInterval](#xAxis.tickInterval),
		 *         [tickPositioner](#xAxis.tickPositioner),
		 *         [tickPositions](#xAxis.tickPositions).
		 * @sample {highcharts} highcharts/xaxis/tickpixelinterval-50/
		 *         50 px on X axis
		 * @sample {highstock} stock/xaxis/tickpixelinterval/
		 *         200 px on X axis
		 */
		tickPixelInterval: 100,

		/**
		 * The position of the major tick marks relative to the axis line.
		 * Can be one of `inside` and `outside`.
		 * 
		 * @validvalue ["inside", "outside"]
		 * @sample     {highcharts} highcharts/xaxis/tickposition-outside/
		 *             "outside" by default
		 * @sample     {highcharts} highcharts/xaxis/tickposition-inside/
		 *             "inside"
		 * @sample     {highstock} stock/xaxis/ticks/
		 *             Formatted ticks on X axis
		 */
		tickPosition: 'outside',

		/**
		 * The axis title, showing next to the axis line.
		 *
		 * @productdesc {highmaps}
		 * In Highmaps, the axis is hidden by default, but adding an axis title
		 * is still possible. X axis and Y axis titles will appear at the bottom
		 * and left by default.
		 */
		title: {
			
			/**
			 * Alignment of the title relative to the axis values. Possible
			 * values are "low", "middle" or "high".
			 * 
			 * @validvalue ["low", "middle", "high"]
			 * @sample     {highcharts} highcharts/xaxis/title-align-low/
			 *             "low"
			 * @sample     {highcharts} highcharts/xaxis/title-align-center/
			 *             "middle" by default
			 * @sample     {highcharts} highcharts/xaxis/title-align-high/
			 *             "high"
			 * @sample     {highcharts} highcharts/yaxis/title-offset/
			 *             Place the Y axis title on top of the axis
			 * @sample     {highstock} stock/xaxis/title-align/
			 *             Aligned to "high" value
			 */
			align: 'middle',
			
			

			/**
			 * CSS styles for the title. If the title text is longer than the
			 * axis length, it will wrap to multiple lines by default. This can
			 * be customized by setting `textOverflow: 'ellipsis'`, by 
			 * setting a specific `width` or by setting `wordSpace: 'nowrap'`.
			 * 
			 * In styled mode, the stroke width is given in the
			 * `.highcharts-axis-title` class.
			 * 
			 * @type    {CSSObject}
			 * @sample  {highcharts} highcharts/xaxis/title-style/
			 *          Red
			 * @sample  {highcharts} highcharts/css/axis/
			 *          Styled mode
			 * @default { "color": "#666666" }
			 */
			style: {
				color: '#666666'
			}
			
		},

		/**
		 * The type of axis. Can be one of `linear`, `logarithmic`, `datetime`
		 * or `category`. In a datetime axis, the numbers are given in
		 * milliseconds, and tick marks are placed on appropriate values like
		 * full hours or days. In a category axis, the 
		 * [point names](#series.line.data.name) of the chart's series are used
		 * for categories, if not a [categories](#xAxis.categories) array is
		 * defined.
		 * 
		 * @validvalue ["linear", "logarithmic", "datetime", "category"]
		 * @sample     {highcharts} highcharts/xaxis/type-linear/
		 *             Linear
		 * @sample     {highcharts} highcharts/yaxis/type-log/
		 *             Logarithmic
		 * @sample     {highcharts} highcharts/yaxis/type-log-minorgrid/
		 *             Logarithmic with minor grid lines
		 * @sample     {highcharts} highcharts/xaxis/type-log-both/
		 *             Logarithmic on two axes
		 * @sample     {highcharts} highcharts/yaxis/type-log-negative/
		 *             Logarithmic with extension to emulate negative values
		 * @product    highcharts
		 */
		type: 'linear',
		
		

		/**
		 * Color of the minor, secondary grid lines.
		 * 
		 * In styled mode, the stroke width is given in the
		 * `.highcharts-minor-grid-line` class.
		 * 
		 * @type    {Color}
		 * @sample  {highcharts} highcharts/yaxis/minorgridlinecolor/
		 *          Bright grey lines from Y axis
		 * @sample  {highcharts|highstock} highcharts/css/axis-grid/
		 *          Styled mode
		 * @sample  {highstock} stock/xaxis/minorgridlinecolor/
		 *          Bright grey lines from Y axis
		 * @default #f2f2f2
		 */
		minorGridLineColor: '#f2f2f2',
		// minorGridLineDashStyle: null,

		/**
		 * Width of the minor, secondary grid lines.
		 * 
		 * In styled mode, the stroke width is given in the
		 * `.highcharts-grid-line` class.
		 * 
		 * @sample {highcharts} highcharts/yaxis/minorgridlinewidth/
		 *         2px lines from Y axis
		 * @sample {highcharts|highstock} highcharts/css/axis-grid/
		 *         Styled mode
		 * @sample {highstock} stock/xaxis/minorgridlinewidth/
		 *         2px lines from Y axis
		 */
		minorGridLineWidth: 1,

		/**
		 * Color for the minor tick marks.
		 * 
		 * @type    {Color}
		 * @sample  {highcharts} highcharts/yaxis/minortickcolor/
		 *          Black tick marks on Y axis
		 * @sample  {highstock} stock/xaxis/minorticks/
		 *          Black tick marks on Y axis
		 * @default #999999
		 */
		minorTickColor: '#999999',
		
		/**
		 * The color of the line marking the axis itself.
		 * 
		 * In styled mode, the line stroke is given in the
		 * `.highcharts-axis-line` or `.highcharts-xaxis-line` class.
		 * 
		 * @productdesc {highmaps}
		 * In Highmaps, the axis line is hidden by default, because the axis is
		 * not visible by default.
		 * 
		 * @type    {Color}
		 * @sample  {highcharts} highcharts/yaxis/linecolor/
		 *          A red line on Y axis
		 * @sample  {highcharts|highstock} highcharts/css/axis/
		 *          Axes in styled mode
		 * @sample  {highstock} stock/xaxis/linecolor/
		 *          A red line on X axis
		 * @default #ccd6eb
		 */
		lineColor: '#ccd6eb',

		/**
		 * The width of the line marking the axis itself.
		 * 
		 * In styled mode, the stroke width is given in the
		 * `.highcharts-axis-line` or `.highcharts-xaxis-line` class.
		 * 
		 * @sample  {highcharts} highcharts/yaxis/linecolor/
		 *          A 1px line on Y axis
		 * @sample  {highcharts|highstock} highcharts/css/axis/
		 *          Axes in styled mode
		 * @sample  {highstock} stock/xaxis/linewidth/
		 *          A 2px line on X axis
		 * @default {highcharts|highstock} 1
		 * @default {highmaps} 0
		 */
		lineWidth: 1,

		/**
		 * Color of the grid lines extending the ticks across the plot area.
		 * 
		 * In styled mode, the stroke is given in the `.highcharts-grid-line`
		 * class.
		 *
		 * @productdesc {highmaps}
		 * In Highmaps, the grid lines are hidden by default.
		 * 
		 * @type    {Color}
		 * @sample  {highcharts} highcharts/yaxis/gridlinecolor/
		 *          Green lines
		 * @sample  {highcharts|highstock} highcharts/css/axis-grid/
		 *          Styled mode
		 * @sample  {highstock} stock/xaxis/gridlinecolor/
		 *          Green lines
		 * @default #e6e6e6
		 */
		gridLineColor: '#e6e6e6',
		// gridLineDashStyle: 'solid',


		/**
		 * The width of the grid lines extending the ticks across the plot area.
		 *
		 * In styled mode, the stroke width is given in the
		 * `.highcharts-grid-line` class.
		 *
		 * @type      {Number}
		 * @sample    {highcharts} highcharts/yaxis/gridlinewidth/
		 *            2px lines
		 * @sample    {highcharts|highstock} highcharts/css/axis-grid/
		 *            Styled mode
		 * @sample    {highstock} stock/xaxis/gridlinewidth/
		 *            2px lines
		 * @default   0
		 * @apioption xAxis.gridLineWidth
		 */
		// gridLineWidth: 0,

		/**
		 * Color for the main tick marks.
		 * 
		 * In styled mode, the stroke is given in the `.highcharts-tick`
		 * class.
		 * 
		 * @type    {Color}
		 * @sample  {highcharts} highcharts/xaxis/tickcolor/
		 *          Red ticks on X axis
		 * @sample  {highcharts|highstock} highcharts/css/axis-grid/
		 *          Styled mode
		 * @sample  {highstock} stock/xaxis/ticks/
		 *          Formatted ticks on X axis
		 * @default #ccd6eb
		 */
		tickColor: '#ccd6eb'
		// tickWidth: 1
		
	},

	/**
	 * The Y axis or value axis. Normally this is the vertical axis,
	 * though if the chart is inverted this is the horizontal axis.
	 * In case of multiple axes, the yAxis node is an array of
	 * configuration objects.
	 *
	 * See [the Axis object](#Axis) for programmatic access to the axis.
	 *
	 * @extends      xAxis
	 * @excluding    ordinal,overscroll
	 * @optionparent yAxis
	 */
	defaultYAxisOptions: {
		/**
		 * @productdesc {highstock}
		 * In Highstock, `endOnTick` is always false when the navigator is
		 * enabled, to prevent jumpy scrolling.
		 */
		endOnTick: true,

		/**
		 * @productdesc {highstock}
		 * In Highstock 1.x, the Y axis was placed on the left side by default.
		 *
		 * @sample    {highcharts} highcharts/yaxis/opposite/
		 *            Secondary Y axis opposite
		 * @sample    {highstock} stock/xaxis/opposite/
		 *            Y axis on left side
		 * @default   {highstock} true
		 * @default   {highcharts} false
		 * @product   highstock highcharts
		 * @apioption yAxis.opposite
		 */

		/**
		 * @see [tickInterval](#xAxis.tickInterval),
		 *      [tickPositioner](#xAxis.tickPositioner),
		 *      [tickPositions](#xAxis.tickPositions).
		 */
		tickPixelInterval: 72,

		showLastLabel: true,

		/**
		 * @extends xAxis.labels
		 */
		labels: {
			/**
			 * What part of the string the given position is anchored to. Can
			 * be one of `"left"`, `"center"` or `"right"`. The exact position
			 * also depends on the `labels.x` setting.
			 *
			 * Angular gauges and solid gauges defaults to `center`.
			 *
			 * @validvalue ["left", "center", "right"]
			 * @type       {String}
			 * @sample     {highcharts} highcharts/yaxis/labels-align-left/
			 *             Left
			 * @default    {highcharts|highmaps} right
			 * @default    {highstock} left
			 * @apioption  yAxis.labels.align
			 */

			/**
			 * The x position offset of the label relative to the tick position
			 * on the axis. Defaults to -15 for left axis, 15 for right axis.
			 * 
			 * @sample {highcharts} highcharts/xaxis/labels-x/
			 *         Y axis labels placed on grid lines
			 */
			x: -8
		},

		/**
		 * @productdesc {highmaps}
		 * In Highmaps, the axis line is hidden by default, because the axis is
		 * not visible by default.
		 * 
		 * @apioption yAxis.lineColor
		 */

		/**
		 * @sample    {highcharts} highcharts/yaxis/min-startontick-false/
		 *            -50 with startOnTick to false
		 * @sample    {highcharts} highcharts/yaxis/min-startontick-true/
		 *            -50 with startOnTick true by default
		 * @sample    {highstock} stock/yaxis/min-max/
		 *            Fixed min and max on Y axis
		 * @sample    {highmaps} maps/axis/min-max/
		 *            Pre-zoomed to a specific area
		 * @apioption yAxis.min
		 */

		/**
		 * @sample    {highcharts} highcharts/yaxis/max-200/
		 *            Y axis max of 200
		 * @sample    {highcharts} highcharts/yaxis/max-logarithmic/
		 *            Y axis max on logarithmic axis
		 * @sample    {highstock} stock/yaxis/min-max/
		 *            Fixed min and max on Y axis
		 * @sample    {highmaps} maps/axis/min-max/
		 *            Pre-zoomed to a specific area
		 * @apioption yAxis.max
		 */

		/**
		 * Padding of the max value relative to the length of the axis. A
		 * padding of 0.05 will make a 100px axis 5px longer. This is useful
		 * when you don't want the highest data value to appear on the edge
		 * of the plot area. When the axis' `max` option is set or a max extreme
		 * is set using `axis.setExtremes()`, the maxPadding will be ignored.
		 * 
		 * @sample  {highcharts} highcharts/yaxis/maxpadding-02/
		 *          Max padding of 0.2
		 * @sample  {highstock} stock/xaxis/minpadding-maxpadding/
		 *          Greater min- and maxPadding
		 * @since   1.2.0
		 * @product highcharts highstock
		 */
		maxPadding: 0.05,

		/**
		 * Padding of the min value relative to the length of the axis. A
		 * padding of 0.05 will make a 100px axis 5px longer. This is useful
		 * when you don't want the lowest data value to appear on the edge
		 * of the plot area. When the axis' `min` option is set or a max extreme
		 * is set using `axis.setExtremes()`, the maxPadding will be ignored.
		 * 
		 * @sample  {highcharts} highcharts/yaxis/minpadding/
		 *          Min padding of 0.2
		 * @sample  {highstock} stock/xaxis/minpadding-maxpadding/
		 *          Greater min- and maxPadding
		 * @since   1.2.0
		 * @product highcharts highstock
		 */
		minPadding: 0.05,

		/**
		 * Whether to force the axis to start on a tick. Use this option with
		 * the `maxPadding` option to control the axis start.
		 * 
		 * @sample  {highcharts} highcharts/xaxis/startontick-false/
		 *          False by default
		 * @sample  {highcharts} highcharts/xaxis/startontick-true/
		 *          True
		 * @sample  {highstock} stock/xaxis/endontick/
		 *          False for Y axis
		 * @since   1.2.0
		 * @product highcharts highstock
		 */
		startOnTick: true,

		/**
		 * @extends xAxis.title
		 */
		title: {

			/**
			 * The rotation of the text in degrees. 0 is horizontal, 270 is
			 * vertical reading from bottom to top.
			 * 
			 * @sample {highcharts} highcharts/yaxis/title-offset/
			 *         Horizontal
			 */
			rotation: 270,

			/**
			 * The actual text of the axis title. Horizontal texts can contain
			 * HTML, but rotated texts are painted using vector techniques and
			 * must be clean text. The Y axis title is disabled by setting the
			 * `text` option to `null`.
			 * 
			 * @sample  {highcharts} highcharts/xaxis/title-text/
			 *          Custom HTML
			 * @default {highcharts} Values
			 * @default {highstock} null
			 * @product highcharts highstock
			 */
			text: 'Values'
		},

		/**
		 * The stack labels show the total value for each bar in a stacked
		 * column or bar chart. The label will be placed on top of positive
		 * columns and below negative columns. In case of an inverted column
		 * chart or a bar chart the label is placed to the right of positive
		 * bars and to the left of negative bars.
		 * 
		 * @product highcharts
		 */
		stackLabels: {

			/**
			 * Allow the stack labels to overlap.
			 * 
			 * @sample  {highcharts}
			 *          highcharts/yaxis/stacklabels-allowoverlap-false/
			 *          Default false
			 * @since   5.0.13
			 * @product highcharts
			 */
			allowOverlap: false,

			/**
			 * Enable or disable the stack total labels.
			 * 
			 * @sample  {highcharts} highcharts/yaxis/stacklabels-enabled/
			 *          Enabled stack total labels
			 * @since   2.1.5
			 * @product highcharts
			 */
			enabled: false,
			
			/**
			 * Callback JavaScript function to format the label. The value is
			 * given by `this.total`.
			 *
			 * @default function() { return this.total; }
			 * 
			 * @type    {Function}
			 * @sample  {highcharts} highcharts/yaxis/stacklabels-formatter/
			 *          Added units to stack total value
			 * @since   2.1.5
			 * @product highcharts
			 */
			formatter: function () {
				return H.numberFormat(this.total, -1);
			},
			

			/**
			 * CSS styles for the label.
			 * 
			 * In styled mode, the styles are set in the
			 * `.highcharts-stack-label` class.
			 * 
			 * @type    {CSSObject}
			 * @sample  {highcharts} highcharts/yaxis/stacklabels-style/
			 *          Red stack total labels
			 * @since   2.1.5
			 * @product highcharts
			 */
			style: {
				fontSize: '11px',
				fontWeight: 'bold',
				color: '#000000',
				textOutline: '1px contrast'
			}
			
		},
		
		gridLineWidth: 1,
		lineWidth: 0
		// tickWidth: 0
		
	},

	/**
	 * These options extend the defaultOptions for left axes.
	 * 
	 * @private
	 * @type {Object}
	 */
	defaultLeftAxisOptions: {
		labels: {
			x: -15
		},
		title: {
			rotation: 270
		}
	},

	/**
	 * These options extend the defaultOptions for right axes.
	 *
	 * @private
	 * @type {Object}
	 */
	defaultRightAxisOptions: {
		labels: {
			x: 15
		},
		title: {
			rotation: 90
		}
	},

	/**
	 * These options extend the defaultOptions for bottom axes.
	 *
	 * @private
	 * @type {Object}
	 */
	defaultBottomAxisOptions: {
		labels: {
			autoRotation: [-45],
			x: 0
			// overflow: undefined,
			// staggerLines: null
		},
		title: {
			rotation: 0
		}
	},
	/**
	 * These options extend the defaultOptions for top axes.
	 *
	 * @private
	 * @type {Object}
	 */
	defaultTopAxisOptions: {
		labels: {
			autoRotation: [-45],
			x: 0
			// overflow: undefined
			// staggerLines: null
		},
		title: {
			rotation: 0
		}
	},

	/**
	 * Overrideable function to initialize the axis. 
	 *
	 * @see {@link Axis}
	 */
	init: function (chart, userOptions) {


		var isXAxis = userOptions.isX,
			axis = this;


		/**
		 * The Chart that the axis belongs to.
		 *
		 * @name     chart
		 * @memberOf Axis
		 * @type     {Chart}
		 */
		axis.chart = chart;
		
		/**
		 * Whether the axis is horizontal.
		 *
		 * @name     horiz
		 * @memberOf Axis
		 * @type     {Boolean}
		 */
		axis.horiz = chart.inverted && !axis.isZAxis ? !isXAxis : isXAxis;

		// Flag, isXAxis
		axis.isXAxis = isXAxis;

		/**
		 * The collection where the axis belongs, for example `xAxis`, `yAxis`
		 * or `colorAxis`. Corresponds to properties on Chart, for example
		 * {@link Chart.xAxis}.
		 *
		 * @name     coll
		 * @memberOf Axis
		 * @type     {String}
		 */
		axis.coll = axis.coll || (isXAxis ? 'xAxis' : 'yAxis');


		axis.opposite = userOptions.opposite; // needed in setOptions

		/**
		 * The side on which the axis is rendered. 0 is top, 1 is right, 2 is
		 * bottom and 3 is left.
		 *
		 * @name     side
		 * @memberOf Axis
		 * @type     {Number}
		 */
		axis.side = userOptions.side || (axis.horiz ?
				(axis.opposite ? 0 : 2) : // top : bottom
				(axis.opposite ? 1 : 3));  // right : left

		axis.setOptions(userOptions);


		var options = this.options,
			type = options.type,
			isDatetimeAxis = type === 'datetime';

		axis.labelFormatter = options.labels.formatter ||
			axis.defaultLabelFormatter; // can be overwritten by dynamic format


		// Flag, stagger lines or not
		axis.userOptions = userOptions;

		axis.minPixelPadding = 0;


		/**
		 * Whether the axis is reversed. Based on the `axis.reversed`,
		 * option, but inverted charts have reversed xAxis by default.
		 *
		 * @name     reversed
		 * @memberOf Axis
		 * @type     {Boolean}
		 */
		axis.reversed = options.reversed;
		axis.visible = options.visible !== false;
		axis.zoomEnabled = options.zoomEnabled !== false;

		// Initial categories
		axis.hasNames = type === 'category' || options.categories === true;
		axis.categories = options.categories || axis.hasNames;
		axis.names = axis.names || []; // Preserve on update (#3830)

		// Placeholder for plotlines and plotbands groups
		axis.plotLinesAndBandsGroups = {};

		// Shorthand types
		axis.isLog = type === 'logarithmic';
		axis.isDatetimeAxis = isDatetimeAxis;
		axis.positiveValuesOnly = axis.isLog && !axis.allowNegativeLog;

		// Flag, if axis is linked to another axis
		axis.isLinked = defined(options.linkedTo);
		
		// Major ticks
		axis.ticks = {};
		axis.labelEdge = [];
		// Minor ticks
		axis.minorTicks = {};

		// List of plotLines/Bands
		axis.plotLinesAndBands = [];

		// Alternate bands
		axis.alternateBands = {};

		// Axis metrics
		axis.len = 0;
		axis.minRange = axis.userMinRange = options.minRange || options.maxZoom;
		axis.range = options.range;
		axis.offset = options.offset || 0;


		// Dictionary for stacks
		axis.stacks = {};
		axis.oldStacks = {};
		axis.stacksTouched = 0;

		
		/**
		 * The maximum value of the axis. In a logarithmic axis, this is the
		 * logarithm of the real value, and the real value can be obtained from
		 * {@link Axis#getExtremes}.
		 *
		 * @name     max
		 * @memberOf Axis
		 * @type     {Number}
		 */
		axis.max = null;
		/**
		 * The minimum value of the axis. In a logarithmic axis, this is the
		 * logarithm of the real value, and the real value can be obtained from
		 * {@link Axis#getExtremes}.
		 *
		 * @name     min
		 * @memberOf Axis
		 * @type     {Number}
		 */
		axis.min = null;


		/**
		 * The processed crosshair options.
		 *
		 * @name     crosshair
		 * @memberOf Axis
		 * @type     {AxisCrosshairOptions}
		 */
		axis.crosshair = pick(
			options.crosshair,
			splat(chart.options.tooltip.crosshairs)[isXAxis ? 0 : 1],
			false
		);
		
		var events = axis.options.events;

		// Register. Don't add it again on Axis.update().
		if (inArray(axis, chart.axes) === -1) { // 
			if (isXAxis) { // #2713
				chart.axes.splice(chart.xAxis.length, 0, axis);
			} else {
				chart.axes.push(axis);
			}

			chart[axis.coll].push(axis);
		}

		/**
		 * All series associated to the axis.
		 *
		 * @name     series
		 * @memberOf Axis
		 * @type     {Array.<Series>}
		 */
		axis.series = axis.series || []; // populated by Series

		// Reversed axis
		if (
			chart.inverted &&
			!axis.isZAxis &&
			isXAxis &&
			axis.reversed === undefined
		) {
			axis.reversed = true;
		}

		// register event listeners
		objectEach(events, function (event, eventType) {
			addEvent(axis, eventType, event);
		});

		// extend logarithmic axis
		axis.lin2log = options.linearToLogConverter || axis.lin2log;
		if (axis.isLog) {
			axis.val2lin = axis.log2lin;
			axis.lin2val = axis.lin2log;
		}
	},

	/**
	 * Merge and set options.
	 *
	 * @private
	 */
	setOptions: function (userOptions) {
		this.options = merge(
			this.defaultOptions,
			this.coll === 'yAxis' && this.defaultYAxisOptions,
			[
				this.defaultTopAxisOptions,
				this.defaultRightAxisOptions,
				this.defaultBottomAxisOptions,
				this.defaultLeftAxisOptions
			][this.side],
			merge(
				defaultOptions[this.coll], // if set in setOptions (#1053)
				userOptions
			)
		);
	},

	/**
	 * The default label formatter. The context is a special config object for
	 * the label. In apps, use the {@link
	 * https://api.highcharts.com/highcharts/xAxis.labels.formatter|
	 * labels.formatter} instead except when a modification is needed.
	 *
	 * @private
	 */
	defaultLabelFormatter: function () {
		var axis = this.axis,
			value = this.value,
			time = axis.chart.time,
			categories = axis.categories,
			dateTimeLabelFormat = this.dateTimeLabelFormat,
			lang = defaultOptions.lang,
			numericSymbols = lang.numericSymbols,
			numSymMagnitude = lang.numericSymbolMagnitude || 1000,
			i = numericSymbols && numericSymbols.length,
			multi,
			ret,
			formatOption = axis.options.labels.format,

			// make sure the same symbol is added for all labels on a linear
			// axis
			numericSymbolDetector = axis.isLog ?
				Math.abs(value) :
				axis.tickInterval;

		if (formatOption) {
			ret = format(formatOption, this, time);

		} else if (categories) {
			ret = value;

		} else if (dateTimeLabelFormat) { // datetime axis
			ret = time.dateFormat(dateTimeLabelFormat, value);

		} else if (i && numericSymbolDetector >= 1000) {
			// Decide whether we should add a numeric symbol like k (thousands)
			// or M (millions). If we are to enable this in tooltip or other
			// places as well, we can move this logic to the numberFormatter and
			// enable it by a parameter.
			while (i-- && ret === undefined) {
				multi = Math.pow(numSymMagnitude, i + 1);
				if (
					// Only accept a numeric symbol when the distance is more 
					// than a full unit. So for example if the symbol is k, we
					// don't accept numbers like 0.5k.
					numericSymbolDetector >= multi &&
					// Accept one decimal before the symbol. Accepts 0.5k but
					// not 0.25k. How does this work with the previous?
					(value * 10) % multi === 0 &&
					numericSymbols[i] !== null &&
					value !== 0
				) { // #5480
					ret = H.numberFormat(value / multi, -1) + numericSymbols[i];
				}
			}
		}

		if (ret === undefined) {
			if (Math.abs(value) >= 10000) { // add thousands separators
				ret = H.numberFormat(value, -1);
			} else { // small numbers
				ret = H.numberFormat(value, -1, undefined, ''); // #2466
			}
		}

		return ret;
	},

	/**
	 * Get the minimum and maximum for the series of each axis. The function
	 * analyzes the axis series and updates `this.dataMin` and `this.dataMax`.
	 *
	 * @private
	 */
	getSeriesExtremes: function () {
		var axis = this,
			chart = axis.chart;
		axis.hasVisibleSeries = false;

		// Reset properties in case we're redrawing (#3353)
		axis.dataMin = axis.dataMax = axis.threshold = null;
		axis.softThreshold = !axis.isXAxis;

		if (axis.buildStacks) {
			axis.buildStacks();
		}

		// loop through this axis' series
		each(axis.series, function (series) {

			if (series.visible || !chart.options.chart.ignoreHiddenSeries) {

				var seriesOptions = series.options,
					xData,
					threshold = seriesOptions.threshold,
					seriesDataMin,
					seriesDataMax;

				axis.hasVisibleSeries = true;

				// Validate threshold in logarithmic axes
				if (axis.positiveValuesOnly && threshold <= 0) {
					threshold = null;
				}

				// Get dataMin and dataMax for X axes
				if (axis.isXAxis) {
					xData = series.xData;
					if (xData.length) {
						// If xData contains values which is not numbers, then
						// filter them out. To prevent performance hit, we only
						// do this after we have already found seriesDataMin
						// because in most cases all data is valid. #5234.
						seriesDataMin = arrayMin(xData);
						seriesDataMax = arrayMax(xData);
						
						if (
							!isNumber(seriesDataMin) &&
							!(seriesDataMin instanceof Date) // #5010
						) {
							xData = grep(xData, isNumber);
							// Do it again with valid data
							seriesDataMin = arrayMin(xData);
							seriesDataMax = arrayMax(xData);
						}

						if (xData.length) {
							axis.dataMin = Math.min(
								pick(axis.dataMin, xData[0], seriesDataMin),
								seriesDataMin
							);
							axis.dataMax = Math.max(
								pick(axis.dataMax, xData[0], seriesDataMax),
								seriesDataMax
							);
						}
					}

				// Get dataMin and dataMax for Y axes, as well as handle
				// stacking and processed data
				} else {

					// Get this particular series extremes
					series.getExtremes();
					seriesDataMax = series.dataMax;
					seriesDataMin = series.dataMin;

					// Get the dataMin and dataMax so far. If percentage is
					// used, the min and max are always 0 and 100. If
					// seriesDataMin and seriesDataMax is null, then series
					// doesn't have active y data, we continue with nulls
					if (defined(seriesDataMin) && defined(seriesDataMax)) {
						axis.dataMin = Math.min(
							pick(axis.dataMin, seriesDataMin),
							seriesDataMin
						);
						axis.dataMax = Math.max(
							pick(axis.dataMax, seriesDataMax),
							seriesDataMax
						);
					}

					// Adjust to threshold
					if (defined(threshold)) {
						axis.threshold = threshold;
					}
					// If any series has a hard threshold, it takes precedence
					if (
						!seriesOptions.softThreshold ||
						axis.positiveValuesOnly
					) {
						axis.softThreshold = false;
					}
				}
			}
		});
	},

	/**
	 * Translate from axis value to pixel position on the chart, or back. Use
	 * the `toPixels` and `toValue` functions in applications.
	 *
	 * @private
	 */
	translate: function (
		val,
		backwards,
		cvsCoord,
		old,
		handleLog,
		pointPlacement
	) {
		var axis = this.linkedParent || this, // #1417
			sign = 1,
			cvsOffset = 0,
			localA = old ? axis.oldTransA : axis.transA,
			localMin = old ? axis.oldMin : axis.min,
			returnValue,
			minPixelPadding = axis.minPixelPadding,
			doPostTranslate = (
				axis.isOrdinal ||
				axis.isBroken ||
				(axis.isLog && handleLog)
			) && axis.lin2val;

		if (!localA) {
			localA = axis.transA;
		}

		// In vertical axes, the canvas coordinates start from 0 at the top like
		// in SVG.
		if (cvsCoord) {
			sign *= -1; // canvas coordinates inverts the value
			cvsOffset = axis.len;
		}

		// Handle reversed axis
		if (axis.reversed) {
			sign *= -1;
			cvsOffset -= sign * (axis.sector || axis.len);
		}

		// From pixels to value
		if (backwards) { // reverse translation

			val = val * sign + cvsOffset;
			val -= minPixelPadding;
			returnValue = val / localA + localMin; // from chart pixel to value
			if (doPostTranslate) { // log and ordinal axes
				returnValue = axis.lin2val(returnValue);
			}

		// From value to pixels
		} else {
			if (doPostTranslate) { // log and ordinal axes
				val = axis.val2lin(val);
			}
			returnValue = isNumber(localMin) ?
				(
					sign * (val - localMin) * localA +
					cvsOffset +
					(sign * minPixelPadding) +
					(isNumber(pointPlacement) ? localA * pointPlacement : 0)
				) : 
				undefined;
		}

		return returnValue;
	},

	/**
	 * Translate a value in terms of axis units into pixels within the chart.
	 * 
	 * @param  {Number} value
	 *         A value in terms of axis units.
	 * @param  {Boolean} paneCoordinates
	 *         Whether to return the pixel coordinate relative to the chart or
	 *         just the axis/pane itself.
	 * @return {Number} Pixel position of the value on the chart or axis.
	 */
	toPixels: function (value, paneCoordinates) {
		return this.translate(value, false, !this.horiz, null, true) +
			(paneCoordinates ? 0 : this.pos);
	},

	/**
	 * Translate a pixel position along the axis to a value in terms of axis
	 * units.
	 * @param  {Number} pixel
	 *         The pixel value coordinate.
	 * @param  {Boolean} paneCoordiantes
	 *         Whether the input pixel is relative to the chart or just the
	 *         axis/pane itself.
	 * @return {Number} The axis value.
	 */
	toValue: function (pixel, paneCoordinates) {
		return this.translate(
			pixel - (paneCoordinates ? 0 : this.pos),
			true,
			!this.horiz,
			null,
			true
		);
	},

	/**
	 * Create the path for a plot line that goes from the given value on
	 * this axis, across the plot to the opposite side. Also used internally for
	 * grid lines and crosshairs.
	 * 
	 * @param  {Number} value
	 *         Axis value.
	 * @param  {Number} [lineWidth=1]
	 *         Used for calculation crisp line coordinates.
	 * @param  {Boolean} [old=false]
	 *         Use old coordinates (for resizing and rescaling).
	 * @param  {Boolean} [force=false]
	 *         If `false`, the function will return null when it falls outside
	 *         the axis bounds.
	 * @param  {Number} [translatedValue]
	 *         If given, return the plot line path of a pixel position on the
	 *         axis.
	 *
	 * @return {Array.<String|Number>}
	 *         The SVG path definition for the plot line.
	 */
	getPlotLinePath: function (value, lineWidth, old, force, translatedValue) {
		var axis = this,
			chart = axis.chart,
			axisLeft = axis.left,
			axisTop = axis.top,
			x1,
			y1,
			x2,
			y2,
			cHeight = (old && chart.oldChartHeight) || chart.chartHeight,
			cWidth = (old && chart.oldChartWidth) || chart.chartWidth,
			skip,
			transB = axis.transB,
			/**
			 * Check if x is between a and b. If not, either move to a/b
			 * or skip, depending on the force parameter.
			 */
			between = function (x, a, b) {
				if (x < a || x > b) {
					if (force) {
						x = Math.min(Math.max(a, x), b);
					} else {
						skip = true;
					}
				}
				return x;
			};

		translatedValue = pick(
			translatedValue,
			axis.translate(value, null, null, old)
		);
		x1 = x2 = Math.round(translatedValue + transB);
		y1 = y2 = Math.round(cHeight - translatedValue - transB);
		if (!isNumber(translatedValue)) { // no min or max
			skip = true;
			force = false; // #7175, don't force it when path is invalid
		} else if (axis.horiz) {
			y1 = axisTop;
			y2 = cHeight - axis.bottom;
			x1 = x2 = between(x1, axisLeft, axisLeft + axis.width);
		} else {
			x1 = axisLeft;
			x2 = cWidth - axis.right;
			y1 = y2 = between(y1, axisTop, axisTop + axis.height);
		}
		return skip && !force ?
			null :
			chart.renderer.crispLine(
				['M', x1, y1, 'L', x2, y2],
				lineWidth || 1
			);
	},

	/**
	 * Internal function to et the tick positions of a linear axis to round
	 * values like whole tens or every five.
	 *
	 * @param  {Number} tickInterval
	 *         The normalized tick interval
	 * @param  {Number} min
	 *         Axis minimum.
	 * @param  {Number} max
	 *         Axis maximum.
	 *
	 * @return {Array.<Number>}
	 *         An array of axis values where ticks should be placed.
	 */
	getLinearTickPositions: function (tickInterval, min, max) {
		var pos,
			lastPos,
			roundedMin =
				correctFloat(Math.floor(min / tickInterval) * tickInterval),
			roundedMax =
				correctFloat(Math.ceil(max / tickInterval) * tickInterval),
			tickPositions = [],
			precision;
		
		// When the precision is higher than what we filter out in
		// correctFloat, skip it (#6183).			
		if (correctFloat(roundedMin + tickInterval) === roundedMin) {
			precision = 20;
		}

		// For single points, add a tick regardless of the relative position
		// (#2662, #6274)
		if (this.single) {
			return [min];
		}

		// Populate the intermediate values
		pos = roundedMin;
		while (pos <= roundedMax) {

			// Place the tick on the rounded value
			tickPositions.push(pos);

			// Always add the raw tickInterval, not the corrected one.
			pos = correctFloat(
				pos + tickInterval,
				precision
			);

			// If the interval is not big enough in the current min - max range
			// to actually increase the loop variable, we need to break out to
			// prevent endless loop. Issue #619
			if (pos === lastPos) {
				break;
			}

			// Record the last value
			lastPos = pos;
		}
		return tickPositions;
	},

	/**
	 * Resolve the new minorTicks/minorTickInterval options into the legacy
	 * loosely typed minorTickInterval option.
	 */
	getMinorTickInterval: function () {
		var options = this.options;

		if (options.minorTicks === true) {
			return pick(options.minorTickInterval, 'auto');
		}
		if (options.minorTicks === false) {
			return null;
		}
		return options.minorTickInterval;
	},

	/**
	 * Internal function to return the minor tick positions. For logarithmic
	 * axes, the same logic as for major ticks is reused.
	 *
	 * @return {Array.<Number>}
	 *         An array of axis values where ticks should be placed.
	 */
	getMinorTickPositions: function () {
		var axis = this,
			options = axis.options,
			tickPositions = axis.tickPositions,
			minorTickInterval = axis.minorTickInterval,
			minorTickPositions = [],
			pos,
			pointRangePadding = axis.pointRangePadding || 0,
			min = axis.min - pointRangePadding, // #1498
			max = axis.max + pointRangePadding, // #1498
			range = max - min;

		// If minor ticks get too dense, they are hard to read, and may cause
		// long running script. So we don't draw them.
		if (range && range / minorTickInterval < axis.len / 3) { // #3875

			if (axis.isLog) {
				// For each interval in the major ticks, compute the minor ticks
				// separately.
				each(this.paddedTicks, function (pos, i, paddedTicks) {
					if (i) {
						minorTickPositions.push.apply(
							minorTickPositions, 
							axis.getLogTickPositions(
								minorTickInterval,
								paddedTicks[i - 1],
								paddedTicks[i],
								true
							)
						);
					}
				});

			} else if (
				axis.isDatetimeAxis &&
				this.getMinorTickInterval() === 'auto'
			) { // #1314
				minorTickPositions = minorTickPositions.concat(
					axis.getTimeTicks(
						axis.normalizeTimeTickInterval(minorTickInterval),
						min,
						max,
						options.startOfWeek
					)
				);
			} else {
				for (
					pos = min + (tickPositions[0] - min) % minorTickInterval;
					pos <= max;
					pos += minorTickInterval
				) {
					// Very, very, tight grid lines (#5771)
					if (pos === minorTickPositions[0]) {
						break;
					}
					minorTickPositions.push(pos);
				}
			}
		}

		if (minorTickPositions.length !== 0) {
			axis.trimTicks(minorTickPositions); // #3652 #3743 #1498 #6330
		}
		return minorTickPositions;
	},

	/**
	 * Adjust the min and max for the minimum range. Keep in mind that the
	 * series data is not yet processed, so we don't have information on data
	 * cropping and grouping, or updated axis.pointRange or series.pointRange.
	 * The data can't be processed until we have finally established min and
	 * max.
	 *
	 * @private
	 */
	adjustForMinRange: function () {
		var axis = this,
			options = axis.options,
			min = axis.min,
			max = axis.max,
			zoomOffset,
			spaceAvailable,
			closestDataRange,
			i,
			distance,
			xData,
			loopLength,
			minArgs,
			maxArgs,
			minRange;

		// Set the automatic minimum range based on the closest point distance
		if (axis.isXAxis && axis.minRange === undefined && !axis.isLog) {

			if (defined(options.min) || defined(options.max)) {
				axis.minRange = null; // don't do this again

			} else {

				// Find the closest distance between raw data points, as opposed
				// to closestPointRange that applies to processed points
				// (cropped and grouped)
				each(axis.series, function (series) {
					xData = series.xData;
					loopLength = series.xIncrement ? 1 : xData.length - 1;
					for (i = loopLength; i > 0; i--) {
						distance = xData[i] - xData[i - 1];
						if (
							closestDataRange === undefined ||
							distance < closestDataRange
						) {
							closestDataRange = distance;
						}
					}
				});
				axis.minRange = Math.min(
					closestDataRange * 5,
					axis.dataMax - axis.dataMin
				);
			}
		}

		// if minRange is exceeded, adjust
		if (max - min < axis.minRange) {

			spaceAvailable = axis.dataMax - axis.dataMin >= axis.minRange;
			minRange = axis.minRange;
			zoomOffset = (minRange - max + min) / 2;

			// if min and max options have been set, don't go beyond it
			minArgs = [min - zoomOffset, pick(options.min, min - zoomOffset)];
			// If space is available, stay within the data range
			if (spaceAvailable) {
				minArgs[2] = axis.isLog ?
					axis.log2lin(axis.dataMin) :
					axis.dataMin;
			}
			min = arrayMax(minArgs);

			maxArgs = [min + minRange, pick(options.max, min + minRange)];
			// If space is availabe, stay within the data range
			if (spaceAvailable) {
				maxArgs[2] = axis.isLog ?
					axis.log2lin(axis.dataMax) :
					axis.dataMax;
			}

			max = arrayMin(maxArgs);

			// now if the max is adjusted, adjust the min back
			if (max - min < minRange) {
				minArgs[0] = max - minRange;
				minArgs[1] = pick(options.min, max - minRange);
				min = arrayMax(minArgs);
			}
		}

		// Record modified extremes
		axis.min = min;
		axis.max = max;
	},

	/**
	 * Find the closestPointRange across all series.
	 *
	 * @private
	 */
	getClosest: function () {
		var ret;

		if (this.categories) {
			ret = 1;
		} else {
			each(this.series, function (series) {
				var seriesClosest = series.closestPointRange,
					visible = series.visible ||
						!series.chart.options.chart.ignoreHiddenSeries;
				
				if (
					!series.noSharedTooltip &&
					defined(seriesClosest) &&
					visible
				) {
					ret = defined(ret) ?
						Math.min(ret, seriesClosest) :
						seriesClosest;
				}
			});
		}
		return ret;
	},

	/**
	 * When a point name is given and no x, search for the name in the existing
	 * categories, or if categories aren't provided, search names or create a
	 * new category (#2522).
	 *
	 * @private
	 *
	 * @param  {Point}
	 *         The point to inspect.
	 *
	 * @return {Number}
	 *         The X value that the point is given.
	 */
	nameToX: function (point) {
		var explicitCategories = isArray(this.categories),
			names = explicitCategories ? this.categories : this.names,
			nameX = point.options.x,
			x;

		point.series.requireSorting = false;

		if (!defined(nameX)) {
			nameX = this.options.uniqueNames === false ?
				point.series.autoIncrement() : 
				inArray(point.name, names);
		}
		if (nameX === -1) { // The name is not found in currenct categories
			if (!explicitCategories) {
				x = names.length;
			}
		} else {
			x = nameX;
		}

		// Write the last point's name to the names array
		if (x !== undefined) {
			this.names[x] = point.name;
		}

		return x;
	},

	/**
	 * When changes have been done to series data, update the axis.names.
	 *
	 * @private
	 */
	updateNames: function () {
		var axis = this;

		if (this.names.length > 0) {
			this.names.length = 0;
			this.minRange = this.userMinRange; // Reset
			each(this.series || [], function (series) {
			
				// Reset incrementer (#5928)
				series.xIncrement = null;

				// When adding a series, points are not yet generated
				if (!series.points || series.isDirtyData) {
					series.processData();
					series.generatePoints();
				}

				each(series.points, function (point, i) {
					var x;
					if (point.options) {
						x = axis.nameToX(point);
						if (x !== undefined && x !== point.x) {
							point.x = x;
							series.xData[i] = x;
						}
					}
				});
			});
		}
	},

	/**
	 * Update translation information.
	 *
	 * @private
	 */
	setAxisTranslation: function (saveOld) {
		var axis = this,
			range = axis.max - axis.min,
			pointRange = axis.axisPointRange || 0,
			closestPointRange,
			minPointOffset = 0,
			pointRangePadding = 0,
			linkedParent = axis.linkedParent,
			ordinalCorrection,
			hasCategories = !!axis.categories,
			transA = axis.transA,
			isXAxis = axis.isXAxis;

		// Adjust translation for padding. Y axis with categories need to go
		// through the same (#1784).
		if (isXAxis || hasCategories || pointRange) {

			// Get the closest points
			closestPointRange = axis.getClosest();

			if (linkedParent) {
				minPointOffset = linkedParent.minPointOffset;
				pointRangePadding = linkedParent.pointRangePadding;
			} else {
				each(axis.series, function (series) {
					var seriesPointRange = hasCategories ? 
						1 : 
						(
							isXAxis ? 
								pick(
									series.options.pointRange,
									closestPointRange,
									0
								) : 
								(axis.axisPointRange || 0)
						), // #2806
						pointPlacement = series.options.pointPlacement;

					pointRange = Math.max(pointRange, seriesPointRange);

					if (!axis.single) {
						// minPointOffset is the value padding to the left of
						// the axis in order to make room for points with a
						// pointRange, typically columns. When the
						// pointPlacement option is 'between' or 'on', this
						// padding does not apply.
						minPointOffset = Math.max(
							minPointOffset,
							isString(pointPlacement) ? 0 : seriesPointRange / 2
						);

						// Determine the total padding needed to the length of
						// the axis to make room for the pointRange. If the
						// series' pointPlacement is 'on', no padding is added.
						pointRangePadding = Math.max(
							pointRangePadding,
							pointPlacement === 'on' ? 0 : seriesPointRange
						);
					}
				});
			}

			// Record minPointOffset and pointRangePadding
			ordinalCorrection = axis.ordinalSlope && closestPointRange ?
				axis.ordinalSlope / closestPointRange :
				1; // #988, #1853
			axis.minPointOffset = minPointOffset =
				minPointOffset * ordinalCorrection;
			axis.pointRangePadding =
				pointRangePadding = pointRangePadding * ordinalCorrection;

			// pointRange means the width reserved for each point, like in a
			// column chart
			axis.pointRange = Math.min(pointRange, range);

			// closestPointRange means the closest distance between points. In
			// columns it is mostly equal to pointRange, but in lines pointRange
			// is 0 while closestPointRange is some other value
			if (isXAxis) {
				axis.closestPointRange = closestPointRange;
			}
		}

		// Secondary values
		if (saveOld) {
			axis.oldTransA = transA;
		}
		axis.translationSlope = axis.transA = transA =
			axis.options.staticScale ||
			axis.len / ((range + pointRangePadding) || 1);

		// Translation addend
		axis.transB = axis.horiz ? axis.left : axis.bottom;
		axis.minPixelPadding = transA * minPointOffset;
	},

	minFromRange: function () {
		return this.max - this.range;
	},

	/**
	 * Set the tick positions to round values and optionally extend the extremes
	 * to the nearest tick.
	 *
	 * @private
	 */
	setTickInterval: function (secondPass) {
		var axis = this,
			chart = axis.chart,
			options = axis.options,
			isLog = axis.isLog,
			log2lin = axis.log2lin,
			isDatetimeAxis = axis.isDatetimeAxis,
			isXAxis = axis.isXAxis,
			isLinked = axis.isLinked,
			maxPadding = options.maxPadding,
			minPadding = options.minPadding,
			length,
			linkedParentExtremes,
			tickIntervalOption = options.tickInterval,
			minTickInterval,
			tickPixelIntervalOption = options.tickPixelInterval,
			categories = axis.categories,
			threshold = axis.threshold,
			softThreshold = axis.softThreshold,
			thresholdMin,
			thresholdMax,
			hardMin,
			hardMax;

		if (!isDatetimeAxis && !categories && !isLinked) {
			this.getTickAmount();
		}

		// Min or max set either by zooming/setExtremes or initial options
		hardMin = pick(axis.userMin, options.min);
		hardMax = pick(axis.userMax, options.max);

		// Linked axis gets the extremes from the parent axis
		if (isLinked) {
			axis.linkedParent = chart[axis.coll][options.linkedTo];
			linkedParentExtremes = axis.linkedParent.getExtremes();
			axis.min = pick(
				linkedParentExtremes.min,
				linkedParentExtremes.dataMin
			);
			axis.max = pick(
				linkedParentExtremes.max,
				linkedParentExtremes.dataMax
			);
			if (options.type !== axis.linkedParent.options.type) {
				H.error(11, 1); // Can't link axes of different type
			}

		// Initial min and max from the extreme data values
		} else {

			// Adjust to hard threshold
			if (!softThreshold && defined(threshold)) {
				if (axis.dataMin >= threshold) {
					thresholdMin = threshold;
					minPadding = 0;
				} else if (axis.dataMax <= threshold) {
					thresholdMax = threshold;
					maxPadding = 0;
				}
			}

			axis.min = pick(hardMin, thresholdMin, axis.dataMin);
			axis.max = pick(hardMax, thresholdMax, axis.dataMax);

		}

		if (isLog) {
			if (
				axis.positiveValuesOnly &&
				!secondPass &&
				Math.min(axis.min, pick(axis.dataMin, axis.min)) <= 0
			) { // #978
				H.error(10, 1); // Can't plot negative values on log axis
			}
			// The correctFloat cures #934, float errors on full tens. But it
			// was too aggressive for #4360 because of conversion back to lin,
			// therefore use precision 15.
			axis.min = correctFloat(log2lin(axis.min), 15);
			axis.max = correctFloat(log2lin(axis.max), 15);
		}

		// handle zoomed range
		if (axis.range && defined(axis.max)) {
			axis.userMin = axis.min = hardMin =
				Math.max(axis.dataMin, axis.minFromRange()); // #618, #6773
			axis.userMax = hardMax = axis.max;

			axis.range = null;  // don't use it when running setExtremes
		}

		// Hook for Highstock Scroller. Consider combining with beforePadding.
		fireEvent(axis, 'foundExtremes');

		// Hook for adjusting this.min and this.max. Used by bubble series.
		if (axis.beforePadding) {
			axis.beforePadding();
		}

		// adjust min and max for the minimum range
		axis.adjustForMinRange();

		// Pad the values to get clear of the chart's edges. To avoid
		// tickInterval taking the padding into account, we do this after
		// computing tick interval (#1337).
		if (
			!categories &&
			!axis.axisPointRange &&
			!axis.usePercentage &&
			!isLinked &&
			defined(axis.min) &&
			defined(axis.max)
		) {
			length = axis.max - axis.min;
			if (length) {
				if (!defined(hardMin) && minPadding) {
					axis.min -= length * minPadding;
				}
				if (!defined(hardMax)  && maxPadding) {
					axis.max += length * maxPadding;
				}
			}
		}

		// Handle options for floor, ceiling, softMin and softMax (#6359)
		if (isNumber(options.softMin) && !isNumber(axis.userMin)) {
			axis.min = Math.min(axis.min, options.softMin);
		}
		if (isNumber(options.softMax) && !isNumber(axis.userMax)) {
			axis.max = Math.max(axis.max, options.softMax);
		}
		if (isNumber(options.floor)) {
			axis.min = Math.max(axis.min, options.floor);
		}
		if (isNumber(options.ceiling)) {
			axis.max = Math.min(axis.max, options.ceiling);
		}
		

		// When the threshold is soft, adjust the extreme value only if the data
		// extreme and the padded extreme land on either side of the threshold.
		// For example, a series of [0, 1, 2, 3] would make the yAxis add a tick
		// for -1 because of the default minPadding and startOnTick options.
		// This is prevented by the softThreshold option.
		if (softThreshold && defined(axis.dataMin)) {
			threshold = threshold || 0;
			if (
				!defined(hardMin) &&
				axis.min < threshold &&
				axis.dataMin >= threshold
			) {
				axis.min = threshold;
			
			} else if (
				!defined(hardMax) &&
				axis.max > threshold &&
				axis.dataMax <= threshold
			) {
				axis.max = threshold;
			}
		}


		// get tickInterval
		if (
			axis.min === axis.max ||
			axis.min === undefined ||
			axis.max === undefined
		) {
			axis.tickInterval = 1;
		
		} else if (
			isLinked &&
			!tickIntervalOption &&
			tickPixelIntervalOption ===
				axis.linkedParent.options.tickPixelInterval
		) {
			axis.tickInterval = tickIntervalOption =
				axis.linkedParent.tickInterval;
		
		} else {
			axis.tickInterval = pick(
				tickIntervalOption,
				this.tickAmount ?
					((axis.max - axis.min) / Math.max(this.tickAmount - 1, 1)) :
					undefined,
				// For categoried axis, 1 is default, for linear axis use
				// tickPix
				categories ?
					1 :
					// don't let it be more than the data range
					(axis.max - axis.min) * tickPixelIntervalOption /
						Math.max(axis.len, tickPixelIntervalOption)
			);
		}

		/**
		 * Now we're finished detecting min and max, crop and group series data.
		 * This is in turn needed in order to find tick positions in
		 * ordinal axes.
		 */
		if (isXAxis && !secondPass) {
			each(axis.series, function (series) {
				series.processData(
					axis.min !== axis.oldMin || axis.max !== axis.oldMax
				);
			});
		}

		// set the translation factor used in translate function
		axis.setAxisTranslation(true);

		// hook for ordinal axes and radial axes
		if (axis.beforeSetTickPositions) {
			axis.beforeSetTickPositions();
		}

		// hook for extensions, used in Highstock ordinal axes
		if (axis.postProcessTickInterval) {
			axis.tickInterval = axis.postProcessTickInterval(axis.tickInterval);
		}

		// In column-like charts, don't cramp in more ticks than there are
		// points (#1943, #4184)
		if (axis.pointRange && !tickIntervalOption) {
			axis.tickInterval = Math.max(axis.pointRange, axis.tickInterval);
		}

		// Before normalizing the tick interval, handle minimum tick interval.
		// This applies only if tickInterval is not defined.
		minTickInterval = pick(
			options.minTickInterval,
			axis.isDatetimeAxis && axis.closestPointRange
		);
		if (!tickIntervalOption && axis.tickInterval < minTickInterval) {
			axis.tickInterval = minTickInterval;
		}

		// for linear axes, get magnitude and normalize the interval
		if (!isDatetimeAxis && !isLog && !tickIntervalOption) {
			axis.tickInterval = normalizeTickInterval(
				axis.tickInterval,
				null,
				getMagnitude(axis.tickInterval),
				// If the tick interval is between 0.5 and 5 and the axis max is
				// in the order of thousands, chances are we are dealing with
				// years. Don't allow decimals. #3363.
				pick(
					options.allowDecimals,
					!(
						axis.tickInterval > 0.5 &&
						axis.tickInterval < 5 &&
						axis.max > 1000 &&
						axis.max < 9999
					)
				),
				!!this.tickAmount
			);
		}

		// Prevent ticks from getting so close that we can't draw the labels
		if (!this.tickAmount) {
			axis.tickInterval = axis.unsquish();
		}

		this.setTickPositions();
	},

	/**
	 * Now we have computed the normalized tickInterval, get the tick positions
	 */
	setTickPositions: function () {

		var options = this.options,
			tickPositions,
			tickPositionsOption = options.tickPositions,
			minorTickIntervalOption = this.getMinorTickInterval(),
			tickPositioner = options.tickPositioner,
			startOnTick = options.startOnTick,
			endOnTick = options.endOnTick;

		// Set the tickmarkOffset
		this.tickmarkOffset = (
			this.categories &&
			options.tickmarkPlacement === 'between' &&
			this.tickInterval === 1
		) ? 0.5 : 0; // #3202


		// get minorTickInterval
		this.minorTickInterval =
			minorTickIntervalOption === 'auto' &&
			this.tickInterval ?
				this.tickInterval / 5 :
				minorTickIntervalOption;

		// When there is only one point, or all points have the same value on
		// this axis, then min and max are equal and tickPositions.length is 0
		// or 1. In this case, add some padding in order to center the point,
		// but leave it with one tick. #1337.
		this.single =
			this.min === this.max &&
			defined(this.min) &&
			!this.tickAmount &&
			(
				// Data is on integer (#6563)
				parseInt(this.min, 10) === this.min ||

				// Between integers and decimals are not allowed (#6274)
				options.allowDecimals !== false
			);

		// Find the tick positions. Work on a copy (#1565)
		this.tickPositions = tickPositions =
			tickPositionsOption && tickPositionsOption.slice();
		if (!tickPositions) {

			if (this.isDatetimeAxis) {
				tickPositions = this.getTimeTicks(
					this.normalizeTimeTickInterval(
						this.tickInterval,
						options.units
					),
					this.min,
					this.max,
					options.startOfWeek,
					this.ordinalPositions,
					this.closestPointRange,
					true
				);
			} else if (this.isLog) {
				tickPositions = this.getLogTickPositions(
					this.tickInterval,
					this.min,
					this.max
				);
			} else {
				tickPositions = this.getLinearTickPositions(
					this.tickInterval,
					this.min,
					this.max
				);
			}

			// Too dense ticks, keep only the first and last (#4477)
			if (tickPositions.length > this.len) {
				tickPositions = [tickPositions[0], tickPositions.pop()];
				// Reduce doubled value (#7339)
				if (tickPositions[0] === tickPositions[1]) {
					tickPositions.length = 1;
				}
			}

			this.tickPositions = tickPositions;

			// Run the tick positioner callback, that allows modifying auto tick
			// positions.
			if (tickPositioner) {
				tickPositioner = tickPositioner.apply(
					this,
					[this.min, this.max]
				);
				if (tickPositioner) {
					this.tickPositions = tickPositions = tickPositioner;
				}
			}

		}

		// Reset min/max or remove extremes based on start/end on tick
		this.paddedTicks = tickPositions.slice(0); // Used for logarithmic minor
		this.trimTicks(tickPositions, startOnTick, endOnTick);
		if (!this.isLinked) {
			
			// Substract half a unit (#2619, #2846, #2515, #3390),
			// but not in case of multiple ticks (#6897)
			if (this.single && tickPositions.length < 2) {
				this.min -= 0.5;
				this.max += 0.5;
			}
			if (!tickPositionsOption && !tickPositioner) {
				this.adjustTickAmount();
			}
		}
	},

	/**
	 * Handle startOnTick and endOnTick by either adapting to padding min/max or
	 * rounded min/max. Also handle single data points.
	 *
	 * @private
	 */
	trimTicks: function (tickPositions, startOnTick, endOnTick) {
		var roundedMin = tickPositions[0],
			roundedMax = tickPositions[tickPositions.length - 1],
			minPointOffset = this.minPointOffset || 0;

		if (!this.isLinked) {
			if (startOnTick && roundedMin !== -Infinity) { // #6502
				this.min = roundedMin;
			} else {
				while (this.min - minPointOffset > tickPositions[0]) {
					tickPositions.shift();
				}
			}

			if (endOnTick) {
				this.max = roundedMax;
			} else {
				while (this.max + minPointOffset <
						tickPositions[tickPositions.length - 1]) {
					tickPositions.pop();
				}
			}

			// If no tick are left, set one tick in the middle (#3195)
			if (
				tickPositions.length === 0 &&
				defined(roundedMin) &&
				!this.options.tickPositions
			) {
				tickPositions.push((roundedMax + roundedMin) / 2);
			}
		}
	},

	/**
	 * Check if there are multiple axes in the same pane.
	 *
	 * @private
	 * @return {Boolean}
	 *         True if there are other axes.
	 */
	alignToOthers: function () {
		var others = {}, // Whether there is another axis to pair with this one
			hasOther,
			options = this.options;

		if (
			// Only if alignTicks is true
			this.chart.options.chart.alignTicks !== false &&
			options.alignTicks !== false &&

			// Don't try to align ticks on a log axis, they are not evenly
			// spaced (#6021)
			!this.isLog
		) {
			each(this.chart[this.coll], function (axis) {
				var otherOptions = axis.options,
					horiz = axis.horiz,
					key = [
						horiz ? otherOptions.left : otherOptions.top, 
						otherOptions.width,
						otherOptions.height, 
						otherOptions.pane
					].join(',');


				if (axis.series.length) { // #4442
					if (others[key]) {
						hasOther = true; // #4201
					} else {
						others[key] = 1;
					}
				}
			});
		}
		return hasOther;
	},

	/**
	 * Find the max ticks of either the x and y axis collection, and record it
	 * in `this.tickAmount`.
	 *
	 * @private
	 */
	getTickAmount: function () {
		var options = this.options,
			tickAmount = options.tickAmount,
			tickPixelInterval = options.tickPixelInterval;

		if (
			!defined(options.tickInterval) &&
			this.len < tickPixelInterval &&
			!this.isRadial &&
			!this.isLog &&
			options.startOnTick &&
			options.endOnTick
		) {
			tickAmount = 2;
		}

		if (!tickAmount && this.alignToOthers()) {
			// Add 1 because 4 tick intervals require 5 ticks (including first
			// and last)
			tickAmount = Math.ceil(this.len / tickPixelInterval) + 1;
		}

		// For tick amounts of 2 and 3, compute five ticks and remove the
		// intermediate ones. This prevents the axis from adding ticks that are
		// too far away from the data extremes.
		if (tickAmount < 4) {
			this.finalTickAmt = tickAmount;
			tickAmount = 5;
		}

		this.tickAmount = tickAmount;
	},

	/**
	 * When using multiple axes, adjust the number of ticks to match the highest
	 * number of ticks in that group.
	 *
	 * @private
	 */
	adjustTickAmount: function () {
		var tickInterval = this.tickInterval,
			tickPositions = this.tickPositions,
			tickAmount = this.tickAmount,
			finalTickAmt = this.finalTickAmt,
			currentTickAmount = tickPositions && tickPositions.length,
			threshold = pick(this.threshold, this.softThreshold ? 0 : null),
			i,
			len;

		if (this.hasData()) {
			if (currentTickAmount < tickAmount) {
				while (tickPositions.length < tickAmount) {

					// Extend evenly for both sides unless we're on the
					// threshold (#3965)
					if (
						tickPositions.length % 2 ||
						this.min === threshold
					) {
						// to the end
						tickPositions.push(correctFloat(
							tickPositions[tickPositions.length - 1] +
							tickInterval
						));
					} else {
						// to the start
						tickPositions.unshift(correctFloat(
							tickPositions[0] - tickInterval
						));
					}
				}
				this.transA *= (currentTickAmount - 1) / (tickAmount - 1);
				this.min = tickPositions[0];
				this.max = tickPositions[tickPositions.length - 1];

			// We have too many ticks, run second pass to try to reduce ticks
			} else if (currentTickAmount > tickAmount) {
				this.tickInterval *= 2;
				this.setTickPositions();
			}

			// The finalTickAmt property is set in getTickAmount
			if (defined(finalTickAmt)) {
				i = len = tickPositions.length;
				while (i--) {
					if (
						// Remove every other tick
						(finalTickAmt === 3 && i % 2 === 1) ||
						// Remove all but first and last
						(finalTickAmt <= 2 && i > 0 && i < len - 1)
					) {
						tickPositions.splice(i, 1);
					}
				}
				this.finalTickAmt = undefined;
			}
		}
	},

	/**
	 * Set the scale based on data min and max, user set min and max or options.
	 * 
	 * @private
	 */
	setScale: function () {
		var axis = this,
			isDirtyData,
			isDirtyAxisLength;

		axis.oldMin = axis.min;
		axis.oldMax = axis.max;
		axis.oldAxisLength = axis.len;

		// set the new axisLength
		axis.setAxisSize();
		isDirtyAxisLength = axis.len !== axis.oldAxisLength;

		// is there new data?
		each(axis.series, function (series) {
			if (
				series.isDirtyData ||
				series.isDirty ||
				// When x axis is dirty, we need new data extremes for y as well
				series.xAxis.isDirty 
			) {
				isDirtyData = true;
			}
		});

		// do we really need to go through all this?
		if (
			isDirtyAxisLength ||
			isDirtyData ||
			axis.isLinked ||
			axis.forceRedraw ||
			axis.userMin !== axis.oldUserMin ||
			axis.userMax !== axis.oldUserMax ||
			axis.alignToOthers()
		) {

			if (axis.resetStacks) {
				axis.resetStacks();
			}

			axis.forceRedraw = false;

			// get data extremes if needed
			axis.getSeriesExtremes();

			// get fixed positions based on tickInterval
			axis.setTickInterval();

			// record old values to decide whether a rescale is necessary later
			// on (#540)
			axis.oldUserMin = axis.userMin;
			axis.oldUserMax = axis.userMax;

			// Mark as dirty if it is not already set to dirty and extremes have
			// changed. #595.
			if (!axis.isDirty) {
				axis.isDirty = 
					isDirtyAxisLength ||
					axis.min !== axis.oldMin ||
					axis.max !== axis.oldMax;
			}
		} else if (axis.cleanStacks) {
			axis.cleanStacks();
		}
	},

	/**
	 * Set the minimum and maximum of the axes after render time. If the
	 * `startOnTick` and `endOnTick` options are true, the minimum and maximum
	 * values are rounded off to the nearest tick. To prevent this, these
	 * options can be set to false before calling setExtremes. Also, setExtremes
	 * will not allow a range lower than the `minRange` option, which by default
	 * is the range of five points.
	 * 
	 * @param  {Number} [newMin]
	 *         The new minimum value.
	 * @param  {Number} [newMax]
	 *         The new maximum value.
	 * @param  {Boolean} [redraw=true]
	 *         Whether to redraw the chart or wait for an explicit call to 
	 *         {@link Highcharts.Chart#redraw}
	 * @param  {AnimationOptions} [animation=true]
	 *         Enable or modify animations.
	 * @param  {Object} [eventArguments]
	 *         Arguments to be accessed in event handler.
	 *
	 * @sample highcharts/members/axis-setextremes/
	 *         Set extremes from a button
	 * @sample highcharts/members/axis-setextremes-datetime/
	 *         Set extremes on a datetime axis
	 * @sample highcharts/members/axis-setextremes-off-ticks/
	 *         Set extremes off ticks
	 * @sample stock/members/axis-setextremes/
	 *         Set extremes in Highstock
	 * @sample maps/members/axis-setextremes/
	 *         Set extremes in Highmaps
	 */
	setExtremes: function (newMin, newMax, redraw, animation, eventArguments) {
		var axis = this,
			chart = axis.chart;

		redraw = pick(redraw, true); // defaults to true

		each(axis.series, function (serie) {
			delete serie.kdTree;
		});

		// Extend the arguments with min and max
		eventArguments = extend(eventArguments, {
			min: newMin,
			max: newMax
		});

		// Fire the event
		fireEvent(axis, 'setExtremes', eventArguments, function () {

			axis.userMin = newMin;
			axis.userMax = newMax;
			axis.eventArgs = eventArguments;

			if (redraw) {
				chart.redraw(animation);
			}
		});
	},

	/**
	 * Overridable method for zooming chart. Pulled out in a separate method to
	 * allow overriding in stock charts.
	 *
	 * @private
	 */
	zoom: function (newMin, newMax) {
		var dataMin = this.dataMin,
			dataMax = this.dataMax,
			options = this.options,
			min = Math.min(dataMin, pick(options.min, dataMin)),
			max = Math.max(dataMax, pick(options.max, dataMax));

		if (newMin !== this.min || newMax !== this.max) { // #5790
			
			// Prevent pinch zooming out of range. Check for defined is for
			// #1946. #1734.
			if (!this.allowZoomOutside) {
				// #6014, sometimes newMax will be smaller than min (or newMin
				// will be larger than max).
				if (defined(dataMin)) {
					if (newMin < min) {
						newMin = min;
					}
					if (newMin > max) {
						newMin = max;
					}
				}
				if (defined(dataMax)) {
					if (newMax < min) {
						newMax = min;
					}
					if (newMax > max) {
						newMax = max;
					}
				}
			}

			// In full view, displaying the reset zoom button is not required
			this.displayBtn = newMin !== undefined || newMax !== undefined;

			// Do it
			this.setExtremes(
				newMin,
				newMax,
				false,
				undefined,
				{ trigger: 'zoom' }
			);
		}

		return true;
	},

	/**
	 * Update the axis metrics.
	 *
	 * @private
	 */
	setAxisSize: function () {
		var chart = this.chart,
			options = this.options,
			// [top, right, bottom, left]
			offsets = options.offsets || [0, 0, 0, 0],
			horiz = this.horiz,

			// Check for percentage based input values. Rounding fixes problems
			// with column overflow and plot line filtering (#4898, #4899)
			width = this.width = Math.round(H.relativeLength(
				pick(
					options.width,
					chart.plotWidth - offsets[3] + offsets[1]
				),
				chart.plotWidth
			)),
			height = this.height = Math.round(H.relativeLength(
				pick(
					options.height,
					chart.plotHeight - offsets[0] + offsets[2]
				),
				chart.plotHeight
			)),
			top = this.top = Math.round(H.relativeLength(
				pick(options.top, chart.plotTop + offsets[0]),
				chart.plotHeight,
				chart.plotTop
			)),
			left = this.left = Math.round(H.relativeLength(
				pick(options.left, chart.plotLeft + offsets[3]),
				chart.plotWidth,
				chart.plotLeft
			));

		// Expose basic values to use in Series object and navigator
		this.bottom = chart.chartHeight - height - top;
		this.right = chart.chartWidth - width - left;

		// Direction agnostic properties
		this.len = Math.max(horiz ? width : height, 0); // Math.max fixes #905
		this.pos = horiz ? left : top; // distance from SVG origin
	},

	/**
	 * The returned object literal from the {@link Highcharts.Axis#getExtremes}
	 * function.
	 *
	 * @typedef  {Object} Extremes
	 * @property {Number} dataMax
	 *           The maximum value of the axis' associated series.
	 * @property {Number} dataMin
	 *           The minimum value of the axis' associated series.
	 * @property {Number} max
	 *           The maximum axis value, either automatic or set manually. If
	 *           the `max` option is not set, `maxPadding` is 0 and `endOnTick`
	 *           is false, this value will be the same as `dataMax`.
	 * @property {Number} min
	 *           The minimum axis value, either automatic or set manually. If
	 *           the `min` option is not set, `minPadding` is 0 and
	 *           `startOnTick` is false, this value will be the same
	 *           as `dataMin`.
	 */
	/**
	 * Get the current extremes for the axis.
	 *
	 * @returns {Extremes}
	 *          An object containing extremes information.
	 * 
	 * @sample  highcharts/members/axis-getextremes/
	 *          Report extremes by click on a button
	 * @sample  maps/members/axis-getextremes/
	 *          Get extremes in Highmaps
	 */
	getExtremes: function () {
		var axis = this,
			isLog = axis.isLog,
			lin2log = axis.lin2log;

		return {
			min: isLog ? correctFloat(lin2log(axis.min)) : axis.min,
			max: isLog ? correctFloat(lin2log(axis.max)) : axis.max,
			dataMin: axis.dataMin,
			dataMax: axis.dataMax,
			userMin: axis.userMin,
			userMax: axis.userMax
		};
	},

	/**
	 * Get the zero plane either based on zero or on the min or max value.
	 * Used in bar and area plots.
	 *
	 * @param  {Number} threshold
	 *         The threshold in axis values.
	 *
	 * @return {Number}
	 *         The translated threshold position in terms of pixels, and
	 *         corrected to stay within the axis bounds.
	 */
	getThreshold: function (threshold) {
		var axis = this,
			isLog = axis.isLog,
			lin2log = axis.lin2log,
			realMin = isLog ? lin2log(axis.min) : axis.min,
			realMax = isLog ? lin2log(axis.max) : axis.max;

		if (threshold === null) {
			threshold = realMin;
		} else if (realMin > threshold) {
			threshold = realMin;
		} else if (realMax < threshold) {
			threshold = realMax;
		}

		return axis.translate(threshold, 0, 1, 0, 1);
	},

	/**
	 * Compute auto alignment for the axis label based on which side the axis is
	 * on and the given rotation for the label.
	 *
	 * @param  {Number} rotation
	 *         The rotation in degrees as set by either the `rotation` or 
	 *         `autoRotation` options.
	 * @private
	 */
	autoLabelAlign: function (rotation) {
		var ret,
			angle = (pick(rotation, 0) - (this.side * 90) + 720) % 360;

		if (angle > 15 && angle < 165) {
			ret = 'right';
		} else if (angle > 195 && angle < 345) {
			ret = 'left';
		} else {
			ret = 'center';
		}
		return ret;
	},

	/**
	 * Get the tick length and width for the axis based on axis options.
	 *
	 * @private
	 * 
	 * @param  {String} prefix
	 *         'tick' or 'minorTick'
	 * @return {Array.<Number>}
	 *         An array of tickLength and tickWidth
	 */
	tickSize: function (prefix) {
		var options = this.options,
			tickLength = options[prefix + 'Length'],
			tickWidth = pick(
				options[prefix + 'Width'],
				prefix === 'tick' && this.isXAxis ? 1 : 0 // X axis default 1
			); 

		if (tickWidth && tickLength) {
			// Negate the length
			if (options[prefix + 'Position'] === 'inside') {
				tickLength = -tickLength;
			}
			return [tickLength, tickWidth];
		}
			
	},

	/**
	 * Return the size of the labels.
	 *
	 * @private
	 */
	labelMetrics: function () {
		var index = this.tickPositions && this.tickPositions[0] || 0;
		return this.chart.renderer.fontMetrics(
			this.options.labels.style && this.options.labels.style.fontSize, 
			this.ticks[index] && this.ticks[index].label
		);
	},

	/**
	 * Prevent the ticks from getting so close we can't draw the labels. On a
	 * horizontal axis, this is handled by rotating the labels, removing ticks
	 * and adding ellipsis. On a vertical axis remove ticks and add ellipsis.
	 *
	 * @private
	 */
	unsquish: function () {
		var labelOptions = this.options.labels,
			horiz = this.horiz,
			tickInterval = this.tickInterval,
			newTickInterval = tickInterval,
			slotSize = this.len / (
				((this.categories ? 1 : 0) + this.max - this.min) / tickInterval
			),
			rotation,
			rotationOption = labelOptions.rotation,
			labelMetrics = this.labelMetrics(),
			step,
			bestScore = Number.MAX_VALUE,
			autoRotation,
			// Return the multiple of tickInterval that is needed to avoid
			// collision
			getStep = function (spaceNeeded) {
				var step = spaceNeeded / (slotSize || 1);
				step = step > 1 ? Math.ceil(step) : 1;
				return step * tickInterval;
			};

		if (horiz) {
			autoRotation = !labelOptions.staggerLines &&
				!labelOptions.step &&
				( // #3971
					defined(rotationOption) ?
						[rotationOption] :
						slotSize < pick(labelOptions.autoRotationLimit, 80) &&
							labelOptions.autoRotation
				);

			if (autoRotation) {

				// Loop over the given autoRotation options, and determine 
				// which gives the best score. The best score is that with
				// the lowest number of steps and a rotation closest
				// to horizontal.
				each(autoRotation, function (rot) {
					var score;

					if (
						rot === rotationOption ||
						(rot && rot >= -90 && rot <= 90)
					) { // #3891
					
						step = getStep(
							Math.abs(labelMetrics.h / Math.sin(deg2rad * rot))
						);

						score = step + Math.abs(rot / 360);

						if (score < bestScore) {
							bestScore = score;
							rotation = rot;
							newTickInterval = step;
						}
					}
				});
			}

		} else if (!labelOptions.step) { // #4411
			newTickInterval = getStep(labelMetrics.h);
		}

		this.autoRotation = autoRotation;
		this.labelRotation = pick(rotation, rotationOption);

		return newTickInterval;
	},

	/**
	 * Get the general slot width for labels/categories on this axis. This may
	 * change between the pre-render (from Axis.getOffset) and the final tick
	 * rendering and placement.
	 *
	 * @private
	 * @return {Number}
	 *         The pixel width allocated to each axis label.
	 */
	getSlotWidth: function () {
		// #5086, #1580, #1931
		var chart = this.chart,
			horiz = this.horiz,
			labelOptions = this.options.labels,
			slotCount = Math.max(
				this.tickPositions.length - (this.categories ? 0 : 1),
				1
			),
			marginLeft = chart.margin[3];

		return (
			horiz &&
			(labelOptions.step || 0) < 2 &&
			!labelOptions.rotation && // #4415
			((this.staggerLines || 1) * this.len) / slotCount
		) || (
			!horiz && (
				// #7028
				(
					labelOptions.style &&
					parseInt(labelOptions.style.width, 10)
				) ||
				(
					marginLeft &&
					(marginLeft - chart.spacing[3])
				) ||
				chart.chartWidth * 0.33
			)
		);

	},

	/**
	 * Render the axis labels and determine whether ellipsis or rotation need
	 * to be applied.
	 *
	 * @private
	 */
	renderUnsquish: function () {
		var chart = this.chart,
			renderer = chart.renderer,
			tickPositions = this.tickPositions,
			ticks = this.ticks,
			labelOptions = this.options.labels,
			horiz = this.horiz,
			slotWidth = this.getSlotWidth(),
			innerWidth = Math.max(
				1,
				Math.round(slotWidth - 2 * (labelOptions.padding || 5))
			),
			attr = {},
			labelMetrics = this.labelMetrics(),
			textOverflowOption = labelOptions.style &&
				labelOptions.style.textOverflow,
			css,
			maxLabelLength = 0,
			label,
			i,
			pos;

		// Set rotation option unless it is "auto", like in gauges
		if (!isString(labelOptions.rotation)) {
			attr.rotation = labelOptions.rotation || 0; // #4443
		}

		// Get the longest label length
		each(tickPositions, function (tick) {
			tick = ticks[tick];
			if (tick && tick.labelLength > maxLabelLength) {
				maxLabelLength = tick.labelLength;
			}
		});
		this.maxLabelLength = maxLabelLength;
		

		// Handle auto rotation on horizontal axis
		if (this.autoRotation) {

			// Apply rotation only if the label is too wide for the slot, and
			// the label is wider than its height.
			if (
				maxLabelLength > innerWidth &&
				maxLabelLength > labelMetrics.h
			) {
				attr.rotation = this.labelRotation;
			} else {
				this.labelRotation = 0;
			}

		// Handle word-wrap or ellipsis on vertical axis
		} else if (slotWidth) {
			// For word-wrap or ellipsis
			css = { width: innerWidth + 'px' };

			if (!textOverflowOption) {
				css.textOverflow = 'clip';

				// On vertical axis, only allow word wrap if there is room
				// for more lines.
				i = tickPositions.length;
				while (!horiz && i--) {
					pos = tickPositions[i];
					label = ticks[pos].label;
					if (label) {
						// Reset ellipsis in order to get the correct
						// bounding box (#4070)
						if (
							label.styles &&
							label.styles.textOverflow === 'ellipsis'
						) {
							label.css({ textOverflow: 'clip' });

						// Set the correct width in order to read
						// the bounding box height (#4678, #5034)
						} else if (ticks[pos].labelLength > slotWidth) {
							label.css({ width: slotWidth + 'px' });
						}

						if (
							label.getBBox().height > (
								this.len / tickPositions.length -
								(labelMetrics.h - labelMetrics.f)
							)
						) {
							label.specCss = { textOverflow: 'ellipsis' };
						}
					}
				}
			}
		}


		// Add ellipsis if the label length is significantly longer than ideal
		if (attr.rotation) {
			css = { 
				width: (
					maxLabelLength > chart.chartHeight * 0.5 ?
						chart.chartHeight * 0.33 :
						chart.chartHeight
				) + 'px'
			};
			if (!textOverflowOption) {
				css.textOverflow = 'ellipsis';
			}
		}

		// Set the explicit or automatic label alignment
		this.labelAlign = labelOptions.align ||
			this.autoLabelAlign(this.labelRotation);
		if (this.labelAlign) {
			attr.align = this.labelAlign;
		}

		// Apply general and specific CSS
		each(tickPositions, function (pos) {
			var tick = ticks[pos],
				label = tick && tick.label;
			if (label) {
				// This needs to go before the CSS in old IE (#4502)
				label.attr(attr);

				if (css) {
					label.css(merge(css, label.specCss));
				}
				delete label.specCss;
				tick.rotation = attr.rotation;
			}
		});

		// Note: Why is this not part of getLabelPosition?
		this.tickRotCorr = renderer.rotCorr(
			labelMetrics.b,
			this.labelRotation || 0,
			this.side !== 0
		);
	},

	/**
	 * Return true if the axis has associated data.
	 *
	 * @return {Boolean}
	 *         True if the axis has associated visible series and those series
	 *         have either valid data points or explicit `min` and `max`
	 *         settings.
	 */
	hasData: function () {
		return (
			this.hasVisibleSeries ||
			(
				defined(this.min) &&
				defined(this.max) &&
				this.tickPositions &&
				this.tickPositions.length > 0
			)
		);
	},
	
	/**
	 * Adds the title defined in axis.options.title.
	 * @param {Boolean} display - whether or not to display the title
	 */
	addTitle: function (display) {
		var axis = this,
			renderer = axis.chart.renderer,
			horiz = axis.horiz,
			opposite = axis.opposite,
			options = axis.options,
			axisTitleOptions = options.title,
			textAlign;
		
		if (!axis.axisTitle) {
			textAlign = axisTitleOptions.textAlign;
			if (!textAlign) {
				textAlign = (horiz ? { 
					low: 'left',
					middle: 'center',
					high: 'right'
				} : { 
					low: opposite ? 'right' : 'left',
					middle: 'center',
					high: opposite ? 'left' : 'right'
				})[axisTitleOptions.align];
			}
			axis.axisTitle = renderer.text(
				axisTitleOptions.text,
				0,
				0,
				axisTitleOptions.useHTML
			)
			.attr({
				zIndex: 7,
				rotation: axisTitleOptions.rotation || 0,
				align: textAlign
			})
			.addClass('highcharts-axis-title')
			
			.css(axisTitleOptions.style)
			
			.add(axis.axisGroup);
			axis.axisTitle.isNew = true;
		}

		// Max width defaults to the length of the axis
		
		if (!axisTitleOptions.style.width && !axis.isRadial) {
		
			axis.axisTitle.css({
				width: axis.len
			});
		
		}
		
			
		
		// hide or show the title depending on whether showEmpty is set
		axis.axisTitle[display ? 'show' : 'hide'](true);
	},

	/**
	 * Generates a tick for initial positioning.
	 *
	 * @private
	 * @param {number} pos
	 *        The tick position in axis values.
	 * @param {number} i
	 *        The index of the tick in {@link Axis.tickPositions}.
	 */
	generateTick: function (pos) {
		var ticks = this.ticks;

		if (!ticks[pos]) {
			ticks[pos] = new Tick(this, pos);
		} else {
			ticks[pos].addLabel(); // update labels depending on tick interval
		}
	},

	/**
	 * Render the tick labels to a preliminary position to get their sizes.
	 *
	 * @private
	 */
	getOffset: function () {
		var axis = this,
			chart = axis.chart,
			renderer = chart.renderer,
			options = axis.options,
			tickPositions = axis.tickPositions,
			ticks = axis.ticks,
			horiz = axis.horiz,
			side = axis.side,
			invertedSide = chart.inverted  &&
				!axis.isZAxis ? [1, 0, 3, 2][side] : side,
			hasData,
			showAxis,
			titleOffset = 0,
			titleOffsetOption,
			titleMargin = 0,
			axisTitleOptions = options.title,
			labelOptions = options.labels,
			labelOffset = 0, // reset
			labelOffsetPadded,
			axisOffset = chart.axisOffset,
			clipOffset = chart.clipOffset,
			clip,
			directionFactor = [-1, 1, 1, -1][side],
			className = options.className,
			axisParent = axis.axisParent, // Used in color axis
			lineHeightCorrection,
			tickSize = this.tickSize('tick');

		// For reuse in Axis.render
		hasData = axis.hasData();
		axis.showAxis = showAxis = hasData || pick(options.showEmpty, true);

		// Set/reset staggerLines
		axis.staggerLines = axis.horiz && labelOptions.staggerLines;

		// Create the axisGroup and gridGroup elements on first iteration
		if (!axis.axisGroup) {
			axis.gridGroup = renderer.g('grid')
				.attr({ zIndex: options.gridZIndex || 1 })
				.addClass(
					'highcharts-' + this.coll.toLowerCase() + '-grid ' +
					(className || '')
				)
				.add(axisParent);
			axis.axisGroup = renderer.g('axis')
				.attr({ zIndex: options.zIndex || 2 })
				.addClass(
					'highcharts-' + this.coll.toLowerCase() + ' ' +
					(className || '')
				)
				.add(axisParent);
			axis.labelGroup = renderer.g('axis-labels')
				.attr({ zIndex: labelOptions.zIndex || 7 })
				.addClass(
					'highcharts-' + axis.coll.toLowerCase() + '-labels ' +
					(className || '')
				)
				.add(axisParent);
		}

		if (hasData || axis.isLinked) {

			// Generate ticks
			each(tickPositions, function (pos, i) {
				// i is not used here, but may be used in overrides
				axis.generateTick(pos, i);
			});

			axis.renderUnsquish();


			// Left side must be align: right and right side must
			// have align: left for labels
			axis.reserveSpaceDefault = (
				side === 0 ||
				side === 2 ||
				{ 1: 'left', 3: 'right' }[side] === axis.labelAlign
			);
			if (pick(
				labelOptions.reserveSpace,
				axis.labelAlign === 'center' ? true : null,
				axis.reserveSpaceDefault)
			) {
				each(tickPositions, function (pos) {
					// get the highest offset
					labelOffset = Math.max(
						ticks[pos].getLabelSize(),
						labelOffset
					);
				});
			}

			if (axis.staggerLines) {
				labelOffset *= axis.staggerLines;
			}
			axis.labelOffset = labelOffset * (axis.opposite ? -1 : 1);

		} else { // doesn't have data
			objectEach(ticks, function (tick, n) {
				tick.destroy();
				delete ticks[n];
			});
		}

		if (
			axisTitleOptions &&
			axisTitleOptions.text &&
			axisTitleOptions.enabled !== false
		) {
			axis.addTitle(showAxis);

			if (showAxis && axisTitleOptions.reserveSpace !== false) {
				axis.titleOffset = titleOffset =
					axis.axisTitle.getBBox()[horiz ? 'height' : 'width'];
				titleOffsetOption = axisTitleOptions.offset;
				titleMargin = defined(titleOffsetOption) ?
					0 :
					pick(axisTitleOptions.margin, horiz ? 5 : 10);
			}
		}

		// Render the axis line
		axis.renderLine();

		// handle automatic or user set offset
		axis.offset = directionFactor * pick(options.offset, axisOffset[side]);

		axis.tickRotCorr = axis.tickRotCorr || { x: 0, y: 0 }; // polar
		if (side === 0) {
			lineHeightCorrection = -axis.labelMetrics().h;
		} else if (side === 2) {
			lineHeightCorrection = axis.tickRotCorr.y;
		} else {
			lineHeightCorrection = 0;
		}

		// Find the padded label offset
		labelOffsetPadded = Math.abs(labelOffset) + titleMargin;
		if (labelOffset) {
			labelOffsetPadded -= lineHeightCorrection;
			labelOffsetPadded += directionFactor * (
				horiz ?
					pick(
						labelOptions.y,
						axis.tickRotCorr.y + directionFactor * 8
					) :
					labelOptions.x
			);
		}

		axis.axisTitleMargin = pick(titleOffsetOption, labelOffsetPadded);

		axisOffset[side] = Math.max(
			axisOffset[side],
			axis.axisTitleMargin + titleOffset + directionFactor * axis.offset,
			labelOffsetPadded, // #3027
			hasData && tickPositions.length && tickSize ?
				tickSize[0] + directionFactor * axis.offset :
				0 // #4866
		);

		// Decide the clipping needed to keep the graph inside
		// the plot area and axis lines
		clip = options.offset ?
			0 :
			Math.floor(axis.axisLine.strokeWidth() / 2) * 2; // #4308, #4371
		clipOffset[invertedSide] = Math.max(clipOffset[invertedSide], clip);
	},

	/**
	 * Internal function to get the path for the axis line. Extended for polar
	 * charts.
	 *
	 * @param  {Number} lineWidth
	 *         The line width in pixels.
	 * @return {Array}
	 *         The SVG path definition in array form.
	 */
	getLinePath: function (lineWidth) {
		var chart = this.chart,
			opposite = this.opposite,
			offset = this.offset,
			horiz = this.horiz,
			lineLeft = this.left + (opposite ? this.width : 0) + offset,
			lineTop = chart.chartHeight - this.bottom -
				(opposite ? this.height : 0) + offset;

		if (opposite) {
			lineWidth *= -1; // crispify the other way - #1480, #1687
		}

		return chart.renderer
			.crispLine([
				'M',
				horiz ?
					this.left :
					lineLeft,
				horiz ?
					lineTop :
					this.top,
				'L',
				horiz ?
					chart.chartWidth - this.right :
					lineLeft,
				horiz ?
					lineTop :
					chart.chartHeight - this.bottom
			], lineWidth);
	},

	/**
	 * Render the axis line. Called internally when rendering and redrawing the
	 * axis.
	 */
	renderLine: function () {
		if (!this.axisLine) {
			this.axisLine = this.chart.renderer.path()
				.addClass('highcharts-axis-line')
				.add(this.axisGroup);

			
			this.axisLine.attr({
				stroke: this.options.lineColor,
				'stroke-width': this.options.lineWidth,
				zIndex: 7
			});
			
		}
	},

	/**
	 * Position the axis title.
	 *
	 * @private
	 *
	 * @return {Object}
	 *         X and Y positions for the title.
	 */
	getTitlePosition: function () {
		// compute anchor points for each of the title align options
		var horiz = this.horiz,
			axisLeft = this.left,
			axisTop = this.top,
			axisLength = this.len,
			axisTitleOptions = this.options.title,
			margin = horiz ? axisLeft : axisTop,
			opposite = this.opposite,
			offset = this.offset,
			xOption = axisTitleOptions.x || 0,
			yOption = axisTitleOptions.y || 0,
			axisTitle = this.axisTitle,
			fontMetrics = this.chart.renderer.fontMetrics(
				axisTitleOptions.style && axisTitleOptions.style.fontSize,
				axisTitle
			),
			// The part of a multiline text that is below the baseline of the
			// first line. Subtract 1 to preserve pixel-perfectness from the 
			// old behaviour (v5.0.12), where only one line was allowed.
			textHeightOvershoot = Math.max(
				axisTitle.getBBox(null, 0).height - fontMetrics.h - 1,
				0
			),

			// the position in the length direction of the axis
			alongAxis = {
				low: margin + (horiz ? 0 : axisLength),
				middle: margin + axisLength / 2,
				high: margin + (horiz ? axisLength : 0)
			}[axisTitleOptions.align],

			// the position in the perpendicular direction of the axis
			offAxis = (horiz ? axisTop + this.height : axisLeft) +
				(horiz ? 1 : -1) * // horizontal axis reverses the margin
				(opposite ? -1 : 1) * // so does opposite axes
				this.axisTitleMargin +
				[
					-textHeightOvershoot, // top
					textHeightOvershoot, // right
					fontMetrics.f, // bottom
					-textHeightOvershoot // left
				][this.side];


		return {
			x: horiz ?
				alongAxis + xOption :
				offAxis + (opposite ? this.width : 0) + offset + xOption,
			y: horiz ?
				offAxis + yOption - (opposite ? this.height : 0) + offset :
				alongAxis + yOption
		};
	},

	/**
	 * Render a minor tick into the given position. If a minor tick already 
	 * exists in this position, move it.
	 * 
	 * @param  {number} pos
	 *         The position in axis values.
	 */
	renderMinorTick: function (pos) {
		var slideInTicks = this.chart.hasRendered && isNumber(this.oldMin),
			minorTicks = this.minorTicks;

		if (!minorTicks[pos]) {
			minorTicks[pos] = new Tick(this, pos, 'minor');
		}

		// Render new ticks in old position
		if (slideInTicks && minorTicks[pos].isNew) {
			minorTicks[pos].render(null, true);
		}

		minorTicks[pos].render(null, false, 1);
	},

	/**
	 * Render a major tick into the given position. If a tick already exists
	 * in this position, move it.
	 * 
	 * @param  {number} pos
	 *         The position in axis values.
	 * @param  {number} i
	 *         The tick index.
	 */
	renderTick: function (pos, i) {
		var isLinked = this.isLinked,
			ticks = this.ticks,
			slideInTicks = this.chart.hasRendered && isNumber(this.oldMin);
		
		// Linked axes need an extra check to find out if
		if (!isLinked || (pos >= this.min && pos <= this.max)) {

			if (!ticks[pos]) {
				ticks[pos] = new Tick(this, pos);
			}

			// render new ticks in old position
			if (slideInTicks && ticks[pos].isNew) {
				ticks[pos].render(i, true, 0.1);
			}

			ticks[pos].render(i);
		}
	},

	/**
	 * Render the axis.
	 *
	 * @private
	 */
	render: function () {
		var axis = this,
			chart = axis.chart,
			renderer = chart.renderer,
			options = axis.options,
			isLog = axis.isLog,
			lin2log = axis.lin2log,
			isLinked = axis.isLinked,
			tickPositions = axis.tickPositions,
			axisTitle = axis.axisTitle,
			ticks = axis.ticks,
			minorTicks = axis.minorTicks,
			alternateBands = axis.alternateBands,
			stackLabelOptions = options.stackLabels,
			alternateGridColor = options.alternateGridColor,
			tickmarkOffset = axis.tickmarkOffset,
			axisLine = axis.axisLine,
			showAxis = axis.showAxis,
			animation = animObject(renderer.globalAnimation),
			from,
			to;

		// Reset
		axis.labelEdge.length = 0;
		axis.overlap = false;

		// Mark all elements inActive before we go over and mark the active ones
		each([ticks, minorTicks, alternateBands], function (coll) {
			objectEach(coll, function (tick) {
				tick.isActive = false;
			});
		});

		// If the series has data draw the ticks. Else only the line and title
		if (axis.hasData() || isLinked) {

			// minor ticks
			if (axis.minorTickInterval && !axis.categories) {
				each(axis.getMinorTickPositions(), function (pos) {
					axis.renderMinorTick(pos);
				});
			}

			// Major ticks. Pull out the first item and render it last so that
			// we can get the position of the neighbour label. #808.
			if (tickPositions.length) { // #1300
				each(tickPositions, function (pos, i) {
					axis.renderTick(pos, i);
				});
				// In a categorized axis, the tick marks are displayed
				// between labels. So we need to add a tick mark and
				// grid line at the left edge of the X axis.
				if (tickmarkOffset && (axis.min === 0 || axis.single)) {
					if (!ticks[-1]) {
						ticks[-1] = new Tick(axis, -1, null, true);
					}
					ticks[-1].render(-1);
				}

			}

			// alternate grid color
			if (alternateGridColor) {
				each(tickPositions, function (pos, i) {
					to = tickPositions[i + 1] !== undefined ?
						tickPositions[i + 1] + tickmarkOffset :
						axis.max - tickmarkOffset;

					if (
						i % 2 === 0 &&
						pos < axis.max &&
						to <= axis.max + (
							chart.polar ?
								-tickmarkOffset :
								tickmarkOffset
						)
					) { // #2248, #4660
						if (!alternateBands[pos]) {
							alternateBands[pos] = new H.PlotLineOrBand(axis);
						}
						from = pos + tickmarkOffset; // #949
						alternateBands[pos].options = {
							from: isLog ? lin2log(from) : from,
							to: isLog ? lin2log(to) : to,
							color: alternateGridColor
						};
						alternateBands[pos].render();
						alternateBands[pos].isActive = true;
					}
				});
			}

			// custom plot lines and bands
			if (!axis._addedPlotLB) { // only first time
				each(
					(options.plotLines || []).concat(options.plotBands || []),
					function (plotLineOptions) {
						axis.addPlotBandOrLine(plotLineOptions);
					}
				);
				axis._addedPlotLB = true;
			}

		} // end if hasData

		// Remove inactive ticks
		each([ticks, minorTicks, alternateBands], function (coll) {
			var i,
				forDestruction = [],
				delay = animation.duration,
				destroyInactiveItems = function () {
					i = forDestruction.length;
					while (i--) {
						// When resizing rapidly, the same items
						// may be destroyed in different timeouts,
						// or the may be reactivated
						if (
							coll[forDestruction[i]] &&
							!coll[forDestruction[i]].isActive
						) {
							coll[forDestruction[i]].destroy();
							delete coll[forDestruction[i]];
						}
					}

				};

			objectEach(coll, function (tick, pos) {
				if (!tick.isActive) {
					// Render to zero opacity
					tick.render(pos, false, 0);
					tick.isActive = false;
					forDestruction.push(pos);
				}
			});

			// When the objects are finished fading out, destroy them
			syncTimeout(
				destroyInactiveItems, 
				coll === alternateBands ||
					!chart.hasRendered ||
					!delay ?
						0 :
						delay
			);
		});

		// Set the axis line path
		if (axisLine) {
			axisLine[axisLine.isPlaced ? 'animate' : 'attr']({
				d: this.getLinePath(axisLine.strokeWidth())
			});
			axisLine.isPlaced = true;

			// Show or hide the line depending on options.showEmpty
			axisLine[showAxis ? 'show' : 'hide'](true);
		}

		if (axisTitle && showAxis) {
			var titleXy = axis.getTitlePosition();
			if (isNumber(titleXy.y)) {
				axisTitle[axisTitle.isNew ? 'attr' : 'animate'](titleXy);
				axisTitle.isNew = false;
			} else {
				axisTitle.attr('y', -9999);
				axisTitle.isNew = true;
			}
		}

		// Stacked totals:
		if (stackLabelOptions && stackLabelOptions.enabled) {
			axis.renderStackTotals();
		}
		// End stacked totals

		axis.isDirty = false;
	},

	/**
	 * Redraw the axis to reflect changes in the data or axis extremes. Called
	 * internally from {@link Chart#redraw}.
	 *
	 * @private
	 */
	redraw: function () {

		if (this.visible) {
			// render the axis
			this.render();

			// move plot lines and bands
			each(this.plotLinesAndBands, function (plotLine) {
				plotLine.render();
			});
		}

		// mark associated series as dirty and ready for redraw
		each(this.series, function (series) {
			series.isDirty = true;
		});

	},

	// Properties to survive after destroy, needed for Axis.update (#4317,
	// #5773, #5881).
	keepProps: ['extKey', 'hcEvents', 'names', 'series', 'userMax', 'userMin'],
	
	/**
	 * Destroys an Axis instance. See {@link Axis#remove} for the API endpoint
	 * to fully remove the axis.
	 *
	 * @private
	 * @param  {Boolean} keepEvents
	 *         Whether to preserve events, used internally in Axis.update.
	 */
	destroy: function (keepEvents) {
		var axis = this,
			stacks = axis.stacks,
			plotLinesAndBands = axis.plotLinesAndBands,
			plotGroup,
			i;

		// Remove the events
		if (!keepEvents) {
			removeEvent(axis);
		}

		// Destroy each stack total
		objectEach(stacks, function (stack, stackKey) {
			destroyObjectProperties(stack);
			
			stacks[stackKey] = null;
		});

		// Destroy collections
		each(
			[axis.ticks, axis.minorTicks, axis.alternateBands],
			function (coll) {
				destroyObjectProperties(coll);
			}
		);
		if (plotLinesAndBands) {
			i = plotLinesAndBands.length;
			while (i--) { // #1975
				plotLinesAndBands[i].destroy();
			}
		}

		// Destroy local variables
		each(
			['stackTotalGroup', 'axisLine', 'axisTitle', 'axisGroup',
				'gridGroup', 'labelGroup', 'cross'],
			function (prop) {
				if (axis[prop]) {
					axis[prop] = axis[prop].destroy();
				}
			}
		);

		// Destroy each generated group for plotlines and plotbands
		for (plotGroup in axis.plotLinesAndBandsGroups) {
			axis.plotLinesAndBandsGroups[plotGroup] =
				axis.plotLinesAndBandsGroups[plotGroup].destroy();
		}

		// Delete all properties and fall back to the prototype.
		objectEach(axis, function (val, key) {
			if (inArray(key, axis.keepProps) === -1) {
				delete axis[key];
			}
		});
	},

	/**
	 * Internal function to draw a crosshair.
	 *
	 * @param  {PointerEvent} [e]
	 *         The event arguments from the modified pointer event, extended 
	 *         with `chartX` and `chartY`
	 * @param  {Point} [point]
	 *         The Point object if the crosshair snaps to points.
	 */
	drawCrosshair: function (e, point) {

		var path,
			options = this.crosshair,
			snap = pick(options.snap, true),
			pos,
			categorized,
			graphic = this.cross;

		// Use last available event when updating non-snapped crosshairs without
		// mouse interaction (#5287)
		if (!e) {
			e = this.cross && this.cross.e;
		}

		if (
			// Disabled in options
			!this.crosshair ||
			// Snap
			((defined(point) || !snap) === false)
		) {
			this.hideCrosshair();
		} else {

			// Get the path
			if (!snap) {
				pos = e &&
					(
						this.horiz ?
							e.chartX - this.pos :
							this.len - e.chartY + this.pos
					);
			} else if (defined(point)) {
				// #3834
				pos = this.isXAxis ? point.plotX : this.len - point.plotY;
			}

			if (defined(pos)) {
				path = this.getPlotLinePath(
					// First argument, value, only used on radial
					point && (this.isXAxis ?
						point.x :
						pick(point.stackY, point.y)
					),
					null,
					null,
					null,
					pos // Translated position
				) || null; // #3189
			}

			if (!defined(path)) {
				this.hideCrosshair();
				return;
			}

			categorized = this.categories && !this.isRadial;
			
			// Draw the cross
			if (!graphic) {
				this.cross = graphic = this.chart.renderer
					.path()
					.addClass(
						'highcharts-crosshair highcharts-crosshair-' + 
						(categorized ? 'category ' : 'thin ') +
						options.className
					)
					.attr({
						zIndex: pick(options.zIndex, 2)
					})
					.add();

				
				// Presentational attributes
				graphic.attr({
					'stroke': options.color ||
						(
							categorized ?
								color('#ccd6eb')
									.setOpacity(0.25).get() :
								'#cccccc'
						),
					'stroke-width': pick(options.width, 1)
				}).css({
					'pointer-events': 'none'
				});
				if (options.dashStyle) {
					graphic.attr({
						dashstyle: options.dashStyle
					});
				}
				
				
			}

			graphic.show().attr({
				d: path
			});

			if (categorized && !options.width) {
				graphic.attr({
					'stroke-width': this.transA
				});
			}
			this.cross.e = e;
		}
	},

	/**
	 *	Hide the crosshair if visible.
	 */
	hideCrosshair: function () {
		if (this.cross) {
			this.cross.hide();
		}
	}
}); // end Axis

H.Axis = Axis;
return Axis;
}(Highcharts));
(function (H) {
/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var Axis = H.Axis,
	defined = H.defined,
	each = H.each,
	extend = H.extend,
	getMagnitude = H.getMagnitude,
	normalizeTickInterval = H.normalizeTickInterval,
	pick = H.pick,
	timeUnits = H.timeUnits;
/**
 * Set the tick positions to a time unit that makes sense, for example
 * on the first of each month or on every Monday. Return an array
 * with the time positions. Used in datetime axes as well as for grouping
 * data on a datetime axis.
 *
 * @param {Object} normalizedInterval The interval in axis values (ms) and the count
 * @param {Number} min The minimum in axis values
 * @param {Number} max The maximum in axis values
 * @param {Number} startOfWeek
 */
Axis.prototype.getTimeTicks = function (normalizedInterval, min, max, startOfWeek) {
	var time = this.chart.time,
		Date = time.Date,
		tickPositions = [],
		i,
		higherRanks = {},
		minYear, // used in months and years as a basis for Date.UTC()
		// When crossing DST, use the max. Resolves #6278.
		minDate = new Date(
			min - Math.max(
				time.getTimezoneOffset(min),
				time.getTimezoneOffset(max)
			)
		),
		interval = normalizedInterval.unitRange,
		count = normalizedInterval.count,
		baseOffset, // #6797
		variableDayLength;

	if (defined(min)) { // #1300
		minDate[time.setMilliseconds](interval >= timeUnits.second ? 0 : // #3935
			count * Math.floor(minDate.getMilliseconds() / count)); // #3652, #3654

		if (interval >= timeUnits.second) { // second
			minDate[time.setSeconds](interval >= timeUnits.minute ? 0 : // #3935
				count * Math.floor(minDate.getSeconds() / count));
		}

		if (interval >= timeUnits.minute) { // minute
			minDate[time.setMinutes](interval >= timeUnits.hour ? 0 :
				count * Math.floor(minDate[time.getMinutes]() / count));
		}

		if (interval >= timeUnits.hour) { // hour
			minDate[time.setHours](interval >= timeUnits.day ? 0 :
				count * Math.floor(minDate[time.getHours]() / count));
		}

		if (interval >= timeUnits.day) { // day
			minDate[time.setDate](interval >= timeUnits.month ? 1 :
				count * Math.floor(minDate[time.getDate]() / count));
		}

		if (interval >= timeUnits.month) { // month
			minDate[time.setMonth](interval >= timeUnits.year ? 0 :
				count * Math.floor(minDate[time.getMonth]() / count));
			minYear = minDate[time.getFullYear]();
		}

		if (interval >= timeUnits.year) { // year
			minYear -= minYear % count;
			minDate[time.setFullYear](minYear);
		}

		// week is a special case that runs outside the hierarchy
		if (interval === timeUnits.week) {
			// get start of current week, independent of count
			minDate[time.setDate](minDate[time.getDate]() - minDate[time.getDay]() +
				pick(startOfWeek, 1));
		}


		// Get basics for variable time spans
		minYear = minDate[time.getFullYear]();
		var minMonth = minDate[time.getMonth](),
			minDateDate = minDate[time.getDate](),
			minHours = minDate[time.getHours]();
		
		// Redefine min to the floored/rounded minimum time (#7432)
		min = minDate.getTime();

		// Handle local timezone offset
		if (time.variableTimezone) {

			// Detect whether we need to take the DST crossover into
			// consideration. If we're crossing over DST, the day length may be
			// 23h or 25h and we need to compute the exact clock time for each
			// tick instead of just adding hours. This comes at a cost, so first
			// we find out if it is needed (#4951).
			variableDayLength = (
				// Long range, assume we're crossing over.
				max - min > 4 * timeUnits.month ||
				// Short range, check if min and max are in different time 
				// zones.
				time.getTimezoneOffset(min) !== time.getTimezoneOffset(max)
			);
		}


		// Adjust minDate to the offset date
		baseOffset = time.getTimezoneOffset(minDate);
		if (baseOffset) {
			minDate = new Date(min + baseOffset);
		}
		

		// Iterate and add tick positions at appropriate values
		var t = minDate.getTime();
		i = 1;
		while (t < max) {
			tickPositions.push(t);

			// if the interval is years, use Date.UTC to increase years
			if (interval === timeUnits.year) {
				t = time.makeTime(minYear + i * count, 0);

			// if the interval is months, use Date.UTC to increase months
			} else if (interval === timeUnits.month) {
				t = time.makeTime(minYear, minMonth + i * count);

			// if we're using global time, the interval is not fixed as it jumps
			// one hour at the DST crossover
			} else if (
					variableDayLength &&
					(interval === timeUnits.day || interval === timeUnits.week)
				) {
				t = time.makeTime(minYear, minMonth, minDateDate +
					i * count * (interval === timeUnits.day ? 1 : 7));

			} else if (variableDayLength && interval === timeUnits.hour) {
				// corrected by the start date time zone offset (baseOffset)
				// to hide duplicated label (#6797)
				t = time.makeTime(minYear, minMonth, minDateDate, minHours +
					i * count, 0, 0, baseOffset) - baseOffset;

			// else, the interval is fixed and we use simple addition
			} else {
				t += interval * count;
			}

			i++;
		}

		// push the last time
		tickPositions.push(t);


		// Handle higher ranks. Mark new days if the time is on midnight
		// (#950, #1649, #1760, #3349). Use a reasonable dropout threshold to 
		// prevent looping over dense data grouping (#6156).
		if (interval <= timeUnits.hour && tickPositions.length < 10000) {
			each(tickPositions, function (t) {
				if (
					// Speed optimization, no need to run dateFormat unless
					// we're on a full or half hour
					t % 1800000 === 0 &&
					// Check for local or global midnight
					time.dateFormat('%H%M%S%L', t) === '000000000'
				) {
					higherRanks[t] = 'day';	
				}
			});
		}
	}


	// record information on the chosen unit - for dynamic label formatter
	tickPositions.info = extend(normalizedInterval, {
		higherRanks: higherRanks,
		totalRange: interval * count
	});

	return tickPositions;
};

/**
 * Get a normalized tick interval for dates. Returns a configuration object with
 * unit range (interval), count and name. Used to prepare data for getTimeTicks.
 * Previously this logic was part of getTimeTicks, but as getTimeTicks now runs
 * of segments in stock charts, the normalizing logic was extracted in order to
 * prevent it for running over again for each segment having the same interval.
 * #662, #697.
 */
Axis.prototype.normalizeTimeTickInterval = function (tickInterval, unitsOption) {
	var units = unitsOption || [[
			'millisecond', // unit name
			[1, 2, 5, 10, 20, 25, 50, 100, 200, 500] // allowed multiples
		], [
			'second',
			[1, 2, 5, 10, 15, 30]
		], [
			'minute',
			[1, 2, 5, 10, 15, 30]
		], [
			'hour',
			[1, 2, 3, 4, 6, 8, 12]
		], [
			'day',
			[1, 2]
		], [
			'week',
			[1, 2]
		], [
			'month',
			[1, 2, 3, 4, 6]
		], [
			'year',
			null
		]],
		unit = units[units.length - 1], // default unit is years
		interval = timeUnits[unit[0]],
		multiples = unit[1],
		count,
		i;

	// loop through the units to find the one that best fits the tickInterval
	for (i = 0; i < units.length; i++) {
		unit = units[i];
		interval = timeUnits[unit[0]];
		multiples = unit[1];


		if (units[i + 1]) {
			// lessThan is in the middle between the highest multiple and the next unit.
			var lessThan = (interval * multiples[multiples.length - 1] +
						timeUnits[units[i + 1][0]]) / 2;

			// break and keep the current unit
			if (tickInterval <= lessThan) {
				break;
			}
		}
	}

	// prevent 2.5 years intervals, though 25, 250 etc. are allowed
	if (interval === timeUnits.year && tickInterval < 5 * interval) {
		multiples = [1, 2, 5];
	}

	// get the count
	count = normalizeTickInterval(
		tickInterval / interval,
		multiples,
		unit[0] === 'year' ? Math.max(getMagnitude(tickInterval / interval), 1) : 1 // #1913, #2360
	);

	return {
		unitRange: interval,
		count: count,
		unitName: unit[0]
	};
};

}(Highcharts));
(function (H) {
/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var Axis = H.Axis,
	getMagnitude = H.getMagnitude,
	map = H.map,
	normalizeTickInterval = H.normalizeTickInterval,
	pick = H.pick;
/**
 * Methods defined on the Axis prototype
 */

/**
 * Set the tick positions of a logarithmic axis
 */
Axis.prototype.getLogTickPositions = function (interval, min, max, minor) {
	var axis = this,
		options = axis.options,
		axisLength = axis.len,
		lin2log = axis.lin2log,
		log2lin = axis.log2lin,
		// Since we use this method for both major and minor ticks,
		// use a local variable and return the result
		positions = [];

	// Reset
	if (!minor) {
		axis._minorAutoInterval = null;
	}

	// First case: All ticks fall on whole logarithms: 1, 10, 100 etc.
	if (interval >= 0.5) {
		interval = Math.round(interval);
		positions = axis.getLinearTickPositions(interval, min, max);

	// Second case: We need intermediary ticks. For example
	// 1, 2, 4, 6, 8, 10, 20, 40 etc.
	} else if (interval >= 0.08) {
		var roundedMin = Math.floor(min),
			intermediate,
			i,
			j,
			len,
			pos,
			lastPos,
			break2;

		if (interval > 0.3) {
			intermediate = [1, 2, 4];
		} else if (interval > 0.15) { // 0.2 equals five minor ticks per 1, 10, 100 etc
			intermediate = [1, 2, 4, 6, 8];
		} else { // 0.1 equals ten minor ticks per 1, 10, 100 etc
			intermediate = [1, 2, 3, 4, 5, 6, 7, 8, 9];
		}

		for (i = roundedMin; i < max + 1 && !break2; i++) {
			len = intermediate.length;
			for (j = 0; j < len && !break2; j++) {
				pos = log2lin(lin2log(i) * intermediate[j]);
				if (pos > min && (!minor || lastPos <= max) && lastPos !== undefined) { // #1670, lastPos is #3113
					positions.push(lastPos);
				}

				if (lastPos > max) {
					break2 = true;
				}
				lastPos = pos;
			}
		}

	// Third case: We are so deep in between whole logarithmic values that
	// we might as well handle the tick positions like a linear axis. For
	// example 1.01, 1.02, 1.03, 1.04.
	} else {
		var realMin = lin2log(min),
			realMax = lin2log(max),
			tickIntervalOption = minor ? 
				this.getMinorTickInterval() : 
				options.tickInterval,
			filteredTickIntervalOption = tickIntervalOption === 'auto' ? null : tickIntervalOption,
			tickPixelIntervalOption = options.tickPixelInterval / (minor ? 5 : 1),
			totalPixelLength = minor ? axisLength / axis.tickPositions.length : axisLength;

		interval = pick(
			filteredTickIntervalOption,
			axis._minorAutoInterval,
			(realMax - realMin) * tickPixelIntervalOption / (totalPixelLength || 1)
		);

		interval = normalizeTickInterval(
			interval,
			null,
			getMagnitude(interval)
		);

		positions = map(axis.getLinearTickPositions(
			interval,
			realMin,
			realMax
		), log2lin);

		if (!minor) {
			axis._minorAutoInterval = interval / 5;
		}
	}

	// Set the axis-level tickInterval variable
	if (!minor) {
		axis.tickInterval = interval;
	}
	return positions;
};

Axis.prototype.log2lin = function (num) {
	return Math.log(num) / Math.LN10;
};

Axis.prototype.lin2log = function (num) {
	return Math.pow(10, num);
};

}(Highcharts));
(function (H, Axis) {
/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var arrayMax = H.arrayMax,
	arrayMin = H.arrayMin,
	defined = H.defined,
	destroyObjectProperties = H.destroyObjectProperties,
	each = H.each,
	erase = H.erase,
	merge = H.merge,
	pick = H.pick;
/*
 * The object wrapper for plot lines and plot bands
 * @param {Object} options
 */
H.PlotLineOrBand = function (axis, options) {
	this.axis = axis;

	if (options) {
		this.options = options;
		this.id = options.id;
	}
};

H.PlotLineOrBand.prototype = {
	
	/**
	 * Render the plot line or plot band. If it is already existing,
	 * move it.
	 */
	render: function () {
		var plotLine = this,
			axis = plotLine.axis,
			horiz = axis.horiz,
			options = plotLine.options,
			optionsLabel = options.label,
			label = plotLine.label,
			to = options.to,
			from = options.from,
			value = options.value,
			isBand = defined(from) && defined(to),
			isLine = defined(value),
			svgElem = plotLine.svgElem,
			isNew = !svgElem,
			path = [],
			color = options.color,
			zIndex = pick(options.zIndex, 0),
			events = options.events,
			attribs = {
				'class': 'highcharts-plot-' + (isBand ? 'band ' : 'line ') +
					(options.className || '')
			},
			groupAttribs = {},
			renderer = axis.chart.renderer,
			groupName = isBand ? 'bands' : 'lines',
			group,
			log2lin = axis.log2lin;

		// logarithmic conversion
		if (axis.isLog) {
			from = log2lin(from);
			to = log2lin(to);
			value = log2lin(value);
		}

		
		// Set the presentational attributes
		if (isLine) {
			attribs = {
				stroke: color,
				'stroke-width': options.width
			};
			if (options.dashStyle) {
				attribs.dashstyle = options.dashStyle;
			}
			
		} else if (isBand) { // plot band
			if (color) {
				attribs.fill = color;
			}
			if (options.borderWidth) {
				attribs.stroke = options.borderColor;
				attribs['stroke-width'] = options.borderWidth;
			}
		}
		

		// Grouping and zIndex
		groupAttribs.zIndex = zIndex;
		groupName += '-' + zIndex;

		group = axis.plotLinesAndBandsGroups[groupName];
		if (!group) {
			axis.plotLinesAndBandsGroups[groupName] = group =
				renderer.g('plot-' + groupName)
					.attr(groupAttribs).add();
		}

		// Create the path
		if (isNew) {
			plotLine.svgElem = svgElem = 
				renderer
					.path()
					.attr(attribs).add(group);
		}
		

		// Set the path or return
		if (isLine) {
			path = axis.getPlotLinePath(value, svgElem.strokeWidth());
		} else if (isBand) { // plot band
			path = axis.getPlotBandPath(from, to, options);
		} else {
			return;
		}


		// common for lines and bands
		if (isNew && path && path.length) {
			svgElem.attr({ d: path });

			// events
			if (events) {
				H.objectEach(events, function (event, eventType) {
					svgElem.on(eventType, function (e) {
						events[eventType].apply(plotLine, [e]);
					});
				});
			}
		} else if (svgElem) {
			if (path) {
				svgElem.show();
				svgElem.animate({ d: path });
			} else {
				svgElem.hide();
				if (label) {
					plotLine.label = label = label.destroy();
				}
			}
		}

		// the plot band/line label
		if (
			optionsLabel &&
			defined(optionsLabel.text) &&
			path &&
			path.length && 
			axis.width > 0 &&
			axis.height > 0 &&
			!path.flat
		) {
			// apply defaults
			optionsLabel = merge({
				align: horiz && isBand && 'center',
				x: horiz ? !isBand && 4 : 10,
				verticalAlign: !horiz && isBand && 'middle',
				y: horiz ? isBand ? 16 : 10 : isBand ? 6 : -4,
				rotation: horiz && !isBand && 90
			}, optionsLabel);

			this.renderLabel(optionsLabel, path, isBand, zIndex);

		} else if (label) { // move out of sight
			label.hide();
		}

		// chainable
		return plotLine;
	},

	/**
	 * Render and align label for plot line or band.
	 */
	renderLabel: function (optionsLabel, path, isBand, zIndex) {
		var plotLine = this,
			label = plotLine.label,
			renderer = plotLine.axis.chart.renderer,
			attribs,
			xBounds,
			yBounds,
			x,
			y;

		// add the SVG element
		if (!label) {
			attribs = {
				align: optionsLabel.textAlign || optionsLabel.align,
				rotation: optionsLabel.rotation,
				'class': 'highcharts-plot-' + (isBand ? 'band' : 'line') +
					'-label ' + (optionsLabel.className || '')
			};
			
			attribs.zIndex = zIndex;
			
			plotLine.label = label = renderer.text(
					optionsLabel.text,
					0,
					0,
					optionsLabel.useHTML
				)
				.attr(attribs)
				.add();

			
			label.css(optionsLabel.style);
			
		}

		// get the bounding box and align the label
		// #3000 changed to better handle choice between plotband or plotline
		xBounds = path.xBounds ||
			[path[1], path[4], (isBand ? path[6] : path[1])];
		yBounds = path.yBounds ||
			[path[2], path[5], (isBand ? path[7] : path[2])];
		
		x = arrayMin(xBounds);
		y = arrayMin(yBounds);

		label.align(optionsLabel, false, {
			x: x,
			y: y,
			width: arrayMax(xBounds) - x,
			height: arrayMax(yBounds) - y
		});
		label.show();
	},

	/**
	 * Remove the plot line or band
	 */
	destroy: function () {
		// remove it from the lookup
		erase(this.axis.plotLinesAndBands, this);

		delete this.axis;
		destroyObjectProperties(this);
	}
};

/**
 * Object with members for extending the Axis prototype
 * @todo Extend directly instead of adding object to Highcharts first
 */

H.extend(Axis.prototype, /** @lends Highcharts.Axis.prototype */ {

	/**
	 * Internal function to create the SVG path definition for a plot band.
	 *
	 * @param  {Number} from
	 *         The axis value to start from.
	 * @param  {Number} to
	 *         The axis value to end on.
	 *
	 * @return {Array.<String|Number>}
	 *         The SVG path definition in array form.
	 */
	getPlotBandPath: function (from, to) {
		var toPath = this.getPlotLinePath(to, null, null, true),
			path   = this.getPlotLinePath(from, null, null, true),
			result = [],
			i,
			// #4964 check if chart is inverted or plotband is on yAxis 
			horiz  = this.horiz,
			plus = 1,
			flat,
			outside =
				(from < this.min && to < this.min) ||
				(from > this.max && to > this.max);

		if (path && toPath) {
			
			// Flat paths don't need labels (#3836)
			if (outside) {
				flat = path.toString() === toPath.toString();
				plus = 0;
			}

			// Go over each subpath - for panes in Highstock
			for (i = 0; i < path.length; i += 6) {

				// Add 1 pixel when coordinates are the same
				if (horiz && toPath[i + 1] === path[i + 1]) {
					toPath[i + 1] += plus;
					toPath[i + 4] += plus;
				} else if (!horiz && toPath[i + 2] === path[i + 2]) {
					toPath[i + 2] += plus;
					toPath[i + 5] += plus;
				}

				result.push(
					'M',
					path[i + 1],
					path[i + 2],
					'L',
					path[i + 4],
					path[i + 5],
					toPath[i + 4],
					toPath[i + 5],
					toPath[i + 1],
					toPath[i + 2],
					'z'
				);
				result.flat = flat;
			}

		} else { // outside the axis area
			path = null;
		}

		return result;
	},

	/**
	 * Add a plot band after render time.
	 *
	 * @param  {AxisPlotBandsOptions} options
	 *         A configuration object for the plot band, as defined in {@link
	 *         https://api.highcharts.com/highcharts/xAxis.plotBands|
	 *         xAxis.plotBands}.
	 * @return {Object}
	 *         The added plot band.
	 * @sample highcharts/members/axis-addplotband/
	 *         Toggle the plot band from a button
	 */
	addPlotBand: function (options) {
		return this.addPlotBandOrLine(options, 'plotBands');
	},

	/**
	 * Add a plot line after render time.
	 * 
	 * @param  {AxisPlotLinesOptions} options
	 *         A configuration object for the plot line, as defined in {@link
	 *         https://api.highcharts.com/highcharts/xAxis.plotLines|
	 *         xAxis.plotLines}.
	 * @return {Object}
	 *         The added plot line.
	 * @sample highcharts/members/axis-addplotline/
	 *         Toggle the plot line from a button
	 */
	addPlotLine: function (options) {
		return this.addPlotBandOrLine(options, 'plotLines');
	},

	/**
	 * Add a plot band or plot line after render time. Called from addPlotBand
	 * and addPlotLine internally.
	 *
	 * @private
	 * @param  options {AxisPlotLinesOptions|AxisPlotBandsOptions}
	 *         The plotBand or plotLine configuration object.
	 */
	addPlotBandOrLine: function (options, coll) {
		var obj = new H.PlotLineOrBand(this, options).render(),
			userOptions = this.userOptions;

		if (obj) { // #2189
			// Add it to the user options for exporting and Axis.update
			if (coll) {
				userOptions[coll] = userOptions[coll] || [];
				userOptions[coll].push(options);
			}
			this.plotLinesAndBands.push(obj);
		}

		return obj;
	},

	/**
	 * Remove a plot band or plot line from the chart by id. Called internally
	 * from `removePlotBand` and `removePlotLine`.
	 *
	 * @private
	 * @param {String} id
	 */
	removePlotBandOrLine: function (id) {
		var plotLinesAndBands = this.plotLinesAndBands,
			options = this.options,
			userOptions = this.userOptions,
			i = plotLinesAndBands.length;
		while (i--) {
			if (plotLinesAndBands[i].id === id) {
				plotLinesAndBands[i].destroy();
			}
		}
		each([
			options.plotLines || [],
			userOptions.plotLines || [],
			options.plotBands || [],
			userOptions.plotBands || []
		], function (arr) {
			i = arr.length;
			while (i--) {
				if (arr[i].id === id) {
					erase(arr, arr[i]);
				}
			}
		});
	},

	/**
	 * Remove a plot band by its id.
	 * 
	 * @param  {String} id
	 *         The plot band's `id` as given in the original configuration
	 *         object or in the `addPlotBand` option.
	 * @sample highcharts/members/axis-removeplotband/
	 *         Remove plot band by id
	 * @sample highcharts/members/axis-addplotband/
	 *         Toggle the plot band from a button
	 */
	removePlotBand: function (id) {
		this.removePlotBandOrLine(id);
	},

	/**
	 * Remove a plot line by its id.
	 * @param  {String} id
	 *         The plot line's `id` as given in the original configuration
	 *         object or in the `addPlotLine` option.
	 * @sample highcharts/xaxis/plotlines-id/
	 *         Remove plot line by id
	 * @sample highcharts/members/axis-addplotline/
	 *         Toggle the plot line from a button
	 */
	removePlotLine: function (id) {
		this.removePlotBandOrLine(id);
	}
});

}(Highcharts, Axis));
(function (H) {
/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var each = H.each,
	extend = H.extend,
	format = H.format,
	isNumber = H.isNumber,
	map = H.map,
	merge = H.merge,
	pick = H.pick,
	splat = H.splat,
	syncTimeout = H.syncTimeout,
	timeUnits = H.timeUnits;
/**
 * The tooltip object
 * @param {Object} chart The chart instance
 * @param {Object} options Tooltip options
 */
H.Tooltip = function () {
	this.init.apply(this, arguments);
};

H.Tooltip.prototype = {

	init: function (chart, options) {

		// Save the chart and options
		this.chart = chart;
		this.options = options;

		// List of crosshairs
		this.crosshairs = [];

		// Current values of x and y when animating
		this.now = { x: 0, y: 0 };

		// The tooltip is initially hidden
		this.isHidden = true;



		// Public property for getting the shared state.
		this.split = options.split && !chart.inverted;
		this.shared = options.shared || this.split;

	},

	/**
	 * Destroy the single tooltips in a split tooltip.
	 * If the tooltip is active then it is not destroyed, unless forced to.
	 * @param  {boolean} force Force destroy all tooltips.
	 * @return {undefined}
	 */
	cleanSplit: function (force) {
		each(this.chart.series, function (series) {
			var tt = series && series.tt;
			if (tt) {
				if (!tt.isActive || force) {
					series.tt = tt.destroy();
				} else {
					tt.isActive = false;
				}
			}
		});
	},

	
	

	/**
	 * Create the Tooltip label element if it doesn't exist, then return the
	 * label.
	 */
	getLabel: function () {

		var renderer = this.chart.renderer,
			options = this.options;

		if (!this.label) {
			// Create the label
			if (this.split) {
				this.label = renderer.g('tooltip');
			} else {
				this.label = renderer.label(
						'',
						0,
						0,
						options.shape || 'callout',
						null,
						null,
						options.useHTML,
						null,
						'tooltip'
					)
					.attr({
						padding: options.padding,
						r: options.borderRadius
					});

				
				this.label
					.attr({
						'fill': options.backgroundColor,
						'stroke-width': options.borderWidth
					})
					// #2301, #2657
					.css(options.style)
					.shadow(options.shadow);
				
			}
			
			

			this.label
				.attr({
					zIndex: 8
				})
				.add();
		}
		return this.label;
	},

	update: function (options) {
		this.destroy();
		// Update user options (#6218)
		merge(true, this.chart.options.tooltip.userOptions, options);
		this.init(this.chart, merge(true, this.options, options));
	},

	/**
	 * Destroy the tooltip and its elements.
	 */
	destroy: function () {
		// Destroy and clear local variables
		if (this.label) {
			this.label = this.label.destroy();
		}
		if (this.split && this.tt) {
			this.cleanSplit(this.chart, true);
			this.tt = this.tt.destroy();
		}
		clearTimeout(this.hideTimer);
		clearTimeout(this.tooltipTimeout);
	},

	/**
	 * Provide a soft movement for the tooltip
	 *
	 * @param {Number} x
	 * @param {Number} y
	 * @private
	 */
	move: function (x, y, anchorX, anchorY) {
		var tooltip = this,
			now = tooltip.now,
			animate = tooltip.options.animation !== false &&
				!tooltip.isHidden &&
				// When we get close to the target position, abort animation and
				// land on the right place (#3056)
				(Math.abs(x - now.x) > 1 || Math.abs(y - now.y) > 1),
			skipAnchor = tooltip.followPointer || tooltip.len > 1;

		// Get intermediate values for animation
		extend(now, {
			x: animate ? (2 * now.x + x) / 3 : x,
			y: animate ? (now.y + y) / 2 : y,
			anchorX: skipAnchor ?
				undefined :
				animate ? (2 * now.anchorX + anchorX) / 3 : anchorX,
			anchorY: skipAnchor ?
				undefined :
				animate ? (now.anchorY + anchorY) / 2 : anchorY
		});

		// Move to the intermediate value
		tooltip.getLabel().attr(now);


		// Run on next tick of the mouse tracker
		if (animate) {

			// Never allow two timeouts
			clearTimeout(this.tooltipTimeout);

			// Set the fixed interval ticking for the smooth tooltip
			this.tooltipTimeout = setTimeout(function () {
				// The interval function may still be running during destroy,
				// so check that the chart is really there before calling.
				if (tooltip) {
					tooltip.move(x, y, anchorX, anchorY);
				}
			}, 32);

		}
	},

	/**
	 * Hide the tooltip
	 */
	hide: function (delay) {
		var tooltip = this;
		// disallow duplicate timers (#1728, #1766)
		clearTimeout(this.hideTimer);
		delay = pick(delay, this.options.hideDelay, 500);
		if (!this.isHidden) {
			this.hideTimer = syncTimeout(function () {
				tooltip.getLabel()[delay ? 'fadeOut' : 'hide']();
				tooltip.isHidden = true;
			}, delay);
		}
	},

	/**
	 * Extendable method to get the anchor position of the tooltip
	 * from a point or set of points
	 */
	getAnchor: function (points, mouseEvent) {
		var ret,
			chart = this.chart,
			inverted = chart.inverted,
			plotTop = chart.plotTop,
			plotLeft = chart.plotLeft,
			plotX = 0,
			plotY = 0,
			yAxis,
			xAxis;

		points = splat(points);

		// Pie uses a special tooltipPos
		ret = points[0].tooltipPos;

		// When tooltip follows mouse, relate the position to the mouse
		if (this.followPointer && mouseEvent) {
			if (mouseEvent.chartX === undefined) {
				mouseEvent = chart.pointer.normalize(mouseEvent);
			}
			ret = [
				mouseEvent.chartX - chart.plotLeft,
				mouseEvent.chartY - plotTop
			];
		}
		// When shared, use the average position
		if (!ret) {
			each(points, function (point) {
				yAxis = point.series.yAxis;
				xAxis = point.series.xAxis;
				plotX += point.plotX  +
					(!inverted && xAxis ? xAxis.left - plotLeft : 0);
				plotY += 
					(
						point.plotLow ?
							(point.plotLow + point.plotHigh) / 2 :
							point.plotY
					) +
					(!inverted && yAxis ? yAxis.top - plotTop : 0); // #1151
			});

			plotX /= points.length;
			plotY /= points.length;

			ret = [
				inverted ? chart.plotWidth - plotY : plotX,
				this.shared && !inverted && points.length > 1 && mouseEvent ?
					// place shared tooltip next to the mouse (#424)
					mouseEvent.chartY - plotTop :
					inverted ? chart.plotHeight - plotX : plotY
			];
		}

		return map(ret, Math.round);
	},

	/**
	 * Place the tooltip in a chart without spilling over
	 * and not covering the point it self.
	 */
	getPosition: function (boxWidth, boxHeight, point) {

		var chart = this.chart,
			distance = this.distance,
			ret = {},
			// Don't use h if chart isn't inverted (#7242)
			h = (chart.inverted && point.h) || 0, // #4117
			swapped,
			first = ['y', chart.chartHeight, boxHeight,
				point.plotY + chart.plotTop, chart.plotTop,
				chart.plotTop + chart.plotHeight],
			second = ['x', chart.chartWidth, boxWidth,
				point.plotX + chart.plotLeft, chart.plotLeft,
				chart.plotLeft + chart.plotWidth],
			// The far side is right or bottom
			preferFarSide = !this.followPointer && pick(
				point.ttBelow,
				!chart.inverted === !!point.negative
			), // #4984
			
			/**
			 * Handle the preferred dimension. When the preferred dimension is
			 * tooltip on top or bottom of the point, it will look for space
			 * there.
			 */
			firstDimension = function (
				dim,
				outerSize,
				innerSize,
				point,
				min,
				max
			) {
				var roomLeft = innerSize < point - distance,
					roomRight = point + distance + innerSize < outerSize,
					alignedLeft = point - distance - innerSize,
					alignedRight = point + distance;

				if (preferFarSide && roomRight) {
					ret[dim] = alignedRight;
				} else if (!preferFarSide && roomLeft) {
					ret[dim] = alignedLeft;
				} else if (roomLeft) {
					ret[dim] = Math.min(
						max - innerSize,
						alignedLeft - h < 0 ? alignedLeft : alignedLeft - h
					);
				} else if (roomRight) {
					ret[dim] = Math.max(
						min,
						alignedRight + h + innerSize > outerSize ?
							alignedRight :
							alignedRight + h
					);
				} else {
					return false;
				}
			},
			/**
			 * Handle the secondary dimension. If the preferred dimension is
			 * tooltip on top or bottom of the point, the second dimension is to
			 * align the tooltip above the point, trying to align center but
			 * allowing left or right align within the chart box.
			 */
			secondDimension = function (dim, outerSize, innerSize, point) {
				var retVal;

				// Too close to the edge, return false and swap dimensions
				if (point < distance || point > outerSize - distance) {
					retVal = false;
				// Align left/top
				} else if (point < innerSize / 2) {
					ret[dim] = 1;
				// Align right/bottom
				} else if (point > outerSize - innerSize / 2) {
					ret[dim] = outerSize - innerSize - 2;
				// Align center
				} else {
					ret[dim] = point - innerSize / 2;
				}
				return retVal;
			},
			/**
			 * Swap the dimensions
			 */
			swap = function (count) {
				var temp = first;
				first = second;
				second = temp;
				swapped = count;
			},
			run = function () {
				if (firstDimension.apply(0, first) !== false) {
					if (
						secondDimension.apply(0, second) === false &&
						!swapped
					) {
						swap(true);
						run();
					}
				} else if (!swapped) {
					swap(true);
					run();
				} else {
					ret.x = ret.y = 0;
				}
			};

		// Under these conditions, prefer the tooltip on the side of the point
		if (chart.inverted || this.len > 1) {
			swap();
		}
		run();

		return ret;

	},

	/**
	 * In case no user defined formatter is given, this will be used. Note that
	 * the context here is an object holding point, series, x, y etc.
	 *
	 * @returns {String|Array<String>}
	 */
	defaultFormatter: function (tooltip) {
		var items = this.points || splat(this),
			s;

		// Build the header
		s = [tooltip.tooltipFooterHeaderFormatter(items[0])];

		// build the values
		s = s.concat(tooltip.bodyFormatter(items));

		// footer
		s.push(tooltip.tooltipFooterHeaderFormatter(items[0], true));

		return s;
	},

	/**
	 * Refresh the tooltip's text and position.
	 * @param {Object|Array} pointOrPoints Rither a point or an array of points
	 */
	refresh: function (pointOrPoints, mouseEvent) {
		var tooltip = this,
			label,
			options = tooltip.options,
			x,
			y,
			point = pointOrPoints,
			anchor,
			textConfig = {},
			text,
			pointConfig = [],
			formatter = options.formatter || tooltip.defaultFormatter,
			shared = tooltip.shared,
			currentSeries;

		if (!options.enabled) {
			return;
		}

		clearTimeout(this.hideTimer);

		// get the reference point coordinates (pie charts use tooltipPos)
		tooltip.followPointer = splat(point)[0].series.tooltipOptions
			.followPointer;
		anchor = tooltip.getAnchor(point, mouseEvent);
		x = anchor[0];
		y = anchor[1];

		// shared tooltip, array is sent over
		if (shared && !(point.series && point.series.noSharedTooltip)) {
			each(point, function (item) {
				item.setState('hover');

				pointConfig.push(item.getLabelConfig());
			});

			textConfig = {
				x: point[0].category,
				y: point[0].y
			};
			textConfig.points = pointConfig;
			point = point[0];

		// single point tooltip
		} else {
			textConfig = point.getLabelConfig();
		}
		this.len = pointConfig.length; // #6128
		text = formatter.call(textConfig, tooltip);

		// register the current series
		currentSeries = point.series;
		this.distance = pick(currentSeries.tooltipOptions.distance, 16);

		// update the inner HTML
		if (text === false) {
			this.hide();
		} else {

			label = tooltip.getLabel();

			// show it
			if (tooltip.isHidden) {
				label.attr({
					opacity: 1
				}).show();
			}

			// update text
			if (tooltip.split) {
				this.renderSplit(text, splat(pointOrPoints));
			} else {

				// Prevent the tooltip from flowing over the chart box (#6659)
				
				if (!options.style.width) {
				
					label.css({
						width: this.chart.spacingBox.width
					});
				
				}
				

				label.attr({
					text: text && text.join ? text.join('') : text
				});

				// Set the stroke color of the box to reflect the point
				label.removeClass(/highcharts-color-[\d]+/g)
					.addClass(
						'highcharts-color-' +
						pick(point.colorIndex, currentSeries.colorIndex)
					);

				
				label.attr({
					stroke: (
						options.borderColor ||
						point.color ||
						currentSeries.color ||
						'#666666'
					)
				});
				

				tooltip.updatePosition({
					plotX: x,
					plotY: y,
					negative: point.negative,
					ttBelow: point.ttBelow,
					h: anchor[2] || 0
				});
			}

			this.isHidden = false;
		}
	},

	/**
	 * Render the split tooltip. Loops over each point's text and adds
	 * a label next to the point, then uses the distribute function to 
	 * find best non-overlapping positions.
	 */
	renderSplit: function (labels, points) {
		var tooltip = this,
			boxes = [],
			chart = this.chart,
			ren = chart.renderer,
			rightAligned = true,
			options = this.options,
			headerHeight = 0,
			tooltipLabel = this.getLabel();

		// Graceful degradation for legacy formatters
		if (H.isString(labels)) { 
			labels = [false, labels];
		}
		// Create the individual labels for header and points, ignore footer
		each(labels.slice(0, points.length + 1), function (str, i) {
			if (str !== false) {
				var point = points[i - 1] ||
						// Item 0 is the header. Instead of this, we could also
						// use the crosshair label
						{ isHeader: true, plotX: points[0].plotX },
					owner = point.series || tooltip,
					tt = owner.tt,
					series = point.series || {},
					colorClass = 'highcharts-color-' + pick(
						point.colorIndex,
						series.colorIndex,
						'none'
					),
					target,
					x,
					bBox,
					boxWidth;

				// Store the tooltip referance on the series
				if (!tt) {
					owner.tt = tt = ren.label(
							null,
							null,
							null,
							'callout',
							null,
							null,
							options.useHTML
						)
						.addClass('highcharts-tooltip-box ' + colorClass)
						.attr({
							'padding': options.padding,
							'r': options.borderRadius,
							
							'fill': options.backgroundColor,
							'stroke': (
								options.borderColor ||
								point.color ||
								series.color ||
								'#333333'
							),
							'stroke-width': options.borderWidth
							
						})
						.add(tooltipLabel);
				}
		
				tt.isActive = true;
				tt.attr({
					text: str
				});
				
				tt.css(options.style)
					.shadow(options.shadow);
				

				// Get X position now, so we can move all to the other side in
				// case of overflow
				bBox = tt.getBBox();
				boxWidth = bBox.width + tt.strokeWidth();
				if (point.isHeader) {
					headerHeight = bBox.height;
					x = Math.max(
						0, // No left overflow
						Math.min(
							point.plotX + chart.plotLeft - boxWidth / 2,
							// No right overflow (#5794)
							chart.chartWidth - boxWidth
						)
					);
				} else {
					x = point.plotX + chart.plotLeft -
						pick(options.distance, 16) - boxWidth;
				}


				// If overflow left, we don't use this x in the next loop
				if (x < 0) {
					rightAligned = false;
				}

				// Prepare for distribution
				target = (point.series && point.series.yAxis &&
					point.series.yAxis.pos) + (point.plotY || 0);
				target -= chart.plotTop;
				boxes.push({
					target: point.isHeader ?
						chart.plotHeight + headerHeight :
						target,
					rank: point.isHeader ? 1 : 0,
					size: owner.tt.getBBox().height + 1,
					point: point,
					x: x,
					tt: tt
				});
			}
		});

		// Clean previous run (for missing points)
		this.cleanSplit();

		// Distribute and put in place
		H.distribute(boxes, chart.plotHeight + headerHeight);
		each(boxes, function (box) {
			var point = box.point,
				series = point.series;

			// Put the label in place
			box.tt.attr({
				visibility: box.pos === undefined ? 'hidden' : 'inherit',
				x: (rightAligned || point.isHeader ? 
					box.x :
					point.plotX + chart.plotLeft + pick(options.distance, 16)),
				y: box.pos + chart.plotTop,
				anchorX: point.isHeader ?
					point.plotX + chart.plotLeft :
					point.plotX + series.xAxis.pos,
				anchorY: point.isHeader ?
					box.pos + chart.plotTop - 15 :
					point.plotY + series.yAxis.pos
			});
		});
	},

	/**
	 * Find the new position and perform the move
	 */
	updatePosition: function (point) {
		var chart = this.chart,
			label = this.getLabel(),
			pos = (this.options.positioner || this.getPosition).call(
				this,
				label.width,
				label.height,
				point
			);

		// do the move
		this.move(
			Math.round(pos.x), 
			Math.round(pos.y || 0), // can be undefined (#3977) 
			point.plotX + chart.plotLeft, 
			point.plotY + chart.plotTop
		);
	},

	/**
	 * Get the optimal date format for a point, based on a range.
	 * @param  {number} range - The time range
	 * @param  {number|Date} date - The date of the point in question
	 * @param  {number} startOfWeek - An integer representing the first day of
	 * the week, where 0 is Sunday
	 * @param  {Object} dateTimeLabelFormats - A map of time units to formats
	 * @return {string} - the optimal date format for a point
	 */
	getDateFormat: function (range, date, startOfWeek, dateTimeLabelFormats) {
		var time = this.chart.time,
			dateStr = time.dateFormat('%m-%d %H:%M:%S.%L', date),
			format,
			n,
			blank = '01-01 00:00:00.000',
			strpos = {
				millisecond: 15,
				second: 12,
				minute: 9,
				hour: 6,
				day: 3
			},
			lastN = 'millisecond'; // for sub-millisecond data, #4223
		for (n in timeUnits) {

			// If the range is exactly one week and we're looking at a
			// Sunday/Monday, go for the week format
			if (
				range === timeUnits.week &&
				+time.dateFormat('%w', date) === startOfWeek &&
				dateStr.substr(6) === blank.substr(6)
			) {
				n = 'week';
				break;
			}

			// The first format that is too great for the range
			if (timeUnits[n] > range) {
				n = lastN;
				break;
			}

			// If the point is placed every day at 23:59, we need to show
			// the minutes as well. #2637.
			if (
				strpos[n] &&
				dateStr.substr(strpos[n]) !== blank.substr(strpos[n])
			) {
				break;
			}

			// Weeks are outside the hierarchy, only apply them on
			// Mondays/Sundays like in the first condition
			if (n !== 'week') {
				lastN = n;
			}
		}

		if (n) {
			format = dateTimeLabelFormats[n];
		}

		return format;
	},

	/**
	 * Get the best X date format based on the closest point range on the axis.
	 */
	getXDateFormat: function (point, options, xAxis) {
		var xDateFormat,
			dateTimeLabelFormats = options.dateTimeLabelFormats,
			closestPointRange = xAxis && xAxis.closestPointRange;

		if (closestPointRange) {
			xDateFormat = this.getDateFormat(
				closestPointRange,
				point.x,
				xAxis.options.startOfWeek,
				dateTimeLabelFormats
			);
		} else {
			xDateFormat = dateTimeLabelFormats.day;
		}

		return xDateFormat || dateTimeLabelFormats.year; // #2546, 2581
	},

	/**
	 * Format the footer/header of the tooltip
	 * #3397: abstraction to enable formatting of footer and header
	 */
	tooltipFooterHeaderFormatter: function (labelConfig, isFooter) {
		var footOrHead = isFooter ? 'footer' : 'header',
			series = labelConfig.series,
			tooltipOptions = series.tooltipOptions,
			xDateFormat = tooltipOptions.xDateFormat,
			xAxis = series.xAxis,
			isDateTime = (
				xAxis &&
				xAxis.options.type === 'datetime' &&
				isNumber(labelConfig.key)
			),
			formatString = tooltipOptions[footOrHead + 'Format'];

		// Guess the best date format based on the closest point distance (#568,
		// #3418)
		if (isDateTime && !xDateFormat) {
			xDateFormat = this.getXDateFormat(
				labelConfig,
				tooltipOptions,
				xAxis
			);
		}

		// Insert the footer date format if any
		if (isDateTime && xDateFormat) {
			each(
				(labelConfig.point && labelConfig.point.tooltipDateKeys) ||
					['key'],
				function (key) {
					formatString = formatString.replace(
						'{point.' + key + '}',
						'{point.' + key + ':' + xDateFormat + '}'
					);
				}
			);
		}

		return format(formatString, {
			point: labelConfig,
			series: series
		}, this.chart.time);
	},

	/**
	 * Build the body (lines) of the tooltip by iterating over the items and
	 * returning one entry for each item, abstracting this functionality allows
	 * to easily overwrite and extend it.
	 */
	bodyFormatter: function (items) {
		return map(items, function (item) {
			var tooltipOptions = item.series.tooltipOptions;
			return (
				tooltipOptions[
					(item.point.formatPrefix || 'point') + 'Formatter'
				] ||
				item.point.tooltipFormatter
			).call(
				item.point,
				tooltipOptions[(item.point.formatPrefix || 'point') + 'Format']
			);
		});
	}

};

}(Highcharts));
(function (Highcharts) {
/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var H = Highcharts,
	addEvent = H.addEvent,
	attr = H.attr,
	charts = H.charts,
	color = H.color,
	css = H.css,
	defined = H.defined,
	each = H.each,
	extend = H.extend,
	find = H.find,
	fireEvent = H.fireEvent,
	isObject = H.isObject,
	offset = H.offset,
	pick = H.pick,
	splat = H.splat,
	Tooltip = H.Tooltip;

/**
 * The mouse and touch tracker object. Each {@link Chart} item has one
 * assosiated Pointer item that can be accessed from the  {@link Chart.pointer}
 * property.
 *
 * @class
 * @param  {Chart} chart
 *         The Chart instance.
 * @param  {Options} options
 *         The root options object. The pointer uses options from the chart and
 *         tooltip structures.
 */
Highcharts.Pointer = function (chart, options) {
	this.init(chart, options);
};

Highcharts.Pointer.prototype = {
	/**
	 * Initialize the Pointer.
	 *
	 * @private
	 */
	init: function (chart, options) {

		// Store references
		this.options = options;
		this.chart = chart;

		// Do we need to handle click on a touch device?
		this.runChartClick = options.chart.events && !!options.chart.events.click;

		this.pinchDown = [];
		this.lastValidTouch = {};

		if (Tooltip) {
			chart.tooltip = new Tooltip(chart, options.tooltip);
			this.followTouchMove = pick(options.tooltip.followTouchMove, true);
		}

		this.setDOMEvents();
	},

	/**
	 * Resolve the zoomType option, this is reset on all touch start and mouse
	 * down events.
	 *
	 * @private
	 */
	zoomOption: function (e) {
		var chart = this.chart,
			options = chart.options.chart,
			zoomType = options.zoomType || '',
			inverted = chart.inverted,
			zoomX,
			zoomY;

		// Look for the pinchType option
		if (/touch/.test(e.type)) {
			zoomType = pick(options.pinchType, zoomType);
		}

		this.zoomX = zoomX = /x/.test(zoomType);
		this.zoomY = zoomY = /y/.test(zoomType);
		this.zoomHor = (zoomX && !inverted) || (zoomY && inverted);
		this.zoomVert = (zoomY && !inverted) || (zoomX && inverted);
		this.hasZoom = zoomX || zoomY;
	},

	/**
	 * @typedef  {Object} PointerEvent
	 *           A native browser mouse or touch event, extended with position
	 *           information relative to the {@link Chart.container}.
	 * @property {Number} chartX
	 *           The X coordinate of the pointer interaction relative to the
	 *           chart.
	 * @property {Number} chartY
	 *           The Y coordinate of the pointer interaction relative to the 
	 *           chart.
	 * 
	 */
	/**
	 * Takes a browser event object and extends it with custom Highcharts
	 * properties `chartX` and `chartY` in order to work on the internal 
	 * coordinate system.
	 * 
	 * @param  {Object} e
	 *         The event object in standard browsers.
	 *
	 * @return {PointerEvent}
	 *         A browser event with extended properties `chartX` and `chartY`.
	 */
	normalize: function (e, chartPosition) {
		var ePos;

		// iOS (#2757)
		ePos = e.touches ?  (e.touches.length ? e.touches.item(0) : e.changedTouches[0]) : e;

		// Get mouse position
		if (!chartPosition) {
			this.chartPosition = chartPosition = offset(this.chart.container);
		}

		return extend(e, {
			chartX: Math.round(ePos.pageX - chartPosition.left),
			chartY: Math.round(ePos.pageY - chartPosition.top)
		});
	},

	/**
	 * Get the click position in terms of axis values.
	 *
	 * @param  {PointerEvent} e
	 *         A pointer event, extended with `chartX` and `chartY`
	 *         properties.
	 */
	getCoordinates: function (e) {
		var coordinates = {
			xAxis: [],
			yAxis: []
		};

		each(this.chart.axes, function (axis) {
			coordinates[axis.isXAxis ? 'xAxis' : 'yAxis'].push({
				axis: axis,
				value: axis.toValue(e[axis.horiz ? 'chartX' : 'chartY'])
			});
		});
		return coordinates;
	},
	/**
	 * Finds the closest point to a set of coordinates, using the k-d-tree
	 * algorithm.
	 *
	 * @param  {Array.<Series>} series
	 *         All the series to search in.
	 * @param  {boolean} shared
	 *         Whether it is a shared tooltip or not.
	 * @param  {object} coordinates
	 *         Chart coordinates of the pointer.
	 * @param  {number} coordinates.chartX
	 * @param  {number} coordinates.chartY
	 *
	 * @return {Point|undefined} The point closest to given coordinates.
	 */
	findNearestKDPoint: function (series, shared, coordinates) {
		var closest,
			sort = function (p1, p2) {
				var isCloserX = p1.distX - p2.distX,
					isCloser = p1.dist - p2.dist,
					isAbove =
						(p2.series.group && p2.series.group.zIndex) -
						(p1.series.group && p1.series.group.zIndex),
					result;

				// We have two points which are not in the same place on xAxis
				// and shared tooltip:
				if (isCloserX !== 0 && shared) { // #5721
					result = isCloserX;
				// Points are not exactly in the same place on x/yAxis:
				} else if (isCloser !== 0) {
					result = isCloser;
				// The same xAxis and yAxis position, sort by z-index:
				} else if (isAbove !== 0) {
					result = isAbove;
				// The same zIndex, sort by array index:
				} else {
					result = p1.series.index > p2.series.index ? -1 : 1;
				}
				return result;
			};
		each(series, function (s) {
			var noSharedTooltip = s.noSharedTooltip && shared,
				compareX = (
					!noSharedTooltip &&
					s.options.findNearestPointBy.indexOf('y') < 0
				),
				point = s.searchPoint(
					coordinates,
					compareX
				);
			if (
				// Check that we actually found a point on the series.
				isObject(point, true) &&
				// Use the new point if it is closer.
				(!isObject(closest, true) || (sort(closest, point) > 0))
			) {
				closest = point;
			}
		});
		return closest;
	},
	getPointFromEvent: function (e) {
		var target = e.target,
			point;

		while (target && !point) {
			point = target.point;
			target = target.parentNode;
		}
		return point;
	},
	
	getChartCoordinatesFromPoint: function (point, inverted) {
		var series = point.series,
			xAxis = series.xAxis,
			yAxis = series.yAxis,
			plotX = pick(point.clientX, point.plotX);

		if (xAxis && yAxis) {
			return inverted ? {
				chartX: xAxis.len + xAxis.pos - plotX,
				chartY: yAxis.len + yAxis.pos - point.plotY
			} : {
				chartX: plotX + xAxis.pos,
				chartY: point.plotY + yAxis.pos
			};
		}
	},

	/**
	 * Calculates what is the current hovered point/points and series.
	 *
	 * @private
	 *
	 * @param  {undefined|Point} existingHoverPoint
	 *         The point currrently beeing hovered.
	 * @param  {undefined|Series} existingHoverSeries
	 *         The series currently beeing hovered.
	 * @param  {Array.<Series>} series
	 *         All the series in the chart.
	 * @param  {boolean} isDirectTouch
	 *         Is the pointer directly hovering the point.
	 * @param  {boolean} shared
	 *         Whether it is a shared tooltip or not.
	 * @param  {object} coordinates
	 *         Chart coordinates of the pointer.
	 * @param  {number} coordinates.chartX
	 * @param  {number} coordinates.chartY
	 * 
	 * @return {object}
	 *         Object containing resulting hover data.
	 */
	getHoverData: function (
		existingHoverPoint,
		existingHoverSeries,
		series,
		isDirectTouch,
		shared,
		coordinates,
		params
	) {
		var hoverPoint,
			hoverPoints = [],
			hoverSeries = existingHoverSeries,
			isBoosting = params && params.isBoosting,
			useExisting = !!(isDirectTouch && existingHoverPoint),
			notSticky = hoverSeries && !hoverSeries.stickyTracking,
			filter = function (s) {
				return (
					s.visible &&
					!(!shared && s.directTouch) && // #3821
					pick(s.options.enableMouseTracking, true)
				);
			},
			// Which series to look in for the hover point
			searchSeries = notSticky ?
				// Only search on hovered series if it has stickyTracking false
				[hoverSeries] :
				// Filter what series to look in.
				H.grep(series, function (s) {
					return filter(s) && s.stickyTracking;
				});

		// Use existing hovered point or find the one closest to coordinates.
		hoverPoint = useExisting ?
			existingHoverPoint :
			this.findNearestKDPoint(searchSeries, shared, coordinates);

		// Assign hover series
		hoverSeries = hoverPoint && hoverPoint.series;

		// If we have a hoverPoint, assign hoverPoints.
		if (hoverPoint) {
			// When tooltip is shared, it displays more than one point
			if (shared && !hoverSeries.noSharedTooltip) {
				searchSeries = H.grep(series, function (s) {
					return filter(s) && !s.noSharedTooltip;
				});

				// Get all points with the same x value as the hoverPoint
				each(searchSeries, function (s) {
					var point = find(s.points, function (p) {
						return p.x === hoverPoint.x && !p.isNull;
					});
					if (isObject(point)) {
						/*
						* Boost returns a minimal point. Convert it to a usable
						* point for tooltip and states.
						*/
						if (isBoosting) {
							point = s.getPoint(point);
						}
						hoverPoints.push(point);
					}
				});
			} else {
				hoverPoints.push(hoverPoint);
			}
		}
		return {
			hoverPoint: hoverPoint,
			hoverSeries: hoverSeries,
			hoverPoints: hoverPoints
		};
	},
	/**
	 * With line type charts with a single tracker, get the point closest to the
	 * mouse. Run Point.onMouseOver and display tooltip for the point or points.
	 *
	 * @private
	 */
	runPointActions: function (e, p) {
		var pointer = this,
			chart = pointer.chart,
			series = chart.series,
			tooltip = chart.tooltip && chart.tooltip.options.enabled ? 
				chart.tooltip :
				undefined,
			shared = tooltip ? tooltip.shared : false,
			hoverPoint = p || chart.hoverPoint,
			hoverSeries = hoverPoint && hoverPoint.series || chart.hoverSeries,
			// onMouseOver or already hovering a series with directTouch
			isDirectTouch = !!p || (
				(hoverSeries && hoverSeries.directTouch) &&
				pointer.isDirectTouch
			),
			hoverData = this.getHoverData(
				hoverPoint,
				hoverSeries,
				series,
				isDirectTouch,
				shared,
				e,
				{ isBoosting: chart.isBoosting }
			),
			useSharedTooltip,
			followPointer,
			anchor,
			points;

		// Update variables from hoverData.
		hoverPoint = hoverData.hoverPoint;
		points = hoverData.hoverPoints;
		hoverSeries = hoverData.hoverSeries;
		followPointer = hoverSeries && hoverSeries.tooltipOptions.followPointer;
		useSharedTooltip = shared && hoverSeries && !hoverSeries.noSharedTooltip;

		// Refresh tooltip for kdpoint if new hover point or tooltip was hidden
		// #3926, #4200
		if (
			hoverPoint &&
			// !(hoverSeries && hoverSeries.directTouch) &&
			(hoverPoint !== chart.hoverPoint || (tooltip && tooltip.isHidden))
		) {
			each(chart.hoverPoints || [], function (p) {
				if (H.inArray(p, points) === -1) {
					p.setState();
				}
			});
			// Do mouseover on all points (#3919, #3985, #4410, #5622)
			each(points || [], function (p) {
				p.setState('hover');
			});
			// set normal state to previous series
			if (chart.hoverSeries !== hoverSeries) {
				hoverSeries.onMouseOver();
			}

			// If tracking is on series in stead of on each point, 
			// fire mouseOver on hover point. // #4448
			if (chart.hoverPoint) {
				chart.hoverPoint.firePointEvent('mouseOut');
			}

			// Hover point may have been destroyed in the event handlers (#7127)
			if (!hoverPoint.series) {
				return;
			}

			hoverPoint.firePointEvent('mouseOver');
			chart.hoverPoints = points;
			chart.hoverPoint = hoverPoint;
			// Draw tooltip if necessary
			if (tooltip) {
				tooltip.refresh(useSharedTooltip ? points : hoverPoint, e);
			}
		// Update positions (regardless of kdpoint or hoverPoint)
		} else if (followPointer && tooltip && !tooltip.isHidden) {
			anchor = tooltip.getAnchor([{}], e);
			tooltip.updatePosition({ plotX: anchor[0], plotY: anchor[1] });
		}

		// Start the event listener to pick up the tooltip and crosshairs
		if (!pointer.unDocMouseMove) {
			pointer.unDocMouseMove = addEvent(
				chart.container.ownerDocument,
				'mousemove',
				function (e) {
					var chart = charts[H.hoverChartIndex];
					if (chart) {
						chart.pointer.onDocumentMouseMove(e);
					}
				}
			);
		}

		// Issues related to crosshair #4927, #5269 #5066, #5658
		each(chart.axes, function drawAxisCrosshair(axis) {
			var snap = pick(axis.crosshair.snap, true),
				point = !snap ?
					undefined :
					H.find(points, function (p) {
						return p.series[axis.coll] === axis;
					});

			// Axis has snapping crosshairs, and one of the hover points belongs
			// to axis. Always call drawCrosshair when it is not snap.
			if (point || !snap) {
				axis.drawCrosshair(e, point);
			// Axis has snapping crosshairs, but no hover point belongs to axis
			} else {
				axis.hideCrosshair();
			}
		});
	},

	/**
	 * Reset the tracking by hiding the tooltip, the hover series state and the
	 * hover point
	 *
	 * @param allowMove {Boolean}
	 *        Instead of destroying the tooltip altogether, allow moving it if
	 *        possible.
	 */
	reset: function (allowMove, delay) {
		var pointer = this,
			chart = pointer.chart,
			hoverSeries = chart.hoverSeries,
			hoverPoint = chart.hoverPoint,
			hoverPoints = chart.hoverPoints,
			tooltip = chart.tooltip,
			tooltipPoints = tooltip && tooltip.shared ? hoverPoints : hoverPoint;

		// Check if the points have moved outside the plot area (#1003, #4736, #5101)
		if (allowMove && tooltipPoints) {
			each(splat(tooltipPoints), function (point) {
				if (point.series.isCartesian && point.plotX === undefined) {
					allowMove = false;
				}
			});
		}
		
		// Just move the tooltip, #349
		if (allowMove) {
			if (tooltip && tooltipPoints) {
				tooltip.refresh(tooltipPoints);
				if (hoverPoint) { // #2500
					hoverPoint.setState(hoverPoint.state, true);
					each(chart.axes, function (axis) {
						if (axis.crosshair) {
							axis.drawCrosshair(null, hoverPoint);
						}
					});
				}
			}

		// Full reset
		} else {

			if (hoverPoint) {
				hoverPoint.onMouseOut();
			}

			if (hoverPoints) {
				each(hoverPoints, function (point) {
					point.setState();
				});
			}

			if (hoverSeries) {
				hoverSeries.onMouseOut();
			}

			if (tooltip) {
				tooltip.hide(delay);
			}

			if (pointer.unDocMouseMove) {
				pointer.unDocMouseMove = pointer.unDocMouseMove();
			}

			// Remove crosshairs
			each(chart.axes, function (axis) {
				axis.hideCrosshair();
			});

			pointer.hoverX = chart.hoverPoints = chart.hoverPoint = null;
		}
	},

	/**
	 * Scale series groups to a certain scale and translation.
	 *
	 * @private
	 */
	scaleGroups: function (attribs, clip) {

		var chart = this.chart,
			seriesAttribs;

		// Scale each series
		each(chart.series, function (series) {
			seriesAttribs = attribs || series.getPlotBox(); // #1701
			if (series.xAxis && series.xAxis.zoomEnabled && series.group) {
				series.group.attr(seriesAttribs);
				if (series.markerGroup) {
					series.markerGroup.attr(seriesAttribs);
					series.markerGroup.clip(clip ? chart.clipRect : null);
				}
				if (series.dataLabelsGroup) {
					series.dataLabelsGroup.attr(seriesAttribs);
				}
			}
		});

		// Clip
		chart.clipRect.attr(clip || chart.clipBox);
	},

	/**
	 * Start a drag operation.
	 *
	 * @private
	 */
	dragStart: function (e) {
		var chart = this.chart;

		// Record the start position
		chart.mouseIsDown = e.type;
		chart.cancelClick = false;
		chart.mouseDownX = this.mouseDownX = e.chartX;
		chart.mouseDownY = this.mouseDownY = e.chartY;
	},

	/**
	 * Perform a drag operation in response to a mousemove event while the mouse
	 * is down.
	 *
	 * @private
	 */
	drag: function (e) {

		var chart = this.chart,
			chartOptions = chart.options.chart,
			chartX = e.chartX,
			chartY = e.chartY,
			zoomHor = this.zoomHor,
			zoomVert = this.zoomVert,
			plotLeft = chart.plotLeft,
			plotTop = chart.plotTop,
			plotWidth = chart.plotWidth,
			plotHeight = chart.plotHeight,
			clickedInside,
			size,
			selectionMarker = this.selectionMarker,
			mouseDownX = this.mouseDownX,
			mouseDownY = this.mouseDownY,
			panKey = chartOptions.panKey && e[chartOptions.panKey + 'Key'];

		// If the device supports both touch and mouse (like IE11), and we are touch-dragging
		// inside the plot area, don't handle the mouse event. #4339.
		if (selectionMarker && selectionMarker.touch) {
			return;
		}

		// If the mouse is outside the plot area, adjust to cooordinates
		// inside to prevent the selection marker from going outside
		if (chartX < plotLeft) {
			chartX = plotLeft;
		} else if (chartX > plotLeft + plotWidth) {
			chartX = plotLeft + plotWidth;
		}

		if (chartY < plotTop) {
			chartY = plotTop;
		} else if (chartY > plotTop + plotHeight) {
			chartY = plotTop + plotHeight;
		}

		// determine if the mouse has moved more than 10px
		this.hasDragged = Math.sqrt(
			Math.pow(mouseDownX - chartX, 2) +
			Math.pow(mouseDownY - chartY, 2)
		);

		if (this.hasDragged > 10) {
			clickedInside = chart.isInsidePlot(mouseDownX - plotLeft, mouseDownY - plotTop);

			// make a selection
			if (chart.hasCartesianSeries && (this.zoomX || this.zoomY) && clickedInside && !panKey) {
				if (!selectionMarker) {
					this.selectionMarker = selectionMarker = chart.renderer.rect(
						plotLeft,
						plotTop,
						zoomHor ? 1 : plotWidth,
						zoomVert ? 1 : plotHeight,
						0
					)
					.attr({
						
						fill: chartOptions.selectionMarkerFill || color('#335cad').setOpacity(0.25).get(),
						
						'class': 'highcharts-selection-marker',						
						'zIndex': 7
					})
					.add();
				}
			}

			// adjust the width of the selection marker
			if (selectionMarker && zoomHor) {
				size = chartX - mouseDownX;
				selectionMarker.attr({
					width: Math.abs(size),
					x: (size > 0 ? 0 : size) + mouseDownX
				});
			}
			// adjust the height of the selection marker
			if (selectionMarker && zoomVert) {
				size = chartY - mouseDownY;
				selectionMarker.attr({
					height: Math.abs(size),
					y: (size > 0 ? 0 : size) + mouseDownY
				});
			}

			// panning
			if (clickedInside && !selectionMarker && chartOptions.panning) {
				chart.pan(e, chartOptions.panning);
			}
		}
	},

	/**
	 * On mouse up or touch end across the entire document, drop the selection.
	 *
	 * @private
	 */
	drop: function (e) {
		var pointer = this,
			chart = this.chart,
			hasPinched = this.hasPinched;

		if (this.selectionMarker) {
			var selectionData = {
					originalEvent: e, // #4890
					xAxis: [],
					yAxis: []
				},
				selectionBox = this.selectionMarker,
				selectionLeft = selectionBox.attr ? selectionBox.attr('x') : selectionBox.x,
				selectionTop = selectionBox.attr ? selectionBox.attr('y') : selectionBox.y,
				selectionWidth = selectionBox.attr ? selectionBox.attr('width') : selectionBox.width,
				selectionHeight = selectionBox.attr ? selectionBox.attr('height') : selectionBox.height,
				runZoom;

			// a selection has been made
			if (this.hasDragged || hasPinched) {

				// record each axis' min and max
				each(chart.axes, function (axis) {
					if (axis.zoomEnabled && defined(axis.min) && (hasPinched || pointer[{ xAxis: 'zoomX', yAxis: 'zoomY' }[axis.coll]])) { // #859, #3569
						var horiz = axis.horiz,
							minPixelPadding = e.type === 'touchend' ? axis.minPixelPadding : 0, // #1207, #3075
							selectionMin = axis.toValue((horiz ? selectionLeft : selectionTop) + minPixelPadding),
							selectionMax = axis.toValue((horiz ? selectionLeft + selectionWidth : selectionTop + selectionHeight) - minPixelPadding);

						selectionData[axis.coll].push({
							axis: axis,
							min: Math.min(selectionMin, selectionMax), // for reversed axes
							max: Math.max(selectionMin, selectionMax)
						});
						runZoom = true;
					}
				});
				if (runZoom) {
					fireEvent(chart, 'selection', selectionData, function (args) { 
						chart.zoom(extend(args, hasPinched ? { animation: false } : null)); 
					});
				}

			}
			this.selectionMarker = this.selectionMarker.destroy();

			// Reset scaling preview
			if (hasPinched) {
				this.scaleGroups();
			}
		}

		// Reset all
		if (chart) { // it may be destroyed on mouse up - #877
			css(chart.container, { cursor: chart._cursor });
			chart.cancelClick = this.hasDragged > 10; // #370
			chart.mouseIsDown = this.hasDragged = this.hasPinched = false;
			this.pinchDown = [];
		}
	},

	onContainerMouseDown: function (e) {

		if (e.button !== 2) {

			e = this.normalize(e);

			this.zoomOption(e);

			// issue #295, dragging not always working in Firefox
			if (e.preventDefault) {
				e.preventDefault();
			}

			this.dragStart(e);
		}
	},



	onDocumentMouseUp: function (e) {
		if (charts[H.hoverChartIndex]) {
			charts[H.hoverChartIndex].pointer.drop(e);
		}
	},

	/**
	 * Special handler for mouse move that will hide the tooltip when the mouse
	 * leaves the plotarea. Issue #149 workaround. The mouseleave event does not
	 * always fire.
	 *
	 * @private
	 */
	onDocumentMouseMove: function (e) {
		var chart = this.chart,
			chartPosition = this.chartPosition;

		e = this.normalize(e, chartPosition);

		// If we're outside, hide the tooltip
		if (chartPosition && !this.inClass(e.target, 'highcharts-tracker') &&
				!chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) {
			this.reset();
		}
	},

	/**
	 * When mouse leaves the container, hide the tooltip.
	 *
	 * @private
	 */
	onContainerMouseLeave: function (e) {
		var chart = charts[H.hoverChartIndex];
		if (chart && (e.relatedTarget || e.toElement)) { // #4886, MS Touch end fires mouseleave but with no related target
			chart.pointer.reset();
			chart.pointer.chartPosition = null; // also reset the chart position, used in #149 fix
		}
	},

	// The mousemove, touchmove and touchstart event handler
	onContainerMouseMove: function (e) {

		var chart = this.chart;

		if (!defined(H.hoverChartIndex) || !charts[H.hoverChartIndex] || !charts[H.hoverChartIndex].mouseIsDown) {
			H.hoverChartIndex = chart.index;
		}

		e = this.normalize(e);
		e.returnValue = false; // #2251, #3224

		if (chart.mouseIsDown === 'mousedown') {
			this.drag(e);
		}

		// Show the tooltip and run mouse over events (#977)
		if ((this.inClass(e.target, 'highcharts-tracker') ||
				chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) && !chart.openMenu) {
			this.runPointActions(e);
		}
	},

	/**
	 * Utility to detect whether an element has, or has a parent with, a specific
	 * class name. Used on detection of tracker objects and on deciding whether
	 * hovering the tooltip should cause the active series to mouse out.
	 *
	 * @param  {SVGDOMElement|HTMLDOMElement} element
	 *         The element to investigate.
	 * @param  {String} className
	 *         The class name to look for.
	 *
	 * @return {Boolean}
	 *         True if either the element or one of its parents has the given
	 *         class name.
	 */
	inClass: function (element, className) {
		var elemClassName;
		while (element) {
			elemClassName = attr(element, 'class');
			if (elemClassName) {
				if (elemClassName.indexOf(className) !== -1) {
					return true;
				}
				if (elemClassName.indexOf('highcharts-container') !== -1) {
					return false;
				}
			}
			element = element.parentNode;
		}
	},

	onTrackerMouseOut: function (e) {
		var series = this.chart.hoverSeries,
			relatedTarget = e.relatedTarget || e.toElement;
		
		this.isDirectTouch = false;

		if (
			series &&
			relatedTarget &&
			!series.stickyTracking && 
			!this.inClass(relatedTarget, 'highcharts-tooltip') &&
			(
				!this.inClass(
					relatedTarget,
					'highcharts-series-' + series.index
				) || // #2499, #4465
				!this.inClass(relatedTarget, 'highcharts-tracker') // #5553
			)
		) {
			series.onMouseOut();
		}
	},

	onContainerClick: function (e) {
		var chart = this.chart,
			hoverPoint = chart.hoverPoint, 
			plotLeft = chart.plotLeft,
			plotTop = chart.plotTop;

		e = this.normalize(e);

		if (!chart.cancelClick) {

			// On tracker click, fire the series and point events. #783, #1583
			if (hoverPoint && this.inClass(e.target, 'highcharts-tracker')) {

				// the series click event
				fireEvent(hoverPoint.series, 'click', extend(e, {
					point: hoverPoint
				}));

				// the point click event
				if (chart.hoverPoint) { // it may be destroyed (#1844)
					hoverPoint.firePointEvent('click', e);
				}

			// When clicking outside a tracker, fire a chart event
			} else {
				extend(e, this.getCoordinates(e));

				// fire a click event in the chart
				if (chart.isInsidePlot(e.chartX - plotLeft, e.chartY - plotTop)) {
					fireEvent(chart, 'click', e);
				}
			}


		}
	},

	/**
	 * Set the JS DOM events on the container and document. This method should contain
	 * a one-to-one assignment between methods and their handlers. Any advanced logic should
	 * be moved to the handler reflecting the event's name.
	 *
	 * @private
	 */
	setDOMEvents: function () {

		var pointer = this,
			container = pointer.chart.container,
			ownerDoc = container.ownerDocument;

		container.onmousedown = function (e) {
			pointer.onContainerMouseDown(e);
		};
		container.onmousemove = function (e) {
			pointer.onContainerMouseMove(e);
		};
		container.onclick = function (e) {
			pointer.onContainerClick(e);
		};
		this.unbindContainerMouseLeave = addEvent(
			container,
			'mouseleave',
			pointer.onContainerMouseLeave
		);
		if (!H.unbindDocumentMouseUp) {
			H.unbindDocumentMouseUp = addEvent(
				ownerDoc,
				'mouseup',
				pointer.onDocumentMouseUp
			);
		}
		if (H.hasTouch) {
			container.ontouchstart = function (e) {
				pointer.onContainerTouchStart(e);
			};
			container.ontouchmove = function (e) {
				pointer.onContainerTouchMove(e);
			};
			if (!H.unbindDocumentTouchEnd) {
				H.unbindDocumentTouchEnd = addEvent(
					ownerDoc,
					'touchend',
					pointer.onDocumentTouchEnd
				);
			}
		}

	},

	/**
	 * Destroys the Pointer object and disconnects DOM events.
	 */
	destroy: function () {
		var pointer = this;

		if (pointer.unDocMouseMove) {
			pointer.unDocMouseMove();
		}

		this.unbindContainerMouseLeave();
		
		if (!H.chartCount) {
			if (H.unbindDocumentMouseUp) {
				H.unbindDocumentMouseUp = H.unbindDocumentMouseUp();
			}
			if (H.unbindDocumentTouchEnd) {
				H.unbindDocumentTouchEnd = H.unbindDocumentTouchEnd();
			}
		}

		// memory and CPU leak
		clearInterval(pointer.tooltipTimeout);

		H.objectEach(pointer, function (val, prop) {
			pointer[prop] = null;
		});
	}
};

}(Highcharts));
(function (H) {
/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var charts = H.charts,
	each = H.each,
	extend = H.extend,
	map = H.map,
	noop = H.noop,
	pick = H.pick,
	Pointer = H.Pointer;

/* Support for touch devices */
extend(Pointer.prototype, /** @lends Pointer.prototype */ {

	/**
	 * Run translation operations
	 */
	pinchTranslate: function (
		pinchDown,
		touches, 
		transform,
		selectionMarker,
		clip,
		lastValidTouch
	) {
		if (this.zoomHor) {
			this.pinchTranslateDirection(
				true,
				pinchDown,
				touches,
				transform,
				selectionMarker,
				clip,
				lastValidTouch
			);
		}
		if (this.zoomVert) {
			this.pinchTranslateDirection(
				false,
				pinchDown,
				touches,
				transform,
				selectionMarker,
				clip,
				lastValidTouch
			);
		}
	},

	/**
	 * Run translation operations for each direction (horizontal and vertical)
	 * independently
	 */
	pinchTranslateDirection: function (horiz, pinchDown, touches, transform,
			selectionMarker, clip, lastValidTouch, forcedScale) {
		var chart = this.chart,
			xy = horiz ? 'x' : 'y',
			XY = horiz ? 'X' : 'Y',
			sChartXY = 'chart' + XY,
			wh = horiz ? 'width' : 'height',
			plotLeftTop = chart['plot' + (horiz ? 'Left' : 'Top')],
			selectionWH,
			selectionXY,
			clipXY,
			scale = forcedScale || 1,
			inverted = chart.inverted,
			bounds = chart.bounds[horiz ? 'h' : 'v'],
			singleTouch = pinchDown.length === 1,
			touch0Start = pinchDown[0][sChartXY],
			touch0Now = touches[0][sChartXY],
			touch1Start = !singleTouch && pinchDown[1][sChartXY],
			touch1Now = !singleTouch && touches[1][sChartXY],
			outOfBounds,
			transformScale,
			scaleKey,
			setScale = function () {
				// Don't zoom if fingers are too close on this axis
				if (!singleTouch && Math.abs(touch0Start - touch1Start) > 20) {
					scale = forcedScale || 
						Math.abs(touch0Now - touch1Now) /
						Math.abs(touch0Start - touch1Start); 
				}

				clipXY = ((plotLeftTop - touch0Now) / scale) + touch0Start;
				selectionWH = chart['plot' + (horiz ? 'Width' : 'Height')] /
					scale;
			};

		// Set the scale, first pass
		setScale();

		// The clip position (x or y) is altered if out of bounds, the selection
		// position is not
		selectionXY = clipXY;

		// Out of bounds
		if (selectionXY < bounds.min) {
			selectionXY = bounds.min;
			outOfBounds = true;
		} else if (selectionXY + selectionWH > bounds.max) {
			selectionXY = bounds.max - selectionWH;
			outOfBounds = true;
		}

		// Is the chart dragged off its bounds, determined by dataMin and
		// dataMax?
		if (outOfBounds) {

			// Modify the touchNow position in order to create an elastic drag
			// movement. This indicates to the user that the chart is responsive
			// but can't be dragged further.
			touch0Now -= 0.8 * (touch0Now - lastValidTouch[xy][0]);
			if (!singleTouch) {
				touch1Now -= 0.8 * (touch1Now - lastValidTouch[xy][1]);
			}

			// Set the scale, second pass to adapt to the modified touchNow
			// positions
			setScale();

		} else {
			lastValidTouch[xy] = [touch0Now, touch1Now];
		}

		// Set geometry for clipping, selection and transformation
		if (!inverted) {
			clip[xy] = clipXY - plotLeftTop;
			clip[wh] = selectionWH;
		}
		scaleKey = inverted ? (horiz ? 'scaleY' : 'scaleX') : 'scale' + XY;
		transformScale = inverted ? 1 / scale : scale;

		selectionMarker[wh] = selectionWH;
		selectionMarker[xy] = selectionXY;
		transform[scaleKey] = scale;
		transform['translate' + XY] = (transformScale * plotLeftTop) +
			(touch0Now - (transformScale * touch0Start));
	},

	/**
	 * Handle touch events with two touches
	 */
	pinch: function (e) {

		var self = this,
			chart = self.chart,
			pinchDown = self.pinchDown,
			touches = e.touches,
			touchesLength = touches.length,
			lastValidTouch = self.lastValidTouch,
			hasZoom = self.hasZoom,
			selectionMarker = self.selectionMarker,
			transform = {},
			fireClickEvent = touchesLength === 1 &&
				((self.inClass(e.target, 'highcharts-tracker') && 
				chart.runTrackerClick) || self.runChartClick),
			clip = {};

		// Don't initiate panning until the user has pinched. This prevents us
		// from blocking page scrolling as users scroll down a long page
		// (#4210).
		if (touchesLength > 1) {
			self.initiated = true;
		}

		// On touch devices, only proceed to trigger click if a handler is
		// defined
		if (hasZoom && self.initiated && !fireClickEvent) {
			e.preventDefault();
		}

		// Normalize each touch
		map(touches, function (e) {
			return self.normalize(e);
		});

		// Register the touch start position
		if (e.type === 'touchstart') {
			each(touches, function (e, i) {
				pinchDown[i] = { chartX: e.chartX, chartY: e.chartY };
			});
			lastValidTouch.x = [pinchDown[0].chartX, pinchDown[1] &&
				pinchDown[1].chartX];
			lastValidTouch.y = [pinchDown[0].chartY, pinchDown[1] &&
				pinchDown[1].chartY];

			// Identify the data bounds in pixels
			each(chart.axes, function (axis) {
				if (axis.zoomEnabled) {
					var bounds = chart.bounds[axis.horiz ? 'h' : 'v'],
						minPixelPadding = axis.minPixelPadding,
						min = axis.toPixels(
							pick(axis.options.min, axis.dataMin)
						),
						max = axis.toPixels(
							pick(axis.options.max, axis.dataMax)
						),
						absMin = Math.min(min, max),
						absMax = Math.max(min, max);

					// Store the bounds for use in the touchmove handler
					bounds.min = Math.min(axis.pos, absMin - minPixelPadding);
					bounds.max = Math.max(
						axis.pos + axis.len,
						absMax + minPixelPadding
					);
				}
			});
			self.res = true; // reset on next move

		// Optionally move the tooltip on touchmove
		} else if (self.followTouchMove && touchesLength === 1) {
			this.runPointActions(self.normalize(e));

		// Event type is touchmove, handle panning and pinching
		} else if (pinchDown.length) { // can be 0 when releasing, if touchend
				// fires first


			// Set the marker
			if (!selectionMarker) {
				self.selectionMarker = selectionMarker = extend({
					destroy: noop,
					touch: true
				}, chart.plotBox);
			}

			self.pinchTranslate(
				pinchDown,
				touches,
				transform,
				selectionMarker,
				clip,
				lastValidTouch
			);

			self.hasPinched = hasZoom;

			// Scale and translate the groups to provide visual feedback during
			// pinching
			self.scaleGroups(transform, clip);

			if (self.res) {
				self.res = false;
				this.reset(false, 0);
			}
		}
	},

	/**
	 * General touch handler shared by touchstart and touchmove.
	 */
	touch: function (e, start) {
		var chart = this.chart,
			hasMoved,
			pinchDown,
			isInside;

		if (chart.index !== H.hoverChartIndex) {
			this.onContainerMouseLeave({ relatedTarget: true });
		}
		H.hoverChartIndex = chart.index;

		if (e.touches.length === 1) {

			e = this.normalize(e);

			isInside = chart.isInsidePlot(
				e.chartX - chart.plotLeft,
				e.chartY - chart.plotTop
			);
			if (isInside && !chart.openMenu) {

				// Run mouse events and display tooltip etc
				if (start) {
					this.runPointActions(e);
				}

				// Android fires touchmove events after the touchstart even if
				// the finger hasn't moved, or moved only a pixel or two. In iOS
				// however, the touchmove doesn't fire unless the finger moves
				// more than ~4px. So we emulate this behaviour in Android by
				// checking how much it moved, and cancelling on small
				// distances. #3450.
				if (e.type === 'touchmove') {
					pinchDown = this.pinchDown;
					hasMoved = pinchDown[0] ? Math.sqrt( // #5266
						Math.pow(pinchDown[0].chartX - e.chartX, 2) +
						Math.pow(pinchDown[0].chartY - e.chartY, 2)
					) >= 4 : false;
				}

				if (pick(hasMoved, true)) {
					this.pinch(e);
				}

			} else if (start) {
				// Hide the tooltip on touching outside the plot area (#1203)
				this.reset();
			}

		} else if (e.touches.length === 2) {
			this.pinch(e);
		}
	},

	onContainerTouchStart: function (e) {
		this.zoomOption(e);
		this.touch(e, true);
	},

	onContainerTouchMove: function (e) {
		this.touch(e);
	},

	onDocumentTouchEnd: function (e) {
		if (charts[H.hoverChartIndex]) {
			charts[H.hoverChartIndex].pointer.drop(e);
		}
	}

});

}(Highcharts));
(function (H) {
/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var addEvent = H.addEvent,
	charts = H.charts,
	css = H.css,
	doc = H.doc,
	extend = H.extend,
	hasTouch = H.hasTouch,
	noop = H.noop,
	Pointer = H.Pointer,
	removeEvent = H.removeEvent,
	win = H.win,
	wrap = H.wrap;

if (!hasTouch && (win.PointerEvent || win.MSPointerEvent)) {
	
	// The touches object keeps track of the points being touched at all times
	var touches = {},
		hasPointerEvent = !!win.PointerEvent,
		getWebkitTouches = function () {
			var fake = [];
			fake.item = function (i) {
				return this[i];
			};
			H.objectEach(touches, function (touch) {
				fake.push({
					pageX: touch.pageX,
					pageY: touch.pageY,
					target: touch.target
				});
			});
			return fake;
		},
		translateMSPointer = function (e, method, wktype, func) {
			var p;
			if ((e.pointerType === 'touch' || e.pointerType === e.MSPOINTER_TYPE_TOUCH) && charts[H.hoverChartIndex]) {
				func(e);
				p = charts[H.hoverChartIndex].pointer;
				p[method]({
					type: wktype,
					target: e.currentTarget,
					preventDefault: noop,
					touches: getWebkitTouches()
				});
			}
		};

	/**
	 * Extend the Pointer prototype with methods for each event handler and more
	 */
	extend(Pointer.prototype, /** @lends Pointer.prototype */ {
		onContainerPointerDown: function (e) {
			translateMSPointer(e, 'onContainerTouchStart', 'touchstart', function (e) {
				touches[e.pointerId] = { pageX: e.pageX, pageY: e.pageY, target: e.currentTarget };
			});
		},
		onContainerPointerMove: function (e) {
			translateMSPointer(e, 'onContainerTouchMove', 'touchmove', function (e) {
				touches[e.pointerId] = { pageX: e.pageX, pageY: e.pageY };
				if (!touches[e.pointerId].target) {
					touches[e.pointerId].target = e.currentTarget;
				}
			});
		},
		onDocumentPointerUp: function (e) {
			translateMSPointer(e, 'onDocumentTouchEnd', 'touchend', function (e) {
				delete touches[e.pointerId];
			});
		},

		/**
		 * Add or remove the MS Pointer specific events
		 */
		batchMSEvents: function (fn) {
			fn(this.chart.container, hasPointerEvent ? 'pointerdown' : 'MSPointerDown', this.onContainerPointerDown);
			fn(this.chart.container, hasPointerEvent ? 'pointermove' : 'MSPointerMove', this.onContainerPointerMove);
			fn(doc, hasPointerEvent ? 'pointerup' : 'MSPointerUp', this.onDocumentPointerUp);
		}
	});

	// Disable default IE actions for pinch and such on chart element
	wrap(Pointer.prototype, 'init', function (proceed, chart, options) {
		proceed.call(this, chart, options);
		if (this.hasZoom) { // #4014
			css(chart.container, {
				'-ms-touch-action': 'none',
				'touch-action': 'none'
			});
		}
	});

	// Add IE specific touch events to chart
	wrap(Pointer.prototype, 'setDOMEvents', function (proceed) {
		proceed.apply(this);
		if (this.hasZoom || this.followTouchMove) {
			this.batchMSEvents(addEvent);
		}
	});
	// Destroy MS events also
	wrap(Pointer.prototype, 'destroy', function (proceed) {
		this.batchMSEvents(removeEvent);
		proceed.call(this);
	});
}

}(Highcharts));
(function (Highcharts) {
/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var H = Highcharts,

	addEvent = H.addEvent,
	css = H.css,
	discardElement = H.discardElement,
	defined = H.defined,
	each = H.each,
	isFirefox = H.isFirefox,
	marginNames = H.marginNames,
	merge = H.merge,
	pick = H.pick,
	setAnimation = H.setAnimation,
	stableSort = H.stableSort,
	win = H.win,
	wrap = H.wrap;

/**
 * The overview of the chart's series. The legend object is instanciated
 * internally in the chart constructor, and available from `chart.legend`. Each
 * chart has only one legend.
 * 
 * @class
 */
Highcharts.Legend = function (chart, options) {
	this.init(chart, options);
};

Highcharts.Legend.prototype = {

	/**
	 * Initialize the legend.
	 *
	 * @private
	 */
	init: function (chart, options) {

		this.chart = chart;
		
		this.setOptions(options);
		
		if (options.enabled) {
		
			// Render it
			this.render();

			// move checkboxes
			addEvent(this.chart, 'endResize', function () {
				this.legend.positionCheckboxes();
			});
		}
	},

	setOptions: function (options) {

		var padding = pick(options.padding, 8);

		this.options = options;
	
		
		this.itemStyle = options.itemStyle;
		this.itemHiddenStyle = merge(this.itemStyle, options.itemHiddenStyle);
		
		this.itemMarginTop = options.itemMarginTop || 0;
		this.padding = padding;
		this.initialItemY = padding - 5; // 5 is pixels above the text
		this.maxItemWidth = 0;
		this.itemHeight = 0;
		this.symbolWidth = pick(options.symbolWidth, 16);
		this.pages = [];

	},

	/**
	 * Update the legend with new options. Equivalent to running `chart.update`
	 * with a legend configuration option.
	 * @param  {LegendOptions} options
	 *         Legend options.
	 * @param  {Boolean} [redraw=true]
	 *         Whether to redraw the chart.
	 *
	 * @sample highcharts/legend/legend-update/
	 *         Legend update
	 */
	update: function (options, redraw) {
		var chart = this.chart;

		this.setOptions(merge(true, this.options, options));
		this.destroy();
		chart.isDirtyLegend = chart.isDirtyBox = true;
		if (pick(redraw, true)) {
			chart.redraw();
		}
	},

	/**
	 * Set the colors for the legend item.
	 *
	 * @private
	 * @param  {Series|Point} item
	 *         A Series or Point instance
	 * @param  {Boolean} visible
	 *         Dimmed or colored
	 */
	colorizeItem: function (item, visible) {
		item.legendGroup[visible ? 'removeClass' : 'addClass'](
			'highcharts-legend-item-hidden'
		);

		
		var legend = this,
			options = legend.options,
			legendItem = item.legendItem,
			legendLine = item.legendLine,
			legendSymbol = item.legendSymbol,
			hiddenColor = legend.itemHiddenStyle.color,
			textColor = visible ? options.itemStyle.color : hiddenColor,
			symbolColor = visible ? (item.color || hiddenColor) : hiddenColor,
			markerOptions = item.options && item.options.marker,
			symbolAttr = { fill: symbolColor };

		if (legendItem) {
			legendItem.css({
				fill: textColor,
				color: textColor // #1553, oldIE
			}); 
		}
		if (legendLine) {
			legendLine.attr({ stroke: symbolColor });
		}

		if (legendSymbol) {

			// Apply marker options
			if (markerOptions && legendSymbol.isMarker) { // #585
				symbolAttr = item.pointAttribs();
				if (!visible) {
					symbolAttr.stroke = symbolAttr.fill = hiddenColor; // #6769
				}
			}

			legendSymbol.attr(symbolAttr);
		}
		
	},

	/**
	 * Position the legend item.
	 *
	 * @private
	 * @param {Series|Point} item
	 *        The item to position
	 */
	positionItem: function (item) {
		var legend = this,
			options = legend.options,
			symbolPadding = options.symbolPadding,
			ltr = !options.rtl,
			legendItemPos = item._legendItemPos,
			itemX = legendItemPos[0],
			itemY = legendItemPos[1],
			checkbox = item.checkbox,
			legendGroup = item.legendGroup;

		if (legendGroup && legendGroup.element) {
			legendGroup.translate(
				ltr ? 
					itemX :
					legend.legendWidth - itemX - 2 * symbolPadding - 4,
				itemY
			);
		}

		if (checkbox) {
			checkbox.x = itemX;
			checkbox.y = itemY;
		}
	},

	/**
	 * Destroy a single legend item, used internally on removing series items.
	 * 
	 * @param {Series|Point} item
	 *        The item to remove
	 */
	destroyItem: function (item) {
		var checkbox = item.checkbox;

		// destroy SVG elements
		each(
			['legendItem', 'legendLine', 'legendSymbol', 'legendGroup'],
			function (key) {
				if (item[key]) {
					item[key] = item[key].destroy();
				}
			}
		);

		if (checkbox) {
			discardElement(item.checkbox);
		}
	},

	/**
	 * Destroy the legend. Used internally. To reflow objects, `chart.redraw`
	 * must be called after destruction.
	 */
	destroy: function () {
		function destroyItems(key) {
			if (this[key]) {
				this[key] = this[key].destroy();
			}
		}

		// Destroy items
		each(this.getAllItems(), function (item) {
			each(['legendItem', 'legendGroup'], destroyItems, item);
		});

		// Destroy legend elements
		each([
			'clipRect',
			'up',
			'down',
			'pager',
			'nav',
			'box',
			'title',
			'group'
		], destroyItems, this);
		this.display = null; // Reset in .render on update.
	},

	/**
	 * Position the checkboxes after the width is determined.
	 *
	 * @private
	 */
	positionCheckboxes: function () {
		var alignAttr = this.group && this.group.alignAttr,
			translateY,
			clipHeight = this.clipHeight || this.legendHeight,
			titleHeight = this.titleHeight;

		if (alignAttr) {
			translateY = alignAttr.translateY;
			each(this.allItems, function (item) {
				var checkbox = item.checkbox,
					top;

				if (checkbox) {
					top = translateY + titleHeight + checkbox.y +
						(this.scrollOffset || 0) + 3;
					css(checkbox, {
						left: (alignAttr.translateX + item.checkboxOffset +
							checkbox.x - 20) + 'px',
						top: top + 'px',
						display: top > translateY - 6 && top < translateY +
							clipHeight - 6 ? '' : 'none'
					});
				}
			}, this);
		}
	},

	/**
	 * Render the legend title on top of the legend.
	 *
	 * @private
	 */
	renderTitle: function () {
		var options = this.options,
			padding = this.padding,
			titleOptions = options.title,
			titleHeight = 0,
			bBox;

		if (titleOptions.text) {
			if (!this.title) {
				this.title = this.chart.renderer.label(
						titleOptions.text,
						padding - 3,
						padding - 4,
						null,
						null,
						null,
						options.useHTML,
						null,
						'legend-title'
					)
					.attr({ zIndex: 1 })
					
					.css(titleOptions.style)
					
					.add(this.group);
			}
			bBox = this.title.getBBox();
			titleHeight = bBox.height;
			this.offsetWidth = bBox.width; // #1717
			this.contentGroup.attr({ translateY: titleHeight });
		}
		this.titleHeight = titleHeight;
	},

	/**
	 * Set the legend item text.
	 *
	 * @param  {Series|Point} item
	 *         The item for which to update the text in the legend.
	 */
	setText: function (item) {
		var options = this.options;
		item.legendItem.attr({
			text: options.labelFormat ?
				H.format(options.labelFormat, item, this.chart.time) :
				options.labelFormatter.call(item)
		});
	},

	/**
	 * Render a single specific legend item. Called internally from the `render`
	 * function.
	 *
	 * @private
	 * @param {Series|Point} item
	 *        The item to render.
	 */
	renderItem: function (item) {
		var legend = this,
			chart = legend.chart,
			renderer = chart.renderer,
			options = legend.options,
			horizontal = options.layout === 'horizontal',
			symbolWidth = legend.symbolWidth,
			symbolPadding = options.symbolPadding,
			
			itemStyle = legend.itemStyle,
			itemHiddenStyle = legend.itemHiddenStyle,
			
			padding = legend.padding,
			itemDistance = horizontal ? pick(options.itemDistance, 20) : 0,
			ltr = !options.rtl,
			itemHeight,
			widthOption = options.width,
			itemMarginBottom = options.itemMarginBottom || 0,
			itemMarginTop = legend.itemMarginTop,
			bBox,
			itemWidth,
			li = item.legendItem,
			isSeries = !item.series,
			series = !isSeries && item.series.drawLegendSymbol ?
				item.series :
				item,
			seriesOptions = series.options,
			showCheckbox = legend.createCheckboxForItem &&
				seriesOptions &&
				seriesOptions.showCheckbox,
			// full width minus text width
			itemExtraWidth = symbolWidth + symbolPadding + itemDistance +
				(showCheckbox ? 20 : 0),
			useHTML = options.useHTML,
			fontSize = 12,
			itemClassName = item.options.className;

		if (!li) { // generate it once, later move it

			// Generate the group box, a group to hold the symbol and text. Text
			// is to be appended in Legend class.
			item.legendGroup = renderer.g('legend-item')
				.addClass(
					'highcharts-' + series.type + '-series ' +
					'highcharts-color-' + item.colorIndex +
					(itemClassName ? ' ' + itemClassName : '') +
					(isSeries ? ' highcharts-series-' + item.index : '')
				)
				.attr({ zIndex: 1 })
				.add(legend.scrollGroup);

			// Generate the list item text and add it to the group
			item.legendItem = li = renderer.text(
					'',
					ltr ? symbolWidth + symbolPadding : -symbolPadding,
					legend.baseline || 0,
					useHTML
				)
				
				// merge to prevent modifying original (#1021)
				.css(merge(item.visible ? itemStyle : itemHiddenStyle))
				
				.attr({
					align: ltr ? 'left' : 'right',
					zIndex: 2
				})
				.add(item.legendGroup);

			// Get the baseline for the first item - the font size is equal for
			// all
			if (!legend.baseline) {
				
				fontSize = itemStyle.fontSize;
				
				legend.fontMetrics = renderer.fontMetrics(
					fontSize,
					li
				);
				legend.baseline = legend.fontMetrics.f + 3 + itemMarginTop;
				li.attr('y', legend.baseline);
			}

			// Draw the legend symbol inside the group box
			legend.symbolHeight = options.symbolHeight || legend.fontMetrics.f;
			series.drawLegendSymbol(legend, item);

			if (legend.setItemEvents) {
				legend.setItemEvents(item, li, useHTML);
			}			

			// add the HTML checkbox on top
			if (showCheckbox) {
				legend.createCheckboxForItem(item);
			}
		}

		// Colorize the items
		legend.colorizeItem(item, item.visible);

		// Take care of max width and text overflow (#6659)
		
		if (!itemStyle.width) {
		
			li.css({
				width: (
					options.itemWidth ||
					options.width ||
					chart.spacingBox.width
				) -	itemExtraWidth
			});
		
		}
		

		// Always update the text
		legend.setText(item);

		// calculate the positions for the next line
		bBox = li.getBBox();

		itemWidth = item.checkboxOffset =
			options.itemWidth ||
			item.legendItemWidth ||
			bBox.width + itemExtraWidth;
		legend.itemHeight = itemHeight = Math.round(
			item.legendItemHeight || bBox.height || legend.symbolHeight
		);

		// If the item exceeds the width, start a new line
		if (
			horizontal &&
			legend.itemX - padding + itemWidth > (
				widthOption || (
					chart.spacingBox.width - 2 * padding - options.x
				)
			)
		) {
			legend.itemX = padding;
			legend.itemY += itemMarginTop + legend.lastLineHeight +
				itemMarginBottom;
			legend.lastLineHeight = 0; // reset for next line (#915, #3976)
		}

		// If the item exceeds the height, start a new column
		/*
		if (!horizontal && legend.itemY + options.y +
				itemHeight > chart.chartHeight - spacingTop - spacingBottom) {
			legend.itemY = legend.initialItemY;
			legend.itemX += legend.maxItemWidth;
			legend.maxItemWidth = 0;
		}
		*/

		// Set the edge positions
		legend.maxItemWidth = Math.max(legend.maxItemWidth, itemWidth);
		legend.lastItemY = itemMarginTop + legend.itemY + itemMarginBottom;
		legend.lastLineHeight = Math.max( // #915
			itemHeight,
			legend.lastLineHeight
		);

		// cache the position of the newly generated or reordered items
		item._legendItemPos = [legend.itemX, legend.itemY];

		// advance
		if (horizontal) {
			legend.itemX += itemWidth;

		} else {
			legend.itemY += itemMarginTop + itemHeight + itemMarginBottom;
			legend.lastLineHeight = itemHeight;
		}

		// the width of the widest item
		legend.offsetWidth = widthOption || Math.max(
			(
				horizontal ? legend.itemX - padding - (item.checkbox ?
					// decrease by itemDistance only when no checkbox #4853
					0 :
					itemDistance
				) : itemWidth
			) + padding,
			legend.offsetWidth
		);
	},

	/**
	 * Get all items, which is one item per series for most series and one
	 * item per point for pie series and its derivatives.
	 *
	 * @return {Array.<Series|Point>}
	 *         The current items in the legend.
	 */
	getAllItems: function () {
		var allItems = [];
		each(this.chart.series, function (series) {
			var seriesOptions = series && series.options;

			// Handle showInLegend. If the series is linked to another series,
			// defaults to false.
			if (series && pick(
				seriesOptions.showInLegend,
				!defined(seriesOptions.linkedTo) ? undefined : false, true
			)) {
				
				// Use points or series for the legend item depending on
				// legendType
				allItems = allItems.concat(
					series.legendItems ||
					(
						seriesOptions.legendType === 'point' ?
							series.data :
							series
					)
				);
			}
		});
		return allItems;
	},

	/**
	 * Get a short, three letter string reflecting the alignment and layout.
	 *
	 * @private
	 * @return {String} The alignment, empty string if floating
	 */
	getAlignment: function () {
		var options = this.options;

		// Use the first letter of each alignment option in order to detect
		// the side. (#4189 - use charAt(x) notation instead of [x] for IE7)
		return options.floating ? '' : (
			options.align.charAt(0) +
			options.verticalAlign.charAt(0) +
			options.layout.charAt(0)
		);
	},

	/**
	 * Adjust the chart margins by reserving space for the legend on only one
	 * side of the chart. If the position is set to a corner, top or bottom is
	 * reserved for horizontal legends and left or right for vertical ones.
	 *
	 * @private
	 */
	adjustMargins: function (margin, spacing) {
		var chart = this.chart,
			options = this.options,
			alignment = this.getAlignment();

		if (alignment) {

			each([
				/(lth|ct|rth)/,
				/(rtv|rm|rbv)/,
				/(rbh|cb|lbh)/,
				/(lbv|lm|ltv)/
			], function (alignments, side) {
				if (alignments.test(alignment) && !defined(margin[side])) {

					// Now we have detected on which side of the chart we should
					// reserve space for the legend
					chart[marginNames[side]] = Math.max(
						chart[marginNames[side]],
						(
							chart.legend[
								(side + 1) % 2 ? 'legendHeight' : 'legendWidth'
							] +
							[1, -1, -1, 1][side] * options[
								(side % 2) ? 'x' : 'y'
							] +
							pick(options.margin, 12) +
							spacing[side] +
							(
								side === 0 ?
									chart.titleOffset +
										chart.options.title.margin :
									0
							) // #7428
						)
					);
				}
			});
		}
	},

	/**
	 * Render the legend. This method can be called both before and after
	 * `chart.render`. If called after, it will only rearrange items instead
	 * of creating new ones. Called internally on initial render and after
	 * redraws.
	 */
	render: function () {
		var legend = this,
			chart = legend.chart,
			renderer = chart.renderer,
			legendGroup = legend.group,
			allItems,
			display,
			legendWidth,
			legendHeight,
			box = legend.box,
			options = legend.options,
			padding = legend.padding,
			alignTo;

		legend.itemX = padding;
		legend.itemY = legend.initialItemY;
		legend.offsetWidth = 0;
		legend.lastItemY = 0;

		if (!legendGroup) {
			legend.group = legendGroup = renderer.g('legend')
				.attr({ zIndex: 7 })
				.add();
			legend.contentGroup = renderer.g()
				.attr({ zIndex: 1 }) // above background
				.add(legendGroup);
			legend.scrollGroup = renderer.g()
				.add(legend.contentGroup);
		}

		legend.renderTitle();

		// add each series or point
		allItems = legend.getAllItems();

		// sort by legendIndex
		stableSort(allItems, function (a, b) {
			return ((a.options && a.options.legendIndex) || 0) -
				((b.options && b.options.legendIndex) || 0);
		});

		// reversed legend
		if (options.reversed) {
			allItems.reverse();
		}

		legend.allItems = allItems;
		legend.display = display = !!allItems.length;

		// render the items
		legend.lastLineHeight = 0;
		each(allItems, function (item) {
			legend.renderItem(item);
		});

		// Get the box
		legendWidth = (options.width || legend.offsetWidth) + padding;
		legendHeight = legend.lastItemY + legend.lastLineHeight +
			legend.titleHeight;
		legendHeight = legend.handleOverflow(legendHeight);
		legendHeight += padding;

		// Draw the border and/or background
		if (!box) {
			legend.box = box = renderer.rect()
				.addClass('highcharts-legend-box')
				.attr({
					r: options.borderRadius
				})
				.add(legendGroup);
			box.isNew = true;
		} 

		
		// Presentational
		box
			.attr({
				stroke: options.borderColor,
				'stroke-width': options.borderWidth || 0,
				fill: options.backgroundColor || 'none'
			})
			.shadow(options.shadow);
		

		if (legendWidth > 0 && legendHeight > 0) {
			box[box.isNew ? 'attr' : 'animate'](
				box.crisp.call({}, { // #7260
					x: 0,
					y: 0,
					width: legendWidth,
					height: legendHeight
				}, box.strokeWidth())
			);
			box.isNew = false;
		}

		// hide the border if no items
		box[display ? 'show' : 'hide']();

		

		legend.legendWidth = legendWidth;
		legend.legendHeight = legendHeight;

		// Now that the legend width and height are established, put the items
		// in the final position
		each(allItems, function (item) {
			legend.positionItem(item);
		});

		if (display) {
			// If aligning to the top and the layout is horizontal, adjust for
			// the title (#7428)
			alignTo = chart.spacingBox;
			if (/(lth|ct|rth)/.test(legend.getAlignment())) {
				alignTo = merge(alignTo, {
					y: alignTo.y + chart.titleOffset +
						chart.options.title.margin
				});
			}

			legendGroup.align(merge(options, {
				width: legendWidth,
				height: legendHeight
			}), true, alignTo);
		}

		if (!chart.isResizing) {
			this.positionCheckboxes();
		}
	},

	/**
	 * Set up the overflow handling by adding navigation with up and down arrows
	 * below the legend.
	 *
	 * @private
	 */
	handleOverflow: function (legendHeight) {
		var legend = this,
			chart = this.chart,
			renderer = chart.renderer,
			options = this.options,
			optionsY = options.y,
			alignTop = options.verticalAlign === 'top',
			padding = this.padding,
			spaceHeight = chart.spacingBox.height +
				(alignTop ? -optionsY : optionsY) - padding,
			maxHeight = options.maxHeight,
			clipHeight,
			clipRect = this.clipRect,
			navOptions = options.navigation,
			animation = pick(navOptions.animation, true),
			arrowSize = navOptions.arrowSize || 12,
			nav = this.nav,
			pages = this.pages,
			lastY,
			allItems = this.allItems,
			clipToHeight = function (height) {
				if (typeof height === 'number') {
					clipRect.attr({
						height: height
					});
				} else if (clipRect) { // Reset (#5912)
					legend.clipRect = clipRect.destroy();
					legend.contentGroup.clip();
				}

				// useHTML
				if (legend.contentGroup.div) {
					legend.contentGroup.div.style.clip = height ? 
						'rect(' + padding + 'px,9999px,' +
							(padding + height) + 'px,0)' :
						'auto';
				}
			};


		// Adjust the height
		if (
			options.layout === 'horizontal' &&
			options.verticalAlign !== 'middle' &&
			!options.floating
		) {
			spaceHeight /= 2;
		}
		if (maxHeight) {
			spaceHeight = Math.min(spaceHeight, maxHeight);
		}

		// Reset the legend height and adjust the clipping rectangle
		pages.length = 0;
		if (legendHeight > spaceHeight && navOptions.enabled !== false) {

			this.clipHeight = clipHeight =
				Math.max(spaceHeight - 20 - this.titleHeight - padding, 0);
			this.currentPage = pick(this.currentPage, 1);
			this.fullHeight = legendHeight;

			// Fill pages with Y positions so that the top of each a legend item
			// defines the scroll top for each page (#2098)
			each(allItems, function (item, i) {
				var y = item._legendItemPos[1],
					h = Math.round(item.legendItem.getBBox().height),
					len = pages.length;

				if (!len || (y - pages[len - 1] > clipHeight &&
						(lastY || y) !== pages[len - 1])) {
					pages.push(lastY || y);
					len++;
				}

				// Keep track of which page each item is on
				item.pageIx = len - 1;
				if (lastY) {
					allItems[i - 1].pageIx = len - 1;
				}

				if (i === allItems.length - 1 &&
						y + h - pages[len - 1] > clipHeight) {
					pages.push(y);
					item.pageIx = len;
				}
				if (y !== lastY) {
					lastY = y;
				}
			});

			// Only apply clipping if needed. Clipping causes blurred legend in
			// PDF export (#1787)
			if (!clipRect) {
				clipRect = legend.clipRect =
					renderer.clipRect(0, padding, 9999, 0);
				legend.contentGroup.clip(clipRect);
			}

			clipToHeight(clipHeight);

			// Add navigation elements
			if (!nav) {
				this.nav = nav = renderer.g()
					.attr({ zIndex: 1 })
					.add(this.group);

				this.up = renderer
					.symbol(
						'triangle',
						0,
						0,
						arrowSize,
						arrowSize
					)
					.on('click', function () {
						legend.scroll(-1, animation);
					})
					.add(nav);

				this.pager = renderer.text('', 15, 10)
					.addClass('highcharts-legend-navigation')
					
					.css(navOptions.style)
					
					.add(nav);

				this.down = renderer
					.symbol(
						'triangle-down',
						0,
						0,
						arrowSize,
						arrowSize
					)
					.on('click', function () {
						legend.scroll(1, animation);
					})
					.add(nav);
			}

			// Set initial position
			legend.scroll(0);

			legendHeight = spaceHeight;

		// Reset
		} else if (nav) {
			clipToHeight();
			this.nav = nav.destroy(); // #6322
			this.scrollGroup.attr({
				translateY: 1
			});
			this.clipHeight = 0; // #1379
		}

		return legendHeight;
	},

	/**
	 * Scroll the legend by a number of pages.
	 * @param  {Number} scrollBy
	 *         The number of pages to scroll.
	 * @param  {AnimationOptions} animation
	 *         Whether and how to apply animation.
	 */
	scroll: function (scrollBy, animation) {
		var pages = this.pages,
			pageCount = pages.length,
			currentPage = this.currentPage + scrollBy,
			clipHeight = this.clipHeight,
			navOptions = this.options.navigation,
			pager = this.pager,
			padding = this.padding;

		// When resizing while looking at the last page
		if (currentPage > pageCount) {
			currentPage = pageCount;
		}

		if (currentPage > 0) {
			
			if (animation !== undefined) {
				setAnimation(animation, this.chart);
			}

			this.nav.attr({
				translateX: padding,
				translateY: clipHeight + this.padding + 7 + this.titleHeight,
				visibility: 'visible'
			});
			this.up.attr({
				'class': currentPage === 1 ?
					'highcharts-legend-nav-inactive' :
					'highcharts-legend-nav-active'
			});
			pager.attr({
				text: currentPage + '/' + pageCount
			});
			this.down.attr({
				'x': 18 + this.pager.getBBox().width, // adjust to text width
				'class': currentPage === pageCount ?
					'highcharts-legend-nav-inactive' :
					'highcharts-legend-nav-active'
			});

			
			this.up
				.attr({
					fill: currentPage === 1 ?
						navOptions.inactiveColor :
						navOptions.activeColor
				})
				.css({
					cursor: currentPage === 1 ? 'default' : 'pointer'
				});
			this.down
				.attr({
					fill: currentPage === pageCount ?
						navOptions.inactiveColor :
						navOptions.activeColor
				})
				.css({
					cursor: currentPage === pageCount ? 'default' : 'pointer'
				});
			
			
			this.scrollOffset = -pages[currentPage - 1] + this.initialItemY;

			this.scrollGroup.animate({
				translateY: this.scrollOffset
			});

			this.currentPage = currentPage;
			this.positionCheckboxes();
		}

	}

};

/*
 * LegendSymbolMixin
 */

H.LegendSymbolMixin = {

	/**
	 * Get the series' symbol in the legend
	 *
	 * @param {Object} legend The legend object
	 * @param {Object} item The series (this) or point
	 */
	drawRectangle: function (legend, item) {
		var options = legend.options,
			symbolHeight = legend.symbolHeight,
			square = options.squareSymbol,
			symbolWidth = square ? symbolHeight : legend.symbolWidth;

		item.legendSymbol = this.chart.renderer.rect(
			square ? (legend.symbolWidth - symbolHeight) / 2 : 0,
			legend.baseline - symbolHeight + 1, // #3988
			symbolWidth,
			symbolHeight,
			pick(legend.options.symbolRadius, symbolHeight / 2)
		)
		.addClass('highcharts-point')
		.attr({
			zIndex: 3
		}).add(item.legendGroup);

	},

	/**
	 * Get the series' symbol in the legend. This method should be overridable
	 * to create custom symbols through
	 * Highcharts.seriesTypes[type].prototype.drawLegendSymbols.
	 *
	 * @param {Object} legend The legend object
	 */
	drawLineMarker: function (legend) {

		var options = this.options,
			markerOptions = options.marker,
			radius,
			legendSymbol,
			symbolWidth = legend.symbolWidth,
			symbolHeight = legend.symbolHeight,
			generalRadius = symbolHeight / 2,
			renderer = this.chart.renderer,
			legendItemGroup = this.legendGroup,
			verticalCenter = legend.baseline -
				Math.round(legend.fontMetrics.b * 0.3),
			attr = {};

		// Draw the line
		
		attr = {
			'stroke-width': options.lineWidth || 0
		};
		if (options.dashStyle) {
			attr.dashstyle = options.dashStyle;
		}
		
		
		this.legendLine = renderer.path([
			'M',
			0,
			verticalCenter,
			'L',
			symbolWidth,
			verticalCenter
		])
		.addClass('highcharts-graph')
		.attr(attr)
		.add(legendItemGroup);
		
		// Draw the marker
		if (markerOptions && markerOptions.enabled !== false) {

			// Do not allow the marker to be larger than the symbolHeight
			radius = Math.min(
				pick(markerOptions.radius, generalRadius),
				generalRadius
			);

			// Restrict symbol markers size
			if (this.symbol.indexOf('url') === 0) {
				markerOptions = merge(markerOptions, {
					width: symbolHeight,
					height: symbolHeight
				});
				radius = 0;
			}
			
			this.legendSymbol = legendSymbol = renderer.symbol(
				this.symbol,
				(symbolWidth / 2) - radius,
				verticalCenter - radius,
				2 * radius,
				2 * radius,
				markerOptions
			)
			.addClass('highcharts-point')
			.add(legendItemGroup);
			legendSymbol.isMarker = true;
		}
	}
};

// Workaround for #2030, horizontal legend items not displaying in IE11 Preview,
// and for #2580, a similar drawing flaw in Firefox 26.
// Explore if there's a general cause for this. The problem may be related
// to nested group elements, as the legend item texts are within 4 group
// elements.
if (/Trident\/7\.0/.test(win.navigator.userAgent) || isFirefox) {
	wrap(Highcharts.Legend.prototype, 'positionItem', function (proceed, item) {
		var legend = this,
			// If chart destroyed in sync, this is undefined (#2030)
			runPositionItem = function () {
				if (item._legendItemPos) {
					proceed.call(legend, item);
				}
			};

		// Do it now, for export and to get checkbox placement
		runPositionItem();

		// Do it after to work around the core issue
		setTimeout(runPositionItem);
	});
}

}(Highcharts));
(function (H) {
/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var addEvent = H.addEvent,
	animate = H.animate,
	animObject = H.animObject,
	attr = H.attr,
	doc = H.doc,
	Axis = H.Axis, // @todo add as requirement
	createElement = H.createElement,
	defaultOptions = H.defaultOptions,
	discardElement = H.discardElement,
	charts = H.charts,
	css = H.css,
	defined = H.defined,
	each = H.each,
	extend = H.extend,
	find = H.find,
	fireEvent = H.fireEvent,
	grep = H.grep,
	isNumber = H.isNumber,
	isObject = H.isObject,
	isString = H.isString,
	Legend = H.Legend, // @todo add as requirement
	marginNames = H.marginNames,
	merge = H.merge,
	objectEach = H.objectEach,
	Pointer = H.Pointer, // @todo add as requirement
	pick = H.pick,
	pInt = H.pInt,
	removeEvent = H.removeEvent,
	seriesTypes = H.seriesTypes,
	splat = H.splat,
	svg = H.svg,
	syncTimeout = H.syncTimeout,
	win = H.win;
/**
 * The Chart class. The recommended constructor is {@link Highcharts#chart}.
 * @class Highcharts.Chart
 * @param  {String|HTMLDOMElement} renderTo
 *         The DOM element to render to, or its id.
 * @param  {Options} options
 *         The chart options structure.
 * @param  {Function} [callback]
 *         Function to run when the chart has loaded and and all external images
 *         are loaded. Defining a {@link
 *         https://api.highcharts.com/highcharts/chart.events.load|chart.event.load}
 *         handler is equivalent.
 *
 * @example
 * var chart = Highcharts.chart('container', {
 * 	   title: {
 * 	   	   text: 'My chart'
 * 	   },
 * 	   series: [{
 * 	       data: [1, 3, 2, 4]
 * 	   }]
 * })
 */
var Chart = H.Chart = function () {
	this.getArgs.apply(this, arguments);
};

/**
 * Factory function for basic charts. 
 *
 * @function #chart
 * @memberOf Highcharts
 * @param  {String|HTMLDOMElement} renderTo - The DOM element to render to, or
 * its id.
 * @param  {Options} options - The chart options structure.
 * @param  {Function} [callback] - Function to run when the chart has loaded and
 * and all external images are loaded. Defining a {@link
 * https://api.highcharts.com/highcharts/chart.events.load|chart.event.load}
 * handler is equivalent.
 * @return {Highcharts.Chart} - Returns the Chart object.
 *
 * @example
 * // Render a chart in to div#container
 * var chart = Highcharts.chart('container', {
 *     title: {
 *         text: 'My chart'
 *     },
 *     series: [{
 *         data: [1, 3, 2, 4]
 *     }]
 * });
 */
H.chart = function (a, b, c) {
	return new Chart(a, b, c);
};

extend(Chart.prototype, /** @lends Highcharts.Chart.prototype */ {

	// Hook for adding callbacks in modules
	callbacks: [],

	/**
	 * Handle the arguments passed to the constructor.
	 *
	 * @private
	 * @returns {Array} Arguments without renderTo
	 */
	getArgs: function () {
		var args = [].slice.call(arguments);
		
		// Remove the optional first argument, renderTo, and
		// set it on this.
		if (isString(args[0]) || args[0].nodeName) {
			this.renderTo = args.shift();
		}
		this.init(args[0], args[1]);
	},

	/**
	 * Overridable function that initializes the chart. The constructor's
	 * arguments are passed on directly.
	 */
	init: function (userOptions, callback) {

		// Handle regular options
		var options,
			type,
			seriesOptions = userOptions.series, // skip merging data points to increase performance
			userPlotOptions = userOptions.plotOptions || {};

		userOptions.series = null;
		options = merge(defaultOptions, userOptions); // do the merge

		// Override (by copy of user options) or clear tooltip options
		// in chart.options.plotOptions (#6218)
		for (type in options.plotOptions) {
			options.plotOptions[type].tooltip = (
				userPlotOptions[type] &&
				merge(userPlotOptions[type].tooltip) // override by copy
			) || undefined; // or clear
		}
		// User options have higher priority than default options (#6218).
		// In case of exporting: path is changed
		options.tooltip.userOptions = (userOptions.chart &&
			userOptions.chart.forExport && userOptions.tooltip.userOptions) ||
			userOptions.tooltip;

		options.series = userOptions.series = seriesOptions; // set back the series data
		this.userOptions = userOptions;

		var optionsChart = options.chart;

		var chartEvents = optionsChart.events;

		this.margin = [];
		this.spacing = [];

		this.bounds = { h: {}, v: {} }; // Pixel data bounds for touch zoom

		// An array of functions that returns labels that should be considered
		// for anti-collision
		this.labelCollectors = [];

		this.callback = callback;
		this.isResizing = 0;

		/**
		 * The options structure for the chart. It contains members for the sub
		 * elements like series, legend, tooltip etc.
		 *
		 * @memberof Highcharts.Chart
		 * @name options
		 * @type {Options}
		 */
		this.options = options;
		/**
		 * All the axes in the chart.
		 *
		 * @memberof Highcharts.Chart
		 * @name axes
		 * @see  Highcharts.Chart.xAxis
		 * @see  Highcharts.Chart.yAxis
		 * @type {Array.<Highcharts.Axis>}
		 */
		this.axes = [];

		/**
		 * All the current series in the chart.
		 *
		 * @memberof Highcharts.Chart
		 * @name series
		 * @type {Array.<Highcharts.Series>}
		 */
		this.series = [];

		/**
		 * The chart title. The title has an `update` method that allows
		 * modifying the options directly or indirectly via `chart.update`.
		 *
		 * @memberof Highcharts.Chart
		 * @name title
		 * @type Object
		 *
		 * @sample highcharts/members/title-update/
		 *         Updating titles
		 */
		
		/**
		 * The chart subtitle. The subtitle has an `update` method that allows
		 * modifying the options directly or indirectly via `chart.update`.
		 *
		 * @memberof Highcharts.Chart
		 * @name subtitle
		 * @type Object
		 */

		/**
		 * The `Time` object associated with the chart. Since v6.0.5, time
		 * settings can be applied individually for each chart. If no individual
		 * settings apply, the `Time` object is shared by all instances.
		 *
		 * @memberof Highcharts.Chart
		 * @name time
		 * @type Highcharts.Time
		 */
		this.time = userOptions.time ? new H.Time(this) : H.time;

		
		this.hasCartesianSeries = optionsChart.showAxes;
		
		var chart = this;

		// Add the chart to the global lookup
		chart.index = charts.length;

		charts.push(chart);
		H.chartCount++;

		// Chart event handlers
		if (chartEvents) {
			objectEach(chartEvents, function (event, eventType) {
				addEvent(chart, eventType, event);
			});
		}

		/**
		 * A collection of the X axes in the chart.
		 * @type {Array.<Highcharts.Axis>}
		 * @name xAxis
		 * @memberOf Highcharts.Chart
		 */
		chart.xAxis = [];
		/**
		 * A collection of the Y axes in the chart.
		 * @type {Array.<Highcharts.Axis>}
		 * @name yAxis
		 * @memberOf Highcharts.Chart
		 */
		chart.yAxis = [];

		chart.pointCount = chart.colorCounter = chart.symbolCounter = 0;

		chart.firstRender();
	},

	/**
	 * Internal function to unitialize an individual series.
	 *
	 * @private
	 */
	initSeries: function (options) {
		var chart = this,
			optionsChart = chart.options.chart,
			type = options.type || optionsChart.type || optionsChart.defaultSeriesType,
			series,
			Constr = seriesTypes[type];

		// No such series type
		if (!Constr) {
			H.error(17, true);
		}

		series = new Constr();
		series.init(this, options);
		return series;
	},

	/**
	 * Order all series above a given index. When series are added and ordered
	 * by configuration, only the last series is handled (#248, #1123, #2456,
	 * #6112). This function is called on series initialization and destroy.
	 *
	 * @private
	 *
	 * @param  {number} fromIndex
	 *         If this is given, only the series above this index are handled.
	 */
	orderSeries: function (fromIndex) {
		var series = this.series,
			i = fromIndex || 0;
		for (; i < series.length; i++) {
			if (series[i]) {
				series[i].index = i;
				series[i].name = series[i].name || 
					'Series ' + (series[i].index + 1);
			}
		}
	},

	/**
	 * Check whether a given point is within the plot area.
	 *
	 * @param  {Number} plotX
	 *         Pixel x relative to the plot area.
	 * @param  {Number} plotY
	 *         Pixel y relative to the plot area.
	 * @param  {Boolean} inverted
	 *         Whether the chart is inverted.
	 *
	 * @return {Boolean}
	 *         Returns true if the given point is inside the plot area.
	 */
	isInsidePlot: function (plotX, plotY, inverted) {
		var x = inverted ? plotY : plotX,
			y = inverted ? plotX : plotY;

		return x >= 0 &&
			x <= this.plotWidth &&
			y >= 0 &&
			y <= this.plotHeight;
	},

	/**
	 * Redraw the chart after changes have been done to the data, axis extremes
	 * chart size or chart elements. All methods for updating axes, series or
	 * points have a parameter for redrawing the chart. This is `true` by
	 * default. But in many cases you want to do more than one operation on the
	 * chart before redrawing, for example add a number of points. In those
	 * cases it is a waste of resources to redraw the chart for each new point
	 * added. So you add the points and call `chart.redraw()` after.
	 *
	 * @param  {AnimationOptions} animation
	 *         If or how to apply animation to the redraw.
	 */
	redraw: function (animation) {
		var chart = this,
			axes = chart.axes,
			series = chart.series,
			pointer = chart.pointer,
			legend = chart.legend,
			redrawLegend = chart.isDirtyLegend,
			hasStackedSeries,
			hasDirtyStacks,
			hasCartesianSeries = chart.hasCartesianSeries,
			isDirtyBox = chart.isDirtyBox,
			i,
			serie,
			renderer = chart.renderer,
			isHiddenChart = renderer.isHidden(),
			afterRedraw = [];

		// Handle responsive rules, not only on resize (#6130)
		if (chart.setResponsive) {
			chart.setResponsive(false);
		}
			
		H.setAnimation(animation, chart);
		
		if (isHiddenChart) {
			chart.temporaryDisplay();
		}

		// Adjust title layout (reflow multiline text)
		chart.layOutTitles();

		// link stacked series
		i = series.length;
		while (i--) {
			serie = series[i];

			if (serie.options.stacking) {
				hasStackedSeries = true;

				if (serie.isDirty) {
					hasDirtyStacks = true;
					break;
				}
			}
		}
		if (hasDirtyStacks) { // mark others as dirty
			i = series.length;
			while (i--) {
				serie = series[i];
				if (serie.options.stacking) {
					serie.isDirty = true;
				}
			}
		}

		// Handle updated data in the series
		each(series, function (serie) {
			if (serie.isDirty) {
				if (serie.options.legendType === 'point') {
					if (serie.updateTotals) {
						serie.updateTotals();
					}
					redrawLegend = true;
				}
			}
			if (serie.isDirtyData) {
				fireEvent(serie, 'updatedData');
			}
		});

		// handle added or removed series
		if (redrawLegend && legend.options.enabled) { // series or pie points are added or removed
			// draw legend graphics
			legend.render();

			chart.isDirtyLegend = false;
		}

		// reset stacks
		if (hasStackedSeries) {
			chart.getStacks();
		}


		if (hasCartesianSeries) {
			// set axes scales
			each(axes, function (axis) {
				axis.updateNames();
				axis.setScale();
			});
		}

		chart.getMargins(); // #3098

		if (hasCartesianSeries) {
			// If one axis is dirty, all axes must be redrawn (#792, #2169)
			each(axes, function (axis) {
				if (axis.isDirty) {
					isDirtyBox = true;
				}
			});

			// redraw axes
			each(axes, function (axis) {

				// Fire 'afterSetExtremes' only if extremes are set
				var key = axis.min + ',' + axis.max;
				if (axis.extKey !== key) { // #821, #4452
					axis.extKey = key;
					afterRedraw.push(function () { // prevent a recursive call to chart.redraw() (#1119)
						fireEvent(axis, 'afterSetExtremes', extend(axis.eventArgs, axis.getExtremes())); // #747, #751
						delete axis.eventArgs;
					});
				}
				if (isDirtyBox || hasStackedSeries) {
					axis.redraw();
				}
			});
		}

		// the plot areas size has changed
		if (isDirtyBox) {
			chart.drawChartBox();
		}

		// Fire an event before redrawing series, used by the boost module to
		// clear previous series renderings.
		fireEvent(chart, 'predraw');

		// redraw affected series
		each(series, function (serie) {
			if ((isDirtyBox || serie.isDirty) && serie.visible) {
				serie.redraw();
			}
			// Set it here, otherwise we will have unlimited 'updatedData' calls
			// for a hidden series after setData(). Fixes #6012
			serie.isDirtyData = false;
		});

		// move tooltip or reset
		if (pointer) {
			pointer.reset(true);
		}

		// redraw if canvas
		renderer.draw();

		// Fire the events
		fireEvent(chart, 'redraw');
		fireEvent(chart, 'render');

		if (isHiddenChart) {
			chart.temporaryDisplay(true);
		}

		// Fire callbacks that are put on hold until after the redraw
		each(afterRedraw, function (callback) {
			callback.call();
		});
	},

	/**
	 * Get an axis, series or point object by `id` as given in the configuration
	 * options. Returns `undefined` if no item is found.
	 * @param id {String} The id as given in the configuration options.
	 * @return {Highcharts.Axis|Highcharts.Series|Highcharts.Point|undefined}
	 *         The retrieved item.
	 * @sample highcharts/plotoptions/series-id/
	 *         Get series by id
	 */
	get: function (id) {

		var ret,
			series = this.series,
			i;

		function itemById(item) {
			return item.id === id || (item.options && item.options.id === id);
		}

		ret = 
			// Search axes
			find(this.axes, itemById) ||

			// Search series
			find(this.series, itemById);

		// Search points
		for (i = 0; !ret && i < series.length; i++) {
			ret = find(series[i].points || [], itemById);
		}

		return ret;
	},

	/**
	 * Create the Axis instances based on the config options.
	 *
	 * @private
	 */
	getAxes: function () {
		var chart = this,
			options = this.options,
			xAxisOptions = options.xAxis = splat(options.xAxis || {}),
			yAxisOptions = options.yAxis = splat(options.yAxis || {}),
			optionsArray;

		// make sure the options are arrays and add some members
		each(xAxisOptions, function (axis, i) {
			axis.index = i;
			axis.isX = true;
		});

		each(yAxisOptions, function (axis, i) {
			axis.index = i;
		});

		// concatenate all axis options into one array
		optionsArray = xAxisOptions.concat(yAxisOptions);

		each(optionsArray, function (axisOptions) {
			new Axis(chart, axisOptions); // eslint-disable-line no-new
		});
	},


	/**
	 * Returns an array of all currently selected points in the chart. Points
	 * can be selected by clicking or programmatically by the {@link
	 * Highcharts.Point#select} function.
	 *
	 * @return {Array.<Highcharts.Point>}
	 *         The currently selected points.
	 *
	 * @sample highcharts/plotoptions/series-allowpointselect-line/
	 *         Get selected points
	 */
	getSelectedPoints: function () {
		var points = [];
		each(this.series, function (serie) {
			// series.data - for points outside of viewed range (#6445)
			points = points.concat(grep(serie.data || [], function (point) {
				return point.selected;
			}));
		});
		return points;
	},

	/**
	 * Returns an array of all currently selected series in the chart. Series
	 * can be selected either programmatically by the {@link
	 * Highcharts.Series#select} function or by checking the checkbox next to
	 * the legend item if {@link
	 * https://api.highcharts.com/highcharts/plotOptions.series.showCheckbox|
	 * series.showCheckBox} is true.
	 * 
	 * @return {Array.<Highcharts.Series>}
	 *         The currently selected series.
	 *
	 * @sample highcharts/members/chart-getselectedseries/
	 *         Get selected series
	 */
	getSelectedSeries: function () {
		return grep(this.series, function (serie) {
			return serie.selected;
		});
	},

	/**
	 * Set a new title or subtitle for the chart.
	 *
	 * @param  titleOptions {TitleOptions}
	 *         New title options. The title text itself is set by the
	 *         `titleOptions.text` property.
	 * @param  subtitleOptions {SubtitleOptions}
	 *         New subtitle options. The subtitle text itself is set by the
	 *         `subtitleOptions.text` property.
	 * @param  redraw {Boolean}
	 *         Whether to redraw the chart or wait for a later call to 
	 *         `chart.redraw()`.
	 *
	 * @sample highcharts/members/chart-settitle/ Set title text and styles
	 *
	 */
	setTitle: function (titleOptions, subtitleOptions, redraw) {
		var chart = this,
			options = chart.options,
			chartTitleOptions,
			chartSubtitleOptions;

		chartTitleOptions = options.title = merge(
			
			// Default styles
			{
				style: {
					color: '#333333',
					fontSize: options.isStock ? '16px' : '18px' // #2944
				}	
			},
			
			options.title,
			titleOptions
		);
		chartSubtitleOptions = options.subtitle = merge(
			
			// Default styles
			{
				style: {
					color: '#666666'
				}	
			},
			
			options.subtitle,
			subtitleOptions
		);

		// add title and subtitle
		each([
			['title', titleOptions, chartTitleOptions],
			['subtitle', subtitleOptions, chartSubtitleOptions]
		], function (arr, i) {
			var name = arr[0],
				title = chart[name],
				titleOptions = arr[1],
				chartTitleOptions = arr[2];

			if (title && titleOptions) {
				chart[name] = title = title.destroy(); // remove old
			}

			if (chartTitleOptions && !title) {
				chart[name] = chart.renderer.text(
					chartTitleOptions.text,
					0,
					0,
					chartTitleOptions.useHTML
				)
				.attr({
					align: chartTitleOptions.align,
					'class': 'highcharts-' + name,
					zIndex: chartTitleOptions.zIndex || 4
				})
				.add();

				// Update methods, shortcut to Chart.setTitle
				chart[name].update = function (o) {
					chart.setTitle(!i && o, i && o);
				};

				
				// Presentational
				chart[name].css(chartTitleOptions.style);
				
				
			}
		});
		chart.layOutTitles(redraw);
	},

	/**
	 * Internal function to lay out the chart titles and cache the full offset
	 * height for use in `getMargins`. The result is stored in 
	 * `this.titleOffset`.
	 *
	 * @private
	 */
	layOutTitles: function (redraw) {
		var titleOffset = 0,
			requiresDirtyBox,
			renderer = this.renderer,
			spacingBox = this.spacingBox;

		// Lay out the title and the subtitle respectively
		each(['title', 'subtitle'], function (key) {
			var title = this[key],
				titleOptions = this.options[key],
				offset = key === 'title' ? -3 :
					// Floating subtitle (#6574)
					titleOptions.verticalAlign ? 0 : titleOffset + 2,
				titleSize;

			if (title) {
				
				titleSize = titleOptions.style.fontSize;
				
				titleSize = renderer.fontMetrics(titleSize, title).b;
				
				title
					.css({
						width: (titleOptions.width ||
							spacingBox.width + titleOptions.widthAdjust) + 'px'
					})
					.align(extend({ 
						y: offset + titleSize
					}, titleOptions), false, 'spacingBox');

				if (!titleOptions.floating && !titleOptions.verticalAlign) {
					titleOffset = Math.ceil(
						titleOffset +
						// Skip the cache for HTML (#3481)
						title.getBBox(titleOptions.useHTML).height
					);
				}
			}
		}, this);

		requiresDirtyBox = this.titleOffset !== titleOffset;
		this.titleOffset = titleOffset; // used in getMargins

		if (!this.isDirtyBox && requiresDirtyBox) {
			this.isDirtyBox = requiresDirtyBox;
			// Redraw if necessary (#2719, #2744)
			if (this.hasRendered && pick(redraw, true) && this.isDirtyBox) {
				this.redraw();
			}
		}
	},

	/**
	 * Internal function to get the chart width and height according to options
	 * and container size. Sets {@link Chart.chartWidth} and {@link
	 * Chart.chartHeight}.
	 */
	getChartSize: function () {
		var chart = this,
			optionsChart = chart.options.chart,
			widthOption = optionsChart.width,
			heightOption = optionsChart.height,
			renderTo = chart.renderTo;

		// Get inner width and height
		if (!defined(widthOption)) {
			chart.containerWidth = H.getStyle(renderTo, 'width');
		}
		if (!defined(heightOption)) {
			chart.containerHeight = H.getStyle(renderTo, 'height');
		}
		
		/**
		 * The current pixel width of the chart.
		 *
		 * @name chartWidth
		 * @memberOf Chart
		 * @type {Number}
		 */
		chart.chartWidth = Math.max( // #1393
			0,
			widthOption || chart.containerWidth || 600 // #1460
		);
		/**
		 * The current pixel height of the chart.
		 *
		 * @name chartHeight
		 * @memberOf Chart
		 * @type {Number}
		 */
		chart.chartHeight = Math.max(
			0,
			H.relativeLength(
				heightOption,
				chart.chartWidth
			) ||
			(chart.containerHeight > 1 ? chart.containerHeight : 400)
		);
	},

	/**
	 * If the renderTo element has no offsetWidth, most likely one or more of
	 * its parents are hidden. Loop up the DOM tree to temporarily display the
	 * parents, then save the original display properties, and when the true
	 * size is retrieved, reset them. Used on first render and on redraws.
	 *
	 * @private
	 * 
	 * @param  {Boolean} revert
	 *         Revert to the saved original styles.
	 */
	temporaryDisplay: function (revert) {
		var node = this.renderTo,
			tempStyle;
		if (!revert) {
			while (node && node.style) {

				// When rendering to a detached node, it needs to be temporarily
				// attached in order to read styling and bounding boxes (#5783,
				// #7024).
				if (!doc.body.contains(node) && !node.parentNode) {
					node.hcOrigDetached = true;
					doc.body.appendChild(node);
				}
				if (
					H.getStyle(node, 'display', false) === 'none' ||
					node.hcOricDetached
				) {
					node.hcOrigStyle = {
						display: node.style.display,
						height: node.style.height,
						overflow: node.style.overflow
					};
					tempStyle = {
						display: 'block',
						overflow: 'hidden'
					};
					if (node !== this.renderTo) {
						tempStyle.height = 0;
					}
					
					H.css(node, tempStyle);

					// If it still doesn't have an offset width after setting
					// display to block, it probably has an !important priority
					// #2631, 6803
					if (!node.offsetWidth) {
						node.style.setProperty('display', 'block', 'important');
					}
				}
				node = node.parentNode;

				if (node === doc.body) {
					break;
				}
			}
		} else {
			while (node && node.style) {
				if (node.hcOrigStyle) {
					H.css(node, node.hcOrigStyle);
					delete node.hcOrigStyle;
				}
				if (node.hcOrigDetached) {
					doc.body.removeChild(node);
					node.hcOrigDetached = false;
				}
				node = node.parentNode;
			}
		}
	},

	/**
	 * Set the {@link Chart.container|chart container's} class name, in
	 * addition to `highcharts-container`. 
	 */
	setClassName: function (className) {
		this.container.className = 'highcharts-container ' + (className || '');
	},

	/**
	 * Get the containing element, determine the size and create the inner
	 * container div to hold the chart.
	 *
	 * @private
	 */
	getContainer: function () {
		var chart = this,
			container,
			options = chart.options,
			optionsChart = options.chart,
			chartWidth,
			chartHeight,
			renderTo = chart.renderTo,
			indexAttrName = 'data-highcharts-chart',
			oldChartIndex,
			Ren,
			containerId = H.uniqueKey(),
			containerStyle,
			key;

		if (!renderTo) {
			chart.renderTo = renderTo = optionsChart.renderTo;
		}
		
		if (isString(renderTo)) {
			chart.renderTo = renderTo = doc.getElementById(renderTo);
		}

		// Display an error if the renderTo is wrong
		if (!renderTo) {
			H.error(13, true);
		}

		// If the container already holds a chart, destroy it. The check for
		// hasRendered is there because web pages that are saved to disk from
		// the browser, will preserve the data-highcharts-chart attribute and
		// the SVG contents, but not an interactive chart. So in this case,
		// charts[oldChartIndex] will point to the wrong chart if any (#2609).
		oldChartIndex = pInt(attr(renderTo, indexAttrName));
		if (
			isNumber(oldChartIndex) &&
			charts[oldChartIndex] &&
			charts[oldChartIndex].hasRendered
		) {
			charts[oldChartIndex].destroy();
		}

		// Make a reference to the chart from the div
		attr(renderTo, indexAttrName, chart.index);

		// remove previous chart
		renderTo.innerHTML = '';

		// If the container doesn't have an offsetWidth, it has or is a child of
		// a node that has display:none. We need to temporarily move it out to a
		// visible state to determine the size, else the legend and tooltips
		// won't render properly. The skipClone option is used in sparklines as
		// a micro optimization, saving about 1-2 ms each chart.
		if (!optionsChart.skipClone && !renderTo.offsetWidth) {
			chart.temporaryDisplay();
		}

		// get the width and height
		chart.getChartSize();
		chartWidth = chart.chartWidth;
		chartHeight = chart.chartHeight;

		// Create the inner container
		
		containerStyle = extend({
			position: 'relative',
			overflow: 'hidden', // needed for context menu (avoid scrollbars)
				// and content overflow in IE
			width: chartWidth + 'px',
			height: chartHeight + 'px',
			textAlign: 'left',
			lineHeight: 'normal', // #427
			zIndex: 0, // #1072
			'-webkit-tap-highlight-color': 'rgba(0,0,0,0)'
		}, optionsChart.style);
		

		/**
		 * The containing HTML element of the chart. The container is
		 * dynamically inserted into the element given as the `renderTo`
		 * parameterin the {@link Highcharts#chart} constructor.
		 *
		 * @memberOf Highcharts.Chart
		 * @type {HTMLDOMElement}
		 */
		container = createElement(
			'div',
			{
				id: containerId
			},
			containerStyle,
			renderTo
		);
		chart.container = container;

		// cache the cursor (#1650)
		chart._cursor = container.style.cursor;

		// Initialize the renderer
		Ren = H[optionsChart.renderer] || H.Renderer;
		
		/**
		 * The renderer instance of the chart. Each chart instance has only one
		 * associated renderer.
		 * @type {SVGRenderer}
		 * @name renderer
		 * @memberOf Chart
		 */
		chart.renderer = new Ren(
			container,
			chartWidth,
			chartHeight,
			null,
			optionsChart.forExport,
			options.exporting && options.exporting.allowHTML
		);


		chart.setClassName(optionsChart.className);
		
		chart.renderer.setStyle(optionsChart.style);
				

		// Add a reference to the charts index
		chart.renderer.chartIndex = chart.index;
	},

	/**
	 * Calculate margins by rendering axis labels in a preliminary position.
	 * Title, subtitle and legend have already been rendered at this stage, but
	 * will be moved into their final positions.
	 *
	 * @private
	 */
	getMargins: function (skipAxes) {
		var chart = this,
			spacing = chart.spacing,
			margin = chart.margin,
			titleOffset = chart.titleOffset;

		chart.resetMargins();

		// Adjust for title and subtitle
		if (titleOffset && !defined(margin[0])) {
			chart.plotTop = Math.max(
				chart.plotTop,
				titleOffset + chart.options.title.margin + spacing[0]
			);
		}

		// Adjust for legend
		if (chart.legend && chart.legend.display) {
			chart.legend.adjustMargins(margin, spacing);
		}

		// adjust for scroller
		if (chart.extraMargin) {
			chart[chart.extraMargin.type] =
				(chart[chart.extraMargin.type] || 0) + chart.extraMargin.value;
		}
		
		// adjust for rangeSelector 
		if (chart.adjustPlotArea) {
			chart.adjustPlotArea();
		}

		if (!skipAxes) {
			this.getAxisMargins();
		}
	},

	getAxisMargins: function () {

		var chart = this,
			// [top, right, bottom, left]
			axisOffset = chart.axisOffset = [0, 0, 0, 0],
			margin = chart.margin;

		// pre-render axes to get labels offset width
		if (chart.hasCartesianSeries) {
			each(chart.axes, function (axis) {
				if (axis.visible) {
					axis.getOffset();
				}
			});
		}

		// Add the axis offsets
		each(marginNames, function (m, side) {
			if (!defined(margin[side])) {
				chart[m] += axisOffset[side];
			}
		});

		chart.setChartSize();

	},

	/**
	 * Reflows the chart to its container. By default, the chart reflows
	 * automatically to its container following a `window.resize` event, as per
	 * the {@link https://api.highcharts/highcharts/chart.reflow|chart.reflow}
	 * option. However, there are no reliable events for div resize, so if the
	 * container is resized without a window resize event, this must be called
	 * explicitly.
	 *
	 * @param  {Object} e
	 *         Event arguments. Used primarily when the function is called
	 *         internally as a response to window resize.
	 *
	 * @sample highcharts/members/chart-reflow/
	 *         Resize div and reflow
	 * @sample highcharts/chart/events-container/
	 *         Pop up and reflow
	 */
	reflow: function (e) {
		var chart = this,
			optionsChart = chart.options.chart,
			renderTo = chart.renderTo,
			hasUserSize = (
				defined(optionsChart.width) &&
				defined(optionsChart.height)
			),
			width = optionsChart.width || H.getStyle(renderTo, 'width'),
			height = optionsChart.height || H.getStyle(renderTo, 'height'),
			target = e ? e.target : win;

		// Width and height checks for display:none. Target is doc in IE8 and
		// Opera, win in Firefox, Chrome and IE9.
		if (
			!hasUserSize &&
			!chart.isPrinting &&
			width &&
			height &&
			(target === win || target === doc)
		) {
			if (
				width !== chart.containerWidth ||
				height !== chart.containerHeight
			) {
				clearTimeout(chart.reflowTimeout);
				// When called from window.resize, e is set, else it's called
				// directly (#2224)
				chart.reflowTimeout = syncTimeout(function () {
					// Set size, it may have been destroyed in the meantime
					// (#1257)
					if (chart.container) {
						chart.setSize(undefined, undefined, false);
					}
				}, e ? 100 : 0);
			}
			chart.containerWidth = width;
			chart.containerHeight = height;
		}
	},

	/**
	 * Add the event handlers necessary for auto resizing, depending on the 
	 * `chart.events.reflow` option.
	 *
	 * @private
	 */
	initReflow: function () {
		var chart = this,
			unbind;
		
		unbind = addEvent(win, 'resize', function (e) {
			chart.reflow(e);
		});
		addEvent(chart, 'destroy', unbind);

		// The following will add listeners to re-fit the chart before and after
		// printing (#2284). However it only works in WebKit. Should have worked
		// in Firefox, but not supported in IE.
		/*
		if (win.matchMedia) {
			win.matchMedia('print').addListener(function reflow() {
				chart.reflow();
			});
		}
		*/
	},

	/**
	 * Resize the chart to a given width and height. In order to set the width
	 * only, the height argument may be skipped. To set the height only, pass
	 * `undefined for the width.
	 * @param  {Number|undefined|null} [width]
	 *         The new pixel width of the chart. Since v4.2.6, the argument can
	 *         be `undefined` in order to preserve the current value (when
	 *         setting height only), or `null` to adapt to the width of the
	 *         containing element.
	 * @param  {Number|undefined|null} [height]
	 *         The new pixel height of the chart. Since v4.2.6, the argument can
	 *         be `undefined` in order to preserve the current value, or `null`
	 *         in order to adapt to the height of the containing element.
	 * @param  {AnimationOptions} [animation=true]
	 *         Whether and how to apply animation.
	 *
	 * @sample highcharts/members/chart-setsize-button/
	 *         Test resizing from buttons
	 * @sample highcharts/members/chart-setsize-jquery-resizable/
	 *         Add a jQuery UI resizable
	 * @sample stock/members/chart-setsize/
	 *         Highstock with UI resizable
	 */
	setSize: function (width, height, animation) {
		var chart = this,
			renderer = chart.renderer,
			globalAnimation;

		// Handle the isResizing counter
		chart.isResizing += 1;
		
		// set the animation for the current process
		H.setAnimation(animation, chart);

		chart.oldChartHeight = chart.chartHeight;
		chart.oldChartWidth = chart.chartWidth;
		if (width !== undefined) {
			chart.options.chart.width = width;
		}
		if (height !== undefined) {
			chart.options.chart.height = height;
		}
		chart.getChartSize();

		// Resize the container with the global animation applied if enabled
		// (#2503)
		
		globalAnimation = renderer.globalAnimation;
		(globalAnimation ? animate : css)(chart.container, {
			width: chart.chartWidth + 'px',
			height: chart.chartHeight + 'px'
		}, globalAnimation);
		

		chart.setChartSize(true);
		renderer.setSize(chart.chartWidth, chart.chartHeight, animation);

		// handle axes
		each(chart.axes, function (axis) {
			axis.isDirty = true;
			axis.setScale();
		});

		chart.isDirtyLegend = true; // force legend redraw
		chart.isDirtyBox = true; // force redraw of plot and chart border

		chart.layOutTitles(); // #2857
		chart.getMargins();

		chart.redraw(animation);


		chart.oldChartHeight = null;
		fireEvent(chart, 'resize');

		// Fire endResize and set isResizing back. If animation is disabled,
		// fire without delay
		syncTimeout(function () {
			if (chart) {
				fireEvent(chart, 'endResize', null, function () {
					chart.isResizing -= 1;
				});
			}
		}, animObject(globalAnimation).duration);
	},

	/**
	 * Set the public chart properties. This is done before and after the
	 * pre-render to determine margin sizes.
	 *
	 * @private
	 */
	setChartSize: function (skipAxes) {
		var chart = this,
			inverted = chart.inverted,
			renderer = chart.renderer,
			chartWidth = chart.chartWidth,
			chartHeight = chart.chartHeight,
			optionsChart = chart.options.chart,
			spacing = chart.spacing,
			clipOffset = chart.clipOffset,
			clipX,
			clipY,
			plotLeft,
			plotTop,
			plotWidth,
			plotHeight,
			plotBorderWidth;

		/**
		 * The current left position of the plot area in pixels.
		 *
		 * @name plotLeft
		 * @memberOf Chart
		 * @type {Number}
		 */
		chart.plotLeft = plotLeft = Math.round(chart.plotLeft);
		
		/**
		 * The current top position of the plot area in pixels.
		 *
		 * @name plotTop
		 * @memberOf Chart
		 * @type {Number}
		 */
		chart.plotTop = plotTop = Math.round(chart.plotTop);

		/**
		 * The current width of the plot area in pixels.
		 *
		 * @name plotWidth
		 * @memberOf Chart
		 * @type {Number}
		 */
		chart.plotWidth = plotWidth = Math.max(
			0,
			Math.round(chartWidth - plotLeft - chart.marginRight)
		);
		
		/**
		 * The current height of the plot area in pixels.
		 *
		 * @name plotHeight
		 * @memberOf Chart
		 * @type {Number}
		 */
		chart.plotHeight = plotHeight = Math.max(
			0,
			Math.round(chartHeight - plotTop - chart.marginBottom)
		);

		chart.plotSizeX = inverted ? plotHeight : plotWidth;
		chart.plotSizeY = inverted ? plotWidth : plotHeight;

		chart.plotBorderWidth = optionsChart.plotBorderWidth || 0;

		// Set boxes used for alignment
		chart.spacingBox = renderer.spacingBox = {
			x: spacing[3],
			y: spacing[0],
			width: chartWidth - spacing[3] - spacing[1],
			height: chartHeight - spacing[0] - spacing[2]
		};
		chart.plotBox = renderer.plotBox = {
			x: plotLeft,
			y: plotTop,
			width: plotWidth,
			height: plotHeight
		};

		plotBorderWidth = 2 * Math.floor(chart.plotBorderWidth / 2);
		clipX = Math.ceil(Math.max(plotBorderWidth, clipOffset[3]) / 2);
		clipY = Math.ceil(Math.max(plotBorderWidth, clipOffset[0]) / 2);
		chart.clipBox = {
			x: clipX, 
			y: clipY, 
			width: Math.floor(
				chart.plotSizeX -
				Math.max(plotBorderWidth, clipOffset[1]) / 2 -
				clipX
			), 
			height: Math.max(
				0,
				Math.floor(
					chart.plotSizeY -
					Math.max(plotBorderWidth, clipOffset[2]) / 2 -
					clipY
				)
			)
		};

		if (!skipAxes) {
			each(chart.axes, function (axis) {
				axis.setAxisSize();
				axis.setAxisTranslation();
			});
		}
	},

	/**
	 * Initial margins before auto size margins are applied.
	 *
	 * @private
	 */
	resetMargins: function () {
		var chart = this,
			chartOptions = chart.options.chart;

		// Create margin and spacing array
		each(['margin', 'spacing'], function splashArrays(target) {
			var value = chartOptions[target],
				values = isObject(value) ? value : [value, value, value, value];

			each(['Top', 'Right', 'Bottom', 'Left'], function (sideName, side) {
				chart[target][side] = pick(
					chartOptions[target + sideName],
					values[side]
				);
			});
		});

		// Set margin names like chart.plotTop, chart.plotLeft,
		// chart.marginRight, chart.marginBottom.
		each(marginNames, function (m, side) {
			chart[m] = pick(chart.margin[side], chart.spacing[side]);
		});
		chart.axisOffset = [0, 0, 0, 0]; // top, right, bottom, left
		chart.clipOffset = [0, 0, 0, 0];
	},

	/**
	 * Internal function to draw or redraw the borders and backgrounds for chart
	 * and plot area.
	 *
	 * @private
	 */
	drawChartBox: function () {
		var chart = this,
			optionsChart = chart.options.chart,
			renderer = chart.renderer,
			chartWidth = chart.chartWidth,
			chartHeight = chart.chartHeight,
			chartBackground = chart.chartBackground,
			plotBackground = chart.plotBackground,
			plotBorder = chart.plotBorder,
			chartBorderWidth,
			
			plotBGImage = chart.plotBGImage,
			chartBackgroundColor = optionsChart.backgroundColor,
			plotBackgroundColor = optionsChart.plotBackgroundColor,
			plotBackgroundImage = optionsChart.plotBackgroundImage,
			
			mgn,
			bgAttr,
			plotLeft = chart.plotLeft,
			plotTop = chart.plotTop,
			plotWidth = chart.plotWidth,
			plotHeight = chart.plotHeight,
			plotBox = chart.plotBox,
			clipRect = chart.clipRect,
			clipBox = chart.clipBox,
			verb = 'animate';

		// Chart area
		if (!chartBackground) {
			chart.chartBackground = chartBackground = renderer.rect()
				.addClass('highcharts-background')
				.add();
			verb = 'attr';
		}

		
		// Presentational
		chartBorderWidth = optionsChart.borderWidth || 0;
		mgn = chartBorderWidth + (optionsChart.shadow ? 8 : 0);

		bgAttr = {
			fill: chartBackgroundColor || 'none'
		};

		if (chartBorderWidth || chartBackground['stroke-width']) { // #980
			bgAttr.stroke = optionsChart.borderColor;
			bgAttr['stroke-width'] = chartBorderWidth;
		}
		chartBackground
			.attr(bgAttr)
			.shadow(optionsChart.shadow);
		
		chartBackground[verb]({
			x: mgn / 2,
			y: mgn / 2,
			width: chartWidth - mgn - chartBorderWidth % 2,
			height: chartHeight - mgn - chartBorderWidth % 2,
			r: optionsChart.borderRadius
		});

		// Plot background
		verb = 'animate';
		if (!plotBackground) {
			verb = 'attr';
			chart.plotBackground = plotBackground = renderer.rect()
				.addClass('highcharts-plot-background')
				.add();
		}
		plotBackground[verb](plotBox);

		
		// Presentational attributes for the background
		plotBackground
			.attr({
				fill: plotBackgroundColor || 'none'
			})
			.shadow(optionsChart.plotShadow);
		
		// Create the background image
		if (plotBackgroundImage) {
			if (!plotBGImage) {
				chart.plotBGImage = renderer.image(
					plotBackgroundImage,
					plotLeft,
					plotTop,
					plotWidth,
					plotHeight
				).add();
			} else {
				plotBGImage.animate(plotBox);
			}
		}
		
		
		// Plot clip
		if (!clipRect) {
			chart.clipRect = renderer.clipRect(clipBox);
		} else {
			clipRect.animate({
				width: clipBox.width,
				height: clipBox.height
			});
		}

		// Plot area border
		verb = 'animate';
		if (!plotBorder) {
			verb = 'attr';
			chart.plotBorder = plotBorder = renderer.rect()
				.addClass('highcharts-plot-border')
				.attr({
					zIndex: 1 // Above the grid
				})
				.add();
		}

		
		// Presentational
		plotBorder.attr({
			stroke: optionsChart.plotBorderColor,
			'stroke-width': optionsChart.plotBorderWidth || 0,
			fill: 'none'
		});
		

		plotBorder[verb](plotBorder.crisp({
			x: plotLeft,
			y: plotTop,
			width: plotWidth,
			height: plotHeight
		}, -plotBorder.strokeWidth())); // #3282 plotBorder should be negative;

		// reset
		chart.isDirtyBox = false;
	},

	/**
	 * Detect whether a certain chart property is needed based on inspecting its
	 * options and series. This mainly applies to the chart.inverted property,
	 * and in extensions to the chart.angular and chart.polar properties.
	 *
	 * @private
	 */
	propFromSeries: function () {
		var chart = this,
			optionsChart = chart.options.chart,
			klass,
			seriesOptions = chart.options.series,
			i,
			value;


		each(['inverted', 'angular', 'polar'], function (key) {

			// The default series type's class
			klass = seriesTypes[optionsChart.type ||
				optionsChart.defaultSeriesType];

			// Get the value from available chart-wide properties
			value = 
				optionsChart[key] || // It is set in the options
				(klass && klass.prototype[key]); // The default series class
					// requires it

			// 4. Check if any the chart's series require it
			i = seriesOptions && seriesOptions.length;
			while (!value && i--) {
				klass = seriesTypes[seriesOptions[i].type];
				if (klass && klass.prototype[key]) {
					value = true;
				}
			}

			// Set the chart property
			chart[key] = value;
		});

	},

	/**
	 * Internal function to link two or more series together, based on the 
	 * `linkedTo` option. This is done from `Chart.render`, and after
	 * `Chart.addSeries` and `Series.remove`.
	 *
	 * @private
	 */
	linkSeries: function () {
		var chart = this,
			chartSeries = chart.series;

		// Reset links
		each(chartSeries, function (series) {
			series.linkedSeries.length = 0;
		});

		// Apply new links
		each(chartSeries, function (series) {
			var linkedTo = series.options.linkedTo;
			if (isString(linkedTo)) {
				if (linkedTo === ':previous') {
					linkedTo = chart.series[series.index - 1];
				} else {
					linkedTo = chart.get(linkedTo);
				}
				// #3341 avoid mutual linking
				if (linkedTo && linkedTo.linkedParent !== series) {
					linkedTo.linkedSeries.push(series);
					series.linkedParent = linkedTo;
					series.visible = pick(
						series.options.visible,
						linkedTo.options.visible,
						series.visible
					); // #3879
				}
			}
		});
	},

	/**
	 * Render series for the chart.
	 *
	 * @private
	 */
	renderSeries: function () {
		each(this.series, function (serie) {
			serie.translate();
			serie.render();
		});
	},

	/**
	 * Render labels for the chart.
	 *
	 * @private
	 */
	renderLabels: function () {
		var chart = this,
			labels = chart.options.labels;
		if (labels.items) {
			each(labels.items, function (label) {
				var style = extend(labels.style, label.style),
					x = pInt(style.left) + chart.plotLeft,
					y = pInt(style.top) + chart.plotTop + 12;

				// delete to prevent rewriting in IE
				delete style.left;
				delete style.top;

				chart.renderer.text(
					label.html,
					x,
					y
				)
				.attr({ zIndex: 2 })
				.css(style)
				.add();

			});
		}
	},

	/**
	 * Render all graphics for the chart. Runs internally on initialization.
	 *
	 * @private
	 */
	render: function () {
		var chart = this,
			axes = chart.axes,
			renderer = chart.renderer,
			options = chart.options,
			tempWidth,
			tempHeight,
			redoHorizontal,
			redoVertical;

		// Title
		chart.setTitle();


		// Legend
		chart.legend = new Legend(chart, options.legend);

		// Get stacks
		if (chart.getStacks) {
			chart.getStacks();
		}

		// Get chart margins
		chart.getMargins(true);
		chart.setChartSize();

		// Record preliminary dimensions for later comparison
		tempWidth = chart.plotWidth;
		// 21 is the most common correction for X axis labels
		// use Math.max to prevent negative plotHeight
		tempHeight = chart.plotHeight = Math.max(chart.plotHeight - 21, 0);

		// Get margins by pre-rendering axes
		each(axes, function (axis) {
			axis.setScale();
		});
		chart.getAxisMargins();

		// If the plot area size has changed significantly, calculate tick positions again
		redoHorizontal = tempWidth / chart.plotWidth > 1.1;
		redoVertical = tempHeight / chart.plotHeight > 1.05; // Height is more sensitive

		if (redoHorizontal || redoVertical) {

			each(axes, function (axis) {
				if ((axis.horiz && redoHorizontal) || (!axis.horiz && redoVertical)) {
					axis.setTickInterval(true); // update to reflect the new margins
				}
			});
			chart.getMargins(); // second pass to check for new labels
		}

		// Draw the borders and backgrounds
		chart.drawChartBox();


		// Axes
		if (chart.hasCartesianSeries) {
			each(axes, function (axis) {
				if (axis.visible) {
					axis.render();
				}
			});
		}

		// The series
		if (!chart.seriesGroup) {
			chart.seriesGroup = renderer.g('series-group')
				.attr({ zIndex: 3 })
				.add();
		}
		chart.renderSeries();

		// Labels
		chart.renderLabels();

		// Credits
		chart.addCredits();

		// Handle responsiveness
		if (chart.setResponsive) {
			chart.setResponsive();
		}

		// Set flag
		chart.hasRendered = true;

	},

	/**
	 * Set a new credits label for the chart.
	 *
	 * @param  {CreditOptions} options
	 *         A configuration object for the new credits.
	 * @sample highcharts/credits/credits-update/ Add and update credits
	 */
	addCredits: function (credits) {
		var chart = this;

		credits = merge(true, this.options.credits, credits);
		if (credits.enabled && !this.credits) {

			/**
			 * The chart's credits label. The label has an `update` method that
			 * allows setting new options as per the {@link
			 * https://api.highcharts.com/highcharts/credits|
			 * credits options set}.
			 *
			 * @memberof Highcharts.Chart
			 * @name credits
			 * @type {Highcharts.SVGElement}
			 */
			this.credits = this.renderer.text(
				credits.text + (this.mapCredits || ''),
				0,
				0
			)
			.addClass('highcharts-credits')
			.on('click', function () {
				if (credits.href) {
					win.location.href = credits.href;
				}
			})
			.attr({
				align: credits.position.align,
				zIndex: 8
			})
			
			.css(credits.style)
			
			.add()
			.align(credits.position);

			// Dynamically update
			this.credits.update = function (options) {
				chart.credits = chart.credits.destroy();
				chart.addCredits(options);
			};
		}
	},

	/**
	 * Remove the chart and purge memory. This method is called internally
	 * before adding a second chart into the same container, as well as on
	 * window unload to prevent leaks.
	 *
	 * @sample highcharts/members/chart-destroy/
	 *         Destroy the chart from a button
	 * @sample stock/members/chart-destroy/
	 *         Destroy with Highstock
	 */
	destroy: function () {
		var chart = this,
			axes = chart.axes,
			series = chart.series,
			container = chart.container,
			i,
			parentNode = container && container.parentNode;

		// fire the chart.destoy event
		fireEvent(chart, 'destroy');

		// Delete the chart from charts lookup array
		if (chart.renderer.forExport) {
			H.erase(charts, chart); // #6569
		} else {
			charts[chart.index] = undefined;
		}
		H.chartCount--;
		chart.renderTo.removeAttribute('data-highcharts-chart');

		// remove events
		removeEvent(chart);

		// ==== Destroy collections:
		// Destroy axes
		i = axes.length;
		while (i--) {
			axes[i] = axes[i].destroy();
		}
		
		// Destroy scroller & scroller series before destroying base series
		if (this.scroller && this.scroller.destroy) {
			this.scroller.destroy();
		}

		// Destroy each series
		i = series.length;
		while (i--) {
			series[i] = series[i].destroy();
		}

		// ==== Destroy chart properties:
		each([
			'title', 'subtitle', 'chartBackground', 'plotBackground',
			'plotBGImage', 'plotBorder', 'seriesGroup', 'clipRect', 'credits',
			'pointer', 'rangeSelector', 'legend', 'resetZoomButton', 'tooltip',
			'renderer'
		], function (name) {
			var prop = chart[name];

			if (prop && prop.destroy) {
				chart[name] = prop.destroy();
			}
		});

		// remove container and all SVG
		if (container) { // can break in IE when destroyed before finished loading
			container.innerHTML = '';
			removeEvent(container);
			if (parentNode) {
				discardElement(container);
			}

		}

		// clean it all up
		objectEach(chart, function (val, key) {
			delete chart[key];
		});

	},


	/**
	 * VML namespaces can't be added until after complete. Listening
	 * for Perini's doScroll hack is not enough.
	 *
	 * @private
	 */
	isReadyToRender: function () {
		var chart = this;

		// Note: win == win.top is required
		if ((!svg && (win == win.top && doc.readyState !== 'complete'))) { // eslint-disable-line eqeqeq
			doc.attachEvent('onreadystatechange', function () {
				doc.detachEvent('onreadystatechange', chart.firstRender);
				if (doc.readyState === 'complete') {
					chart.firstRender();
				}
			});
			return false;
		}
		return true;
	},

	/**
	 * Prepare for first rendering after all data are loaded.
	 *
	 * @private
	 */
	firstRender: function () {
		var chart = this,
			options = chart.options;

		// Check whether the chart is ready to render
		if (!chart.isReadyToRender()) {
			return;
		}

		// Create the container
		chart.getContainer();

		// Run an early event after the container and renderer are established
		fireEvent(chart, 'init');


		chart.resetMargins();
		chart.setChartSize();

		// Set the common chart properties (mainly invert) from the given series
		chart.propFromSeries();

		// get axes
		chart.getAxes();

		// Initialize the series
		each(options.series || [], function (serieOptions) {
			chart.initSeries(serieOptions);
		});

		chart.linkSeries();

		// Run an event after axes and series are initialized, but before render. At this stage,
		// the series data is indexed and cached in the xData and yData arrays, so we can access
		// those before rendering. Used in Highstock.
		fireEvent(chart, 'beforeRender');

		// depends on inverted and on margins being set
		if (Pointer) {

			/**
			 * The Pointer that keeps track of mouse and touch interaction.
			 *
			 * @memberof Chart
			 * @name pointer
			 * @type Pointer
			 */
			chart.pointer = new Pointer(chart, options);
		}

		chart.render();

		// Fire the load event if there are no external images
		if (!chart.renderer.imgCount && chart.onload) {
			chart.onload();
		}

		// If the chart was rendered outside the top container, put it back in (#3679)
		chart.temporaryDisplay(true);

	},

	/** 
	 * Internal function that runs on chart load, async if any images are loaded
	 * in the chart. Runs the callbacks and triggers the `load` and `render`
	 * events.
	 *
	 * @private
	 */
	onload: function () {

		// Run callbacks
		each([this.callback].concat(this.callbacks), function (fn) {
			if (fn && this.index !== undefined) { // Chart destroyed in its own callback (#3600)
				fn.apply(this, [this]);
			}
		}, this);

		fireEvent(this, 'load');
		fireEvent(this, 'render');
		

		// Set up auto resize, check for not destroyed (#6068)
		if (defined(this.index) && this.options.chart.reflow !== false) {
			this.initReflow();
		}

		// Don't run again
		this.onload = null;
	}

}); // end Chart

}(Highcharts));
(function (Highcharts) {
/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var Point,
	H = Highcharts,

	each = H.each,
	extend = H.extend,
	erase = H.erase,
	fireEvent = H.fireEvent,
	format = H.format,
	isArray = H.isArray,
	isNumber = H.isNumber,
	pick = H.pick,
	removeEvent = H.removeEvent;

/**
 * The Point object. The point objects are generated from the `series.data` 
 * configuration objects or raw numbers. They can be accessed from the
 * `Series.points` array. Other ways to instaniate points are through {@link
 * Highcharts.Series#addPoint} or {@link Highcharts.Series#setData}.
 *
 * @class
 */

Highcharts.Point = Point = function () {};
Highcharts.Point.prototype = {

	/**
	 * Initialize the point. Called internally based on the `series.data`
	 * option.
	 * @param  {Series} series
	 *         The series object containing this point.
	 * @param  {Number|Array|Object} options
	 *         The data in either number, array or object format.
	 * @param  {Number} x Optionally, the X value of the point.
	 * @return {Point} The Point instance.
	 */
	init: function (series, options, x) {

		var point = this,
			colors,
			colorCount = series.chart.options.chart.colorCount,
			colorIndex;

		/**
		 * The series object associated with the point.
		 *
		 * @name series
		 * @memberof Highcharts.Point
		 * @type Highcharts.Series
		 */
		point.series = series;

		
		/**
		 * The point's current color.
		 * @name color
		 * @memberof Highcharts.Point
		 * @type {Color}
		 */
		point.color = series.color; // #3445
		
		point.applyOptions(options, x);

		if (series.options.colorByPoint) {
			
			colors = series.options.colors || series.chart.options.colors;
			point.color = point.color || colors[series.colorCounter];
			colorCount = colors.length;
			
			colorIndex = series.colorCounter;
			series.colorCounter++;
			// loop back to zero
			if (series.colorCounter === colorCount) {
				series.colorCounter = 0;
			}
		} else {
			colorIndex = series.colorIndex;
		}

		/**
		 * The point's current color index, used in styled mode instead of 
		 * `color`. The color index is inserted in class names used for styling.
		 * @name colorIndex
		 * @memberof Highcharts.Point
		 * @type {Number}
		 */
		point.colorIndex = pick(point.colorIndex, colorIndex);

		series.chart.pointCount++;
		return point;
	},
	/**
	 * Apply the options containing the x and y data and possible some extra
	 * properties. Called on point init or from point.update.
	 *
	 * @private
	 * @param {Object} options The point options as defined in series.data.
	 * @param {Number} x Optionally, the X value.
	 * @returns {Object} The Point instance.
	 */
	applyOptions: function (options, x) {
		var point = this,
			series = point.series,
			pointValKey = series.options.pointValKey || series.pointValKey;

		options = Point.prototype.optionsToObject.call(this, options);

		// copy options directly to point
		extend(point, options);
		point.options = point.options ? extend(point.options, options) : options;

		// Since options are copied into the Point instance, some accidental options must be shielded (#5681)
		if (options.group) {
			delete point.group;
		}

		// For higher dimension series types. For instance, for ranges, point.y is mapped to point.low.
		if (pointValKey) {
			point.y = point[pointValKey];
		}
		point.isNull = pick(
			point.isValid && !point.isValid(),
			point.x === null || !isNumber(point.y, true)
		); // #3571, check for NaN

		// The point is initially selected by options (#5777)
		if (point.selected) {
			point.state = 'select';
		}

		// If no x is set by now, get auto incremented value. All points must have an
		// x value, however the y value can be null to create a gap in the series
		if ('name' in point && x === undefined && series.xAxis && series.xAxis.hasNames) {
			point.x = series.xAxis.nameToX(point);
		}
		if (point.x === undefined && series) {
			if (x === undefined) {
				point.x = series.autoIncrement(point);
			} else {
				point.x = x;
			}
		}
		
		return point;
	},

	/**
	 * Transform number or array configs into objects. Used internally to unify
	 * the different configuration formats for points. For example, a simple
	 * number `10` in a line series will be transformed to `{ y: 10 }`, and an
	 * array config like `[1, 10]` in a scatter series will be transformed to
	 * `{ x: 1, y: 10 }`.
	 *
	 * @param  {Number|Array|Object} options
	 *         The input options
	 * @return {Object} Transformed options.
	 */
	optionsToObject: function (options) {
		var ret = {},
			series = this.series,
			keys = series.options.keys,
			pointArrayMap = keys || series.pointArrayMap || ['y'],
			valueCount = pointArrayMap.length,
			firstItemType,
			i = 0,
			j = 0;

		if (isNumber(options) || options === null) {
			ret[pointArrayMap[0]] = options;

		} else if (isArray(options)) {
			// with leading x value
			if (!keys && options.length > valueCount) {
				firstItemType = typeof options[0];
				if (firstItemType === 'string') {
					ret.name = options[0];
				} else if (firstItemType === 'number') {
					ret.x = options[0];
				}
				i++;
			}
			while (j < valueCount) {
				if (!keys || options[i] !== undefined) { // Skip undefined positions for keys
					ret[pointArrayMap[j]] = options[i];
				}
				i++;
				j++;
			}
		} else if (typeof options === 'object') {
			ret = options;

			// This is the fastest way to detect if there are individual point dataLabels that need
			// to be considered in drawDataLabels. These can only occur in object configs.
			if (options.dataLabels) {
				series._hasPointLabels = true;
			}

			// Same approach as above for markers
			if (options.marker) {
				series._hasPointMarkers = true;
			}
		}
		return ret;
	},

	/**
	 * Get the CSS class names for individual points. Used internally where the
	 * returned value is set on every point.
	 * 
	 * @returns {String} The class names.
	 */
	getClassName: function () {
		return 'highcharts-point' + 
			(this.selected ? ' highcharts-point-select' : '') + 
			(this.negative ? ' highcharts-negative' : '') + 
			(this.isNull ? ' highcharts-null-point' : '') + 
			(this.colorIndex !== undefined ? ' highcharts-color-' +
				this.colorIndex : '') +
			(this.options.className ? ' ' + this.options.className : '') +
			(this.zone && this.zone.className ? ' ' +
				this.zone.className.replace('highcharts-negative', '') : '');
	},

	/**
	 * In a series with `zones`, return the zone that the point belongs to.
	 *
	 * @return {Object}
	 *         The zone item.
	 */
	getZone: function () {
		var series = this.series,
			zones = series.zones,
			zoneAxis = series.zoneAxis || 'y',
			i = 0,
			zone;

		zone = zones[i];
		while (this[zoneAxis] >= zone.value) {				
			zone = zones[++i];
		}

		if (zone && zone.color && !this.options.color) {
			this.color = zone.color;
		}

		return zone;
	},

	/**
	 * Destroy a point to clear memory. Its reference still stays in
	 * `series.data`.
	 *
	 * @private
	 */
	destroy: function () {
		var point = this,
			series = point.series,
			chart = series.chart,
			hoverPoints = chart.hoverPoints,
			prop;

		chart.pointCount--;

		if (hoverPoints) {
			point.setState();
			erase(hoverPoints, point);
			if (!hoverPoints.length) {
				chart.hoverPoints = null;
			}

		}
		if (point === chart.hoverPoint) {
			point.onMouseOut();
		}

		// remove all events
		if (point.graphic || point.dataLabel) { // removeEvent and destroyElements are performance expensive
			removeEvent(point);
			point.destroyElements();
		}

		if (point.legendItem) { // pies have legend items
			chart.legend.destroyItem(point);
		}

		for (prop in point) {
			point[prop] = null;
		}


	},

	/**
	 * Destroy SVG elements associated with the point.
	 *
	 * @private
	 */
	destroyElements: function () {
		var point = this,
			props = ['graphic', 'dataLabel', 'dataLabelUpper', 'connector', 'shadowGroup'],
			prop,
			i = 6;
		while (i--) {
			prop = props[i];
			if (point[prop]) {
				point[prop] = point[prop].destroy();
			}
		}
	},

	/**
	 * Return the configuration hash needed for the data label and tooltip
	 * formatters.
	 *
	 * @returns {Object}
	 *          Abstract object used in formatters and formats.
	 */
	getLabelConfig: function () {
		return {
			x: this.category,
			y: this.y,
			color: this.color,
			colorIndex: this.colorIndex,
			key: this.name || this.category,
			series: this.series,
			point: this,
			percentage: this.percentage,
			total: this.total || this.stackTotal
		};
	},

	/**
	 * Extendable method for formatting each point's tooltip line.
	 *
	 * @param  {String} pointFormat
	 *         The point format.
	 * @return {String}
	 *         A string to be concatenated in to the common tooltip text.
	 */
	tooltipFormatter: function (pointFormat) {

		// Insert options for valueDecimals, valuePrefix, and valueSuffix
		var series = this.series,
			seriesTooltipOptions = series.tooltipOptions,
			valueDecimals = pick(seriesTooltipOptions.valueDecimals, ''),
			valuePrefix = seriesTooltipOptions.valuePrefix || '',
			valueSuffix = seriesTooltipOptions.valueSuffix || '';

		// Loop over the point array map and replace unformatted values with sprintf formatting markup
		each(series.pointArrayMap || ['y'], function (key) {
			key = '{point.' + key; // without the closing bracket
			if (valuePrefix || valueSuffix) {
				pointFormat = pointFormat.replace(key + '}', valuePrefix + key + '}' + valueSuffix);
			}
			pointFormat = pointFormat.replace(key + '}', key + ':,.' + valueDecimals + 'f}');
		});

		return format(pointFormat, {
			point: this,
			series: this.series
		}, series.chart.time);
	},

	/**
	 * Fire an event on the Point object.
	 *
	 * @private
	 * @param {String} eventType
	 * @param {Object} eventArgs Additional event arguments
	 * @param {Function} defaultFunction Default event handler
	 */
	firePointEvent: function (eventType, eventArgs, defaultFunction) {
		var point = this,
			series = this.series,
			seriesOptions = series.options;

		// load event handlers on demand to save time on mouseover/out
		if (seriesOptions.point.events[eventType] || (point.options && point.options.events && point.options.events[eventType])) {
			this.importEvents();
		}

		// add default handler if in selection mode
		if (eventType === 'click' && seriesOptions.allowPointSelect) {
			defaultFunction = function (event) {
				// Control key is for Windows, meta (= Cmd key) for Mac, Shift for Opera
				if (point.select) { // Could be destroyed by prior event handlers (#2911)
					point.select(null, event.ctrlKey || event.metaKey || event.shiftKey);
				}
			};
		}

		fireEvent(this, eventType, eventArgs, defaultFunction);
	},

	/**
	 * For certain series types, like pie charts, where individual points can
	 * be shown or hidden. 
	 *
	 * @name visible
	 * @memberOf Highcharts.Point
	 * @type {Boolean}
	 */
	visible: true
};

/**
 * For categorized axes this property holds the category name for the 
 * point. For other axes it holds the X value.
 *
 * @name category
 * @memberOf Highcharts.Point
 * @type {String|Number}
 */

/**
 * The name of the point. The name can be given as the first position of the 
 * point configuration array, or as a `name` property in the configuration:
 *
 * @example
 * // Array config
 * data: [
 *     ['John', 1],
 *     ['Jane', 2]
 * ]
 *
 * // Object config
 * data: [{
 * 	   name: 'John',
 * 	   y: 1
 * }, {
 *     name: 'Jane',
 *     y: 2
 * }]
 *
 * @name name
 * @memberOf Highcharts.Point
 * @type {String}
 */


/**
 * The percentage for points in a stacked series or pies.
 *
 * @name percentage
 * @memberOf Highcharts.Point
 * @type {Number}
 */

/**
 * The total of values in either a stack for stacked series, or a pie in a pie
 * series.
 *
 * @name total
 * @memberOf Highcharts.Point
 * @type {Number}
 */

/**
 * The x value of the point.
 *
 * @name x
 * @memberOf Highcharts.Point
 * @type {Number}
 */

/**
 * The y value of the point.
 *
 * @name y
 * @memberOf Highcharts.Point
 * @type {Number}
 */

}(Highcharts));
(function (H) {
/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var addEvent = H.addEvent,
	animObject = H.animObject,
	arrayMax = H.arrayMax,
	arrayMin = H.arrayMin,
	correctFloat = H.correctFloat,
	defaultOptions = H.defaultOptions,
	defaultPlotOptions = H.defaultPlotOptions,
	defined = H.defined,
	each = H.each,
	erase = H.erase,
	extend = H.extend,
	fireEvent = H.fireEvent,
	grep = H.grep,
	isArray = H.isArray,
	isNumber = H.isNumber,
	isString = H.isString,
	LegendSymbolMixin = H.LegendSymbolMixin, // @todo add as a requirement
	merge = H.merge,
	objectEach = H.objectEach,
	pick = H.pick,
	Point = H.Point, // @todo  add as a requirement
	removeEvent = H.removeEvent,
	splat = H.splat,
	SVGElement = H.SVGElement,
	syncTimeout = H.syncTimeout,
	win = H.win;

/**
 * This is the base series prototype that all other series types inherit from.
 * A new series is initialized either through the
 * {@link https://api.highcharts.com/highcharts/series|series} option structure,
 * or after the chart is initialized, through
 * {@link Highcharts.Chart#addSeries}.
 *
 * The object can be accessed in a number of ways. All series and point event
 * handlers give a reference to the `series` object. The chart object has a
 * {@link Highcharts.Chart.series|series} property that is a collection of all
 * the chart's series. The point objects and axis objects also have the same
 * reference.
 *
 * Another way to reference the series programmatically is by `id`. Add an id
 * in the series configuration options, and get the series object by {@link
 * Highcharts.Chart#get}.
 *
 * Configuration options for the series are given in three levels. Options for
 * all series in a chart are given in the
 * {@link https://api.highcharts.com/highcharts/plotOptions.series|
 * plotOptions.series} object. Then options for all series of a specific type
 * are given in the plotOptions of that type, for example `plotOptions.line`.
 * Next, options for one single series are given in the series array, or as
 * arguements to `chart.addSeries`.
 *
 * The data in the series is stored in various arrays.
 *
 * - First, `series.options.data` contains all the original config options for
 * each point whether added by options or methods like `series.addPoint`.
 * - Next, `series.data` contains those values converted to points, but in case
 * the series data length exceeds the `cropThreshold`, or if the data is
 * grouped, `series.data` doesn't contain all the points. It only contains the
 * points that have been created on demand.
 * - Then there's `series.points` that contains all currently visible point
 * objects. In case of cropping, the cropped-away points are not part of this
 * array. The `series.points` array starts at `series.cropStart` compared to
 * `series.data` and `series.options.data`. If however the series data is
 * grouped, these can't be correlated one to one.
 * - `series.xData` and `series.processedXData` contain clean x values,
 * equivalent to `series.data` and `series.points`.
 * - `series.yData` and `series.processedYData` contain clean y values,
 * equivalent to `series.data` and `series.points`.
 *
 * @class Highcharts.Series
 * @param  {Highcharts.Chart} chart
 *         The chart instance.
 * @param  {Options.plotOptions.series} options
 *         The series options.
 *
 */

/**
 * General options for all series types.
 * @optionparent plotOptions.series
 */
H.Series = H.seriesType('line', null, { // base series options
	
	/**
	 * The SVG value used for the `stroke-linecap` and `stroke-linejoin`
	 * of a line graph. Round means that lines are rounded in the ends and
	 * bends.
	 * 
	 * @validvalue ["round", "butt", "square"]
	 * @type {String}
	 * @default round
	 * @since 3.0.7
	 * @apioption plotOptions.line.linecap
	 */

	/**
	 * Pixel with of the graph line.
	 * 
	 * @type {Number}
	 * @see In styled mode, the line stroke-width can be set with the
	 * `.highcharts-graph` class name.
	 * @sample {highcharts} highcharts/plotoptions/series-linewidth-general/
	 *         On all series
	 * @sample {highcharts} highcharts/plotoptions/series-linewidth-specific/
	 *         On one single series
	 * @default 2
	 * @product highcharts highstock
	 */
	lineWidth: 2,
	

	/**
	 * For some series, there is a limit that shuts down initial animation
	 * by default when the total number of points in the chart is too high.
	 * For example, for a column chart and its derivatives, animation doesn't
	 * run if there is more than 250 points totally. To disable this cap, set
	 * `animationLimit` to `Infinity`.
	 * 
	 * @type {Number}
	 * @apioption plotOptions.series.animationLimit
	 */

	/**
	 * Allow this series' points to be selected by clicking on the graphic 
	 * (columns, point markers, pie slices, map areas etc).
	 *
	 * @see [Chart#getSelectedPoints]
	 *      (../class-reference/Highcharts.Chart#getSelectedPoints).
	 * 
	 * @type {Boolean}
	 * @sample {highcharts} highcharts/plotoptions/series-allowpointselect-line/
	 *         Line
	 * @sample {highcharts}
	 *         highcharts/plotoptions/series-allowpointselect-column/
	 *         Column
	 * @sample {highcharts} highcharts/plotoptions/series-allowpointselect-pie/
	 *         Pie
	 * @sample {highmaps} maps/plotoptions/series-allowpointselect/
	 *         Map area
	 * @sample {highmaps} maps/plotoptions/mapbubble-allowpointselect/
	 *         Map bubble
	 * @default false
	 * @since 1.2.0
	 */
	allowPointSelect: false,



	/**
	 * If true, a checkbox is displayed next to the legend item to allow
	 * selecting the series. The state of the checkbox is determined by
	 * the `selected` option.
	 *
	 * @productdesc {highmaps}
	 * Note that if a `colorAxis` is defined, the color axis is represented in
	 * the legend, not the series.
	 * 
	 * @type {Boolean}
	 * @sample {highcharts} highcharts/plotoptions/series-showcheckbox-true/
	 *         Show select box
	 * @default false
	 * @since 1.2.0
	 */
	showCheckbox: false,



	/**
	 * Enable or disable the initial animation when a series is displayed.
	 * The animation can also be set as a configuration object. Please
	 * note that this option only applies to the initial animation of the
	 * series itself. For other animations, see [chart.animation](#chart.
	 * animation) and the animation parameter under the API methods. The
	 * following properties are supported:
	 * 
	 * <dl>
	 * 
	 * <dt>duration</dt>
	 * 
	 * <dd>The duration of the animation in milliseconds.</dd>
	 * 
	 * <dt>easing</dt>
	 * 
	 * <dd>A string reference to an easing function set on the `Math` object.
	 * See the _Custom easing function_ demo below.</dd>
	 * 
	 * </dl>
	 * 
	 * Due to poor performance, animation is disabled in old IE browsers
	 * for several chart types.
	 * 
	 * @type {Boolean}
	 * @sample {highcharts} highcharts/plotoptions/series-animation-disabled/
	 *         Animation disabled
	 * @sample {highcharts} highcharts/plotoptions/series-animation-slower/
	 *         Slower animation
	 * @sample {highcharts} highcharts/plotoptions/series-animation-easing/
	 *         Custom easing function
	 * @sample {highstock} stock/plotoptions/animation-slower/
	 *         Slower animation
	 * @sample {highstock} stock/plotoptions/animation-easing/
	 *         Custom easing function
	 * @sample {highmaps} maps/plotoptions/series-animation-true/
	 *         Animation enabled on map series
	 * @sample {highmaps} maps/plotoptions/mapbubble-animation-false/
	 *         Disabled on mapbubble series
	 * @default {highcharts} true
	 * @default {highstock} true
	 * @default {highmaps} false
	 */
	animation: {
		duration: 1000
	},

	/**
	 * A class name to apply to the series' graphical elements.
	 * 
	 * @type {String}
	 * @since 5.0.0
	 * @apioption plotOptions.series.className
	 */
	
	/**
	 * The main color of the series. In line type series it applies to the
	 * line and the point markers unless otherwise specified. In bar type
	 * series it applies to the bars unless a color is specified per point.
	 * The default value is pulled from the `options.colors` array.
	 * 
	 * In styled mode, the color can be defined by the
	 * [colorIndex](#plotOptions.series.colorIndex) option. Also, the series
	 * color can be set with the `.highcharts-series`, `.highcharts-color-{n}`,
	 * `.highcharts-{type}-series` or `.highcharts-series-{n}` class, or
	 * individual classes given by the `className` option.
	 *
	 * @productdesc {highmaps}
	 * In maps, the series color is rarely used, as most choropleth maps use the
	 * color to denote the value of each point. The series color can however be
	 * used in a map with multiple series holding categorized data.
	 * 
	 * @type {Color}
	 * @sample {highcharts} highcharts/plotoptions/series-color-general/
	 *         General plot option
	 * @sample {highcharts} highcharts/plotoptions/series-color-specific/
	 *         One specific series
	 * @sample {highcharts} highcharts/plotoptions/series-color-area/
	 *         Area color
	 * @sample {highmaps} maps/demo/category-map/
	 *         Category map by multiple series
	 * @apioption plotOptions.series.color
	 */
	
	/**
	 * Styled mode only. A specific color index to use for the series, so its
	 * graphic representations are given the class name `highcharts-color-
	 * {n}`.
	 * 
	 * @type {Number}
	 * @since 5.0.0
	 * @apioption plotOptions.series.colorIndex
	 */
	

	/**
	 * Whether to connect a graph line across null points, or render a gap
	 * between the two points on either side of the null.
	 * 
	 * @type {Boolean}
	 * @sample {highcharts} highcharts/plotoptions/series-connectnulls-false/
	 *         False by default
	 * @sample {highcharts} highcharts/plotoptions/series-connectnulls-true/
	 *         True
	 * @product highcharts highstock
	 * @apioption plotOptions.series.connectNulls
	 */
	

	/**
	 * You can set the cursor to "pointer" if you have click events attached
	 * to the series, to signal to the user that the points and lines can
	 * be clicked.
	 * 
	 * @validvalue [null, "default", "none", "help", "pointer", "crosshair"]
	 * @type {String}
	 * @see In styled mode, the series cursor can be set with the same classes
	 * as listed under [series.color](#plotOptions.series.color).
	 * @sample {highcharts} highcharts/plotoptions/series-cursor-line/
	 *         On line graph
	 * @sample {highcharts} highcharts/plotoptions/series-cursor-column/
	 *         On columns
	 * @sample {highcharts} highcharts/plotoptions/series-cursor-scatter/
	 *         On scatter markers
	 * @sample {highstock} stock/plotoptions/cursor/
	 *         Pointer on a line graph
	 * @sample {highmaps} maps/plotoptions/series-allowpointselect/
	 *         Map area
	 * @sample {highmaps} maps/plotoptions/mapbubble-allowpointselect/
	 *         Map bubble
	 * @apioption plotOptions.series.cursor
	 */


	/**
	 * A name for the dash style to use for the graph, or for some series types
	 * the outline of each shape. The value for the `dashStyle` include:
	 * 
	 * *   Solid
	 * *   ShortDash
	 * *   ShortDot
	 * *   ShortDashDot
	 * *   ShortDashDotDot
	 * *   Dot
	 * *   Dash
	 * *   LongDash
	 * *   DashDot
	 * *   LongDashDot
	 * *   LongDashDotDot
	 * 
	 * @validvalue ["Solid", "ShortDash", "ShortDot", "ShortDashDot",
	 *             "ShortDashDotDot", "Dot", "Dash" ,"LongDash", "DashDot",
	 *             "LongDashDot", "LongDashDotDot"]
	 * @type {String}
	 * @see In styled mode, the [stroke dash-array](http://jsfiddle.net/gh/get/
	 * library/pure/highcharts/highcharts/tree/master/samples/highcharts/css/
	 * series-dashstyle/) can be set with the same classes as listed under
	 * [series.color](#plotOptions.series.color).
	 * 
	 * @sample {highcharts} highcharts/plotoptions/series-dashstyle-all/
	 *         Possible values demonstrated
	 * @sample {highcharts} highcharts/plotoptions/series-dashstyle/
	 *         Chart suitable for printing in black and white
	 * @sample {highstock} highcharts/plotoptions/series-dashstyle-all/
	 *         Possible values demonstrated
	 * @sample {highmaps} highcharts/plotoptions/series-dashstyle-all/
	 *         Possible values demonstrated
	 * @sample {highmaps} maps/plotoptions/series-dashstyle/
	 *         Dotted borders on a map
	 * @default Solid
	 * @since 2.1
	 * @apioption plotOptions.series.dashStyle
	 */
		
	/**
	 * Requires the Accessibility module.
	 * 
	 * A description of the series to add to the screen reader information
	 * about the series.
	 * 
	 * @type {String}
	 * @default undefined
	 * @since 5.0.0
	 * @apioption plotOptions.series.description
	 */
	




	/**
	 * Enable or disable the mouse tracking for a specific series. This
	 * includes point tooltips and click events on graphs and points. For
	 * large datasets it improves performance.
	 * 
	 * @type {Boolean}
	 * @sample {highcharts}
	 *         highcharts/plotoptions/series-enablemousetracking-false/
	 *         No mouse tracking
	 * @sample {highmaps}
	 *         maps/plotoptions/series-enablemousetracking-false/
	 *         No mouse tracking
	 * @default true
	 * @apioption plotOptions.series.enableMouseTracking
	 */

	/**
	 * By default, series are exposed to screen readers as regions. By enabling
	 * this option, the series element itself will be exposed in the same
	 * way as the data points. This is useful if the series is not used
	 * as a grouping entity in the chart, but you still want to attach a
	 * description to the series.
	 * 
	 * Requires the Accessibility module.
	 * 
	 * @type {Boolean}
	 * @sample highcharts/accessibility/art-grants/
	 *         Accessible data visualization
	 * @default undefined
	 * @since 5.0.12
	 * @apioption plotOptions.series.exposeElementToA11y
	 */

	/**
	 * Whether to use the Y extremes of the total chart width or only the
	 * zoomed area when zooming in on parts of the X axis. By default, the
	 * Y axis adjusts to the min and max of the visible data. Cartesian
	 * series only.
	 * 
	 * @type {Boolean}
	 * @default false
	 * @since 4.1.6
	 * @product highcharts highstock
	 * @apioption plotOptions.series.getExtremesFromAll
	 */
	
	/**
	 * An id for the series. This can be used after render time to get a
	 * pointer to the series object through `chart.get()`.
	 * 
	 * @type {String}
	 * @sample {highcharts} highcharts/plotoptions/series-id/ Get series by id
	 * @since 1.2.0
	 * @apioption series.id
	 */

	/**
	 * The index of the series in the chart, affecting the internal index
	 * in the `chart.series` array, the visible Z index as well as the order
	 * in the legend.
	 * 
	 * @type {Number}
	 * @default undefined
	 * @since 2.3.0
	 * @apioption series.index
	 */

	/**
	 * An array specifying which option maps to which key in the data point
	 * array. This makes it convenient to work with unstructured data arrays
	 * from different sources.
	 * 
	 * @type {Array<String>}
	 * @see [series.data](#series.line.data)
	 * @sample {highcharts|highstock} highcharts/series/data-keys/
	 *         An extended data array with keys
	 * @since 4.1.6
	 * @product highcharts highstock
	 * @apioption plotOptions.series.keys
	 */
	
	/**
	 * The sequential index of the series in the legend.
	 * 
	 * @sample {highcharts|highstock} highcharts/series/legendindex/
	 *         Legend in opposite order
	 * @type {Number}
	 * @see [legend.reversed](#legend.reversed), [yAxis.reversedStacks](#yAxis.
	 * reversedStacks)
	 * @apioption series.legendIndex
	 */

	/**
	 * The line cap used for line ends and line joins on the graph.
	 * 
	 * @validvalue ["round", "square"]
	 * @type {String}
	 * @default round
	 * @product highcharts highstock
	 * @apioption plotOptions.series.linecap
	 */

	/**
	 * The [id](#series.id) of another series to link to. Additionally,
	 * the value can be ":previous" to link to the previous series. When
	 * two series are linked, only the first one appears in the legend.
	 * Toggling the visibility of this also toggles the linked series.
	 * 
	 * @type {String}
	 * @sample {highcharts} highcharts/demo/arearange-line/ Linked series
	 * @sample {highstock} highcharts/demo/arearange-line/ Linked series
	 * @since 3.0
	 * @product highcharts highstock
	 * @apioption plotOptions.series.linkedTo
	 */
	
	/**
	 * The name of the series as shown in the legend, tooltip etc.
	 * 
	 * @type {String}
	 * @sample {highcharts} highcharts/series/name/ Series name
	 * @sample {highmaps} maps/demo/category-map/ Series name
	 * @apioption series.name
	 */

	/**
	 * The color for the parts of the graph or points that are below the
	 * [threshold](#plotOptions.series.threshold).
	 * 
	 * @type {Color}
	 * @see In styled mode, a negative color is applied by setting this
	 * option to `true` combined with the `.highcharts-negative` class name.
	 * 
	 * @sample {highcharts} highcharts/plotoptions/series-negative-color/
	 *         Spline, area and column
	 * @sample {highcharts} highcharts/plotoptions/arearange-negativecolor/
	 *         Arearange
	 * @sample {highcharts} highcharts/css/series-negative-color/
	 *         Styled mode
	 * @sample {highstock} highcharts/plotoptions/series-negative-color/
	 *         Spline, area and column
	 * @sample {highstock} highcharts/plotoptions/arearange-negativecolor/
	 *         Arearange
	 * @sample {highmaps} highcharts/plotoptions/series-negative-color/
	 *         Spline, area and column
	 * @sample {highmaps} highcharts/plotoptions/arearange-negativecolor/
	 *         Arearange
	 * @default null
	 * @since 3.0
	 * @apioption plotOptions.series.negativeColor
	 */

	/**
	 * Same as [accessibility.pointDescriptionFormatter](#accessibility.
	 * pointDescriptionFormatter), but for an individual series. Overrides
	 * the chart wide configuration.
	 * 
	 * @type {Function}
	 * @since 5.0.12
	 * @apioption plotOptions.series.pointDescriptionFormatter
	 */

	/**
	 * If no x values are given for the points in a series, `pointInterval`
	 * defines the interval of the x values. For example, if a series contains
	 * one value every decade starting from year 0, set `pointInterval` to
	 * `10`. In true `datetime` axes, the `pointInterval` is set in
	 * milliseconds.
	 * 
	 * It can be also be combined with `pointIntervalUnit` to draw irregular
	 * time intervals.
	 * 
	 * @type {Number}
	 * @sample {highcharts} highcharts/plotoptions/series-pointstart-datetime/
	 *         Datetime X axis
	 * @sample {highstock} stock/plotoptions/pointinterval-pointstart/
	 *         Using pointStart and pointInterval
	 * @default 1
	 * @product highcharts highstock
	 * @apioption plotOptions.series.pointInterval
	 */

	/**
	 * On datetime series, this allows for setting the
	 * [pointInterval](#plotOptions.series.pointInterval) to irregular time 
	 * units, `day`, `month` and `year`. A day is usually the same as 24 hours,
	 * but `pointIntervalUnit` also takes the DST crossover into consideration
	 * when dealing with local time. Combine this option with `pointInterval`
	 * to draw weeks, quarters, 6 months, 10 years etc.
	 * 
	 * @validvalue [null, "day", "month", "year"]
	 * @type {String}
	 * @sample {highcharts} highcharts/plotoptions/series-pointintervalunit/
	 *         One point a month
	 * @sample {highstock} highcharts/plotoptions/series-pointintervalunit/
	 *         One point a month
	 * @since 4.1.0
	 * @product highcharts highstock
	 * @apioption plotOptions.series.pointIntervalUnit
	 */

	/**
	 * Possible values: `null`, `"on"`, `"between"`.
	 * 
	 * In a column chart, when pointPlacement is `"on"`, the point will
	 * not create any padding of the X axis. In a polar column chart this
	 * means that the first column points directly north. If the pointPlacement
	 * is `"between"`, the columns will be laid out between ticks. This
	 * is useful for example for visualising an amount between two points
	 * in time or in a certain sector of a polar chart.
	 * 
	 * Since Highcharts 3.0.2, the point placement can also be numeric,
	 * where 0 is on the axis value, -0.5 is between this value and the
	 * previous, and 0.5 is between this value and the next. Unlike the
	 * textual options, numeric point placement options won't affect axis
	 * padding.
	 * 
	 * Note that pointPlacement needs a [pointRange](#plotOptions.series.
	 * pointRange) to work. For column series this is computed, but for
	 * line-type series it needs to be set.
	 * 
	 * Defaults to `null` in cartesian charts, `"between"` in polar charts.
	 * 
	 * @validvalue [null, "on", "between"]
	 * @type {String|Number}
	 * @see [xAxis.tickmarkPlacement](#xAxis.tickmarkPlacement)
	 * @sample {highcharts|highstock}
	 *         highcharts/plotoptions/series-pointplacement-between/
	 *         Between in a column chart
	 * @sample {highcharts|highstock}
	 *         highcharts/plotoptions/series-pointplacement-numeric/
	 *         Numeric placement for custom layout
	 * @default null
	 * @since 2.3.0
	 * @product highcharts highstock
	 * @apioption plotOptions.series.pointPlacement
	 */

	/**
	 * If no x values are given for the points in a series, pointStart defines
	 * on what value to start. For example, if a series contains one yearly
	 * value starting from 1945, set pointStart to 1945.
	 * 
	 * @type {Number}
	 * @sample {highcharts} highcharts/plotoptions/series-pointstart-linear/
	 *         Linear
	 * @sample {highcharts} highcharts/plotoptions/series-pointstart-datetime/
	 *         Datetime
	 * @sample {highstock} stock/plotoptions/pointinterval-pointstart/
	 *         Using pointStart and pointInterval
	 * @default 0
	 * @product highcharts highstock
	 * @apioption plotOptions.series.pointStart
	 */

	/**
	 * Whether to select the series initially. If `showCheckbox` is true,
	 * the checkbox next to the series name in the legend will be checked for a
	 * selected series.
	 * 
	 * @type {Boolean}
	 * @sample {highcharts} highcharts/plotoptions/series-selected/
	 *         One out of two series selected
	 * @default false
	 * @since 1.2.0
	 * @apioption plotOptions.series.selected
	 */

	/**
	 * Whether to apply a drop shadow to the graph line. Since 2.3 the shadow
	 * can be an object configuration containing `color`, `offsetX`, `offsetY`,
	 *  `opacity` and `width`.
	 * 
	 * @type {Boolean|Object}
	 * @sample {highcharts} highcharts/plotoptions/series-shadow/ Shadow enabled
	 * @default false
	 * @apioption plotOptions.series.shadow
	 */

	/**
	 * Whether to display this particular series or series type in the legend.
	 * The default value is `true` for standalone series, `false` for linked
	 * series.
	 * 
	 * @type {Boolean}
	 * @sample {highcharts} highcharts/plotoptions/series-showinlegend/
	 *         One series in the legend, one hidden
	 * @default true
	 * @apioption plotOptions.series.showInLegend
	 */

	/**
	 * If set to `True`, the accessibility module will skip past the points
	 * in this series for keyboard navigation.
	 * 
	 * @type {Boolean}
	 * @since 5.0.12
	 * @apioption plotOptions.series.skipKeyboardNavigation
	 */
	
	/**
	 * This option allows grouping series in a stacked chart. The stack
	 * option can be a string or a number or anything else, as long as the
	 * grouped series' stack options match each other.
	 * 
	 * @type {String}
	 * @sample {highcharts} highcharts/series/stack/ Stacked and grouped columns
	 * @default null
	 * @since 2.1
	 * @product highcharts highstock
	 * @apioption series.stack
	 */

	/**
	 * Whether to stack the values of each series on top of each other.
	 * Possible values are `null` to disable, `"normal"` to stack by value or
	 * `"percent"`. When stacking is enabled, data must be sorted in ascending
	 * X order. A special stacking option is with the streamgraph series type,
	 * where the stacking option is set to `"stream"`.
	 * 
	 * @validvalue [null, "normal", "percent"]
	 * @type {String}
	 * @see [yAxis.reversedStacks](#yAxis.reversedStacks)
	 * @sample {highcharts} highcharts/plotoptions/series-stacking-line/
	 *         Line
	 * @sample {highcharts} highcharts/plotoptions/series-stacking-column/
	 *         Column
	 * @sample {highcharts} highcharts/plotoptions/series-stacking-bar/
	 *         Bar
	 * @sample {highcharts} highcharts/plotoptions/series-stacking-area/
	 *         Area
	 * @sample {highcharts} highcharts/plotoptions/series-stacking-percent-line/
	 *         Line
	 * @sample {highcharts}
	 *         highcharts/plotoptions/series-stacking-percent-column/
	 *         Column
	 * @sample {highcharts} highcharts/plotoptions/series-stacking-percent-bar/
	 *         Bar
	 * @sample {highcharts} highcharts/plotoptions/series-stacking-percent-area/
	 *         Area
	 * @sample {highstock} stock/plotoptions/stacking/
	 *         Area
	 * @default null
	 * @product highcharts highstock
	 * @apioption plotOptions.series.stacking
	 */

	/**
	 * Whether to apply steps to the line. Possible values are `left`, `center`
	 * and `right`.
	 * 
	 * @validvalue [null, "left", "center", "right"]
	 * @type {String}
	 * @sample {highcharts} highcharts/plotoptions/line-step/
	 *         Different step line options
	 * @sample {highcharts} highcharts/plotoptions/area-step/
	 *         Stepped, stacked area
	 * @sample {highstock} stock/plotoptions/line-step/
	 *         Step line
	 * @default {highcharts} null
	 * @default {highstock} false
	 * @since 1.2.5
	 * @product highcharts highstock
	 * @apioption plotOptions.series.step
	 */

	/**
	 * The threshold, also called zero level or base level. For line type
	 * series this is only used in conjunction with
	 * [negativeColor](#plotOptions.series.negativeColor).
	 * 
	 * @type {Number}
	 * @see [softThreshold](#plotOptions.series.softThreshold).
	 * @default 0
	 * @since 3.0
	 * @product highcharts highstock
	 * @apioption plotOptions.series.threshold
	 */
	
	/**
	 * The type of series, for example `line` or `column`. By default, the
	 * series type is inherited from [chart.type](#chart.type), so unless the
	 * chart is a combination of series types, there is no need to set it on the
	 * series level.
	 * 
	 * @validvalue [null, "line", "spline", "column", "area", "areaspline",
	 *       "pie", "arearange", "areasplinerange", "boxplot", "bubble",
	 *       "columnrange", "errorbar", "funnel", "gauge", "scatter",
	 *       "waterfall"]
	 * @type {String}
	 * @sample {highcharts} highcharts/series/type/
	 *         Line and column in the same chart
	 * @sample {highmaps} maps/demo/mapline-mappoint/
	 *         Multiple types in the same map
	 * @apioption series.type
	 */

	/**
	 * Set the initial visibility of the series.
	 * 
	 * @type {Boolean}
	 * @sample {highcharts} highcharts/plotoptions/series-visible/
	 *         Two series, one hidden and one visible
	 * @sample {highstock} stock/plotoptions/series-visibility/
	 *         Hidden series
	 * @default true
	 * @apioption plotOptions.series.visible
	 */

	/**
	 * When using dual or multiple x axes, this number defines which xAxis
	 * the particular series is connected to. It refers to either the [axis
	 * id](#xAxis.id) or the index of the axis in the xAxis array, with
	 * 0 being the first.
	 * 
	 * @type {Number|String}
	 * @default 0
	 * @product highcharts highstock
	 * @apioption series.xAxis
	 */

	/**
	 * When using dual or multiple y axes, this number defines which yAxis
	 * the particular series is connected to. It refers to either the [axis
	 * id](#yAxis.id) or the index of the axis in the yAxis array, with
	 * 0 being the first.
	 * 
	 * @type {Number|String}
	 * @sample {highcharts} highcharts/series/yaxis/
	 *         Apply the column series to the secondary Y axis
	 * @default 0
	 * @product highcharts highstock
	 * @apioption series.yAxis
	 */

	/**
	 * Defines the Axis on which the zones are applied.
	 * 
	 * @type {String}
	 * @see [zones](#plotOptions.series.zones)
	 * @sample {highcharts} highcharts/series/color-zones-zoneaxis-x/
	 *         Zones on the X-Axis
	 * @sample {highstock} highcharts/series/color-zones-zoneaxis-x/
	 *         Zones on the X-Axis
	 * @default y
	 * @since 4.1.0
	 * @product highcharts highstock
	 * @apioption plotOptions.series.zoneAxis
	 */
	
	/**
	 * Define the visual z index of the series.
	 * 
	 * @type {Number}
	 * @sample {highcharts} highcharts/plotoptions/series-zindex-default/
	 *         With no z index, the series defined last are on top
	 * @sample {highcharts} highcharts/plotoptions/series-zindex/
	 *         With a z index, the series with the highest z index is on top
	 * @sample {highstock} highcharts/plotoptions/series-zindex-default/
	 *         With no z index, the series defined last are on top
	 * @sample {highstock} highcharts/plotoptions/series-zindex/
	 *         With a z index, the series with the highest z index is on top
	 * @product highcharts highstock
	 * @apioption series.zIndex
	 */

	/**
	 * General event handlers for the series items. These event hooks can also
	 * be attached to the series at run time using the `Highcharts.addEvent`
	 * function.
	 */
	events: {

		/**
		 * Fires after the series has finished its initial animation, or in
		 * case animation is disabled, immediately as the series is displayed.
		 * 
		 * @type {Function}
		 * @context Series
		 * @sample {highcharts}
		 *         highcharts/plotoptions/series-events-afteranimate/
		 *         Show label after animate
		 * @sample {highstock}
		 *         highcharts/plotoptions/series-events-afteranimate/
		 *         Show label after animate
		 * @since 4.0
		 * @product highcharts highstock
		 * @apioption plotOptions.series.events.afterAnimate
		 */

		/**
		 * Fires when the checkbox next to the series' name in the legend is
		 * clicked. One parameter, `event`, is passed to the function. The state
		 * of the checkbox is found by `event.checked`. The checked item is
		 * found by `event.item`. Return `false` to prevent the default action
		 * which is to toggle the select state of the series.
		 * 
		 * @type {Function}
		 * @context Series
		 * @sample {highcharts}
		 *         highcharts/plotoptions/series-events-checkboxclick/
		 *         Alert checkbox status
		 * @since 1.2.0
		 * @apioption plotOptions.series.events.checkboxClick
		 */

		/**
		 * Fires when the series is clicked. One parameter, `event`, is passed
		 * to the function, containing common event information. Additionally,
		 * `event.point` holds a pointer to the nearest point on the graph.
		 * 
		 * @type {Function}
		 * @context Series
		 * @sample {highcharts} highcharts/plotoptions/series-events-click/
		 *         Alert click info
		 * @sample {highstock} stock/plotoptions/series-events-click/
		 *         Alert click info
		 * @sample {highmaps} maps/plotoptions/series-events-click/
		 *         Display click info in subtitle
		 * @apioption plotOptions.series.events.click
		 */

		/**
		 * Fires when the series is hidden after chart generation time, either
		 * by clicking the legend item or by calling `.hide()`.
		 * 
		 * @type {Function}
		 * @context Series
		 * @sample {highcharts} highcharts/plotoptions/series-events-hide/
		 *         Alert when the series is hidden by clicking the legend item
		 * @since 1.2.0
		 * @apioption plotOptions.series.events.hide
		 */

		/**
		 * Fires when the legend item belonging to the series is clicked. One
		 * parameter, `event`, is passed to the function. The default action
		 * is to toggle the visibility of the series. This can be prevented
		 * by returning `false` or calling `event.preventDefault()`.
		 * 
		 * @type {Function}
		 * @context Series
		 * @sample {highcharts}
		 *         highcharts/plotoptions/series-events-legenditemclick/
		 *         Confirm hiding and showing
		 * @apioption plotOptions.series.events.legendItemClick
		 */

		/**
		 * Fires when the mouse leaves the graph. One parameter, `event`, is
		 * passed to the function, containing common event information. If the
		 * [stickyTracking](#plotOptions.series) option is true, `mouseOut`
		 * doesn't happen before the mouse enters another graph or leaves the
		 * plot area.
		 * 
		 * @type {Function}
		 * @context Series
		 * @sample {highcharts}
		 *         highcharts/plotoptions/series-events-mouseover-sticky/
		 *         With sticky tracking    by default
		 * @sample {highcharts}
		 *         highcharts/plotoptions/series-events-mouseover-no-sticky/
		 *         Without sticky tracking
		 * @apioption plotOptions.series.events.mouseOut
		 */

		/**
		 * Fires when the mouse enters the graph. One parameter, `event`, is
		 * passed to the function, containing common event information.
		 * 
		 * @type {Function}
		 * @context Series
		 * @sample {highcharts}
		 *         highcharts/plotoptions/series-events-mouseover-sticky/
		 *         With sticky tracking by default
		 * @sample {highcharts}
		 *         highcharts/plotoptions/series-events-mouseover-no-sticky/
		 *         Without sticky tracking
		 * @apioption plotOptions.series.events.mouseOver
		 */

		/**
		 * Fires when the series is shown after chart generation time, either
		 * by clicking the legend item or by calling `.show()`.
		 * 
		 * @type {Function}
		 * @context Series
		 * @sample {highcharts} highcharts/plotoptions/series-events-show/
		 *         Alert when the series is shown by clicking the legend item.
		 * @since 1.2.0
		 * @apioption plotOptions.series.events.show
		 */

	},



	/**
	 * Options for the point markers of line-like series. Properties like
	 * `fillColor`, `lineColor` and `lineWidth` define the visual appearance
	 * of the markers. Other series types, like column series, don't have
	 * markers, but have visual options on the series level instead.
	 * 
	 * In styled mode, the markers can be styled with the `.highcharts-point`,
	 * `.highcharts-point-hover` and `.highcharts-point-select`
	 * class names.
	 * 
	 * @product highcharts highstock
	 */
	marker: {
		


		/**
		 * The width of the point marker's outline.
		 * 
		 * @type {Number}
		 * @sample {highcharts} highcharts/plotoptions/series-marker-fillcolor/
		 *         2px blue marker
		 * @default 0
		 * @product highcharts highstock
		 */
		lineWidth: 0,


		/**
		 * The color of the point marker's outline. When `null`, the series'
		 * or point's color is used.
		 * 
		 * @type {Color}
		 * @sample {highcharts} highcharts/plotoptions/series-marker-fillcolor/
		 *         Inherit from series color (null)
		 * @product highcharts highstock
		 */
		lineColor: '#ffffff',
		
		/**
		 * The fill color of the point marker. When `null`, the series' or
		 * point's color is used.
		 * 
		 * @type {Color}
		 * @sample {highcharts} highcharts/plotoptions/series-marker-fillcolor/
		 *         White fill
		 * @default null
		 * @product highcharts highstock
		 * @apioption plotOptions.series.marker.fillColor
		 */
		
		
		
		/**
		 * Enable or disable the point marker. If `null`, the markers are hidden
		 * when the data is dense, and shown for more widespread data points.
		 * 
		 * @type {Boolean}
		 * @sample {highcharts} highcharts/plotoptions/series-marker-enabled/
		 *         Disabled markers
		 * @sample {highcharts}
		 *         highcharts/plotoptions/series-marker-enabled-false/
		 *         Disabled in normal state but enabled on hover
		 * @sample {highstock} stock/plotoptions/series-marker/
		 *         Enabled markers
		 * @default {highcharts} null
		 * @default {highstock} false
		 * @product highcharts highstock
		 * @apioption plotOptions.series.marker.enabled
		 */
		
		/**
		 * Image markers only. Set the image width explicitly. When using this
		 * option, a `width` must also be set.
		 * 
		 * @type {Number}
		 * @sample {highcharts}
		 *         highcharts/plotoptions/series-marker-width-height/
		 *         Fixed width and height
		 * @sample {highstock}
		 *         highcharts/plotoptions/series-marker-width-height/
		 *         Fixed width and height
		 * @default null
		 * @since 4.0.4
		 * @product highcharts highstock
		 * @apioption plotOptions.series.marker.height
		 */

		/**
		 * A predefined shape or symbol for the marker. When null, the symbol
		 * is pulled from options.symbols. Other possible values are "circle",
		 * "square", "diamond", "triangle" and "triangle-down".
		 * 
		 * Additionally, the URL to a graphic can be given on this form:
		 * "url(graphic.png)". Note that for the image to be applied to exported
		 * charts, its URL needs to be accessible by the export server.
		 * 
		 * Custom callbacks for symbol path generation can also be added to
		 * `Highcharts.SVGRenderer.prototype.symbols`. The callback is then
		 * used by its method name, as shown in the demo.
		 * 
		 * @validvalue [null, "circle", "square", "diamond", "triangle",
		 *         "triangle-down"]
		 * @type {String}
		 * @sample {highcharts} highcharts/plotoptions/series-marker-symbol/
		 *         Predefined, graphic and custom markers
		 * @sample {highstock} highcharts/plotoptions/series-marker-symbol/
		 *         Predefined, graphic and custom markers
		 * @default null
		 * @product highcharts highstock
		 * @apioption plotOptions.series.marker.symbol
		 */

		/**
		 * The radius of the point marker.
		 * 
		 * @type {Number}
		 * @sample {highcharts} highcharts/plotoptions/series-marker-radius/
		 *         Bigger markers
		 * @default 4
		 * @product highcharts highstock
		 */
		radius: 4,

		/**
		 * Image markers only. Set the image width explicitly. When using this
		 * option, a `height` must also be set.
		 * 
		 * @type {Number}
		 * @sample {highcharts}
		 *         highcharts/plotoptions/series-marker-width-height/
		 *         Fixed width and height
		 * @sample {highstock}
		 *         highcharts/plotoptions/series-marker-width-height/
		 *         Fixed width and height
		 * @default null
		 * @since 4.0.4
		 * @product highcharts highstock
		 * @apioption plotOptions.series.marker.width
		 */


		/**
		 * States for a single point marker.
		 * @product highcharts highstock
		 */
		states: {
			/**
			 * The hover state for a single point marker.
			 * @product highcharts highstock
			 */
			hover: {

				/**
				 * Animation when hovering over the marker.
				 * @type {Boolean|Object}
				 */
				animation: {
					duration: 50
				},

				/**
				 * Enable or disable the point marker.
				 * 
				 * @type {Boolean}
				 * @sample {highcharts}
				 *         highcharts/plotoptions/series-marker-states-hover-enabled/
				 *         Disabled hover state
				 * @default true
				 * @product highcharts highstock
				 */
				enabled: true,

				/**
				 * The fill color of the marker in hover state.
				 * 
				 * @type {Color}
				 * @default null
				 * @product highcharts highstock
				 * @apioption plotOptions.series.marker.states.hover.fillColor
				 */

				/**
				 * The color of the point marker's outline. When `null`, the
				 * series' or point's color is used.
				 * 
				 * @type {Color}
				 * @sample {highcharts}
				 *         highcharts/plotoptions/series-marker-states-hover-linecolor/
				 *         White fill color, black line color
				 * @default #ffffff
				 * @product highcharts highstock
				 * @apioption plotOptions.series.marker.states.hover.lineColor
				 */

				/**
				 * The width of the point marker's outline.
				 * 
				 * @type {Number}
				 * @sample {highcharts}
				 *         highcharts/plotoptions/series-marker-states-hover-linewidth/
				 *         3px line width
				 * @default 0
				 * @product highcharts highstock
				 * @apioption plotOptions.series.marker.states.hover.lineWidth
				 */

				/**
				 * The radius of the point marker. In hover state, it defaults to the
				 * normal state's radius + 2 as per the [radiusPlus](#plotOptions.series.
				 * marker.states.hover.radiusPlus) option.
				 * 
				 * @type {Number}
				 * @sample {highcharts} highcharts/plotoptions/series-marker-states-hover-radius/ 10px radius
				 * @product highcharts highstock
				 * @apioption plotOptions.series.marker.states.hover.radius
				 */
				
				/**
				 * The number of pixels to increase the radius of the hovered point.
				 * 
				 * @type {Number}
				 * @sample {highcharts} highcharts/plotoptions/series-states-hover-linewidthplus/ 5 pixels greater radius on hover
				 * @sample {highstock} highcharts/plotoptions/series-states-hover-linewidthplus/ 5 pixels greater radius on hover
				 * @default 2
				 * @since 4.0.3
				 * @product highcharts highstock
				 */
				radiusPlus: 2,

				

				/**
				 * The additional line width for a hovered point.
				 * 
				 * @type {Number}
				 * @sample {highcharts} highcharts/plotoptions/series-states-hover-linewidthplus/ 2 pixels wider on hover
				 * @sample {highstock} highcharts/plotoptions/series-states-hover-linewidthplus/ 2 pixels wider on hover
				 * @default 1
				 * @since 4.0.3
				 * @product highcharts highstock
				 */
				lineWidthPlus: 1
				
			},
			



			/**
			 * The appearance of the point marker when selected. In order to
			 * allow a point to be selected, set the `series.allowPointSelect`
			 * option to true.
			 * 
			 * @product highcharts highstock
			 */
			select: {

				/**
				 * Enable or disable visible feedback for selection.
				 * 
				 * @type {Boolean}
				 * @sample {highcharts} highcharts/plotoptions/series-marker-states-select-enabled/
				 *         Disabled select state
				 * @default true
				 * @product highcharts highstock
				 * @apioption plotOptions.series.marker.states.select.enabled
				 */

				/**
				 * The fill color of the point marker.
				 * 
				 * @type {Color}
				 * @sample {highcharts} highcharts/plotoptions/series-marker-states-select-fillcolor/
				 *         Solid red discs for selected points
				 * @default null
				 * @product highcharts highstock
				 */
				fillColor: '#cccccc',



				/**
				 * The color of the point marker's outline. When `null`, the series'
				 * or point's color is used.
				 * 
				 * @type {Color}
				 * @sample {highcharts} highcharts/plotoptions/series-marker-states-select-linecolor/
				 *         Red line color for selected points
				 * @default #000000
				 * @product highcharts highstock
				 */
				lineColor: '#000000',



				/**
				 * The width of the point marker's outline.
				 * 
				 * @type {Number}
				 * @sample {highcharts} highcharts/plotoptions/series-marker-states-select-linewidth/
				 *         3px line width for selected points
				 * @default 0
				 * @product highcharts highstock
				 */
				lineWidth: 2

				/**
				 * The radius of the point marker. In hover state, it defaults to the
				 * normal state's radius + 2.
				 * 
				 * @type {Number}
				 * @sample {highcharts} highcharts/plotoptions/series-marker-states-select-radius/
				 *         10px radius for selected points
				 * @product highcharts highstock
				 * @apioption plotOptions.series.marker.states.select.radius
				 */

			}
			
		}
	},



	/**
	 * Properties for each single point.
	 */
	point: {


		/**
		 * Events for each single point.
		 */
		events: {

			/**
			 * Fires when a point is clicked. One parameter, `event`, is passed
			 * to the function, containing common event information.
			 * 
			 * If the `series.allowPointSelect` option is true, the default action
			 * for the point's click event is to toggle the point's select state.
			 *  Returning `false` cancels this action.
			 * 
			 * @type {Function}
			 * @context Point
			 * @sample {highcharts} highcharts/plotoptions/series-point-events-click/ Click marker to alert values
			 * @sample {highcharts} highcharts/plotoptions/series-point-events-click-column/ Click column
			 * @sample {highcharts} highcharts/plotoptions/series-point-events-click-url/ Go to URL
			 * @sample {highmaps} maps/plotoptions/series-point-events-click/ Click marker to display values
			 * @sample {highmaps} maps/plotoptions/series-point-events-click-url/ Go to URL
			 * @apioption plotOptions.series.point.events.click
			 */

			/**
			 * Fires when the mouse leaves the area close to the point. One parameter,
			 * `event`, is passed to the function, containing common event information.
			 * 
			 * @type {Function}
			 * @context Point
			 * @sample {highcharts} highcharts/plotoptions/series-point-events-mouseover/ Show values in the chart's corner on mouse over
			 * @apioption plotOptions.series.point.events.mouseOut
			 */

			/**
			 * Fires when the mouse enters the area close to the point. One parameter,
			 * `event`, is passed to the function, containing common event information.
			 * 
			 * @type {Function}
			 * @context Point
			 * @sample {highcharts} highcharts/plotoptions/series-point-events-mouseover/ Show values in the chart's corner on mouse over
			 * @apioption plotOptions.series.point.events.mouseOver
			 */

			/**
			 * Fires when the point is removed using the `.remove()` method. One
			 * parameter, `event`, is passed to the function. Returning `false`
			 * cancels the operation.
			 * 
			 * @type {Function}
			 * @context Point
			 * @sample {highcharts} highcharts/plotoptions/series-point-events-remove/ Remove point and confirm
			 * @since 1.2.0
			 * @apioption plotOptions.series.point.events.remove
			 */

			/**
			 * Fires when the point is selected either programmatically or following
			 * a click on the point. One parameter, `event`, is passed to the function.
			 *  Returning `false` cancels the operation.
			 * 
			 * @type {Function}
			 * @context Point
			 * @sample {highcharts} highcharts/plotoptions/series-point-events-select/ Report the last selected point
			 * @sample {highmaps} maps/plotoptions/series-allowpointselect/ Report select and unselect
			 * @since 1.2.0
			 * @apioption plotOptions.series.point.events.select
			 */

			/**
			 * Fires when the point is unselected either programmatically or following
			 * a click on the point. One parameter, `event`, is passed to the function.
			 *  Returning `false` cancels the operation.
			 * 
			 * @type {Function}
			 * @context Point
			 * @sample {highcharts} highcharts/plotoptions/series-point-events-unselect/ Report the last unselected point
			 * @sample {highmaps} maps/plotoptions/series-allowpointselect/ Report select and unselect
			 * @since 1.2.0
			 * @apioption plotOptions.series.point.events.unselect
			 */

			/**
			 * Fires when the point is updated programmatically through the `.update()`
			 * method. One parameter, `event`, is passed to the function. The new
			 * point options can be accessed through `event.options`. Returning
			 * `false` cancels the operation.
			 * 
			 * @type {Function}
			 * @context Point
			 * @sample {highcharts} highcharts/plotoptions/series-point-events-update/ Confirm point updating
			 * @since 1.2.0
			 * @apioption plotOptions.series.point.events.update
			 */

		}
	},



	/**
	 * Options for the series data labels, appearing next to each data
	 * point.
	 * 
	 * In styled mode, the data labels can be styled wtih the `.highcharts-data-label-box` and `.highcharts-data-label` class names ([see example](http://jsfiddle.
	 * net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/css/series-
	 * datalabels)).
	 */
	dataLabels: {


		/**
		 * The alignment of the data label compared to the point. If `right`,
		 * the right side of the label should be touching the point. For
		 * points with an extent, like columns, the alignments also dictates
		 * how to align it inside the box, as given with the [inside](#plotOptions.
		 * column.dataLabels.inside) option. Can be one of "left", "center"
		 * or "right".
		 * 
		 * @validvalue ["left", "center", "right"]
		 * @type {String}
		 * @sample {highcharts} highcharts/plotoptions/series-datalabels-align-left/ Left aligned
		 * @default center
		 */
		align: 'center',
		

		/**
		 * Whether to allow data labels to overlap. To make the labels less
		 * sensitive for overlapping, the [dataLabels.padding](#plotOptions.
		 * series.dataLabels.padding) can be set to 0.
		 * 
		 * @type {Boolean}
		 * @sample {highcharts} highcharts/plotoptions/series-datalabels-allowoverlap-false/ Don't allow overlap
		 * @sample {highstock} highcharts/plotoptions/series-datalabels-allowoverlap-false/ Don't allow overlap
		 * @sample {highmaps} highcharts/plotoptions/series-datalabels-allowoverlap-false/ Don't allow overlap
		 * @default false
		 * @since 4.1.0
		 * @apioption plotOptions.series.dataLabels.allowOverlap
		 */		


		/**
		 * The border radius in pixels for the data label.
		 * 
		 * @type {Number}
		 * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/ Data labels box options
		 * @sample {highstock} highcharts/plotoptions/series-datalabels-box/ Data labels box options
		 * @sample {highmaps} maps/plotoptions/series-datalabels-box/ Data labels box options
		 * @default 0
		 * @since 2.2.1
		 * @apioption plotOptions.series.dataLabels.borderRadius
		 */
		

		/**
		 * The border width in pixels for the data label.
		 * 
		 * @type {Number}
		 * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/ Data labels box options
		 * @sample {highstock} highcharts/plotoptions/series-datalabels-box/ Data labels box options
		 * @default 0
		 * @since 2.2.1
		 * @apioption plotOptions.series.dataLabels.borderWidth
		 */
		
		/**
		 * A class name for the data label. Particularly in styled mode, this can
		 * be used to give each series' or point's data label unique styling.
		 * In addition to this option, a default color class name is added
		 * so that we can give the labels a [contrast text shadow](http://jsfiddle.
		 * net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/css/data-
		 * label-contrast/).
		 * 
		 * @type {String}
		 * @sample {highcharts} highcharts/css/series-datalabels/ Styling by CSS
		 * @sample {highstock} highcharts/css/series-datalabels/ Styling by CSS
		 * @sample {highmaps} highcharts/css/series-datalabels/ Styling by CSS
		 * @since 5.0.0
		 * @apioption plotOptions.series.dataLabels.className
		 */
		
		/**
		 * The text color for the data labels. Defaults to `null`. For certain series
		 * types, like column or map, the data labels can be drawn inside the points.
		 * In this case the data label will be drawn with maximum contrast by default.
		 * Additionally, it will be given a `text-outline` style with the opposite
		 * color, to further increase the contrast. This can be overridden by setting
		 * the `text-outline` style to `none` in the `dataLabels.style` option.
		 * 
		 * @type {Color}
		 * @sample {highcharts} highcharts/plotoptions/series-datalabels-color/
		 *         Red data labels
		 * @sample {highmaps} maps/demo/color-axis/
		 *         White data labels
		 * @apioption plotOptions.series.dataLabels.color
		 */
		
		/**
		 * Whether to hide data labels that are outside the plot area. By default,
		 * the data label is moved inside the plot area according to the [overflow](#plotOptions.
		 * series.dataLabels.overflow) option.
		 * 
		 * @type {Boolean}
		 * @default true
		 * @since 2.3.3
		 * @apioption plotOptions.series.dataLabels.crop
		 */

		/**
		 * Whether to defer displaying the data labels until the initial series
		 * animation has finished.
		 * 
		 * @type {Boolean}
		 * @default true
		 * @since 4.0
		 * @product highcharts highstock
		 * @apioption plotOptions.series.dataLabels.defer
		 */
		
		/**
		 * Enable or disable the data labels.
		 * 
		 * @type {Boolean}
		 * @sample {highcharts} highcharts/plotoptions/series-datalabels-enabled/ Data labels enabled
		 * @sample {highmaps} maps/demo/color-axis/ Data labels enabled
		 * @default false
		 * @apioption plotOptions.series.dataLabels.enabled
		 */

		/**
		 * A [format string](http://www.highcharts.com/docs/chart-concepts/labels-
		 * and-string-formatting) for the data label. Available variables are
		 * the same as for `formatter`.
		 * 
		 * @type {String}
		 * @sample {highcharts} highcharts/plotoptions/series-datalabels-format/ Add a unit
		 * @sample {highstock} highcharts/plotoptions/series-datalabels-format/ Add a unit
		 * @sample {highmaps} maps/plotoptions/series-datalabels-format/ Formatted value in the data label
		 * @default {highcharts} {y}
		 * @default {highstock} {y}
		 * @default {highmaps} {point.value}
		 * @since 3.0
		 * @apioption plotOptions.series.dataLabels.format
		 */

		/**
		 * Callback JavaScript function to format the data label. Note that
		 * if a `format` is defined, the format takes precedence and the formatter
		 * is ignored. Available data are:
		 * 
		 * <table>
		 * 
		 * <tbody>
		 * 
		 * <tr>
		 * 
		 * <td>`this.percentage`</td>
		 * 
		 * <td>Stacked series and pies only. The point's percentage of the
		 * total.</td>
		 * 
		 * </tr>
		 * 
		 * <tr>
		 * 
		 * <td>`this.point`</td>
		 * 
		 * <td>The point object. The point name, if defined, is available
		 * through `this.point.name`.</td>
		 * 
		 * </tr>
		 * 
		 * <tr>
		 * 
		 * <td>`this.series`:</td>
		 * 
		 * <td>The series object. The series name is available through `this.
		 * series.name`.</td>
		 * 
		 * </tr>
		 * 
		 * <tr>
		 * 
		 * <td>`this.total`</td>
		 * 
		 * <td>Stacked series only. The total value at this point's x value.
		 * </td>
		 * 
		 * </tr>
		 * 
		 * <tr>
		 * 
		 * <td>`this.x`:</td>
		 * 
		 * <td>The x value.</td>
		 * 
		 * </tr>
		 * 
		 * <tr>
		 * 
		 * <td>`this.y`:</td>
		 * 
		 * <td>The y value.</td>
		 * 
		 * </tr>
		 * 
		 * </tbody>
		 * 
		 * </table>
		 * 
		 * @type {Function}
		 * @sample {highmaps} maps/plotoptions/series-datalabels-format/ Formatted value
		 */
		formatter: function () {
			return this.y === null ? '' : H.numberFormat(this.y, -1);
		},
		


		/**
		 * Styles for the label. The default `color` setting is `"contrast"`,
		 * which is a pseudo color that Highcharts picks up and applies the
		 * maximum contrast to the underlying point item, for example the
		 * bar in a bar chart.
		 * 
		 * The `textOutline` is a pseudo property that
		 * applies an outline of the given width with the given color, which
		 * by default is the maximum contrast to the text. So a bright text
		 * color will result in a black text outline for maximum readability
		 * on a mixed background. In some cases, especially with grayscale
		 * text, the text outline doesn't work well, in which cases it can
		 * be disabled by setting it to `"none"`. When `useHTML` is true, the
		 * `textOutline` will not be picked up. In this, case, the same effect
		 * can be acheived through the `text-shadow` CSS property.
		 * 
		 * @type {CSSObject}
		 * @sample {highcharts} highcharts/plotoptions/series-datalabels-style/
		 *         Bold labels
		 * @sample {highmaps} maps/demo/color-axis/ Bold labels
		 * @default {"color": "contrast", "fontSize": "11px", "fontWeight": "bold", "textOutline": "1px contrast" }
		 * @since 4.1.0
		 */
		style: {
			fontSize: '11px',
			fontWeight: 'bold',
			color: 'contrast',
			textOutline: '1px contrast'
		},

		/**
		 * The background color or gradient for the data label.
		 * 
		 * @type {Color}
		 * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/ Data labels box options
		 * @sample {highmaps} maps/plotoptions/series-datalabels-box/ Data labels box options
		 * @since 2.2.1
		 * @apioption plotOptions.series.dataLabels.backgroundColor
		 */
		
		/**
		 * The border color for the data label. Defaults to `undefined`.
		 * 
		 * @type {Color}
		 * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/ Data labels box options
		 * @sample {highstock} highcharts/plotoptions/series-datalabels-box/ Data labels box options
		 * @default undefined
		 * @since 2.2.1
		 * @apioption plotOptions.series.dataLabels.borderColor
		 */

		/**
		 * The shadow of the box. Works best with `borderWidth` or `backgroundColor`.
		 * Since 2.3 the shadow can be an object configuration containing `color`,
		 *  `offsetX`, `offsetY`, `opacity` and `width`.
		 * 
		 * @type {Boolean|Object}
		 * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/ Data labels box options
		 * @sample {highstock} highcharts/plotoptions/series-datalabels-box/ Data labels box options
		 * @default false
		 * @since 2.2.1
		 * @apioption plotOptions.series.dataLabels.shadow
		 */
		

		/**
		 * For points with an extent, like columns or map areas, whether to align the data
		 * label inside the box or to the actual value point. Defaults to `false`
		 * in most cases, `true` in stacked columns.
		 * 
		 * @type {Boolean}
		 * @since 3.0
		 * @apioption plotOptions.series.dataLabels.inside
		 */

		/**
		 * How to handle data labels that flow outside the plot area. The default
		 * is `justify`, which aligns them inside the plot area. For columns
		 * and bars, this means it will be moved inside the bar. To display
		 * data labels outside the plot area, set `crop` to `false` and `overflow`
		 * to `"none"`.
		 * 
		 * @validvalue ["justify", "none"]
		 * @type {String}
		 * @default justify
		 * @since 3.0.6
		 * @apioption plotOptions.series.dataLabels.overflow
		 */

		/**
		 * Text rotation in degrees. Note that due to a more complex structure,
		 * backgrounds, borders and padding will be lost on a rotated data
		 * label.
		 * 
		 * @type {Number}
		 * @sample {highcharts} highcharts/plotoptions/series-datalabels-rotation/ Vertical labels
		 * @default 0
		 * @apioption plotOptions.series.dataLabels.rotation
		 */

		/**
		 * Whether to [use HTML](http://www.highcharts.com/docs/chart-concepts/labels-
		 * and-string-formatting#html) to render the labels.
		 *
		 * @type {Boolean}
		 * @default false
		 * @apioption plotOptions.series.dataLabels.useHTML
		 */

		/**
		 * The vertical alignment of a data label. Can be one of `top`, `middle`
		 * or `bottom`. The default value depends on the data, for instance
		 * in a column chart, the label is above positive values and below
		 * negative values.
		 * 
		 * @validvalue ["top", "middle", "bottom"]
		 * @type {String}
		 * @since 2.3.3
		 */
		verticalAlign: 'bottom', // above singular point


		/**
		 * The x position offset of the label relative to the point.
		 * 
		 * @type {Number}
		 * @sample {highcharts} highcharts/plotoptions/series-datalabels-rotation/ Vertical and positioned
		 * @default 0
		 */
		x: 0,


		/**
		 * The y position offset of the label relative to the point.
		 * 
		 * @type {Number}
		 * @sample {highcharts} highcharts/plotoptions/series-datalabels-rotation/ Vertical and positioned
		 * @default -6
		 */
		y: 0,


		/**
		 * When either the `borderWidth` or the `backgroundColor` is set,
		 * this is the padding within the box.
		 * 
		 * @type {Number}
		 * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/ Data labels box options
		 * @sample {highstock} highcharts/plotoptions/series-datalabels-box/ Data labels box options
		 * @sample {highmaps} maps/plotoptions/series-datalabels-box/ Data labels box options
		 * @default {highcharts} 5
		 * @default {highstock} 5
		 * @default {highmaps} 0
		 * @since 2.2.1
		 */
		padding: 5

		/**
		 * The name of a symbol to use for the border around the label. Symbols
		 * are predefined functions on the Renderer object.
		 * 
		 * @type {String}
		 * @sample {highcharts} highcharts/plotoptions/series-datalabels-shape/ A callout for annotations
		 * @sample {highstock} highcharts/plotoptions/series-datalabels-shape/ A callout for annotations
		 * @sample {highmaps} highcharts/plotoptions/series-datalabels-shape/ A callout for annotations (Highcharts demo)
		 * @default square
		 * @since 4.1.2
		 * @apioption plotOptions.series.dataLabels.shape
		 */

		/**
		 * The Z index of the data labels. The default Z index puts it above
		 * the series. Use a Z index of 2 to display it behind the series.
		 * 
		 * @type {Number}
		 * @default 6
		 * @since 2.3.5
		 * @apioption plotOptions.series.dataLabels.zIndex
		 */
		
		/**
		 * A declarative filter for which data labels to display. The
		 * declarative filter is designed for use when callback functions are
		 * not available, like when the chart options require a pure JSON
		 * structure or for use with graphical editors. For programmatic
		 * control, use the `formatter` instead, and return `false` to disable
		 * a single data label.
		 *
		 * @example
		 * filter: {
         *     property: 'percentage',
         *     operator: '>',
         *     value: 4
         * }
		 *
		 * @sample highcharts/demo/pie-monochrome
		 *         Data labels filtered by percentage
		 *
		 * @type {Object}
		 * @since 6.0.3
		 * @apioption plotOptions.series.dataLabels.filter
		 */
		
		/**
		 * The point property to filter by. Point options are passed directly to
		 * properties, additionally there are `y` value, `percentage` and others
		 * listed under [Point](https://api.highcharts.com/class-reference/Highcharts.Point)
		 * members.
		 *
		 * @type {String}
		 * @apioption plotOptions.series.dataLabels.filter.property
		 */
		
		/**
		 * The operator to compare by. Can be one of `>`, `<`, `>=`, `<=`, `==`,
		 * and `===`.
		 *
		 * @type {String}
		 * @validvalue [">", "<", ">=", "<=", "==", "===""]
		 * @apioption plotOptions.series.dataLabels.filter.operator
		 */
		
		/**
		 * The value to compare against.
		 *
		 * @type {Mixed}
		 * @apioption plotOptions.series.dataLabels.filter.value
		 */
	},
	// draw points outside the plot area when the number of points is less than
	// this



	/**
	 * When the series contains less points than the crop threshold, all
	 * points are drawn, even if the points fall outside the visible plot
	 * area at the current zoom. The advantage of drawing all points (including
	 * markers and columns), is that animation is performed on updates.
	 * On the other hand, when the series contains more points than the
	 * crop threshold, the series data is cropped to only contain points
	 * that fall within the plot area. The advantage of cropping away invisible
	 * points is to increase performance on large series.
	 * 
	 * @type {Number}
	 * @default 300
	 * @since 2.2
	 * @product highcharts highstock
	 */
	cropThreshold: 300,



	/**
	 * The width of each point on the x axis. For example in a column chart
	 * with one value each day, the pointRange would be 1 day (= 24 * 3600
	 * * 1000 milliseconds). This is normally computed automatically, but
	 * this option can be used to override the automatic value.
	 * 
	 * @type {Number}
	 * @default 0
	 * @product highstock
	 */
	pointRange: 0,
	
	/**
	 * When this is true, the series will not cause the Y axis to cross
	 * the zero plane (or [threshold](#plotOptions.series.threshold) option)
	 * unless the data actually crosses the plane.
	 * 
	 * For example, if `softThreshold` is `false`, a series of 0, 1, 2,
	 * 3 will make the Y axis show negative values according to the `minPadding`
	 * option. If `softThreshold` is `true`, the Y axis starts at 0.
	 * 
	 * @type {Boolean}
	 * @default true
	 * @since 4.1.9
	 * @product highcharts highstock
	 */
	softThreshold: true,



	/**
	 * A wrapper object for all the series options in specific states.
	 * 
	 * @type {plotOptions.series.states}
	 */
	states: {


		/**
		 * Options for the hovered series. These settings override the normal
		 * state options when a series is moused over or touched.
		 *
		 */
		hover: {

			/**
			 * Enable separate styles for the hovered series to visualize that the
			 * user hovers either the series itself or the legend. .
			 * 
			 * @type {Boolean}
			 * @sample {highcharts} highcharts/plotoptions/series-states-hover-enabled/ Line
			 * @sample {highcharts} highcharts/plotoptions/series-states-hover-enabled-column/ Column
			 * @sample {highcharts} highcharts/plotoptions/series-states-hover-enabled-pie/ Pie
			 * @default true
			 * @since 1.2
			 * @apioption plotOptions.series.states.hover.enabled
			 */


			/**
			 * Animation setting for hovering the graph in line-type series.
			 * 
			 * @type {Boolean|Object}
			 * @default { "duration": 50 }
			 * @since 5.0.8
			 * @product highcharts
			 */
			animation: {
				/**
				 * The duration of the hover animation in milliseconds. By
				 * default the hover state animates quickly in, and slowly back
				 * to normal.
				 */
				duration: 50
			},

			/**
			 * Pixel with of the graph line. By default this property is
			 * undefined, and the `lineWidthPlus` property dictates how much
			 * to increase the linewidth from normal state.
			 * 
			 * @type {Number}
			 * @sample {highcharts} highcharts/plotoptions/series-states-hover-linewidth/
			 *         5px line on hover
			 * @default undefined
			 * @product highcharts highstock
			 * @apioption plotOptions.series.states.hover.lineWidth
			 */


			/**
			 * The additional line width for the graph of a hovered series.
			 * 
			 * @type {Number}
			 * @sample {highcharts} highcharts/plotoptions/series-states-hover-linewidthplus/
			 *         5 pixels wider
			 * @sample {highstock} highcharts/plotoptions/series-states-hover-linewidthplus/
			 *         5 pixels wider
			 * @default 1
			 * @since 4.0.3
			 * @product highcharts highstock
			 */
			lineWidthPlus: 1,



			/**
			 * In Highcharts 1.0, the appearance of all markers belonging to
			 * the hovered series. For settings on the hover state of the individual
			 * point, see [marker.states.hover](#plotOptions.series.marker.states.
			 * hover).
			 * 
			 * @extends plotOptions.series.marker
			 * @deprecated
			 * @product highcharts highstock
			 */
			marker: {
				// lineWidth: base + 1,
				// radius: base + 1
			},



			/**
			 * Options for the halo appearing around the hovered point in line-
			 * type series as well as outside the hovered slice in pie charts.
			 * By default the halo is filled by the current point or series
			 * color with an opacity of 0.25\. The halo can be disabled by setting
			 * the `halo` option to `false`.
			 * 
			 * In styled mode, the halo is styled with the `.highcharts-halo` class, with colors inherited from `.highcharts-color-{n}`.
			 * 
			 * @type {Object}
			 * @sample {highcharts} highcharts/plotoptions/halo/ Halo options
			 * @sample {highstock} highcharts/plotoptions/halo/ Halo options
			 * @since 4.0
			 * @product highcharts highstock
			 */
			halo: {

				/**
				 * A collection of SVG attributes to override the appearance of the
				 * halo, for example `fill`, `stroke` and `stroke-width`.
				 * 
				 * @type {Object}
				 * @since 4.0
				 * @product highcharts highstock
				 * @apioption plotOptions.series.states.hover.halo.attributes
				 */


				/**
				 * The pixel size of the halo. For point markers this is the radius
				 * of the halo. For pie slices it is the width of the halo outside
				 * the slice. For bubbles it defaults to 5 and is the width of the
				 * halo outside the bubble.
				 * 
				 * @type {Number}
				 * @default 10
				 * @since 4.0
				 * @product highcharts highstock
				 */
				size: 10,
				



				/**
				 * Opacity for the halo unless a specific fill is overridden using
				 * the `attributes` setting. Note that Highcharts is only able to
				 * apply opacity to colors of hex or rgb(a) formats.
				 * 
				 * @type {Number}
				 * @default 0.25
				 * @since 4.0
				 * @product highcharts highstock
				 */
				opacity: 0.25
				
			}
		},


		/**
		 * Specific options for point in selected states, after being selected
		 * by [allowPointSelect](#plotOptions.series.allowPointSelect) or
		 * programmatically.
		 * 
		 * @type {Object}
		 * @extends plotOptions.series.states.hover
		 * @excluding brightness
		 * @sample {highmaps} maps/plotoptions/series-allowpointselect/
		 *         Allow point select demo
		 * @product highmaps
		 */
		select: {
			marker: {}
		}
	},



	/**
	 * Sticky tracking of mouse events. When true, the `mouseOut` event
	 * on a series isn't triggered until the mouse moves over another series,
	 * or out of the plot area. When false, the `mouseOut` event on a
	 * series is triggered when the mouse leaves the area around the series'
	 * graph or markers. This also implies the tooltip when not shared. When
	 * `stickyTracking` is false and `tooltip.shared` is false, the tooltip will
	 * be hidden when moving the mouse between series. Defaults to true for line
	 * and area type series, but to false for columns, pies etc.
	 * 
	 * @type {Boolean}
	 * @sample {highcharts} highcharts/plotoptions/series-stickytracking-true/
	 *         True by default
	 * @sample {highcharts} highcharts/plotoptions/series-stickytracking-false/
	 *         False
	 * @default {highcharts} true
	 * @default {highstock} true
	 * @default {highmaps} false
	 * @since 2.0
	 */
	stickyTracking: true,

	/**
	 * A configuration object for the tooltip rendering of each single series.
	 * Properties are inherited from [tooltip](#tooltip), but only the
	 * following properties can be defined on a series level.
	 * 
	 * @type {Object}
	 * @extends tooltip
	 * @excluding animation,backgroundColor,borderColor,borderRadius,borderWidth,crosshairs,enabled,formatter,positioner,shadow,shared,shape,snap,style,useHTML
	 * @since 2.3
	 * @apioption plotOptions.series.tooltip
	 */

	/**
	 * When a series contains a data array that is longer than this, only
	 * one dimensional arrays of numbers, or two dimensional arrays with
	 * x and y values are allowed. Also, only the first point is tested,
	 * and the rest are assumed to be the same format. This saves expensive
	 * data checking and indexing in long series. Set it to `0` disable.
	 * 
	 * @type {Number}
	 * @default 1000
	 * @since 2.2
	 * @product highcharts highstock
	 */
	turboThreshold: 1000,
	
	/**
	 * An array defining zones within a series. Zones can be applied to
	 * the X axis, Y axis or Z axis for bubbles, according to the `zoneAxis`
	 * option.
	 * 
	 * In styled mode, the color zones are styled with the `.highcharts-
	 * zone-{n}` class, or custom classed from the `className` option ([view
	 * live demo](http://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/css/color-
	 * zones/)).
	 * 
	 * @type {Array}
	 * @see [zoneAxis](#plotOptions.series.zoneAxis)
	 * @sample {highcharts} highcharts/series/color-zones-simple/ Color zones
	 * @sample {highstock} highcharts/series/color-zones-simple/ Color zones
	 * @since 4.1.0
	 * @product highcharts highstock
	 * @apioption plotOptions.series.zones
	 */

	/**
	 * Styled mode only. A custom class name for the zone.
	 * 
	 * @type {String}
	 * @sample {highcharts} highcharts/css/color-zones/ Zones styled by class name
	 * @sample {highstock} highcharts/css/color-zones/ Zones styled by class name
	 * @sample {highmaps} highcharts/css/color-zones/ Zones styled by class name
	 * @since 5.0.0
	 * @apioption plotOptions.series.zones.className
	 */

	/**
	 * Defines the color of the series.
	 * 
	 * @type {Color}
	 * @see [series color](#plotOptions.series.color)
	 * @since 4.1.0
	 * @product highcharts highstock
	 * @apioption plotOptions.series.zones.color
	 */

	/**
	 * A name for the dash style to use for the graph.
	 * 
	 * @type {String}
	 * @see [series.dashStyle](#plotOptions.series.dashStyle)
	 * @sample {highcharts} highcharts/series/color-zones-dashstyle-dot/
	 *         Dashed line indicates prognosis
	 * @sample {highstock} highcharts/series/color-zones-dashstyle-dot/
	 *         Dashed line indicates prognosis
	 * @since 4.1.0
	 * @product highcharts highstock
	 * @apioption plotOptions.series.zones.dashStyle
	 */

	/**
	 * Defines the fill color for the series (in area type series)
	 * 
	 * @type {Color}
	 * @see [fillColor](#plotOptions.area.fillColor)
	 * @since 4.1.0
	 * @product highcharts highstock
	 * @apioption plotOptions.series.zones.fillColor
	 */

	/**
	 * The value up to where the zone extends, if undefined the zones stretches
	 * to the last value in the series.
	 * 
	 * @type {Number}
	 * @default undefined
	 * @since 4.1.0
	 * @product highcharts highstock
	 * @apioption plotOptions.series.zones.value
	 */



	/**
	 * Determines whether the series should look for the nearest point
	 * in both dimensions or just the x-dimension when hovering the series.
	 * Defaults to `'xy'` for scatter series and `'x'` for most other
	 * series. If the data has duplicate x-values, it is recommended to
	 * set this to `'xy'` to allow hovering over all points.
	 * 
	 * Applies only to series types using nearest neighbor search (not
	 * direct hover) for tooltip.
	 * 
	 * @validvalue ['x', 'xy']
	 * @type {String}
	 * @sample {highcharts} highcharts/series/findnearestpointby/
	 *         Different hover behaviors
	 * @sample {highstock} highcharts/series/findnearestpointby/
	 *         Different hover behaviors
	 * @sample {highmaps} highcharts/series/findnearestpointby/
	 *         Different hover behaviors
	 * @since 5.0.10
	 */
	findNearestPointBy: 'x'

}, /** @lends Highcharts.Series.prototype */ {
	isCartesian: true,
	pointClass: Point,
	sorted: true, // requires the data to be sorted
	requireSorting: true,
	directTouch: false,
	axisTypes: ['xAxis', 'yAxis'],
	colorCounter: 0,
	// each point's x and y values are stored in this.xData and this.yData
	parallelArrays: ['x', 'y'],
	coll: 'series',
	init: function (chart, options) {
		var series = this,
			events,
			chartSeries = chart.series,
			lastSeries;

		/**
		 * Read only. The chart that the series belongs to.
		 *
		 * @name chart
		 * @memberOf Series
		 * @type {Chart}
		 */
		series.chart = chart;

		/**
		 * Read only. The series' type, like "line", "area", "column" etc. The
		 * type in the series options anc can be altered using {@link
		 * Series#update}.
		 *
		 * @name type
		 * @memberOf Series
		 * @type String
		 */

		/**
		 * Read only. The series' current options. To update, use {@link
		 * Series#update}.
		 *
		 * @name options
		 * @memberOf Series
		 * @type SeriesOptions
		 */
		series.options = options = series.setOptions(options);
		series.linkedSeries = [];

		// bind the axes
		series.bindAxes();

		// set some variables
		extend(series, {
			/**
			 * The series name as given in the options. Defaults to
			 * "Series {n}".
			 *
			 * @name name
			 * @memberOf Series
			 * @type {String}
			 */
			name: options.name,
			state: '',
			/**
			 * Read only. The series' visibility state as set by {@link
			 * Series#show}, {@link Series#hide}, or in the initial
			 * configuration.
			 *
			 * @name visible
			 * @memberOf Series
			 * @type {Boolean}
			 */
			visible: options.visible !== false, // true by default
			/**
			 * Read only. The series' selected state as set by {@link
			 * Highcharts.Series#select}.
			 *
			 * @name selected
			 * @memberOf Series
			 * @type {Boolean}
			 */
			selected: options.selected === true // false by default
		});

		// register event listeners
		events = options.events;

		objectEach(events, function (event, eventType) {
			addEvent(series, eventType, event);
		});
		if (
			(events && events.click) ||
			(
				options.point &&
				options.point.events &&
				options.point.events.click
			) ||
			options.allowPointSelect
		) {
			chart.runTrackerClick = true;
		}

		series.getColor();
		series.getSymbol();

		// Set the data
		each(series.parallelArrays, function (key) {
			series[key + 'Data'] = [];
		});
		series.setData(options.data, false);

		// Mark cartesian
		if (series.isCartesian) {
			chart.hasCartesianSeries = true;
		}

		// Get the index and register the series in the chart. The index is one
		// more than the current latest series index (#5960).
		if (chartSeries.length) {
			lastSeries = chartSeries[chartSeries.length - 1];
		}
		series._i = pick(lastSeries && lastSeries._i, -1) + 1;

		// Insert the series and re-order all series above the insertion point.
		chart.orderSeries(this.insert(chartSeries));
	},

	/**
	 * Insert the series in a collection with other series, either the chart
	 * series or yAxis series, in the correct order according to the index
	 * option. Used internally when adding series.
	 *
	 * @private
	 * @param   {Array.<Series>} collection
	 *          A collection of series, like `chart.series` or `xAxis.series`.
	 * @returns {Number} The index of the series in the collection.
	 */
	insert: function (collection) {
		var indexOption = this.options.index,
			i;

		// Insert by index option
		if (isNumber(indexOption)) {
			i = collection.length;
			while (i--) {
				// Loop down until the interted element has higher index
				if (indexOption >=
						pick(collection[i].options.index, collection[i]._i)) {
					collection.splice(i + 1, 0, this);
					break;
				}
			}
			if (i === -1) {
				collection.unshift(this);
			}
			i = i + 1;

		// Or just push it to the end
		} else {
			collection.push(this);
		}
		return pick(i, collection.length - 1);
	},

	/**
	 * Set the xAxis and yAxis properties of cartesian series, and register the
	 * series in the `axis.series` array.
	 *
	 * @private
	 */
	bindAxes: function () {
		var series = this,
			seriesOptions = series.options,
			chart = series.chart,
			axisOptions;

		// repeat for xAxis and yAxis
		each(series.axisTypes || [], function (AXIS) {

			// loop through the chart's axis objects
			each(chart[AXIS], function (axis) {
				axisOptions = axis.options;

				// apply if the series xAxis or yAxis option mathches the number
				// of the axis, or if undefined, use the first axis
				if (
					seriesOptions[AXIS] === axisOptions.index ||
					(
						seriesOptions[AXIS] !== undefined &&
						seriesOptions[AXIS] === axisOptions.id
					) ||
					(
						seriesOptions[AXIS] === undefined &&
						axisOptions.index === 0
					)
				) {

					// register this series in the axis.series lookup
					series.insert(axis.series);

					// set this series.xAxis or series.yAxis reference
					/**
					 * Read only. The unique xAxis object associated with the
					 * series.
					 *
					 * @name xAxis
					 * @memberOf Series
					 * @type Axis
					 */
					/**
					 * Read only. The unique yAxis object associated with the
					 * series.
					 *
					 * @name yAxis
					 * @memberOf Series
					 * @type Axis
					 */
					series[AXIS] = axis;

					// mark dirty for redraw
					axis.isDirty = true;
				}
			});

			// The series needs an X and an Y axis
			if (!series[AXIS] && series.optionalAxis !== AXIS) {
				H.error(18, true);
			}

		});
	},

	/**
	 * For simple series types like line and column, the data values are held in
	 * arrays like xData and yData for quick lookup to find extremes and more.
	 * For multidimensional series like bubble and map, this can be extended
	 * with arrays like zData and valueData by adding to the
	 * `series.parallelArrays` array.
	 *
	 * @private
	 */
	updateParallelArrays: function (point, i) {
		var series = point.series,
			args = arguments,
			fn = isNumber(i) ?
				// Insert the value in the given position
				function (key) {
					var val = key === 'y' && series.toYData ?
						series.toYData(point) :
						point[key];
					series[key + 'Data'][i] = val;
				} :
				// Apply the method specified in i with the following arguments
				// as arguments
				function (key) {
					Array.prototype[i].apply(
						series[key + 'Data'],
						Array.prototype.slice.call(args, 2)
					);
				};

		each(series.parallelArrays, fn);
	},

	/**
	 * Return an auto incremented x value based on the pointStart and
	 * pointInterval options. This is only used if an x value is not given for
	 * the point that calls autoIncrement.
	 *
	 * @private
	 */
	autoIncrement: function () {

		var options = this.options,
			xIncrement = this.xIncrement,
			date,
			pointInterval,
			pointIntervalUnit = options.pointIntervalUnit,
			dstCrossover = 0,
			time = this.chart.time;

		xIncrement = pick(xIncrement, options.pointStart, 0);

		this.pointInterval = pointInterval = pick(
			this.pointInterval,
			options.pointInterval,
			1
		);

		// Added code for pointInterval strings
		if (pointIntervalUnit) {
			date = new time.Date(xIncrement);

			if (pointIntervalUnit === 'day') {
				date = +date[time.setDate](
					date[time.getDate]() + pointInterval
				);
			} else if (pointIntervalUnit === 'month') {
				date = +date[time.setMonth](
					date[time.getMonth]() + pointInterval
				);
			} else if (pointIntervalUnit === 'year') {
				date = +date[time.setFullYear](
					date[time.getFullYear]() + pointInterval
				);
			}

			if (time.variableTimezone) {
				dstCrossover = (
					time.getTimezoneOffset(date) -
					time.getTimezoneOffset(xIncrement)
				);
			}
			pointInterval = date - xIncrement + dstCrossover;

		}

		this.xIncrement = xIncrement + pointInterval;
		return xIncrement;
	},

	/**
	 * Set the series options by merging from the options tree. Called
	 * internally on initiating and updating series. This function will not
	 * redraw the series. For API usage, use {@link Series#update}.
	 * 
	 * @param  {Options.plotOptions.series} itemOptions
	 *         The series options.
	 */
	setOptions: function (itemOptions) {
		var chart = this.chart,
			chartOptions = chart.options,
			plotOptions = chartOptions.plotOptions,
			userOptions = chart.userOptions || {},
			userPlotOptions = userOptions.plotOptions || {},
			typeOptions = plotOptions[this.type],
			options,
			zones;

		this.userOptions = itemOptions;

		// General series options take precedence over type options because
		// otherwise, default type options like column.animation would be
		// overwritten by the general option. But issues have been raised here
		// (#3881), and the solution may be to distinguish between default
		// option and userOptions like in the tooltip below.
		options = merge(
			typeOptions,
			plotOptions.series,
			itemOptions
		);

		// The tooltip options are merged between global and series specific
		// options. Importance order asscendingly:
		// globals: (1)tooltip, (2)plotOptions.series, (3)plotOptions[this.type]
		// init userOptions with possible later updates: 4-6 like 1-3 and
		// (7)this series options
		this.tooltipOptions = merge(
			defaultOptions.tooltip, // 1
			defaultOptions.plotOptions.series &&
				defaultOptions.plotOptions.series.tooltip, // 2
			defaultOptions.plotOptions[this.type].tooltip, // 3
			chartOptions.tooltip.userOptions, // 4
			plotOptions.series && plotOptions.series.tooltip, // 5
			plotOptions[this.type].tooltip, // 6
			itemOptions.tooltip // 7
		);

		// When shared tooltip, stickyTracking is true by default,
		// unless user says otherwise.
		this.stickyTracking = pick(
			itemOptions.stickyTracking,
			userPlotOptions[this.type] &&
				userPlotOptions[this.type].stickyTracking,
			userPlotOptions.series && userPlotOptions.series.stickyTracking,
			(
				this.tooltipOptions.shared && !this.noSharedTooltip ?
				true :
				options.stickyTracking
			)
		);

		// Delete marker object if not allowed (#1125)
		if (typeOptions.marker === null) {
			delete options.marker;
		}

		// Handle color zones
		this.zoneAxis = options.zoneAxis;
		zones = this.zones = (options.zones || []).slice();
		if (
			(options.negativeColor || options.negativeFillColor) &&
			!options.zones
		) {
			zones.push({
				value:
					options[this.zoneAxis + 'Threshold'] ||
					options.threshold ||
					0,
				className: 'highcharts-negative',
				
				color: options.negativeColor,
				fillColor: options.negativeFillColor
				
			});
		}
		if (zones.length) { // Push one extra zone for the rest
			if (defined(zones[zones.length - 1].value)) {
				zones.push({
					
					color: this.color,
					fillColor: this.fillColor
					
				});
			}
		}
		return options;
	},

	getCyclic: function (prop, value, defaults) {
		var i,
			chart = this.chart,
			userOptions = this.userOptions,
			indexName = prop + 'Index',
			counterName = prop + 'Counter',
			len = defaults ? defaults.length : pick(
				chart.options.chart[prop + 'Count'],
				chart[prop + 'Count']
			),
			setting;

		if (!value) {
			// Pick up either the colorIndex option, or the _colorIndex after
			// Series.update()
			setting = pick(
				userOptions[indexName],
				userOptions['_' + indexName]
			);
			if (defined(setting)) { // after Series.update()
				i = setting;
			} else {
				// #6138
				if (!chart.series.length) {
					chart[counterName] = 0;
				}
				userOptions['_' + indexName] = i = chart[counterName] % len;
				chart[counterName] += 1;
			}
			if (defaults) {
				value = defaults[i];
			}
		}
		// Set the colorIndex
		if (i !== undefined) {
			this[indexName] = i;
		}
		this[prop] = value;
	},

	/**
	 * Get the series' color based on either the options or pulled from global
	 * options.
	 *
	 * @return  {Color} The series color.
	 */
	
	getColor: function () {
		if (this.options.colorByPoint) {
			// #4359, selected slice got series.color even when colorByPoint was
			// set.
			this.options.color = null;
		} else {
			this.getCyclic(
				'color',
				this.options.color || defaultPlotOptions[this.type].color,
				this.chart.options.colors
			);
		}
	},
	
	/**
	 * Get the series' symbol based on either the options or pulled from global
	 * options.
	 */
	getSymbol: function () {
		var seriesMarkerOption = this.options.marker;

		this.getCyclic(
			'symbol',
			seriesMarkerOption.symbol,
			this.chart.options.symbols
		);
	},

	drawLegendSymbol: LegendSymbolMixin.drawLineMarker,

	/**
	 * Apply a new set of data to the series and optionally redraw it. The new
	 * data array is passed by reference (except in case of `updatePoints`), and
	 * may later be mutated when updating the chart data.
	 *
	 * Note the difference in behaviour when setting the same amount of points,
	 * or a different amount of points, as handled by the `updatePoints`
	 * parameter.
	 *
	 * @param  {SeriesDataOptions} data
	 *         Takes an array of data in the same format as described under
	 *         `series.typedata` for the given series type.
	 * @param  {Boolean} [redraw=true]
	 *         Whether to redraw the chart after the series is altered. If doing
	 *         more operations on the chart, it is a good idea to set redraw to
	 *         false and call {@link Chart#redraw} after.
	 * @param  {AnimationOptions} [animation]
	 *         When the updated data is the same length as the existing data,
	 *         points will be updated by default, and animation visualizes how
	 *         the points are changed. Set false to disable animation, or a
	 *         configuration object to set duration or easing.
	 * @param  {Boolean} [updatePoints=true]
	 *         When the updated data is the same length as the existing data,
	 *         points will be updated instead of replaced. This allows updating
	 *         with animation and performs better. In this case, the original
	 *         array is not passed by reference. Set false to prevent.
	 *
	 * @sample highcharts/members/series-setdata/
	 *         Set new data from a button
	 * @sample highcharts/members/series-setdata-pie/
	 *         Set data in a pie
	 * @sample stock/members/series-setdata/
	 *         Set new data in Highstock
	 * @sample maps/members/series-setdata/
	 *         Set new data in Highmaps
	 */
	setData: function (data, redraw, animation, updatePoints) {
		var series = this,
			oldData = series.points,
			oldDataLength = (oldData && oldData.length) || 0,
			dataLength,
			options = series.options,
			chart = series.chart,
			firstPoint = null,
			xAxis = series.xAxis,
			i,
			turboThreshold = options.turboThreshold,
			pt,
			xData = this.xData,
			yData = this.yData,
			pointArrayMap = series.pointArrayMap,
			valueCount = pointArrayMap && pointArrayMap.length;

		data = data || [];
		dataLength = data.length;
		redraw = pick(redraw, true);

		// If the point count is the same as is was, just run Point.update which
		// is cheaper, allows animation, and keeps references to points.
		if (
			updatePoints !== false &&
			dataLength &&
			oldDataLength === dataLength &&
			!series.cropped &&
			!series.hasGroupedData &&
			series.visible
		) {
			each(data, function (point, i) {
				// .update doesn't exist on a linked, hidden series (#3709)
				if (oldData[i].update && point !== options.data[i]) {
					oldData[i].update(point, false, null, false);
				}
			});

		} else {

			// Reset properties
			series.xIncrement = null;

			series.colorCounter = 0; // for series with colorByPoint (#1547)

			// Update parallel arrays
			each(this.parallelArrays, function (key) {
				series[key + 'Data'].length = 0;
			});

			// In turbo mode, only one- or twodimensional arrays of numbers are
			// allowed. The first value is tested, and we assume that all the
			// rest are defined the same way. Although the 'for' loops are
			// similar, they are repeated inside each if-else conditional for
			// max performance.
			if (turboThreshold && dataLength > turboThreshold) {

				// find the first non-null point
				i = 0;
				while (firstPoint === null && i < dataLength) {
					firstPoint = data[i];
					i++;
				}


				if (isNumber(firstPoint)) { // assume all points are numbers
					for (i = 0; i < dataLength; i++) {
						xData[i] = this.autoIncrement();
						yData[i] = data[i];
					}

				// Assume all points are arrays when first point is
				} else if (isArray(firstPoint)) {
					if (valueCount) { // [x, low, high] or [x, o, h, l, c]
						for (i = 0; i < dataLength; i++) {
							pt = data[i];
							xData[i] = pt[0];
							yData[i] = pt.slice(1, valueCount + 1);
						}
					} else { // [x, y]
						for (i = 0; i < dataLength; i++) {
							pt = data[i];
							xData[i] = pt[0];
							yData[i] = pt[1];
						}
					}
				} else {
					// Highcharts expects configs to be numbers or arrays in
					// turbo mode
					H.error(12);
				}
			} else {
				for (i = 0; i < dataLength; i++) {
					if (data[i] !== undefined) { // stray commas in oldIE
						pt = { series: series };
						series.pointClass.prototype.applyOptions.apply(
							pt,
							[data[i]]
						);
						series.updateParallelArrays(pt, i);
					}
				}
			}

			// Forgetting to cast strings to numbers is a common caveat when
			// handling CSV or JSON
			if (yData && isString(yData[0])) {
				H.error(14, true);
			}

			series.data = [];
			series.options.data = series.userOptions.data = data;

			// destroy old points
			i = oldDataLength;
			while (i--) {
				if (oldData[i] && oldData[i].destroy) {
					oldData[i].destroy();
				}
			}

			// reset minRange (#878)
			if (xAxis) {
				xAxis.minRange = xAxis.userMinRange;
			}

			// redraw
			series.isDirty = chart.isDirtyBox = true;
			series.isDirtyData = !!oldData;
			animation = false;
		}

		// Typically for pie series, points need to be processed and generated
		// prior to rendering the legend
		if (options.legendType === 'point') {
			this.processData();
			this.generatePoints();
		}

		if (redraw) {
			chart.redraw(animation);
		}
	},

	/**
	 * Internal function to process the data by cropping away unused data points
	 * if the series is longer than the crop threshold. This saves computing
	 * time for large series. In Highstock, this function is extended to
	 * provide data grouping.
	 *
	 * @private
	 * @param  {Boolean} force
	 *         Force data grouping.
	 */
	processData: function (force) {
		var series = this,
			processedXData = series.xData, // copied during slice operation
			processedYData = series.yData,
			dataLength = processedXData.length,
			croppedData,
			cropStart = 0,
			cropped,
			distance,
			closestPointRange,
			xAxis = series.xAxis,
			i, // loop variable
			options = series.options,
			cropThreshold = options.cropThreshold,
			getExtremesFromAll =
				series.getExtremesFromAll ||
				options.getExtremesFromAll, // #4599
			isCartesian = series.isCartesian,
			xExtremes,
			val2lin = xAxis && xAxis.val2lin,
			isLog = xAxis && xAxis.isLog,
			throwOnUnsorted = series.requireSorting,
			min,
			max;

		// If the series data or axes haven't changed, don't go through this.
		// Return false to pass the message on to override methods like in data
		// grouping.
		if (
			isCartesian &&
			!series.isDirty &&
			!xAxis.isDirty &&
			!series.yAxis.isDirty &&
			!force
		) {
			return false;
		}

		if (xAxis) {
			xExtremes = xAxis.getExtremes(); // corrected for log axis (#3053)
			min = xExtremes.min;
			max = xExtremes.max;
		}

		// optionally filter out points outside the plot area
		if (
			isCartesian &&
			series.sorted &&
			!getExtremesFromAll &&
			(!cropThreshold || dataLength > cropThreshold || series.forceCrop)
		) {

			// it's outside current extremes
			if (
				processedXData[dataLength - 1] < min ||
				processedXData[0] > max
			) {
				processedXData = [];
				processedYData = [];

			// only crop if it's actually spilling out
			} else if (
				processedXData[0] < min ||
				processedXData[dataLength - 1] > max
			) {
				croppedData = this.cropData(
					series.xData,
					series.yData,
					min,
					max
				);
				processedXData = croppedData.xData;
				processedYData = croppedData.yData;
				cropStart = croppedData.start;
				cropped = true;
			}
		}


		// Find the closest distance between processed points
		i = processedXData.length || 1;
		while (--i) {
			distance = isLog ?
				val2lin(processedXData[i]) - val2lin(processedXData[i - 1]) :
				processedXData[i] - processedXData[i - 1];

			if (
				distance > 0 &&
				(
					closestPointRange === undefined ||
					distance < closestPointRange
				)
			) {
				closestPointRange = distance;

			// Unsorted data is not supported by the line tooltip, as well as
			// data grouping and navigation in Stock charts (#725) and width
			// calculation of columns (#1900)
			} else if (distance < 0 && throwOnUnsorted) {
				H.error(15);
				throwOnUnsorted = false; // Only once
			}
		}

		// Record the properties
		series.cropped = cropped; // undefined or true
		series.cropStart = cropStart;
		series.processedXData = processedXData;
		series.processedYData = processedYData;

		series.closestPointRange = closestPointRange;

	},

	/**
	 * Iterate over xData and crop values between min and max. Returns object
	 * containing crop start/end cropped xData with corresponding part of yData,
	 * dataMin and dataMax within the cropped range.
	 *
	 * @private
	 */
	cropData: function (xData, yData, min, max) {
		var dataLength = xData.length,
			cropStart = 0,
			cropEnd = dataLength,
			// line-type series need one point outside
			cropShoulder = pick(this.cropShoulder, 1),
			i,
			j;

		// iterate up to find slice start
		for (i = 0; i < dataLength; i++) {
			if (xData[i] >= min) {
				cropStart = Math.max(0, i - cropShoulder);
				break;
			}
		}

		// proceed to find slice end
		for (j = i; j < dataLength; j++) {
			if (xData[j] > max) {
				cropEnd = j + cropShoulder;
				break;
			}
		}

		return {
			xData: xData.slice(cropStart, cropEnd),
			yData: yData.slice(cropStart, cropEnd),
			start: cropStart,
			end: cropEnd
		};
	},


	/**
	 * Generate the data point after the data has been processed by cropping
	 * away unused points and optionally grouped in Highcharts Stock.
	 *
	 * @private
	 */
	generatePoints: function () {
		var series = this,
			options = series.options,
			dataOptions = options.data,
			data = series.data,
			dataLength,
			processedXData = series.processedXData,
			processedYData = series.processedYData,
			PointClass = series.pointClass,
			processedDataLength = processedXData.length,
			cropStart = series.cropStart || 0,
			cursor,
			hasGroupedData = series.hasGroupedData,
			keys = options.keys,
			point,
			points = [],
			i;

		if (!data && !hasGroupedData) {
			var arr = [];
			arr.length = dataOptions.length;
			data = series.data = arr;
		}

		if (keys && hasGroupedData) {
			// grouped data has already applied keys (#6590)
			series.options.keys = false;
		}

		for (i = 0; i < processedDataLength; i++) {
			cursor = cropStart + i;
			if (!hasGroupedData) {
				point = data[cursor];
				if (!point && dataOptions[cursor] !== undefined) { // #970
					data[cursor] = point = (new PointClass()).init(
						series,
						dataOptions[cursor],
						processedXData[i]
					);
				}
			} else {
				// splat the y data in case of ohlc data array
				point = (new PointClass()).init(
					series,
					[processedXData[i]].concat(splat(processedYData[i]))
				);

				/**
				 * Highstock only. If a point object is created by data
				 * grouping, it doesn't reflect actual points in the raw data.
				 * In this case, the `dataGroup` property holds information
				 * that points back to the raw data.
				 *
				 * - `dataGroup.start` is the index of the first raw data point
				 * in the group.
				 * - `dataGroup.length` is the amount of points in the group.
				 *
				 * @name dataGroup
				 * @memberOf Point
				 * @type {Object}
				 *
				 */
				point.dataGroup = series.groupMap[i];
			}
			if (point) { // #6279
				point.index = cursor; // For faster access in Point.update
				points[i] = point;
			}
		}

		// restore keys options (#6590)
		series.options.keys = keys;

		// Hide cropped-away points - this only runs when the number of points
		// is above cropThreshold, or when swithching view from non-grouped
		// data to grouped data (#637)
		if (
			data &&
			(
				processedDataLength !== (dataLength = data.length) ||
				hasGroupedData
			)
		) {
			for (i = 0; i < dataLength; i++) {
				// when has grouped data, clear all points
				if (i === cropStart && !hasGroupedData) {
					i += processedDataLength;
				}
				if (data[i]) {
					data[i].destroyElements();
					data[i].plotX = undefined; // #1003
				}
			}
		}

		/**
		 * Read only. An array containing those values converted to points, but
		 * in case the series data length exceeds the `cropThreshold`, or if the
		 * data is grouped, `series.data` doesn't contain all the points. It
		 * only contains the points that have been created on demand. To
		 * modify the data, use {@link Highcharts.Series#setData} or {@link
		 * Highcharts.Point#update}.
		 *
		 * @name data
		 * @memberOf Highcharts.Series
		 * @see  Series.points
		 * @type {Array.<Highcharts.Point>}
		 */
		series.data = data;

		/**
		 * An array containing all currently visible point objects. In case of
		 * cropping, the cropped-away points are not part of this array. The
		 * `series.points` array starts at `series.cropStart` compared to
		 * `series.data` and `series.options.data`. If however the series data
		 * is grouped, these can't be correlated one to one. To
		 * modify the data, use {@link Highcharts.Series#setData} or {@link
		 * Highcharts.Point#update}.
		 * @name points
		 * @memberof Series
		 * @type {Array.<Point>}
		 */
		series.points = points;
	},

	/**
	 * Calculate Y extremes for the visible data. The result is set as 
	 * `dataMin` and `dataMax` on the Series item.
	 *
	 * @param  {Array.<Number>} [yData]
	 *         The data to inspect. Defaults to the current data within the
	 *         visible range.
	 * 
	 */
	getExtremes: function (yData) {
		var xAxis = this.xAxis,
			yAxis = this.yAxis,
			xData = this.processedXData,
			yDataLength,
			activeYData = [],
			activeCounter = 0,
			// #2117, need to compensate for log X axis
			xExtremes = xAxis.getExtremes(),
			xMin = xExtremes.min,
			xMax = xExtremes.max,
			validValue,
			withinRange,
			x,
			y,
			i,
			j;

		yData = yData || this.stackedYData || this.processedYData || [];
		yDataLength = yData.length;

		for (i = 0; i < yDataLength; i++) {

			x = xData[i];
			y = yData[i];

			// For points within the visible range, including the first point
			// outside the visible range (#7061), consider y extremes.
			validValue =
				(isNumber(y, true) || isArray(y)) &&
				(!yAxis.positiveValuesOnly || (y.length || y > 0));
			withinRange =
				this.getExtremesFromAll ||
				this.options.getExtremesFromAll ||
				this.cropped ||
				((xData[i + 1] || x) >= xMin &&	(xData[i - 1] || x) <= xMax);

			if (validValue && withinRange) {

				j = y.length;
				if (j) { // array, like ohlc or range data
					while (j--) {
						if (typeof y[j] === 'number') { // #7380
							activeYData[activeCounter++] = y[j];
						}
					}
				} else {
					activeYData[activeCounter++] = y;
				}
			}
		}

		this.dataMin = arrayMin(activeYData);
		this.dataMax = arrayMax(activeYData);
	},

	/**
	 * Translate data points from raw data values to chart specific positioning
	 * data needed later in the `drawPoints` and `drawGraph` functions. This
	 * function can be overridden in plugins and custom series type
	 * implementations.
	 */
	translate: function () {
		if (!this.processedXData) { // hidden series
			this.processData();
		}
		this.generatePoints();
		var series = this,
			options = series.options,
			stacking = options.stacking,
			xAxis = series.xAxis,
			categories = xAxis.categories,
			yAxis = series.yAxis,
			points = series.points,
			dataLength = points.length,
			hasModifyValue = !!series.modifyValue,
			i,
			pointPlacement = options.pointPlacement,
			dynamicallyPlaced =
				pointPlacement === 'between' ||
				isNumber(pointPlacement),
			threshold = options.threshold,
			stackThreshold = options.startFromThreshold ? threshold : 0,
			plotX,
			plotY,
			lastPlotX,
			stackIndicator,
			closestPointRangePx = Number.MAX_VALUE;

		/*
		 * Plotted coordinates need to be within a limited range. Drawing too
		 * far outside the viewport causes various rendering issues (#3201,
		 * #3923, #7555).
		 */
		function limitedRange(val) {
			return Math.min(Math.max(-1e5, val), 1e5);
		}

		// Point placement is relative to each series pointRange (#5889)
		if (pointPlacement === 'between') {
			pointPlacement = 0.5;
		}
		if (isNumber(pointPlacement)) {
			pointPlacement *= pick(options.pointRange || xAxis.pointRange);
		}

		// Translate each point
		for (i = 0; i < dataLength; i++) {
			var point = points[i],
				xValue = point.x,
				yValue = point.y,
				yBottom = point.low,
				stack = stacking && yAxis.stacks[(
					series.negStacks &&
					yValue < (stackThreshold ? 0 : threshold) ? '-' : ''
				) + series.stackKey],
				pointStack,
				stackValues;

			// Discard disallowed y values for log axes (#3434)
			if (yAxis.positiveValuesOnly && yValue !== null && yValue <= 0) {
				point.isNull = true;
			}

			// Get the plotX translation
			point.plotX = plotX = correctFloat( // #5236
				limitedRange(xAxis.translate( // #3923
					xValue,
					0,
					0,
					0,
					1,
					pointPlacement,
					this.type === 'flags'
				)) // #3923
			);

			// Calculate the bottom y value for stacked series
			if (
				stacking &&
				series.visible &&
				!point.isNull &&
				stack &&
				stack[xValue]
			) {
				stackIndicator = series.getStackIndicator(
					stackIndicator,
					xValue,
					series.index
				);
				pointStack = stack[xValue];
				stackValues = pointStack.points[stackIndicator.key];
				yBottom = stackValues[0];
				yValue = stackValues[1];

				if (
					yBottom === stackThreshold &&
					stackIndicator.key === stack[xValue].base
				) {
					yBottom = pick(threshold, yAxis.min);
				}
				if (yAxis.positiveValuesOnly && yBottom <= 0) { // #1200, #1232
					yBottom = null;
				}

				point.total = point.stackTotal = pointStack.total;
				point.percentage =
					pointStack.total &&
					(point.y / pointStack.total * 100);
				point.stackY = yValue;

				// Place the stack label
				pointStack.setOffset(
					series.pointXOffset || 0,
					series.barW || 0
				);

			}

			// Set translated yBottom or remove it
			point.yBottom = defined(yBottom) ?
				limitedRange(yAxis.translate(yBottom, 0, 1, 0, 1)) :
				null;

			// general hook, used for Highstock compare mode
			if (hasModifyValue) {
				yValue = series.modifyValue(yValue, point);
			}

			// Set the the plotY value, reset it for redraws
			point.plotY = plotY =
				(typeof yValue === 'number' && yValue !== Infinity) ?
					limitedRange(yAxis.translate(yValue, 0, 1, 0, 1)) : // #3201
					undefined;

			point.isInside =
				plotY !== undefined &&
				plotY >= 0 &&
				plotY <= yAxis.len && // #3519
				plotX >= 0 &&
				plotX <= xAxis.len;


			// Set client related positions for mouse tracking
			point.clientX = dynamicallyPlaced ?
				correctFloat(
					xAxis.translate(xValue, 0, 0, 0, 1, pointPlacement)
				) :
				plotX; // #1514, #5383, #5518

			point.negative = point.y < (threshold || 0);

			// some API data
			point.category = categories && categories[point.x] !== undefined ?
				categories[point.x] : point.x;

			// Determine auto enabling of markers (#3635, #5099)
			if (!point.isNull) {
				if (lastPlotX !== undefined) {
					closestPointRangePx = Math.min(
						closestPointRangePx,
						Math.abs(plotX - lastPlotX)
					);
				}
				lastPlotX = plotX;
			}

			// Find point zone
			point.zone = this.zones.length && point.getZone();
		}
		series.closestPointRangePx = closestPointRangePx;
	},

	/**
	 * Return the series points with null points filtered out.
	 *
	 * @param  {Array.<Point>} [points]
	 *         The points to inspect, defaults to {@link Series.points}.
	 * @param  {Boolean} [insideOnly=false]
	 *         Whether to inspect only the points that are inside the visible
	 *         view.
	 *
	 * @return {Array.<Point>}
	 *         The valid points.
	 */
	getValidPoints: function (points, insideOnly) {
		var chart = this.chart;
		// #3916, #5029, #5085
		return grep(points || this.points || [], function isValidPoint(point) {
			if (insideOnly && !chart.isInsidePlot(
				point.plotX,
				point.plotY,
				chart.inverted
			)) {
				return false;
			}
			return !point.isNull;
		});
	},

	/**
	 * Set the clipping for the series. For animated series it is called twice,
	 * first to initiate animating the clip then the second time without the
	 * animation to set the final clip.
	 *
	 * @private
	 */
	setClip: function (animation) {
		var chart = this.chart,
			options = this.options,
			renderer = chart.renderer,
			inverted = chart.inverted,
			seriesClipBox = this.clipBox,
			clipBox = seriesClipBox || chart.clipBox,
			sharedClipKey =
				this.sharedClipKey ||
				[
					'_sharedClip',
					animation && animation.duration,
					animation && animation.easing,
					clipBox.height,
					options.xAxis,
					options.yAxis
				].join(','), // #4526
			clipRect = chart[sharedClipKey],
			markerClipRect = chart[sharedClipKey + 'm'];

		// If a clipping rectangle with the same properties is currently present
		// in the chart, use that.
		if (!clipRect) {

			// When animation is set, prepare the initial positions
			if (animation) {
				clipBox.width = 0;
				if (inverted) {
					clipBox.x = chart.plotSizeX;
				}

				chart[sharedClipKey + 'm'] = markerClipRect = renderer.clipRect(
					inverted ? chart.plotSizeX + 99 : -99, // include the width of the first marker
					inverted ? -chart.plotLeft : -chart.plotTop,
					99,
					inverted ? chart.chartWidth : chart.chartHeight
				);
			}
			chart[sharedClipKey] = clipRect = renderer.clipRect(clipBox);
			// Create hashmap for series indexes
			clipRect.count = { length: 0 };

		}
		if (animation) {
			if (!clipRect.count[this.index]) {
				clipRect.count[this.index] = true;
				clipRect.count.length += 1;
			}
		}

		if (options.clip !== false) {
			this.group.clip(animation || seriesClipBox ? clipRect : chart.clipRect);
			this.markerGroup.clip(markerClipRect);
			this.sharedClipKey = sharedClipKey;
		}

		// Remove the shared clipping rectangle when all series are shown
		if (!animation) {
			if (clipRect.count[this.index]) {
				delete clipRect.count[this.index];
				clipRect.count.length -= 1;
			}

			if (clipRect.count.length === 0 && sharedClipKey && chart[sharedClipKey]) {
				if (!seriesClipBox) {
					chart[sharedClipKey] = chart[sharedClipKey].destroy();
				}
				if (chart[sharedClipKey + 'm']) {
					chart[sharedClipKey + 'm'] = chart[sharedClipKey + 'm'].destroy();
				}
			}
		}
	},

	/**
	 * Animate in the series. Called internally twice. First with the `init`
	 * parameter set to true, which sets up the initial state of the animation.
	 * Then when ready, it is called with the `init` parameter undefined, in 
	 * order to perform the actual animation. After the second run, the function
	 * is removed.
	 *
	 * @param  {Boolean} init
	 *         Initialize the animation.
	 */
	animate: function (init) {
		var series = this,
			chart = series.chart,
			clipRect,
			animation = animObject(series.options.animation),
			sharedClipKey;

		// Initialize the animation. Set up the clipping rectangle.
		if (init) {

			series.setClip(animation);

		// Run the animation
		} else {
			sharedClipKey = this.sharedClipKey;
			clipRect = chart[sharedClipKey];
			if (clipRect) {
				clipRect.animate({
					width: chart.plotSizeX,
					x: 0
				}, animation);
			}
			if (chart[sharedClipKey + 'm']) {
				chart[sharedClipKey + 'm'].animate({
					width: chart.plotSizeX + 99,
					x: 0
				}, animation);
			}

			// Delete this function to allow it only once
			series.animate = null;

		}
	},

	/**
	 * This runs after animation to land on the final plot clipping.
	 *
	 * @private
	 */
	afterAnimate: function () {
		this.setClip();
		fireEvent(this, 'afterAnimate');
		this.finishedAnimating = true;
	},

	/**
	 * Draw the markers for line-like series types, and columns or other
	 * graphical representation for {@link Point} objects for other series
	 * types. The resulting element is typically stored as {@link
	 * Point.graphic}, and is created on the first call and updated and moved on
	 * subsequent calls.
	 */
	drawPoints: function () {
		var series = this,
			points = series.points,
			chart = series.chart,
			i,
			point,
			symbol,
			graphic,
			options = series.options,
			seriesMarkerOptions = options.marker,
			pointMarkerOptions,
			hasPointMarker,
			enabled,
			isInside,
			markerGroup = series[series.specialGroup] || series.markerGroup,
			xAxis = series.xAxis,
			markerAttribs,
			globallyEnabled = pick(
				seriesMarkerOptions.enabled,
				xAxis.isRadial ? true : null,
				// Use larger or equal as radius is null in bubbles (#6321)
				series.closestPointRangePx >= 2 * seriesMarkerOptions.radius
			);

		if (seriesMarkerOptions.enabled !== false || series._hasPointMarkers) {

			for (i = 0; i < points.length; i++) {
				point = points[i];
				graphic = point.graphic;
				pointMarkerOptions = point.marker || {};
				hasPointMarker = !!point.marker;
				enabled = (globallyEnabled && pointMarkerOptions.enabled === undefined) || pointMarkerOptions.enabled;
				isInside = point.isInside;

				// only draw the point if y is defined
				if (enabled && !point.isNull) {

					// Shortcuts
					symbol = pick(pointMarkerOptions.symbol, series.symbol);
					point.hasImage = symbol.indexOf('url') === 0;

					markerAttribs = series.markerAttribs(
						point,
						point.selected && 'select'
					);

					if (graphic) { // update
						graphic[isInside ? 'show' : 'hide'](true) // Since the marker group isn't clipped, each individual marker must be toggled
							.animate(markerAttribs);
					} else if (isInside && (markerAttribs.width > 0 || point.hasImage)) {

						/**
						 * The graphic representation of the point. Typically
						 * this is a simple shape, like a `rect` for column
						 * charts or `path` for line markers, but for some 
						 * complex series types like boxplot or 3D charts, the
						 * graphic may be a `g` element containing other shapes.
						 * The graphic is generated the first time {@link
						 * Series#drawPoints} runs, and updated and moved on
						 * subsequent runs.
						 *
						 * @memberof Point
						 * @name graphic
						 * @type {SVGElement}
						 */
						point.graphic = graphic = chart.renderer.symbol(
							symbol,
							markerAttribs.x,
							markerAttribs.y,
							markerAttribs.width,
							markerAttribs.height,
							hasPointMarker ? pointMarkerOptions : seriesMarkerOptions
						)
						.add(markerGroup);
					}

					
					// Presentational attributes
					if (graphic) {
						graphic.attr(series.pointAttribs(point, point.selected && 'select'));
					}
					

					if (graphic) {
						graphic.addClass(point.getClassName(), true);
					}

				} else if (graphic) {
					point.graphic = graphic.destroy(); // #1269
				}
			}
		}

	},

	/**
	 * Get non-presentational attributes for a point. Used internally for both
	 * styled mode and classic. Can be overridden for different series types.
	 *
	 * @see    Series#pointAttribs
	 *
	 * @param  {Point} point
	 *         The Point to inspect.
	 * @param  {String} [state]
	 *         The state, can be either `hover`, `select` or undefined.
	 *
	 * @return {SVGAttributes}
	 *         A hash containing those attributes that are not settable from
	 *         CSS.
	 */
	markerAttribs: function (point, state) {
		var seriesMarkerOptions = this.options.marker,
			seriesStateOptions,
			pointMarkerOptions = point.marker || {},
			pointStateOptions,
			radius = pick(
				pointMarkerOptions.radius,
				seriesMarkerOptions.radius
			),
			attribs;

		// Handle hover and select states
		if (state) {
			seriesStateOptions = seriesMarkerOptions.states[state];
			pointStateOptions = pointMarkerOptions.states &&
				pointMarkerOptions.states[state];

			radius = pick(
				pointStateOptions && pointStateOptions.radius,
				seriesStateOptions && seriesStateOptions.radius,
				radius + (seriesStateOptions && seriesStateOptions.radiusPlus || 0)
			);
		}

		if (point.hasImage) {
			radius = 0; // and subsequently width and height is not set
		}

		attribs = {
			x: Math.floor(point.plotX) - radius, // Math.floor for #1843
			y: point.plotY - radius
		};

		if (radius) {
			attribs.width = attribs.height = 2 * radius;
		}

		return attribs;

	},

	
	/**
	 * Internal function to get presentational attributes for each point. Unlike
	 * {@link Series#markerAttribs}, this function should return those
	 * attributes that can also be set in CSS. In styled mode, `pointAttribs`
	 * won't be called.
	 *
	 * @param  {Point} point
	 *         The point instance to inspect.
	 * @param  {String} [state]
	 *         The point state, can be either `hover`, `select` or undefined for
	 *         normal state.
	 *
	 * @return {SVGAttributes}
	 *         The presentational attributes to be set on the point.
	 */
	pointAttribs: function (point, state) {
		var seriesMarkerOptions = this.options.marker,
			seriesStateOptions,
			pointOptions = point && point.options,
			pointMarkerOptions = (pointOptions && pointOptions.marker) || {},
			pointStateOptions,
			color = this.color,
			pointColorOption = pointOptions && pointOptions.color,
			pointColor = point && point.color,
			strokeWidth = pick(
				pointMarkerOptions.lineWidth,
				seriesMarkerOptions.lineWidth
			),
			zoneColor = point && point.zone && point.zone.color,
			fill,
			stroke;

		color = pointColorOption || zoneColor || pointColor || color;
		fill = pointMarkerOptions.fillColor || seriesMarkerOptions.fillColor || color;
		stroke = pointMarkerOptions.lineColor || seriesMarkerOptions.lineColor || color;

		// Handle hover and select states
		if (state) {
			seriesStateOptions = seriesMarkerOptions.states[state];
			pointStateOptions = (pointMarkerOptions.states && pointMarkerOptions.states[state]) || {};
			strokeWidth = pick(
				pointStateOptions.lineWidth,
				seriesStateOptions.lineWidth,
				strokeWidth + pick(
					pointStateOptions.lineWidthPlus,
					seriesStateOptions.lineWidthPlus,
					0
				)
			);
			fill = pointStateOptions.fillColor || seriesStateOptions.fillColor || fill;
			stroke = pointStateOptions.lineColor || seriesStateOptions.lineColor || stroke;
		}

		return {
			'stroke': stroke,
			'stroke-width': strokeWidth,
			'fill': fill
		};
	},
	
	/**
	 * Clear DOM objects and free up memory.
	 *
	 * @private
	 */
	destroy: function () {
		var series = this,
			chart = series.chart,
			issue134 = /AppleWebKit\/533/.test(win.navigator.userAgent),
			destroy,
			i,
			data = series.data || [],
			point,
			axis;

		// add event hook
		fireEvent(series, 'destroy');

		// remove all events
		removeEvent(series);

		// erase from axes
		each(series.axisTypes || [], function (AXIS) {
			axis = series[AXIS];
			if (axis && axis.series) {
				erase(axis.series, series);
				axis.isDirty = axis.forceRedraw = true;
			}
		});

		// remove legend items
		if (series.legendItem) {
			series.chart.legend.destroyItem(series);
		}

		// destroy all points with their elements
		i = data.length;
		while (i--) {
			point = data[i];
			if (point && point.destroy) {
				point.destroy();
			}
		}
		series.points = null;

		// Clear the animation timeout if we are destroying the series during initial animation
		clearTimeout(series.animationTimeout);

		// Destroy all SVGElements associated to the series
		objectEach(series, function (val, prop) {
			if (val instanceof SVGElement && !val.survive) { // Survive provides a hook for not destroying

				// issue 134 workaround
				destroy = issue134 && prop === 'group' ?
				'hide' :
				'destroy';

				val[destroy]();
			}
		});

		// remove from hoverSeries
		if (chart.hoverSeries === series) {
			chart.hoverSeries = null;
		}
		erase(chart.series, series);
		chart.orderSeries();

		// clear all members
		objectEach(series, function (val, prop) {
			delete series[prop];
		});
	},

	/**
	 * Get the graph path.
	 *
	 * @private
	 */
	getGraphPath: function (points, nullsAsZeroes, connectCliffs) {
		var series = this,
			options = series.options,
			step = options.step,
			reversed,
			graphPath = [],
			xMap = [],
			gap;

		points = points || series.points;

		// Bottom of a stack is reversed
		reversed = points.reversed;
		if (reversed) {
			points.reverse();
		}
		// Reverse the steps (#5004)
		step = { right: 1, center: 2 }[step] || (step && 3);
		if (step && reversed) {
			step = 4 - step;
		}

		// Remove invalid points, especially in spline (#5015)
		if (options.connectNulls && !nullsAsZeroes && !connectCliffs) {
			points = this.getValidPoints(points);
		}

		// Build the line
		each(points, function (point, i) {

			var plotX = point.plotX,
				plotY = point.plotY,
				lastPoint = points[i - 1],
				pathToPoint; // the path to this point from the previous

			if ((point.leftCliff || (lastPoint && lastPoint.rightCliff)) && !connectCliffs) {
				gap = true; // ... and continue
			}

			// Line series, nullsAsZeroes is not handled
			if (point.isNull && !defined(nullsAsZeroes) && i > 0) {
				gap = !options.connectNulls;

			// Area series, nullsAsZeroes is set
			} else if (point.isNull && !nullsAsZeroes) {
				gap = true;

			} else {

				if (i === 0 || gap) {
					pathToPoint = ['M', point.plotX, point.plotY];

				} else if (series.getPointSpline) { // generate the spline as defined in the SplineSeries object

					pathToPoint = series.getPointSpline(points, point, i);

				} else if (step) {

					if (step === 1) { // right
						pathToPoint = [
							'L',
							lastPoint.plotX,
							plotY
						];

					} else if (step === 2) { // center
						pathToPoint = [
							'L',
							(lastPoint.plotX + plotX) / 2,
							lastPoint.plotY,
							'L',
							(lastPoint.plotX + plotX) / 2,
							plotY
						];

					} else {
						pathToPoint = [
							'L',
							plotX,
							lastPoint.plotY
						];
					}
					pathToPoint.push('L', plotX, plotY);

				} else {
					// normal line to next point
					pathToPoint = [
						'L',
						plotX,
						plotY
					];
				}

				// Prepare for animation. When step is enabled, there are two path nodes for each x value.
				xMap.push(point.x);
				if (step) {
					xMap.push(point.x);
				}

				graphPath.push.apply(graphPath, pathToPoint);
				gap = false;
			}
		});

		graphPath.xMap = xMap;
		series.graphPath = graphPath;

		return graphPath;

	},

	/**
	 * Draw the graph. Called internally when rendering line-like series types.
	 * The first time it generates the `series.graph` item and optionally other
	 * series-wide items like `series.area` for area charts. On subsequent calls
	 * these items are updated with new positions and attributes.
	 */
	drawGraph: function () {
		var series = this,
			options = this.options,
			graphPath = (this.gappedPath || this.getGraphPath).call(this),
			props = [[
				'graph',
				'highcharts-graph',
				
				options.lineColor || this.color,
				options.dashStyle
				
			]];

		// Add the zone properties if any
		each(this.zones, function (zone, i) {
			props.push([
				'zone-graph-' + i,
				'highcharts-graph highcharts-zone-graph-' + i + ' ' + (zone.className || ''),
				
				zone.color || series.color,
				zone.dashStyle || options.dashStyle
				
			]);
		});

		// Draw the graph
		each(props, function (prop, i) {
			var graphKey = prop[0],
				graph = series[graphKey],
				attribs;

			if (graph) {
				graph.endX = series.preventGraphAnimation ?
					null :
					graphPath.xMap;
				graph.animate({ d: graphPath });

			} else if (graphPath.length) { // #1487

				series[graphKey] = series.chart.renderer.path(graphPath)
					.addClass(prop[1])
					.attr({ zIndex: 1 }) // #1069
					.add(series.group);

				
				attribs = {
					'stroke': prop[2],
					'stroke-width': options.lineWidth,
					'fill': (series.fillGraph && series.color) || 'none' // Polygon series use filled graph
				};

				if (prop[3]) {
					attribs.dashstyle = prop[3];
				} else if (options.linecap !== 'square') {
					attribs['stroke-linecap'] = attribs['stroke-linejoin'] = 'round';
				}

				graph = series[graphKey]
					.attr(attribs)
					.shadow((i < 2) && options.shadow); // add shadow to normal series (0) or to first zone (1) #3932
				
			}

			// Helpers for animation
			if (graph) {
				graph.startX = graphPath.xMap;
				graph.isArea = graphPath.isArea; // For arearange animation
			}
		});
	},

	/**
	 * Clip the graphs into zones for colors and styling.
	 *
	 * @private
	 */
	applyZones: function () {
		var series = this,
			chart = this.chart,
			renderer = chart.renderer,
			zones = this.zones,
			translatedFrom,
			translatedTo,
			clips = this.clips || [],
			clipAttr,
			graph = this.graph,
			area = this.area,
			chartSizeMax = Math.max(chart.chartWidth, chart.chartHeight),
			axis = this[(this.zoneAxis || 'y') + 'Axis'],
			extremes,
			reversed,
			inverted = chart.inverted,
			horiz,
			pxRange,
			pxPosMin,
			pxPosMax,
			ignoreZones = false;

		if (zones.length && (graph || area) && axis && axis.min !== undefined) {
			reversed = axis.reversed;
			horiz = axis.horiz;
			// The use of the Color Threshold assumes there are no gaps
			// so it is safe to hide the original graph and area
			if (graph) {
				graph.hide();
			}
			if (area) {
				area.hide();
			}

			// Create the clips
			extremes = axis.getExtremes();
			each(zones, function (threshold, i) {

				translatedFrom = reversed ?
					(horiz ? chart.plotWidth : 0) :
					(horiz ? 0 : axis.toPixels(extremes.min));
				translatedFrom = Math.min(Math.max(pick(translatedTo, translatedFrom), 0), chartSizeMax);
				translatedTo = Math.min(Math.max(Math.round(axis.toPixels(pick(threshold.value, extremes.max), true)), 0), chartSizeMax);

				if (ignoreZones) {
					translatedFrom = translatedTo = axis.toPixels(extremes.max);
				}

				pxRange = Math.abs(translatedFrom - translatedTo);
				pxPosMin = Math.min(translatedFrom, translatedTo);
				pxPosMax = Math.max(translatedFrom, translatedTo);
				if (axis.isXAxis) {
					clipAttr = {
						x: inverted ? pxPosMax : pxPosMin,
						y: 0,
						width: pxRange,
						height: chartSizeMax
					};
					if (!horiz) {
						clipAttr.x = chart.plotHeight - clipAttr.x;
					}
				} else {
					clipAttr = {
						x: 0,
						y: inverted ? pxPosMax : pxPosMin,
						width: chartSizeMax,
						height: pxRange
					};
					if (horiz) {
						clipAttr.y = chart.plotWidth - clipAttr.y;
					}
				}

				
				// VML SUPPPORT
				if (inverted && renderer.isVML) {
					if (axis.isXAxis) {
						clipAttr = {
							x: 0,
							y: reversed ? pxPosMin : pxPosMax,
							height: clipAttr.width,
							width: chart.chartWidth
						};
					} else {
						clipAttr = {
							x: clipAttr.y - chart.plotLeft - chart.spacingBox.x,
							y: 0,
							width: clipAttr.height,
							height: chart.chartHeight
						};
					}
				}
				// END OF VML SUPPORT
				

				if (clips[i]) {
					clips[i].animate(clipAttr);
				} else {
					clips[i] = renderer.clipRect(clipAttr);

					if (graph) {
						series['zone-graph-' + i].clip(clips[i]);
					}

					if (area) {
						series['zone-area-' + i].clip(clips[i]);
					}
				}
				// if this zone extends out of the axis, ignore the others
				ignoreZones = threshold.value > extremes.max;
			});
			this.clips = clips;
		}
	},

	/**
	 * Initialize and perform group inversion on series.group and
	 * series.markerGroup.
	 *
	 * @private
	 */
	invertGroups: function (inverted) {
		var series = this,
			chart = series.chart,
			remover;

		function setInvert() {
			each(['group', 'markerGroup'], function (groupName) {
				if (series[groupName]) {

					// VML/HTML needs explicit attributes for flipping
					if (chart.renderer.isVML) {
						series[groupName].attr({
							width: series.yAxis.len,
							height: series.xAxis.len
						});
					}

					series[groupName].width = series.yAxis.len;
					series[groupName].height = series.xAxis.len;
					series[groupName].invert(inverted);
				}
			});
		}

		// Pie, go away (#1736)
		if (!series.xAxis) {
			return;
		}

		// A fixed size is needed for inversion to work
		remover = addEvent(chart, 'resize', setInvert);
		addEvent(series, 'destroy', remover);

		// Do it now
		setInvert(inverted); // do it now

		// On subsequent render and redraw, just do setInvert without setting up events again
		series.invertGroups = setInvert;
	},

	/**
	 * General abstraction for creating plot groups like series.group,
	 * series.dataLabelsGroup and series.markerGroup. On subsequent calls, the
	 * group will only be adjusted to the updated plot size.
	 *
	 * @private
	 */
	plotGroup: function (prop, name, visibility, zIndex, parent) {
		var group = this[prop],
			isNew = !group;

		// Generate it on first call
		if (isNew) {
			this[prop] = group = this.chart.renderer.g()
				.attr({
					zIndex: zIndex || 0.1 // IE8 and pointer logic use this
				})
				.add(parent);

		}

		// Add the class names, and replace existing ones as response to
		// Series.update (#6660)
		group.addClass(
			(
				'highcharts-' + name +
				' highcharts-series-' + this.index +
				' highcharts-' + this.type + '-series ' +
				(
					defined(this.colorIndex) ?
						'highcharts-color-' + this.colorIndex + ' ' :
						''
				) +
				(this.options.className || '') +
				(group.hasClass('highcharts-tracker') ? ' highcharts-tracker' : '')
			),
			true
		);

		// Place it on first and subsequent (redraw) calls
		group.attr({ visibility: visibility })[isNew ? 'attr' : 'animate'](
			this.getPlotBox()
		);
		return group;
	},

	/**
	 * Get the translation and scale for the plot area of this series.
	 */
	getPlotBox: function () {
		var chart = this.chart,
			xAxis = this.xAxis,
			yAxis = this.yAxis;

		// Swap axes for inverted (#2339)
		if (chart.inverted) {
			xAxis = yAxis;
			yAxis = this.xAxis;
		}
		return {
			translateX: xAxis ? xAxis.left : chart.plotLeft,
			translateY: yAxis ? yAxis.top : chart.plotTop,
			scaleX: 1, // #1623
			scaleY: 1
		};
	},

	/**
	 * Render the graph and markers. Called internally when first rendering and
	 * later when redrawing the chart. This function can be extended in plugins,
	 * but normally shouldn't be called directly.
	 */
	render: function () {
		var series = this,
			chart = series.chart,
			group,
			options = series.options,
			// Animation doesn't work in IE8 quirks when the group div is
			// hidden, and looks bad in other oldIE
			animDuration = (
				!!series.animate &&
				chart.renderer.isSVG &&
				animObject(options.animation).duration
			),
			visibility = series.visible ? 'inherit' : 'hidden', // #2597
			zIndex = options.zIndex,
			hasRendered = series.hasRendered,
			chartSeriesGroup = chart.seriesGroup,
			inverted = chart.inverted;

		// the group
		group = series.plotGroup(
			'group',
			'series',
			visibility,
			zIndex,
			chartSeriesGroup
		);

		series.markerGroup = series.plotGroup(
			'markerGroup',
			'markers',
			visibility,
			zIndex,
			chartSeriesGroup
		);

		// initiate the animation
		if (animDuration) {
			series.animate(true);
		}

		// SVGRenderer needs to know this before drawing elements (#1089, #1795)
		group.inverted = series.isCartesian ? inverted : false;

		// draw the graph if any
		if (series.drawGraph) {
			series.drawGraph();
			series.applyZones();
		}

/*		each(series.points, function (point) {
			if (point.redraw) {
				point.redraw();
			}
		});*/

		// draw the data labels (inn pies they go before the points)
		if (series.drawDataLabels) {
			series.drawDataLabels();
		}

		// draw the points
		if (series.visible) {
			series.drawPoints();
		}


		// draw the mouse tracking area
		if (
			series.drawTracker &&
			series.options.enableMouseTracking !== false
		) {
			series.drawTracker();
		}

		// Handle inverted series and tracker groups
		series.invertGroups(inverted);

		// Initial clipping, must be defined after inverting groups for VML.
		// Applies to columns etc. (#3839).
		if (options.clip !== false && !series.sharedClipKey && !hasRendered) {
			group.clip(chart.clipRect);
		}

		// Run the animation
		if (animDuration) {
			series.animate();
		}

		// Call the afterAnimate function on animation complete (but don't
		// overwrite the animation.complete option which should be available to
		// the user).
		if (!hasRendered) {
			series.animationTimeout = syncTimeout(function () {
				series.afterAnimate();
			}, animDuration);
		}

		series.isDirty = false; // means data is in accordance with what you see
		// (See #322) series.isDirty = series.isDirtyData = false; // means
		// data is in accordance with what you see
		series.hasRendered = true;
	},

	/**
	 * Redraw the series. This function is called internally from `chart.redraw`
	 * and normally shouldn't be called directly.
	 *
	 * @private
	 */
	redraw: function () {
		var series = this,
			chart = series.chart,
			// cache it here as it is set to false in render, but used after
			wasDirty = series.isDirty || series.isDirtyData,
			group = series.group,
			xAxis = series.xAxis,
			yAxis = series.yAxis;

		// reposition on resize
		if (group) {
			if (chart.inverted) {
				group.attr({
					width: chart.plotWidth,
					height: chart.plotHeight
				});
			}

			group.animate({
				translateX: pick(xAxis && xAxis.left, chart.plotLeft),
				translateY: pick(yAxis && yAxis.top, chart.plotTop)
			});
		}

		series.translate();
		series.render();
		if (wasDirty) { // #3868, #3945
			delete this.kdTree;
		}
	},

	kdAxisArray: ['clientX', 'plotY'],

	searchPoint: function (e, compareX) {
		var series = this,
			xAxis = series.xAxis,
			yAxis = series.yAxis,
			inverted = series.chart.inverted;

		return this.searchKDTree({
			clientX: inverted ?
				xAxis.len - e.chartY + xAxis.pos :
				e.chartX - xAxis.pos,
			plotY: inverted ?
				yAxis.len - e.chartX + yAxis.pos :
				e.chartY - yAxis.pos
		}, compareX);
	},

	/**
	 * Build the k-d-tree that is used by mouse and touch interaction to get the
	 * closest point. Line-like series typically have a one-dimensional tree
	 * where points are searched along the X axis, while scatter-like series
	 * typically search in two dimensions, X and Y.
	 *
	 * @private
	 */
	buildKDTree: function () {

		// Prevent multiple k-d-trees from being built simultaneously (#6235)
		this.buildingKdTree = true;

		var series = this,
			dimensions = series.options.findNearestPointBy.indexOf('y') > -1 ?
							2 : 1;

		// Internal function
		function _kdtree(points, depth, dimensions) {
			var axis,
				median,
				length = points && points.length;

			if (length) {

				// alternate between the axis
				axis = series.kdAxisArray[depth % dimensions];

				// sort point array
				points.sort(function (a, b) {
					return a[axis] - b[axis];
				});

				median = Math.floor(length / 2);

				// build and return nod
				return {
					point: points[median],
					left: _kdtree(
						points.slice(0, median), depth + 1, dimensions
					),
					right: _kdtree(
						points.slice(median + 1), depth + 1, dimensions
					)
				};

			}
		}

		// Start the recursive build process with a clone of the points array
		// and null points filtered out (#3873)
		function startRecursive() {
			series.kdTree = _kdtree(
				series.getValidPoints(
					null,
					// For line-type series restrict to plot area, but
					// column-type series not (#3916, #4511)
					!series.directTouch
				),
				dimensions,
				dimensions
			);
			series.buildingKdTree = false;
		}
		delete series.kdTree;

		// For testing tooltips, don't build async
		syncTimeout(startRecursive, series.options.kdNow ? 0 : 1);
	},

	searchKDTree: function (point, compareX) {
		var series = this,
			kdX = this.kdAxisArray[0],
			kdY = this.kdAxisArray[1],
			kdComparer = compareX ? 'distX' : 'dist',
			kdDimensions = series.options.findNearestPointBy.indexOf('y') > -1 ?
							2 : 1;

		// Set the one and two dimensional distance on the point object
		function setDistance(p1, p2) {
			var x = (defined(p1[kdX]) && defined(p2[kdX])) ?
					Math.pow(p1[kdX] - p2[kdX], 2) :
					null,
				y = (defined(p1[kdY]) && defined(p2[kdY])) ?
					Math.pow(p1[kdY] - p2[kdY], 2) :
					null,
				r = (x || 0) + (y || 0);

			p2.dist = defined(r) ? Math.sqrt(r) : Number.MAX_VALUE;
			p2.distX = defined(x) ? Math.sqrt(x) : Number.MAX_VALUE;
		}
		function _search(search, tree, depth, dimensions) {
			var point = tree.point,
				axis = series.kdAxisArray[depth % dimensions],
				tdist,
				sideA,
				sideB,
				ret = point,
				nPoint1,
				nPoint2;

			setDistance(search, point);

			// Pick side based on distance to splitting point
			tdist = search[axis] - point[axis];
			sideA = tdist < 0 ? 'left' : 'right';
			sideB = tdist < 0 ? 'right' : 'left';

			// End of tree
			if (tree[sideA]) {
				nPoint1 = _search(search, tree[sideA], depth + 1, dimensions);

				ret = (nPoint1[kdComparer] < ret[kdComparer] ? nPoint1 : point);
			}
			if (tree[sideB]) {
				// compare distance to current best to splitting point to decide
				// wether to check side B or not
				if (Math.sqrt(tdist * tdist) < ret[kdComparer]) {
					nPoint2 = _search(
						search,
						tree[sideB],
						depth + 1,
						dimensions
					);
					ret = nPoint2[kdComparer] < ret[kdComparer] ?
						nPoint2 :
						ret;
				}
			}

			return ret;
		}

		if (!this.kdTree && !this.buildingKdTree) {
			this.buildKDTree();
		}

		if (this.kdTree) {
			return _search(point, this.kdTree, kdDimensions, kdDimensions);
		}
	}

}); // end Series prototype

/**
 * A line series displays information as a series of data points connected by
 * straight line segments.
 *
 * @sample {highcharts} highcharts/demo/line-basic/ Line chart
 * @sample {highstock} stock/demo/basic-line/ Line chart
 * 
 * @extends plotOptions.series
 * @product highcharts highstock
 * @apioption plotOptions.line
 */

/**
 * A `line` series. If the [type](#series.line.type) option is not
 * specified, it is inherited from [chart.type](#chart.type).
 * 
 * For options that apply to multiple series, it is recommended to add
 * them to the [plotOptions.series](#plotOptions.series) options structure.
 * To apply to all series of this specific type, apply it to [plotOptions.
 * line](#plotOptions.line).
 * 
 * @type {Object}
 * @extends series,plotOptions.line
 * @excluding dataParser,dataURL
 * @product highcharts highstock
 * @apioption series.line
 */

/**
 * An array of data points for the series. For the `line` series type,
 * points can be given in the following ways:
 * 
 * 1.  An array of numerical values. In this case, the numerical values
 * will be interpreted as `y` options. The `x` values will be automatically
 * calculated, either starting at 0 and incremented by 1, or from `pointStart`
 * and `pointInterval` given in the series options. If the axis has
 * categories, these will be used. Example:
 * 
 *  ```js
 *  data: [0, 5, 3, 5]
 *  ```
 * 
 * 2.  An array of arrays with 2 values. In this case, the values correspond
 * to `x,y`. If the first value is a string, it is applied as the name
 * of the point, and the `x` value is inferred.
 * 
 *  ```js
 *     data: [
 *         [0, 1],
 *         [1, 2],
 *         [2, 8]
 *     ]
 *  ```
 * 
 * 3.  An array of objects with named values. The objects are point
 * configuration objects as seen below. If the total number of data
 * points exceeds the series' [turboThreshold](#series.line.turboThreshold),
 * this option is not available.
 * 
 *  ```js
 *     data: [{
 *         x: 1,
 *         y: 9,
 *         name: "Point2",
 *         color: "#00FF00"
 *     }, {
 *         x: 1,
 *         y: 6,
 *         name: "Point1",
 *         color: "#FF00FF"
 *     }]
 *  ```
 * 
 * @type {Array<Object|Array|Number>}
 * @sample {highcharts} highcharts/chart/reflow-true/ Numerical values
 * @sample {highcharts} highcharts/series/data-array-of-arrays/ Arrays of numeric x and y
 * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/ Arrays of datetime x and y
 * @sample {highcharts} highcharts/series/data-array-of-name-value/ Arrays of point.name and y
 * @sample {highcharts} highcharts/series/data-array-of-objects/ Config objects
 * @apioption series.line.data
 */

/**
 * An additional, individual class name for the data point's graphic
 * representation.
 * 
 * @type {String}
 * @since 5.0.0
 * @product highcharts
 * @apioption series.line.data.className
 */

/**
 * Individual color for the point. By default the color is pulled from
 * the global `colors` array.
 *
 * In styled mode, the `color` option doesn't take effect. Instead, use 
 * `colorIndex`.
 * 
 * @type {Color}
 * @sample {highcharts} highcharts/point/color/ Mark the highest point
 * @default undefined
 * @product highcharts highstock
 * @apioption series.line.data.color
 */

/**
 * Styled mode only. A specific color index to use for the point, so its
 * graphic representations are given the class name
 * `highcharts-color-{n}`.
 * 
 * @type {Number}
 * @since 5.0.0
 * @product highcharts
 * @apioption series.line.data.colorIndex
 */

/**
 * Individual data label for each point. The options are the same as
 * the ones for [plotOptions.series.dataLabels](#plotOptions.series.
 * dataLabels)
 * 
 * @type {Object}
 * @sample {highcharts} highcharts/point/datalabels/ Show a label for the last value
 * @sample {highstock} highcharts/point/datalabels/ Show a label for the last value
 * @product highcharts highstock
 * @apioption series.line.data.dataLabels
 */

/**
 * A description of the point to add to the screen reader information
 * about the point. Requires the Accessibility module.
 * 
 * @type {String}
 * @default undefined
 * @since 5.0.0
 * @apioption series.line.data.description
 */

/**
 * An id for the point. This can be used after render time to get a
 * pointer to the point object through `chart.get()`.
 * 
 * @type {String}
 * @sample {highcharts} highcharts/point/id/ Remove an id'd point
 * @default null
 * @since 1.2.0
 * @product highcharts highstock
 * @apioption series.line.data.id
 */

/**
 * The rank for this point's data label in case of collision. If two
 * data labels are about to overlap, only the one with the highest `labelrank`
 * will be drawn.
 * 
 * @type {Number}
 * @apioption series.line.data.labelrank
 */

/**
 * The name of the point as shown in the legend, tooltip, dataLabel
 * etc.
 * 
 * @type {String}
 * @sample {highcharts} highcharts/series/data-array-of-objects/ Point names
 * @see [xAxis.uniqueNames](#xAxis.uniqueNames)
 * @apioption series.line.data.name
 */

/**
 * Whether the data point is selected initially.
 * 
 * @type {Boolean}
 * @default false
 * @product highcharts highstock
 * @apioption series.line.data.selected
 */

/**
 * The x value of the point. For datetime axes, the X value is the timestamp
 * in milliseconds since 1970.
 * 
 * @type {Number}
 * @product highcharts highstock
 * @apioption series.line.data.x
 */

/**
 * The y value of the point.
 * 
 * @type {Number}
 * @default null
 * @product highcharts highstock
 * @apioption series.line.data.y
 */

/**
 * Individual point events
 * 
 * @extends plotOptions.series.point.events
 * @product highcharts highstock
 * @apioption series.line.data.events
 */

/**
 * @extends plotOptions.series.marker
 * @product highcharts highstock
 * @apioption series.line.data.marker
 */

}(Highcharts));
(function (H) {
/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var Axis = H.Axis,
	Chart = H.Chart,
	correctFloat = H.correctFloat,
	defined = H.defined,
	destroyObjectProperties = H.destroyObjectProperties,
	each = H.each,
	format = H.format,
	objectEach = H.objectEach,
	pick = H.pick,
	Series = H.Series;

/**
 * The class for stacks. Each stack, on a specific X value and either negative
 * or positive, has its own stack item.
 *
 * @class
 */
H.StackItem = function (axis, options, isNegative, x, stackOption) {

	var inverted = axis.chart.inverted;

	this.axis = axis;

	// Tells if the stack is negative
	this.isNegative = isNegative;

	// Save the options to be able to style the label
	this.options = options;

	// Save the x value to be able to position the label later
	this.x = x;

	// Initialize total value
	this.total = null;

	// This will keep each points' extremes stored by series.index and point 
	// index
	this.points = {};

	// Save the stack option on the series configuration object, and whether to 
	// treat it as percent
	this.stack = stackOption;
	this.leftCliff = 0;
	this.rightCliff = 0;

	// The align options and text align varies on whether the stack is negative 
	// and if the chart is inverted or not.
	// First test the user supplied value, then use the dynamic.
	this.alignOptions = {
		align: options.align ||
			(inverted ? (isNegative ? 'left' : 'right') : 'center'),
		verticalAlign: options.verticalAlign || 
			(inverted ? 'middle' : (isNegative ? 'bottom' : 'top')),
		y: pick(options.y, inverted ? 4 : (isNegative ? 14 : -6)),
		x: pick(options.x, inverted ? (isNegative ? -6 : 6) : 0)
	};

	this.textAlign = options.textAlign ||
		(inverted ? (isNegative ? 'right' : 'left') : 'center');
};

H.StackItem.prototype = {
	destroy: function () {
		destroyObjectProperties(this, this.axis);
	},

	/**
	 * Renders the stack total label and adds it to the stack label group.
	 */
	render: function (group) {
		var chart = this.axis.chart,
			options = this.options,
			formatOption = options.format,
			str = formatOption ?
				format(formatOption, this, chart.time) :
				options.formatter.call(this);  // format the text in the label

		// Change the text to reflect the new total and set visibility to hidden
		// in case the serie is hidden
		if (this.label) {
			this.label.attr({ text: str, visibility: 'hidden' });
		// Create new label
		} else {
			this.label =
				chart.renderer.text(str, null, null, options.useHTML)
					.css(options.style)
					.attr({
						align: this.textAlign,
						rotation: options.rotation,
						visibility: 'hidden' // hidden until setOffset is called
					})
					.add(group); // add to the labels-group
		}
	},

	/**
	 * Sets the offset that the stack has from the x value and repositions the
	 * label.
	 */
	setOffset: function (xOffset, xWidth) {
		var stackItem = this,
			axis = stackItem.axis,
			chart = axis.chart,
			// stack value translated mapped to chart coordinates
			y = axis.translate(
				axis.usePercentage ? 100 : stackItem.total,
				0,
				0,
				0,
				1
			),
			yZero = axis.translate(0), // stack origin
			h = Math.abs(y - yZero), // stack height
			x = chart.xAxis[0].translate(stackItem.x) + xOffset, // x position
			stackBox = stackItem.getStackBox(chart, stackItem, x, y, xWidth, h),
			label = stackItem.label,
			alignAttr;

		if (label) {
			// Align the label to the box
			label.align(stackItem.alignOptions, null, stackBox);

			// Set visibility (#678)
			alignAttr = label.alignAttr;
			label[
				stackItem.options.crop === false || chart.isInsidePlot(
					alignAttr.x,
					alignAttr.y
				) ? 'show' : 'hide'](true);
		}
	},
	getStackBox: function (chart, stackItem, x, y, xWidth, h) {
		var reversed = stackItem.axis.reversed,
			inverted = chart.inverted,
			plotHeight = chart.plotHeight,
			neg = (stackItem.isNegative && !reversed) ||
				(!stackItem.isNegative && reversed); // #4056

		return { // this is the box for the complete stack
			x: inverted ? (neg ? y : y - h) : x,
			y: inverted ?
					plotHeight - x - xWidth :
					(neg ?
						(plotHeight - y - h) :
						plotHeight - y
					),
			width: inverted ? h : xWidth,
			height: inverted ? xWidth : h
		};
	}
};

/**
 * Generate stacks for each series and calculate stacks total values
 */
Chart.prototype.getStacks = function () {
	var chart = this;

	// reset stacks for each yAxis
	each(chart.yAxis, function (axis) {
		if (axis.stacks && axis.hasVisibleSeries) {
			axis.oldStacks = axis.stacks;
		}
	});

	each(chart.series, function (series) {
		if (series.options.stacking && (series.visible === true ||
				chart.options.chart.ignoreHiddenSeries === false)) {
			series.stackKey = series.type + pick(series.options.stack, '');
		}
	});
};


// Stacking methods defined on the Axis prototype

/**
 * Build the stacks from top down
 */
Axis.prototype.buildStacks = function () {
	var axisSeries = this.series,
		reversedStacks = pick(this.options.reversedStacks, true),
		len = axisSeries.length,
		i;
	if (!this.isXAxis) {
		this.usePercentage = false;
		i = len;
		while (i--) {
			axisSeries[reversedStacks ? i : len - i - 1].setStackedPoints();
		}

		// Loop up again to compute percent and stream stack
		for (i = 0; i < len; i++) {
			axisSeries[i].modifyStacks();
		}
	}
};

Axis.prototype.renderStackTotals = function () {
	var axis = this,
		chart = axis.chart,
		renderer = chart.renderer,
		stacks = axis.stacks,
		stackTotalGroup = axis.stackTotalGroup;

	// Create a separate group for the stack total labels
	if (!stackTotalGroup) {
		axis.stackTotalGroup = stackTotalGroup =
			renderer.g('stack-labels')
				.attr({
					visibility: 'visible',
					zIndex: 6
				})
				.add();
	}

	// plotLeft/Top will change when y axis gets wider so we need to translate
	// the stackTotalGroup at every render call. See bug #506 and #516
	stackTotalGroup.translate(chart.plotLeft, chart.plotTop);

	// Render each stack total
	objectEach(stacks, function (type) {
		objectEach(type, function (stack) {
			stack.render(stackTotalGroup);
		});
	});
};

/**
 * Set all the stacks to initial states and destroy unused ones.
 */
Axis.prototype.resetStacks = function () {
	var axis = this,
		stacks = axis.stacks;
	if (!axis.isXAxis) {
		objectEach(stacks, function (type) {
			objectEach(type, function (stack, key) {
				// Clean up memory after point deletion (#1044, #4320)
				if (stack.touched < axis.stacksTouched) {
					stack.destroy();
					delete type[key];
		
				// Reset stacks
				} else {
					stack.total = null;
					stack.cumulative = null;
				}
			});
		});
	}
};

Axis.prototype.cleanStacks = function () {
	var stacks;

	if (!this.isXAxis) {
		if (this.oldStacks) {
			stacks = this.stacks = this.oldStacks;
		}

		// reset stacks
		objectEach(stacks, function (type) {
			objectEach(type, function (stack) {
				stack.cumulative = stack.total;
			});
		});
	}
};


// Stacking methods defnied for Series prototype

/**
 * Adds series' points value to corresponding stack
 */
Series.prototype.setStackedPoints = function () {
	if (!this.options.stacking || (this.visible !== true &&
			this.chart.options.chart.ignoreHiddenSeries !== false)) {
		return;
	}

	var series = this,
		xData = series.processedXData,
		yData = series.processedYData,
		stackedYData = [],
		yDataLength = yData.length,
		seriesOptions = series.options,
		threshold = seriesOptions.threshold,
		stackThreshold = pick(seriesOptions.startFromThreshold && threshold, 0),
		stackOption = seriesOptions.stack,
		stacking = seriesOptions.stacking,
		stackKey = series.stackKey,
		negKey = '-' + stackKey,
		negStacks = series.negStacks,
		yAxis = series.yAxis,
		stacks = yAxis.stacks,
		oldStacks = yAxis.oldStacks,
		stackIndicator,
		isNegative,
		stack,
		other,
		key,
		pointKey,
		i,
		x,
		y;


	yAxis.stacksTouched += 1;

	// loop over the non-null y values and read them into a local array
	for (i = 0; i < yDataLength; i++) {
		x = xData[i];
		y = yData[i];
		stackIndicator = series.getStackIndicator(
			stackIndicator,
			x,
			series.index
		);
		pointKey = stackIndicator.key;
		// Read stacked values into a stack based on the x value,
		// the sign of y and the stack key. Stacking is also handled for null
		// values (#739)
		isNegative = negStacks && y < (stackThreshold ? 0 : threshold);
		key = isNegative ? negKey : stackKey;

		// Create empty object for this stack if it doesn't exist yet
		if (!stacks[key]) {
			stacks[key] = {};
		}

		// Initialize StackItem for this x
		if (!stacks[key][x]) {
			if (oldStacks[key] && oldStacks[key][x]) {
				stacks[key][x] = oldStacks[key][x];
				stacks[key][x].total = null;
			} else {
				stacks[key][x] = new H.StackItem(
					yAxis,
					yAxis.options.stackLabels,
					isNegative,
					x,
					stackOption
				);
			}
		}

		// If the StackItem doesn't exist, create it first
		stack = stacks[key][x];
		if (y !== null) {
			stack.points[pointKey] = stack.points[series.index] =
				[pick(stack.cumulative, stackThreshold)];

			// Record the base of the stack
			if (!defined(stack.cumulative)) {
				stack.base = pointKey;
			}
			stack.touched = yAxis.stacksTouched;
		

			// In area charts, if there are multiple points on the same X value,
			// let the area fill the full span of those points
			if (stackIndicator.index > 0 && series.singleStacks === false) {
				stack.points[pointKey][0] =
					stack.points[series.index + ',' + x + ',0'][0];
			}

		// When updating to null, reset the point stack (#7493)
		} else {
			stack.points[pointKey] = stack.points[series.index] = null;
		}

		// Add value to the stack total
		if (stacking === 'percent') {

			// Percent stacked column, totals are the same for the positive and
			// negative stacks
			other = isNegative ? stackKey : negKey;
			if (negStacks && stacks[other] && stacks[other][x]) {
				other = stacks[other][x];
				stack.total = other.total =
					Math.max(other.total, stack.total) + Math.abs(y) || 0;

			// Percent stacked areas
			} else {
				stack.total = correctFloat(stack.total + (Math.abs(y) || 0));
			}
		} else {
			stack.total = correctFloat(stack.total + (y || 0));
		}

		stack.cumulative = pick(stack.cumulative, stackThreshold) + (y || 0);

		if (y !== null) {
			stack.points[pointKey].push(stack.cumulative);
			stackedYData[i] = stack.cumulative;
		}

	}

	if (stacking === 'percent') {
		yAxis.usePercentage = true;
	}

	this.stackedYData = stackedYData; // To be used in getExtremes

	// Reset old stacks
	yAxis.oldStacks = {};
};

/**
 * Iterate over all stacks and compute the absolute values to percent
 */
Series.prototype.modifyStacks = function () {
	var series = this,
		stackKey = series.stackKey,
		stacks = series.yAxis.stacks,
		processedXData = series.processedXData,
		stackIndicator,
		stacking = series.options.stacking;

	if (series[stacking + 'Stacker']) { // Modifier function exists
		each([stackKey, '-' + stackKey], function (key) {
			var i = processedXData.length,
				x,
				stack,
				pointExtremes;

			while (i--) {
				x = processedXData[i];
				stackIndicator = series.getStackIndicator(
					stackIndicator,
					x,
					series.index,
					key
				);
				stack = stacks[key] && stacks[key][x];
				pointExtremes = stack && stack.points[stackIndicator.key];
				if (pointExtremes) {
					series[stacking + 'Stacker'](pointExtremes, stack, i);
				}
			}
		});
	}
};

/**
 * Modifier function for percent stacks. Blows up the stack to 100%.
 */
Series.prototype.percentStacker = function (pointExtremes, stack, i) {
	var totalFactor = stack.total ? 100 / stack.total : 0;
	// Y bottom value
	pointExtremes[0] = correctFloat(pointExtremes[0] * totalFactor);
	// Y value
	pointExtremes[1] = correctFloat(pointExtremes[1] * totalFactor);
	this.stackedYData[i] = pointExtremes[1];
};

/**
* Get stack indicator, according to it's x-value, to determine points with the
* same x-value
*/
Series.prototype.getStackIndicator = function (stackIndicator, x, index, key) {
	// Update stack indicator, when:
	// first point in a stack || x changed || stack type (negative vs positive)
	// changed:
	if (!defined(stackIndicator) || stackIndicator.x !== x ||
			(key && stackIndicator.key !== key)) {
		stackIndicator = {
			x: x,
			index: 0,
			key: key
		};
	} else {
		stackIndicator.index++;
	}

	stackIndicator.key = [index, x, stackIndicator.index].join(',');

	return stackIndicator;
};

}(Highcharts));
(function (H) {
/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var addEvent = H.addEvent,
	animate = H.animate,
	Axis = H.Axis,
	Chart = H.Chart,
	createElement = H.createElement,
	css = H.css,
	defined = H.defined,
	each = H.each,
	erase = H.erase,
	extend = H.extend,
	fireEvent = H.fireEvent,
	inArray = H.inArray,
	isNumber = H.isNumber,
	isObject = H.isObject,
	isArray = H.isArray,
	merge = H.merge,
	objectEach = H.objectEach,
	pick = H.pick,
	Point = H.Point,
	Series = H.Series,
	seriesTypes = H.seriesTypes,
	setAnimation = H.setAnimation,
	splat = H.splat;
		
// Extend the Chart prototype for dynamic methods
extend(Chart.prototype, /** @lends Highcharts.Chart.prototype */ {

	/**
	 * Add a series to the chart after render time. Note that this method should
	 * never be used when adding data synchronously at chart render time, as it
	 * adds expense to the calculations and rendering. When adding data at the
	 * same time as the chart is initialized, add the series as a configuration
	 * option instead. With multiple axes, the `offset` is dynamically adjusted.
	 *
	 * @param  {SeriesOptions} options
	 *         The config options for the series.
	 * @param  {Boolean} [redraw=true]
	 *         Whether to redraw the chart after adding.
	 * @param  {AnimationOptions} animation
	 *         Whether to apply animation, and optionally animation
	 *         configuration.
	 *
	 * @return {Highcharts.Series}
	 *         The newly created series object.
	 *
	 * @sample highcharts/members/chart-addseries/
	 *         Add a series from a button
	 * @sample stock/members/chart-addseries/
	 *         Add a series in Highstock
	 */
	addSeries: function (options, redraw, animation) {
		var series,
			chart = this;

		if (options) {
			redraw = pick(redraw, true); // defaults to true

			fireEvent(chart, 'addSeries', { options: options }, function () {
				series = chart.initSeries(options);

				chart.isDirtyLegend = true; // the series array is out of sync with the display
				chart.linkSeries();
				if (redraw) {
					chart.redraw(animation);
				}
			});
		}

		return series;
	},

	/**
     * Add an axis to the chart after render time. Note that this method should
     * never be used when adding data synchronously at chart render time, as it
     * adds expense to the calculations and rendering. When adding data at the
     * same time as the chart is initialized, add the axis as a configuration
     * option instead.
     * @param  {AxisOptions} options
     *         The axis options.
     * @param  {Boolean} [isX=false]
     *         Whether it is an X axis or a value axis.
     * @param  {Boolean} [redraw=true]
     *         Whether to redraw the chart after adding.
     * @param  {AnimationOptions} [animation=true]
     *         Whether and how to apply animation in the redraw.
     *
     * @sample highcharts/members/chart-addaxis/ Add and remove axes
     *
     * @return {Axis}
     *         The newly generated Axis object.
     */
	addAxis: function (options, isX, redraw, animation) {
		var key = isX ? 'xAxis' : 'yAxis',
			chartOptions = this.options,
			userOptions = merge(options, {
				index: this[key].length,
				isX: isX
			}),
			axis;

		axis = new Axis(this, userOptions);

		// Push the new axis options to the chart options
		chartOptions[key] = splat(chartOptions[key] || {});
		chartOptions[key].push(userOptions);

		if (pick(redraw, true)) {
			this.redraw(animation);
		}

		return axis;
	},

	/**
	 * Dim the chart and show a loading text or symbol. Options for the loading
	 * screen are defined in {@link
	 * https://api.highcharts.com/highcharts/loading|the loading options}.
	 * 
	 * @param  {String} str
	 *         An optional text to show in the loading label instead of the
	 *         default one. The default text is set in {@link
	 *         http://api.highcharts.com/highcharts/lang.loading|lang.loading}.
	 *
	 * @sample highcharts/members/chart-hideloading/
	 *         Show and hide loading from a button
	 * @sample highcharts/members/chart-showloading/
	 *         Apply different text labels
	 * @sample stock/members/chart-show-hide-loading/
	 *         Toggle loading in Highstock
	 */
	showLoading: function (str) {
		var chart = this,
			options = chart.options,
			loadingDiv = chart.loadingDiv,
			loadingOptions = options.loading,
			setLoadingSize = function () {
				if (loadingDiv) {
					css(loadingDiv, {
						left: chart.plotLeft + 'px',
						top: chart.plotTop + 'px',
						width: chart.plotWidth + 'px',
						height: chart.plotHeight + 'px'
					});
				}
			};

		// create the layer at the first call
		if (!loadingDiv) {
			chart.loadingDiv = loadingDiv = createElement('div', {
				className: 'highcharts-loading highcharts-loading-hidden'
			}, null, chart.container);

			chart.loadingSpan = createElement(
				'span',
				{ className: 'highcharts-loading-inner' },
				null,
				loadingDiv
			);
			addEvent(chart, 'redraw', setLoadingSize); // #1080
		}
		
		loadingDiv.className = 'highcharts-loading';

		// Update text
		chart.loadingSpan.innerHTML = str || options.lang.loading;

		
		// Update visuals
		css(loadingDiv, extend(loadingOptions.style, {
			zIndex: 10
		}));
		css(chart.loadingSpan, loadingOptions.labelStyle);

		// Show it
		if (!chart.loadingShown) {
			css(loadingDiv, {
				opacity: 0,
				display: ''
			});
			animate(loadingDiv, {
				opacity: loadingOptions.style.opacity || 0.5
			}, {
				duration: loadingOptions.showDuration || 0
			});
		}
		

		chart.loadingShown = true;
		setLoadingSize();
	},

	/**
	 * Hide the loading layer.
	 *
	 * @see    Highcharts.Chart#showLoading
	 * @sample highcharts/members/chart-hideloading/
	 *         Show and hide loading from a button
	 * @sample stock/members/chart-show-hide-loading/
	 *         Toggle loading in Highstock
	 */
	hideLoading: function () {
		var options = this.options,
			loadingDiv = this.loadingDiv;

		if (loadingDiv) {
			loadingDiv.className = 'highcharts-loading highcharts-loading-hidden';
			
			animate(loadingDiv, {
				opacity: 0
			}, {
				duration: options.loading.hideDuration || 100,
				complete: function () {
					css(loadingDiv, { display: 'none' });
				}
			});
			
		}
		this.loadingShown = false;
	},

	/** 
	 * These properties cause isDirtyBox to be set to true when updating. Can be extended from plugins.
	 */
	propsRequireDirtyBox: ['backgroundColor', 'borderColor', 'borderWidth', 'margin', 'marginTop', 'marginRight',
		'marginBottom', 'marginLeft', 'spacing', 'spacingTop', 'spacingRight', 'spacingBottom', 'spacingLeft',
		'borderRadius', 'plotBackgroundColor', 'plotBackgroundImage', 'plotBorderColor', 'plotBorderWidth', 
		'plotShadow', 'shadow'],

	/** 
	 * These properties cause all series to be updated when updating. Can be
	 * extended from plugins.
	 */
	propsRequireUpdateSeries: ['chart.inverted', 'chart.polar',
		'chart.ignoreHiddenSeries', 'chart.type', 'colors', 'plotOptions',
		'time', 'tooltip'],

	/**
	 * A generic function to update any element of the chart. Elements can be
	 * enabled and disabled, moved, re-styled, re-formatted etc.
	 *
	 * A special case is configuration objects that take arrays, for example
	 * {@link https://api.highcharts.com/highcharts/xAxis|xAxis}, 
	 * {@link https://api.highcharts.com/highcharts/yAxis|yAxis} or 
	 * {@link https://api.highcharts.com/highcharts/series|series}. For these
	 * collections, an `id` option is used to map the new option set to an
	 * existing object. If an existing object of the same id is not found, the
	 * corresponding item is updated. So for example, running `chart.update`
	 * with a series item without an id, will cause the existing chart's series
	 * with the same index in the series array to be updated. When the
	 * `oneToOne` parameter is true, `chart.update` will also take care of
	 * adding and removing items from the collection. Read more under the
	 * parameter description below.
	 *
	 * See also the {@link https://api.highcharts.com/highcharts/responsive|
	 * responsive option set}. Switching between `responsive.rules` basically
	 * runs `chart.update` under the hood.
	 *
	 * @param  {Options} options
	 *         A configuration object for the new chart options.
	 * @param  {Boolean} [redraw=true]
	 *         Whether to redraw the chart.
	 * @param  {Boolean} [oneToOne=false]
	 *         When `true`, the `series`, `xAxis` and `yAxis` collections will
	 *         be updated one to one, and items will be either added or removed
	 *         to match the new updated options. For example, if the chart has
	 *         two series and we call `chart.update` with a configuration 
	 *         containing three series, one will be added. If we call
	 *         `chart.update` with one series, one will be removed. Setting an
	 *         empty `series` array will remove all series, but leaving out the
	 *         `series` property will leave all series untouched. If the series
	 *         have id's, the new series options will be matched by id, and the
	 *         remaining ones removed.
	 *
	 * @sample highcharts/members/chart-update/
	 *         Update chart geometry 
	 */
	update: function (options, redraw, oneToOne) {
		var chart = this,
			adders = {
				credits: 'addCredits',
				title: 'setTitle',
				subtitle: 'setSubtitle'
			},
			optionsChart = options.chart,
			updateAllAxes,
			updateAllSeries,
			newWidth,
			newHeight,
			itemsForRemoval = [];

		// If the top-level chart option is present, some special updates are required		
		if (optionsChart) {
			merge(true, chart.options.chart, optionsChart);

			// Setter function
			if ('className' in optionsChart) {
				chart.setClassName(optionsChart.className);
			}

			if ('inverted' in optionsChart || 'polar' in optionsChart) {
				// Parse options.chart.inverted and options.chart.polar together
				// with the available series.
				chart.propFromSeries();
				updateAllAxes = true;
			}

			if ('alignTicks' in optionsChart) { // #6452
				updateAllAxes = true;
			}

			objectEach(optionsChart, function (val, key) {
				if (inArray('chart.' + key, chart.propsRequireUpdateSeries) !== -1) {
					updateAllSeries = true;
				}
				// Only dirty box
				if (inArray(key, chart.propsRequireDirtyBox) !== -1) {
					chart.isDirtyBox = true;
				}
			});

			
			if ('style' in optionsChart) {
				chart.renderer.setStyle(optionsChart.style);
			}
			
		}

		// Moved up, because tooltip needs updated plotOptions (#6218)
		
		if (options.colors) {
			this.options.colors = options.colors;
		}
		

		if (options.plotOptions) {
			merge(true, this.options.plotOptions, options.plotOptions);
		}
		
		// Some option stuctures correspond one-to-one to chart objects that
		// have update methods, for example
		// options.credits => chart.credits
		// options.legend => chart.legend
		// options.title => chart.title
		// options.tooltip => chart.tooltip
		// options.subtitle => chart.subtitle
		// options.mapNavigation => chart.mapNavigation
		// options.navigator => chart.navigator
		// options.scrollbar => chart.scrollbar
		objectEach(options, function (val, key) {
			if (chart[key] && typeof chart[key].update === 'function') {
				chart[key].update(val, false);
				
			// If a one-to-one object does not exist, look for an adder function
			} else if (typeof chart[adders[key]] === 'function') {
				chart[adders[key]](val);
			}
			
			if (
				key !== 'chart' &&
				inArray(key, chart.propsRequireUpdateSeries) !== -1
			) {
				updateAllSeries = true;
			}
		});

		// Setters for collections. For axes and series, each item is referred
		// by an id. If the id is not found, it defaults to the corresponding
		// item in the collection, so setting one series without an id, will
		// update the first series in the chart. Setting two series without
		// an id will update the first and the second respectively (#6019)
		// chart.update and responsive.
		each([
			'xAxis',
			'yAxis',
			'zAxis',
			'series',
			'colorAxis',
			'pane'
		], function (coll) {
			if (options[coll]) {
				each(splat(options[coll]), function (newOptions, i) {
					var item = (
						defined(newOptions.id) &&
						chart.get(newOptions.id)
					) || chart[coll][i];
					if (item && item.coll === coll) {
						item.update(newOptions, false);

						if (oneToOne) {
							item.touched = true;
						}
					}

					// If oneToOne and no matching item is found, add one
					if (!item && oneToOne) {
						if (coll === 'series') {
							chart.addSeries(newOptions, false)
								.touched = true;
						} else if (coll === 'xAxis' || coll === 'yAxis') {
							chart.addAxis(newOptions, coll === 'xAxis', false)
								.touched = true;
						}
					}

				});

				// Add items for removal
				if (oneToOne) {
					each(chart[coll], function (item) {
						if (!item.touched) {
							itemsForRemoval.push(item);
						} else {
							delete item.touched;
						}
					});
				}


			}
		});

		each(itemsForRemoval, function (item) {
			item.remove(false);
		});

		if (updateAllAxes) {
			each(chart.axes, function (axis) {
				axis.update({}, false);
			});
		}

		// Certain options require the whole series structure to be thrown away
		// and rebuilt
		if (updateAllSeries) {
			each(chart.series, function (series) {
				series.update({}, false);
			});
		}

		// For loading, just update the options, do not redraw
		if (options.loading) {
			merge(true, chart.options.loading, options.loading);
		}

		// Update size. Redraw is forced.
		newWidth = optionsChart && optionsChart.width;
		newHeight = optionsChart && optionsChart.height;
		if ((isNumber(newWidth) && newWidth !== chart.chartWidth) ||
				(isNumber(newHeight) && newHeight !== chart.chartHeight)) {
			chart.setSize(newWidth, newHeight);
		} else if (pick(redraw, true)) {
			chart.redraw();
		}
	},

	/**
	 * Shortcut to set the subtitle options. This can also be done from {@link
	 * Chart#update} or {@link Chart#setTitle}.
	 *
	 * @param  {SubtitleOptions} options
	 *         New subtitle options. The subtitle text itself is set by the
	 *         `options.text` property.
	 */
	setSubtitle: function (options) {
		this.setTitle(undefined, options);
	}

	
});

// extend the Point prototype for dynamic methods
extend(Point.prototype, /** @lends Highcharts.Point.prototype */ {
	/**
	 * Update point with new options (typically x/y data) and optionally redraw
	 * the series.
	 *
	 * @param  {Object} options
	 *         The point options. Point options are handled as described under
	 *         the `series.type.data` item for each series type. For example
	 *         for a line series, if options is a single number, the point will
	 *         be given that number as the main y value. If it is an array, it
	 *         will be interpreted as x and y values respectively. If it is an
	 *         object, advanced options are applied. 
	 * @param  {Boolean} [redraw=true]
	 *          Whether to redraw the chart after the point is updated. If doing
	 *          more operations on the chart, it is best practice to set
	 *          `redraw` to false and call `chart.redraw()` after.
	 * @param  {AnimationOptions} [animation=true]
	 *         Whether to apply animation, and optionally animation
	 *         configuration.
	 *
	 * @sample highcharts/members/point-update-column/
	 *         Update column value
	 * @sample highcharts/members/point-update-pie/
	 *         Update pie slice
	 * @sample maps/members/point-update/
	 *         Update map area value in Highmaps
	 */
	update: function (options, redraw, animation, runEvent) {
		var point = this,
			series = point.series,
			graphic = point.graphic,
			i,
			chart = series.chart,
			seriesOptions = series.options;

		redraw = pick(redraw, true);

		function update() {

			point.applyOptions(options);

			// Update visuals
			if (point.y === null && graphic) { // #4146
				point.graphic = graphic.destroy();
			}
			if (isObject(options, true)) {
				// Destroy so we can get new elements
				if (graphic && graphic.element) {
					// "null" is also a valid symbol
					if (options && options.marker && options.marker.symbol !== undefined) {
						point.graphic = graphic.destroy();
					}
				}
				if (options && options.dataLabels && point.dataLabel) { // #2468
					point.dataLabel = point.dataLabel.destroy();
				}
				if (point.connector) {
					point.connector = point.connector.destroy(); // #7243
				}
			}

			// record changes in the parallel arrays
			i = point.index;
			series.updateParallelArrays(point, i);
			
			// Record the options to options.data. If the old or the new config
			// is an object, use point options, otherwise use raw options
			// (#4701, #4916).
			seriesOptions.data[i] = (
					isObject(seriesOptions.data[i], true) ||
					isObject(options, true)
				) ?
				point.options :
				options;

			// redraw
			series.isDirty = series.isDirtyData = true;
			if (!series.fixedBox && series.hasCartesianSeries) { // #1906, #2320
				chart.isDirtyBox = true;
			}

			if (seriesOptions.legendType === 'point') { // #1831, #1885
				chart.isDirtyLegend = true;
			}
			if (redraw) {
				chart.redraw(animation);
			}
		}

		// Fire the event with a default handler of doing the update
		if (runEvent === false) { // When called from setData
			update();
		} else {
			point.firePointEvent('update', { options: options }, update);
		}
	},

	/**
	 * Remove a point and optionally redraw the series and if necessary the axes
	 * @param  {Boolean} redraw
	 *         Whether to redraw the chart or wait for an explicit call. When
	 *         doing more operations on the chart, for example running
	 *         `point.remove()` in a loop, it is best practice to set `redraw`
	 *         to false and call `chart.redraw()` after.         
	 * @param  {AnimationOptions} [animation=false]
	 *         Whether to apply animation, and optionally animation
	 *         configuration.
	 *
	 * @sample highcharts/plotoptions/series-point-events-remove/
	 *         Remove point and confirm
	 * @sample highcharts/members/point-remove/
	 *         Remove pie slice
	 * @sample maps/members/point-remove/
	 *         Remove selected points in Highmaps
	 */
	remove: function (redraw, animation) {
		this.series.removePoint(inArray(this, this.series.data), redraw, animation);
	}
});

// Extend the series prototype for dynamic methods
extend(Series.prototype, /** @lends Series.prototype */ {
	/**
	 * Add a point to the series after render time. The point can be added at
	 * the end, or by giving it an X value, to the start or in the middle of the
	 * series.
	 * 
	 * @param  {Number|Array|Object} options
	 *         The point options. If options is a single number, a point with
	 *         that y value is appended to the series.If it is an array, it will
	 *         be interpreted as x and y values respectively. If it is an
	 *         object, advanced options as outlined under `series.data` are
	 *         applied.
	 * @param  {Boolean} [redraw=true]
	 *         Whether to redraw the chart after the point is added. When adding
	 *         more than one point, it is highly recommended that the redraw
	 *         option be set to false, and instead {@link Chart#redraw}
	 *         is explicitly called after the adding of points is finished.
	 *         Otherwise, the chart will redraw after adding each point.
	 * @param  {Boolean} [shift=false]
	 *         If true, a point is shifted off the start of the series as one is
	 *         appended to the end.
	 * @param  {AnimationOptions} [animation]
	 *         Whether to apply animation, and optionally animation
	 *         configuration.
	 *
	 * @sample highcharts/members/series-addpoint-append/
	 *         Append point
	 * @sample highcharts/members/series-addpoint-append-and-shift/
	 *         Append and shift
	 * @sample highcharts/members/series-addpoint-x-and-y/
	 *         Both X and Y values given
	 * @sample highcharts/members/series-addpoint-pie/
	 *         Append pie slice
	 * @sample stock/members/series-addpoint/
	 *         Append 100 points in Highstock
	 * @sample stock/members/series-addpoint-shift/
	 *         Append and shift in Highstock
	 * @sample maps/members/series-addpoint/
	 *         Add a point in Highmaps
	 */
	addPoint: function (options, redraw, shift, animation) {
		var series = this,
			seriesOptions = series.options,
			data = series.data,
			chart = series.chart,
			xAxis = series.xAxis,
			names = xAxis && xAxis.hasNames && xAxis.names,
			dataOptions = seriesOptions.data,
			point,
			isInTheMiddle,
			xData = series.xData,
			i,
			x;

		// Optional redraw, defaults to true
		redraw = pick(redraw, true);

		// Get options and push the point to xData, yData and series.options. In series.generatePoints
		// the Point instance will be created on demand and pushed to the series.data array.
		point = { series: series };
		series.pointClass.prototype.applyOptions.apply(point, [options]);
		x = point.x;

		// Get the insertion point
		i = xData.length;
		if (series.requireSorting && x < xData[i - 1]) {
			isInTheMiddle = true;
			while (i && xData[i - 1] > x) {
				i--;
			}
		}
		
		series.updateParallelArrays(point, 'splice', i, 0, 0); // insert undefined item
		series.updateParallelArrays(point, i); // update it

		if (names && point.name) {
			names[x] = point.name;
		}
		dataOptions.splice(i, 0, options);

		if (isInTheMiddle) {
			series.data.splice(i, 0, null);
			series.processData();
		}

		// Generate points to be added to the legend (#1329)
		if (seriesOptions.legendType === 'point') {
			series.generatePoints();
		}

		// Shift the first point off the parallel arrays
		if (shift) {
			if (data[0] && data[0].remove) {
				data[0].remove(false);
			} else {
				data.shift();
				series.updateParallelArrays(point, 'shift');

				dataOptions.shift();
			}
		}

		// redraw
		series.isDirty = true;
		series.isDirtyData = true;

		if (redraw) {
			chart.redraw(animation); // Animation is set anyway on redraw, #5665
		}
	},

	/**
	 * Remove a point from the series. Unlike the {@link Highcharts.Point#remove}
	 * method, this can also be done on a point that is not instanciated because
	 * it is outside the view or subject to Highstock data grouping.
	 *
	 * @param  {Number} i
	 *         The index of the point in the {@link Highcharts.Series.data|data}
	 *         array.
	 * @param  {Boolean} [redraw=true]
	 *         Whether to redraw the chart after the point is added. When 
	 *         removing more than one point, it is highly recommended that the
	 *         `redraw` option be set to `false`, and instead {@link
	 *         Highcharts.Chart#redraw} is explicitly called after the adding of
	 *         points is finished.
	 * @param  {AnimationOptions} [animation]
	 *         Whether and optionally how the series should be animated.
	 *
	 * @sample highcharts/members/series-removepoint/
	 *         Remove cropped point
	 */
	removePoint: function (i, redraw, animation) {

		var series = this,
			data = series.data,
			point = data[i],
			points = series.points,
			chart = series.chart,
			remove = function () {

				if (points && points.length === data.length) { // #4935
					points.splice(i, 1);
				}
				data.splice(i, 1);
				series.options.data.splice(i, 1);
				series.updateParallelArrays(point || { series: series }, 'splice', i, 1);

				if (point) {
					point.destroy();
				}

				// redraw
				series.isDirty = true;
				series.isDirtyData = true;
				if (redraw) {
					chart.redraw();
				}
			};

		setAnimation(animation, chart);
		redraw = pick(redraw, true);

		// Fire the event with a default handler of removing the point
		if (point) {
			point.firePointEvent('remove', null, remove);
		} else {
			remove();
		}
	},

	/**
	 * Remove a series and optionally redraw the chart.
	 *
	 * @param  {Boolean} [redraw=true]
	 *         Whether to redraw the chart or wait for an explicit call to
	 *         {@link Highcharts.Chart#redraw}.
	 * @param  {AnimationOptions} [animation]
	 *         Whether to apply animation, and optionally animation
	 *         configuration
	 * @param  {Boolean} [withEvent=true]
	 *         Used internally, whether to fire the series `remove` event.
	 *
	 * @sample highcharts/members/series-remove/
	 *         Remove first series from a button
	 */
	remove: function (redraw, animation, withEvent) {
		var series = this,
			chart = series.chart;

		function remove() {

			// Destroy elements
			series.destroy();

			// Redraw
			chart.isDirtyLegend = chart.isDirtyBox = true;
			chart.linkSeries();

			if (pick(redraw, true)) {
				chart.redraw(animation);
			}
		}

		// Fire the event with a default handler of removing the point
		if (withEvent !== false) {
			fireEvent(series, 'remove', null, remove);
		} else {
			remove();
		}
	},

	/**
	 * Update the series with a new set of options. For a clean and precise
	 * handling of new options, all methods and elements from the series are
	 * removed, and it is initiated from scratch. Therefore, this method is more
	 * performance expensive than some other utility methods like {@link
	 * Series#setData} or {@link Series#setVisible}.
	 *
	 * @param  {SeriesOptions} options
	 *         New options that will be merged with the series' existing
	 *         options.
	 * @param  {Boolean} [redraw=true]
	 *         Whether to redraw the chart after the series is altered. If doing
	 *         more operations on the chart, it is a good idea to set redraw to
	 *         false and call {@link Chart#redraw} after.
	 *
	 * @sample highcharts/members/series-update/
	 *         Updating series options
	 * @sample maps/members/series-update/
	 *         Update series options in Highmaps
	 */
	update: function (newOptions, redraw) {
		var series = this,
			chart = series.chart,
			// must use user options when changing type because series.options
			// is merged in with type specific plotOptions
			oldOptions = series.userOptions,
			oldType = series.oldType || series.type,
			newType = newOptions.type || oldOptions.type || chart.options.chart.type,
			proto = seriesTypes[oldType].prototype,
			n,
			groups = [
				'group',
				'markerGroup',
				'dataLabelsGroup'
			],
			preserve = [
				'navigatorSeries',
				'baseSeries'
			],

			// Animation must be enabled when calling update before the initial
			// animation has first run. This happens when calling update
			// directly after chart initialization, or when applying responsive
			// rules (#6912).
			animation = series.finishedAnimating && { animation: false };

		// Running Series.update to update the data only is an intuitive usage,
		// so we want to make sure that when used like this, we run the
		// cheaper setData function and allow animation instead of completely
		// recreating the series instance.
		if (Object.keys && Object.keys(newOptions).toString() === 'data') {
			return this.setData(newOptions.data, redraw);
		}

		// Make sure preserved properties are not destroyed (#3094)
		preserve = groups.concat(preserve);
		each(preserve, function (prop) {
			preserve[prop] = series[prop];
			delete series[prop];
		});

		// Do the merge, with some forced options
		newOptions = merge(oldOptions, animation, {
			index: series.index,
			pointStart: series.xData[0] // when updating after addPoint
		}, { data: series.options.data }, newOptions);

		// Destroy the series and delete all properties. Reinsert all methods
		// and properties from the new type prototype (#2270, #3719)
		series.remove(false, null, false);
		for (n in proto) {
			series[n] = undefined;
		}
		extend(series, seriesTypes[newType || oldType].prototype);

		// Re-register groups (#3094) and other preserved properties
		each(preserve, function (prop) {
			series[prop] = preserve[prop];
		});

		series.init(chart, newOptions);

		// Update the Z index of groups (#3380, #7397)
		if (newOptions.zIndex !== oldOptions.zIndex) {
			each(groups, function (groupName) {
				if (series[groupName]) {
					series[groupName].attr({
						zIndex: newOptions.zIndex
					});
				}
			});
		}


		series.oldType = oldType;
		chart.linkSeries(); // Links are lost in series.remove (#3028)
		if (pick(redraw, true)) {
			chart.redraw(false);
		}
	}
});

// Extend the Axis.prototype for dynamic methods
extend(Axis.prototype, /** @lends Highcharts.Axis.prototype */ {

	/**
	 * Update an axis object with a new set of options. The options are merged
	 * with the existing options, so only new or altered options need to be
	 * specified.
	 *
	 * @param  {Object} options
	 *         The new options that will be merged in with existing options on
	 *         the axis.
	 * @sample highcharts/members/axis-update/ Axis update demo
	 */
	update: function (options, redraw) {
		var chart = this.chart;

		options = chart.options[this.coll][this.options.index] =
			merge(this.userOptions, options);

		this.destroy(true);

		this.init(chart, extend(options, { events: undefined }));

		chart.isDirtyBox = true;
		if (pick(redraw, true)) {
			chart.redraw();
		}
	},

	/**
     * Remove the axis from the chart.
     *
     * @param {Boolean} [redraw=true] Whether to redraw the chart following the
     * remove.
     *
     * @sample highcharts/members/chart-addaxis/ Add and remove axes
     */
	remove: function (redraw) {
		var chart = this.chart,
			key = this.coll, // xAxis or yAxis
			axisSeries = this.series,
			i = axisSeries.length;

		// Remove associated series (#2687)
		while (i--) {
			if (axisSeries[i]) {
				axisSeries[i].remove(false);
			}
		}

		// Remove the axis
		erase(chart.axes, this);
		erase(chart[key], this);

		if (isArray(chart.options[key])) {
			chart.options[key].splice(this.options.index, 1);
		} else { // color axis, #6488
			delete chart.options[key];
		}

		each(chart[key], function (axis, i) { // Re-index, #1706
			axis.options.index = i;
		});
		this.destroy();
		chart.isDirtyBox = true;

		if (pick(redraw, true)) {
			chart.redraw();
		}
	},

	/**
	 * Update the axis title by options after render time.
	 *
	 * @param  {TitleOptions} titleOptions
	 *         The additional title options.
	 * @param  {Boolean} [redraw=true]
	 *         Whether to redraw the chart after setting the title.
	 * @sample highcharts/members/axis-settitle/ Set a new Y axis title
	 */
	setTitle: function (titleOptions, redraw) {
		this.update({ title: titleOptions }, redraw);
	},

	/**
	 * Set new axis categories and optionally redraw.
	 * @param {Array.<String>} categories - The new categories.
	 * @param {Boolean} [redraw=true] - Whether to redraw the chart.
	 * @sample highcharts/members/axis-setcategories/ Set categories by click on
	 * a button
	 */
	setCategories: function (categories, redraw) {
		this.update({ categories: categories }, redraw);
	}

});

}(Highcharts));
(function (H) {
/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var color = H.color,
	each = H.each,
	LegendSymbolMixin = H.LegendSymbolMixin,
	map = H.map,
	pick = H.pick,
	Series = H.Series,
	seriesType = H.seriesType;

/**
 * Area series type.
 * @constructor seriesTypes.area
 * @extends {Series}
 */
/**
 * The area series type.
 * @extends {plotOptions.line}
 * @product highcharts highstock
 * @sample {highcharts} highcharts/demo/area-basic/
 *         Area chart
 * @sample {highstock} stock/demo/area/
 *         Area chart
 * @optionparent plotOptions.area
 */
seriesType('area', 'line', {

	/**
	 * Fill color or gradient for the area. When `null`, the series' `color`
	 * is used with the series' `fillOpacity`.
	 * 
	 * @type {Color}
	 * @see In styled mode, the fill color can be set with the `.highcharts-area` class name.
	 * @sample {highcharts} highcharts/plotoptions/area-fillcolor-default/ Null by default
	 * @sample {highcharts} highcharts/plotoptions/area-fillcolor-gradient/ Gradient
	 * @default null
	 * @product highcharts highstock
	 * @apioption plotOptions.area.fillColor
	 */

	/**
	 * Fill opacity for the area. When you set an explicit `fillColor`,
	 * the `fillOpacity` is not applied. Instead, you should define the
	 * opacity in the `fillColor` with an rgba color definition. The `fillOpacity`
	 * setting, also the default setting, overrides the alpha component
	 * of the `color` setting.
	 * 
	 * @type {Number}
	 * @see In styled mode, the fill opacity can be set with the `.highcharts-area` class name.
	 * @sample {highcharts} highcharts/plotoptions/area-fillopacity/ Automatic fill color and fill opacity of 0.1
	 * @default {highcharts} 0.75
	 * @default {highstock} .75
	 * @product highcharts highstock
	 * @apioption plotOptions.area.fillOpacity
	 */

	/**
	 * A separate color for the graph line. By default the line takes the
	 * `color` of the series, but the lineColor setting allows setting a
	 * separate color for the line without altering the `fillColor`.
	 * 
	 * @type {Color}
	 * @see In styled mode, the line stroke can be set with the `.highcharts-graph` class name.
	 * @sample {highcharts} highcharts/plotoptions/area-linecolor/ Dark gray line
	 * @default null
	 * @product highcharts highstock
	 * @apioption plotOptions.area.lineColor
	 */

	/**
	 * A separate color for the negative part of the area.
	 * 
	 * @type {Color}
	 * @see [negativeColor](#plotOptions.area.negativeColor). In styled mode, a negative
	 * color is set with the `.highcharts-negative` class name ([view live
	 * demo](http://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/css/series-
	 * negative-color/)).
	 * @since 3.0
	 * @product highcharts
	 * @apioption plotOptions.area.negativeFillColor
	 */
	
	/**
	 * When this is true, the series will not cause the Y axis to cross
	 * the zero plane (or [threshold](#plotOptions.series.threshold) option)
	 * unless the data actually crosses the plane.
	 * 
	 * For example, if `softThreshold` is `false`, a series of 0, 1, 2,
	 * 3 will make the Y axis show negative values according to the `minPadding`
	 * option. If `softThreshold` is `true`, the Y axis starts at 0.
	 * 
	 * @type {Boolean}
	 * @default false
	 * @since 4.1.9
	 * @product highcharts highstock
	 */
	softThreshold: false,

	/**
	 * The Y axis value to serve as the base for the area, for distinguishing
	 * between values above and below a threshold. If `null`, the area
	 * behaves like a line series with fill between the graph and the Y
	 * axis minimum.
	 * 
	 * @type {Number}
	 * @sample {highcharts} highcharts/plotoptions/area-threshold/ A threshold of 100
	 * @default 0
	 * @since 2.0
	 * @product highcharts highstock
	 */
	threshold: 0
	
	/**
	 * Whether the whole area or just the line should respond to mouseover
	 * tooltips and other mouse or touch events.
	 * 
	 * @type {Boolean}
	 * @sample {highcharts} highcharts/plotoptions/area-trackbyarea/ Display the tooltip when the     area is hovered
	 * @sample {highstock} highcharts/plotoptions/area-trackbyarea/ Display the tooltip when the     area is hovered
	 * @default false
	 * @since 1.1.6
	 * @product highcharts highstock
	 * @apioption plotOptions.area.trackByArea
	 */
	

}, /** @lends seriesTypes.area.prototype */ {
	singleStacks: false,
	/** 
	 * Return an array of stacked points, where null and missing points are replaced by 
	 * dummy points in order for gaps to be drawn correctly in stacks.
	 */
	getStackPoints: function (points) {
		var series = this,
			segment = [],
			keys = [],
			xAxis = this.xAxis,
			yAxis = this.yAxis,
			stack = yAxis.stacks[this.stackKey],
			pointMap = {},
			seriesIndex = series.index,
			yAxisSeries = yAxis.series,
			seriesLength = yAxisSeries.length,
			visibleSeries,
			upOrDown = pick(yAxis.options.reversedStacks, true) ? 1 : -1,
			i;


		points = points || this.points;

		if (this.options.stacking) {
			
			for (i = 0; i < points.length; i++) {
				// Reset after point update (#7326)
				points[i].leftNull = points[i].rightNull = null;

				// Create a map where we can quickly look up the points by their
				// X values.
				pointMap[points[i].x] = points[i];
			}

			// Sort the keys (#1651)
			H.objectEach(stack, function (stackX, x) {
				if (stackX.total !== null) { // nulled after switching between grouping and not (#1651, #2336)
					keys.push(x);
				}
			});
			keys.sort(function (a, b) {
				return a - b;
			});

			visibleSeries = map(yAxisSeries, function () {
				return this.visible;
			});

			each(keys, function (x, idx) {
				var y = 0,
					stackPoint,
					stackedValues;

				if (pointMap[x] && !pointMap[x].isNull) {
					segment.push(pointMap[x]);

					// Find left and right cliff. -1 goes left, 1 goes right.
					each([-1, 1], function (direction) {
						var nullName = direction === 1 ? 'rightNull' : 'leftNull',
							cliffName = direction === 1 ? 'rightCliff' : 'leftCliff',
							cliff = 0,
							otherStack = stack[keys[idx + direction]];

						// If there is a stack next to this one, to the left or to the right...
						if (otherStack) {
							i = seriesIndex;
							while (i >= 0 && i < seriesLength) { // Can go either up or down, depending on reversedStacks
								stackPoint = otherStack.points[i];
								if (!stackPoint) {
									// If the next point in this series is missing, mark the point
									// with point.leftNull or point.rightNull = true.
									if (i === seriesIndex) {
										pointMap[x][nullName] = true;

									// If there are missing points in the next stack in any of the 
									// series below this one, we need to substract the missing values
									// and add a hiatus to the left or right.
									} else if (visibleSeries[i]) {
										stackedValues = stack[x].points[i];
										if (stackedValues) {
											cliff -= stackedValues[1] - stackedValues[0];
										}
									}
								}
								// When reversedStacks is true, loop up, else loop down
								i += upOrDown; 
							}					
						}
						pointMap[x][cliffName] = cliff;
					});


				// There is no point for this X value in this series, so we 
				// insert a dummy point in order for the areas to be drawn
				// correctly.
				} else {

					// Loop down the stack to find the series below this one that has
					// a value (#1991)
					i = seriesIndex;
					while (i >= 0 && i < seriesLength) {
						stackPoint = stack[x].points[i];
						if (stackPoint) {
							y = stackPoint[1];
							break;
						}
						// When reversedStacks is true, loop up, else loop down
						i += upOrDown;
					}
					y = yAxis.translate(y, 0, 1, 0, 1); // #6272
					segment.push({ 
						isNull: true,
						plotX: xAxis.translate(x, 0, 0, 0, 1), // #6272
						x: x,
						plotY: y,
						yBottom: y
					});
				}
			});

		} 

		return segment;
	},

	getGraphPath: function (points) {
		var getGraphPath = Series.prototype.getGraphPath,
			graphPath,
			options = this.options,
			stacking = options.stacking,
			yAxis = this.yAxis,
			topPath,
			bottomPath,
			bottomPoints = [],
			graphPoints = [],
			seriesIndex = this.index,
			i,
			areaPath,
			plotX,
			stacks = yAxis.stacks[this.stackKey],
			threshold = options.threshold,
			translatedThreshold = yAxis.getThreshold(options.threshold),
			isNull,
			yBottom,
			connectNulls = options.connectNulls || stacking === 'percent',
			/**
			 * To display null points in underlying stacked series, this series graph must be 
			 * broken, and the area also fall down to fill the gap left by the null point. #2069
			 */
			addDummyPoints = function (i, otherI, side) {
				var point = points[i],
					stackedValues = stacking && stacks[point.x].points[seriesIndex],
					nullVal = point[side + 'Null'] || 0,
					cliffVal = point[side + 'Cliff'] || 0,
					top,
					bottom,
					isNull = true;

				if (cliffVal || nullVal) {

					top = (nullVal ? stackedValues[0] : stackedValues[1]) + cliffVal;
					bottom = stackedValues[0] + cliffVal;
					isNull = !!nullVal;
				
				} else if (!stacking && points[otherI] && points[otherI].isNull) {
					top = bottom = threshold;
				}

				// Add to the top and bottom line of the area
				if (top !== undefined) {
					graphPoints.push({
						plotX: plotX,
						plotY: top === null ? translatedThreshold : yAxis.getThreshold(top),
						isNull: isNull,
						isCliff: true
					});
					bottomPoints.push({
						plotX: plotX,
						plotY: bottom === null ? translatedThreshold : yAxis.getThreshold(bottom),
						doCurve: false // #1041, gaps in areaspline areas
					});
				}
			};

		// Find what points to use
		points = points || this.points;

		// Fill in missing points
		if (stacking) {
			points = this.getStackPoints(points);
		}

		for (i = 0; i < points.length; i++) {
			isNull = points[i].isNull;
			plotX = pick(points[i].rectPlotX, points[i].plotX);
			yBottom = pick(points[i].yBottom, translatedThreshold);

			if (!isNull || connectNulls) {

				if (!connectNulls) {
					addDummyPoints(i, i - 1, 'left');
				}

				if (!(isNull && !stacking && connectNulls)) { // Skip null point when stacking is false and connectNulls true
					graphPoints.push(points[i]);
					bottomPoints.push({
						x: i,
						plotX: plotX,
						plotY: yBottom
					});
				}

				if (!connectNulls) {
					addDummyPoints(i, i + 1, 'right');
				}
			}
		}

		topPath = getGraphPath.call(this, graphPoints, true, true);
		
		bottomPoints.reversed = true;
		bottomPath = getGraphPath.call(this, bottomPoints, true, true);
		if (bottomPath.length) {
			bottomPath[0] = 'L';
		}

		areaPath = topPath.concat(bottomPath);
		graphPath = getGraphPath.call(this, graphPoints, false, connectNulls); // TODO: don't set leftCliff and rightCliff when connectNulls?

		areaPath.xMap = topPath.xMap;
		this.areaPath = areaPath;

		return graphPath;
	},

	/**
	 * Draw the graph and the underlying area. This method calls the Series base
	 * function and adds the area. The areaPath is calculated in the getSegmentPath
	 * method called from Series.prototype.drawGraph.
	 */
	drawGraph: function () {

		// Define or reset areaPath
		this.areaPath = [];

		// Call the base method
		Series.prototype.drawGraph.apply(this);

		// Define local variables
		var series = this,
			areaPath = this.areaPath,
			options = this.options,
			zones = this.zones,
			props = [[
				'area',
				'highcharts-area',
				
				this.color,
				options.fillColor
				
			]]; // area name, main color, fill color
		
		each(zones, function (zone, i) {
			props.push([
				'zone-area-' + i, 
				'highcharts-area highcharts-zone-area-' + i + ' ' + zone.className,
				
				zone.color || series.color, 
				zone.fillColor || options.fillColor
				
			]);
		});

		each(props, function (prop) {
			var areaKey = prop[0],
				area = series[areaKey];

			// Create or update the area
			if (area) { // update
				area.endX = series.preventGraphAnimation ? null : areaPath.xMap;
				area.animate({ d: areaPath });

			} else { // create
				area = series[areaKey] = series.chart.renderer.path(areaPath)
					.addClass(prop[1])
					.attr({
						
						fill: pick(
							prop[3],
							color(prop[2]).setOpacity(pick(options.fillOpacity, 0.75)).get()
						),
						
						zIndex: 0 // #1069
					}).add(series.group);
				area.isArea = true;
			}
			area.startX = areaPath.xMap;
			area.shiftUnit = options.step ? 2 : 1;
		});
	},

	drawLegendSymbol: LegendSymbolMixin.drawRectangle
});

/**
 * A `area` series. If the [type](#series.area.type) option is not
 * specified, it is inherited from [chart.type](#chart.type).
 * 
 * For options that apply to multiple series, it is recommended to add
 * them to the [plotOptions.series](#plotOptions.series) options structure.
 * To apply to all series of this specific type, apply it to [plotOptions.
 * area](#plotOptions.area).
 * 
 * @type {Object}
 * @extends series,plotOptions.area
 * @excluding dataParser,dataURL
 * @product highcharts highstock
 * @apioption series.area
 */

/**
 * An array of data points for the series. For the `area` series type,
 * points can be given in the following ways:
 * 
 * 1.  An array of numerical values. In this case, the numerical values
 * will be interpreted as `y` options. The `x` values will be automatically
 * calculated, either starting at 0 and incremented by 1, or from `pointStart`
 * and `pointInterval` given in the series options. If the axis has
 * categories, these will be used. Example:
 * 
 *  ```js
 *  data: [0, 5, 3, 5]
 *  ```
 * 
 * 2.  An array of arrays with 2 values. In this case, the values correspond
 * to `x,y`. If the first value is a string, it is applied as the name
 * of the point, and the `x` value is inferred.
 * 
 *  ```js
 *     data: [
 *         [0, 9],
 *         [1, 7],
 *         [2, 6]
 *     ]
 *  ```
 * 
 * 3.  An array of objects with named values. The objects are point
 * configuration objects as seen below. If the total number of data
 * points exceeds the series' [turboThreshold](#series.area.turboThreshold),
 * this option is not available.
 * 
 *  ```js
 *     data: [{
 *         x: 1,
 *         y: 9,
 *         name: "Point2",
 *         color: "#00FF00"
 *     }, {
 *         x: 1,
 *         y: 6,
 *         name: "Point1",
 *         color: "#FF00FF"
 *     }]
 *  ```
 * 
 * @type {Array<Object|Array|Number>}
 * @extends series.line.data
 * @sample {highcharts} highcharts/chart/reflow-true/ Numerical values
 * @sample {highcharts} highcharts/series/data-array-of-arrays/ Arrays of numeric x and y
 * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/ Arrays of datetime x and y
 * @sample {highcharts} highcharts/series/data-array-of-name-value/ Arrays of point.name and y
 * @sample {highcharts} highcharts/series/data-array-of-objects/ Config objects
 * @product highcharts highstock
 * @apioption series.area.data
 */

}(Highcharts));
(function (H) {
/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var pick = H.pick,
	seriesType = H.seriesType;

/**
 * A spline series is a special type of line series, where the segments between
 * the data points are smoothed.
 *
 * @sample {highcharts} highcharts/demo/spline-irregular-time/ Spline chart
 * @sample {highstock} stock/demo/spline/ Spline chart
 * 
 * @extends plotOptions.series
 * @excluding step
 * @product highcharts highstock
 * @apioption plotOptions.spline
 */

/**
 * Spline series type.
 * @constructor seriesTypes.spline
 * @extends {Series}
 */
seriesType('spline', 'line', {}, /** @lends seriesTypes.spline.prototype */ {
	/**
	 * Get the spline segment from a given point's previous neighbour to the
	 * given point
	 */
	getPointSpline: function (points, point, i) {
		var 
			// 1 means control points midway between points, 2 means 1/3 from
			// the point, 3 is 1/4 etc
			smoothing = 1.5,
			denom = smoothing + 1,
			plotX = point.plotX,
			plotY = point.plotY,
			lastPoint = points[i - 1],
			nextPoint = points[i + 1],
			leftContX,
			leftContY,
			rightContX,
			rightContY,
			ret;

		function doCurve(otherPoint) {
			return otherPoint &&
				!otherPoint.isNull &&
				otherPoint.doCurve !== false &&
				!point.isCliff; // #6387, area splines next to null
		}

		// Find control points
		if (doCurve(lastPoint) && doCurve(nextPoint)) {
			var lastX = lastPoint.plotX,
				lastY = lastPoint.plotY,
				nextX = nextPoint.plotX,
				nextY = nextPoint.plotY,
				correction = 0;

			leftContX = (smoothing * plotX + lastX) / denom;
			leftContY = (smoothing * plotY + lastY) / denom;
			rightContX = (smoothing * plotX + nextX) / denom;
			rightContY = (smoothing * plotY + nextY) / denom;

			// Have the two control points make a straight line through main
			// point
			if (rightContX !== leftContX) { // #5016, division by zero
				correction = ((rightContY - leftContY) * (rightContX - plotX)) /
					(rightContX - leftContX) + plotY - rightContY;
			}

			leftContY += correction;
			rightContY += correction;

			// to prevent false extremes, check that control points are between
			// neighbouring points' y values
			if (leftContY > lastY && leftContY > plotY) {
				leftContY = Math.max(lastY, plotY);
				// mirror of left control point
				rightContY = 2 * plotY - leftContY;
			} else if (leftContY < lastY && leftContY < plotY) {
				leftContY = Math.min(lastY, plotY);
				rightContY = 2 * plotY - leftContY;
			}
			if (rightContY > nextY && rightContY > plotY) {
				rightContY = Math.max(nextY, plotY);
				leftContY = 2 * plotY - rightContY;
			} else if (rightContY < nextY && rightContY < plotY) {
				rightContY = Math.min(nextY, plotY);
				leftContY = 2 * plotY - rightContY;
			}

			// record for drawing in next point
			point.rightContX = rightContX;
			point.rightContY = rightContY;

			
		}

		// Visualize control points for debugging
		/*
		if (leftContX) {
			this.chart.renderer.circle(
					leftContX + this.chart.plotLeft,
					leftContY + this.chart.plotTop,
					2
				)
				.attr({
					stroke: 'red',
					'stroke-width': 2,
					fill: 'none',
					zIndex: 9
				})
				.add();
			this.chart.renderer.path(['M', leftContX + this.chart.plotLeft,
				leftContY + this.chart.plotTop,
				'L', plotX + this.chart.plotLeft, plotY + this.chart.plotTop])
				.attr({
					stroke: 'red',
					'stroke-width': 2,
					zIndex: 9
				})
				.add();
		}
		if (rightContX) {
			this.chart.renderer.circle(
					rightContX + this.chart.plotLeft,
					rightContY + this.chart.plotTop,
					2
				)
				.attr({
					stroke: 'green',
					'stroke-width': 2,
					fill: 'none',
					zIndex: 9
				})
				.add();
			this.chart.renderer.path(['M', rightContX + this.chart.plotLeft,
				rightContY + this.chart.plotTop,
				'L', plotX + this.chart.plotLeft, plotY + this.chart.plotTop])
				.attr({
					stroke: 'green',
					'stroke-width': 2,
					zIndex: 9
				})
				.add();
		}
		// */
		ret = [
			'C',
			pick(lastPoint.rightContX, lastPoint.plotX),
			pick(lastPoint.rightContY, lastPoint.plotY),
			pick(leftContX, plotX),
			pick(leftContY, plotY),
			plotX,
			plotY
		];
		// reset for updating series later
		lastPoint.rightContX = lastPoint.rightContY = null;
		return ret;
	}
});

/**
 * A `spline` series. If the [type](#series.spline.type) option is
 * not specified, it is inherited from [chart.type](#chart.type).
 * 
 * For options that apply to multiple series, it is recommended to add
 * them to the [plotOptions.series](#plotOptions.series) options structure.
 * To apply to all series of this specific type, apply it to [plotOptions.
 * spline](#plotOptions.spline).
 * 
 * @type {Object}
 * @extends series,plotOptions.spline
 * @excluding dataParser,dataURL
 * @product highcharts highstock
 * @apioption series.spline
 */

/**
 * An array of data points for the series. For the `spline` series type,
 * points can be given in the following ways:
 * 
 * 1.  An array of numerical values. In this case, the numerical values
 * will be interpreted as `y` options. The `x` values will be automatically
 * calculated, either starting at 0 and incremented by 1, or from `pointStart`
 * and `pointInterval` given in the series options. If the axis has
 * categories, these will be used. Example:
 * 
 *  ```js
 *  data: [0, 5, 3, 5]
 *  ```
 * 
 * 2.  An array of arrays with 2 values. In this case, the values correspond
 * to `x,y`. If the first value is a string, it is applied as the name
 * of the point, and the `x` value is inferred.
 * 
 *  ```js
 *     data: [
 *         [0, 9],
 *         [1, 2],
 *         [2, 8]
 *     ]
 *  ```
 * 
 * 3.  An array of objects with named values. The objects are point
 * configuration objects as seen below. If the total number of data
 * points exceeds the series' [turboThreshold](#series.spline.turboThreshold),
 * this option is not available.
 * 
 *  ```js
 *     data: [{
 *         x: 1,
 *         y: 9,
 *         name: "Point2",
 *         color: "#00FF00"
 *     }, {
 *         x: 1,
 *         y: 0,
 *         name: "Point1",
 *         color: "#FF00FF"
 *     }]
 *  ```
 * 
 * @type {Array<Object|Array|Number>}
 * @extends series.line.data
 * @sample {highcharts} highcharts/chart/reflow-true/
 *         Numerical values
 * @sample {highcharts} highcharts/series/data-array-of-arrays/
 *         Arrays of numeric x and y
 * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/
 *         Arrays of datetime x and y
 * @sample {highcharts} highcharts/series/data-array-of-name-value/
 *         Arrays of point.name and y
 * @sample {highcharts} highcharts/series/data-array-of-objects/
 *         Config objects
 * @product highcharts highstock
 * @apioption series.spline.data
 */

}(Highcharts));
(function (H) {
/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var areaProto = H.seriesTypes.area.prototype,
	defaultPlotOptions = H.defaultPlotOptions,
	LegendSymbolMixin = H.LegendSymbolMixin,
	seriesType = H.seriesType;
/**
 * AreaSplineSeries object
 */
/**
 * The area spline series is an area series where the graph between the points
 * is smoothed into a spline.
 * 
 * @extends plotOptions.area
 * @excluding step
 * @sample {highcharts} highcharts/demo/areaspline/ Area spline chart
 * @sample {highstock} stock/demo/areaspline/ Area spline chart
 * @product highcharts highstock
 * @apioption plotOptions.areaspline
 */
seriesType('areaspline', 'spline', defaultPlotOptions.area, {
	getStackPoints: areaProto.getStackPoints,
	getGraphPath: areaProto.getGraphPath,
	drawGraph: areaProto.drawGraph,
	drawLegendSymbol: LegendSymbolMixin.drawRectangle
});
/**
 * A `areaspline` series. If the [type](#series.areaspline.type) option
 * is not specified, it is inherited from [chart.type](#chart.type).
 * 
 * 
 * For options that apply to multiple series, it is recommended to add
 * them to the [plotOptions.series](#plotOptions.series) options structure.
 * To apply to all series of this specific type, apply it to [plotOptions.
 * areaspline](#plotOptions.areaspline).
 * 
 * @type {Object}
 * @extends series,plotOptions.areaspline
 * @excluding dataParser,dataURL
 * @product highcharts highstock
 * @apioption series.areaspline
 */


/**
 * An array of data points for the series. For the `areaspline` series
 * type, points can be given in the following ways:
 * 
 * 1.  An array of numerical values. In this case, the numerical values
 * will be interpreted as `y` options. The `x` values will be automatically
 * calculated, either starting at 0 and incremented by 1, or from `pointStart`
 * and `pointInterval` given in the series options. If the axis has
 * categories, these will be used. Example:
 * 
 *  ```js
 *  data: [0, 5, 3, 5]
 *  ```
 * 
 * 2.  An array of arrays with 2 values. In this case, the values correspond
 * to `x,y`. If the first value is a string, it is applied as the name
 * of the point, and the `x` value is inferred.
 * 
 *  ```js
 *     data: [
 *         [0, 10],
 *         [1, 9],
 *         [2, 3]
 *     ]
 *  ```
 * 
 * 3.  An array of objects with named values. The objects are point
 * configuration objects as seen below. If the total number of data
 * points exceeds the series' [turboThreshold](#series.areaspline.turboThreshold),
 * this option is not available.
 * 
 *  ```js
 *     data: [{
 *         x: 1,
 *         y: 4,
 *         name: "Point2",
 *         color: "#00FF00"
 *     }, {
 *         x: 1,
 *         y: 4,
 *         name: "Point1",
 *         color: "#FF00FF"
 *     }]
 *  ```
 * 
 * @type {Array<Object|Array|Number>}
 * @extends series.line.data
 * @sample {highcharts} highcharts/chart/reflow-true/ Numerical values
 * @sample {highcharts} highcharts/series/data-array-of-arrays/ Arrays of numeric x and y
 * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/ Arrays of datetime x and y
 * @sample {highcharts} highcharts/series/data-array-of-name-value/ Arrays of point.name and y
 * @sample {highcharts} highcharts/series/data-array-of-objects/ Config objects
 * @product highcharts highstock
 * @apioption series.areaspline.data
 */



}(Highcharts));
(function (H) {
/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var animObject = H.animObject,
	color = H.color,
	each = H.each,
	extend = H.extend,
	isNumber = H.isNumber,
	LegendSymbolMixin = H.LegendSymbolMixin,
	merge = H.merge,
	noop = H.noop,
	pick = H.pick,
	Series = H.Series,
	seriesType = H.seriesType,
	svg = H.svg;
/**
 * The column series type.
 *
 * @constructor seriesTypes.column
 * @augments Series
 */

/**
 * Column series display one column per value along an X axis.
 *
 * @sample {highcharts} highcharts/demo/column-basic/ Column chart
 * @sample {highstock} stock/demo/column/ Column chart
 *
 * @extends {plotOptions.line}
 * @product highcharts highstock
 * @excluding connectNulls,dashStyle,gapSize,gapUnit,linecap,lineWidth,marker,
 *          connectEnds,step
 * @optionparent plotOptions.column
 */
seriesType('column', 'line', {

	/**
	 * The corner radius of the border surrounding each column or bar.
	 *
	 * @type {Number}
	 * @sample {highcharts} highcharts/plotoptions/column-borderradius/
	 *         Rounded columns
	 * @default 0
	 * @product highcharts highstock
	 */
	borderRadius: 0,

	/**
	 * The width of the border surrounding each column or bar.
	 *
	 * In styled mode, the stroke width can be set with the `.highcharts-point`
	 * rule.
	 *
	 * @type {Number}
	 * @sample {highcharts} highcharts/plotoptions/column-borderwidth/
	 *         2px black border
	 * @default 1
	 * @product highcharts highstock
	 * @apioption plotOptions.column.borderWidth
	 */

	/**
	 * When using automatic point colors pulled from the `options.colors`
	 * collection, this option determines whether the chart should receive
	 * one color per series or one color per point.
	 *
	 * @type {Boolean}
	 * @see [series colors](#plotOptions.column.colors)
	 * @sample {highcharts} highcharts/plotoptions/column-colorbypoint-false/
	 *         False by default
	 * @sample {highcharts} highcharts/plotoptions/column-colorbypoint-true/
	 *         True
	 * @default false
	 * @since 2.0
	 * @product highcharts highstock
	 * @apioption plotOptions.column.colorByPoint
	 */

	/**
	 * A series specific or series type specific color set to apply instead
	 * of the global [colors](#colors) when [colorByPoint](#plotOptions.
	 * column.colorByPoint) is true.
	 *
	 * @type {Array<Color>}
	 * @since 3.0
	 * @product highcharts highstock
	 * @apioption plotOptions.column.colors
	 */

	/**
	 * When true, each column edge is rounded to its nearest pixel in order
	 * to render sharp on screen. In some cases, when there are a lot of
	 * densely packed columns, this leads to visible difference in column
	 * widths or distance between columns. In these cases, setting `crisp`
	 * to `false` may look better, even though each column is rendered
	 * blurry.
	 *
	 * @type {Boolean}
	 * @sample {highcharts} highcharts/plotoptions/column-crisp-false/
	 *         Crisp is false
	 * @default true
	 * @since 5.0.10
	 * @product highcharts highstock
	 */
	crisp: true,

	/**
	 * Padding between each value groups, in x axis units.
	 *
	 * @type {Number}
	 * @sample {highcharts} highcharts/plotoptions/column-grouppadding-default/
	 *         0.2 by default
	 * @sample {highcharts} highcharts/plotoptions/column-grouppadding-none/
	 *         No group padding - all columns are evenly spaced
	 * @default 0.2
	 * @product highcharts highstock
	 */
	groupPadding: 0.2,

	/**
	 * Whether to group non-stacked columns or to let them render independent
	 * of each other. Non-grouped columns will be laid out individually
	 * and overlap each other.
	 *
	 * @type {Boolean}
	 * @sample {highcharts} highcharts/plotoptions/column-grouping-false/
	 *         Grouping disabled
	 * @sample {highstock} highcharts/plotoptions/column-grouping-false/
	 *         Grouping disabled
	 * @default true
	 * @since 2.3.0
	 * @product highcharts highstock
	 * @apioption plotOptions.column.grouping
	 */

	marker: null, // point options are specified in the base options

	/**
	 * The maximum allowed pixel width for a column, translated to the height
	 * of a bar in a bar chart. This prevents the columns from becoming
	 * too wide when there is a small number of points in the chart.
	 *
	 * @type {Number}
	 * @see [pointWidth](#plotOptions.column.pointWidth)
	 * @sample {highcharts} highcharts/plotoptions/column-maxpointwidth-20/
	 *         Limited to 50
	 * @sample {highstock} highcharts/plotoptions/column-maxpointwidth-20/
	 *         Limited to 50
	 * @default null
	 * @since 4.1.8
	 * @product highcharts highstock
	 * @apioption plotOptions.column.maxPointWidth
	 */

	/**
	 * Padding between each column or bar, in x axis units.
	 *
	 * @type {Number}
	 * @sample {highcharts} highcharts/plotoptions/column-pointpadding-default/
	 *         0.1 by default
	 * @sample {highcharts} highcharts/plotoptions/column-pointpadding-025/
	 *         0.25
	 * @sample {highcharts} highcharts/plotoptions/column-pointpadding-none/
	 *         0 for tightly packed columns
	 * @default 0.1
	 * @product highcharts highstock
	 */
	pointPadding: 0.1,

	/**
	 * A pixel value specifying a fixed width for each column or bar. When
	 * `null`, the width is calculated from the `pointPadding` and
	 * `groupPadding`.
	 *
	 * @type {Number}
	 * @see [maxPointWidth](#plotOptions.column.maxPointWidth)
	 * @sample {highcharts} highcharts/plotoptions/column-pointwidth-20/
	 *         20px wide columns regardless of chart width or the amount of data
	 *         points
	 * @default null
	 * @since 1.2.5
	 * @product highcharts highstock
	 * @apioption plotOptions.column.pointWidth
	 */

	/**
	 * The minimal height for a column or width for a bar. By default,
	 * 0 values are not shown. To visualize a 0 (or close to zero) point,
	 * set the minimal point length to a pixel value like 3\. In stacked
	 * column charts, minPointLength might not be respected for tightly
	 * packed values.
	 *
	 * @type {Number}
	 * @sample {highcharts} highcharts/plotoptions/column-minpointlength/
	 *         Zero base value
	 * @sample {highcharts} highcharts/plotoptions/column-minpointlength-pos-and-neg/
	 *         Positive and negative close to zero values
	 * @default 0
	 * @product highcharts highstock
	 */
	minPointLength: 0,

	/**
	 * When the series contains less points than the crop threshold, all
	 * points are drawn, event if the points fall outside the visible plot
	 * area at the current zoom. The advantage of drawing all points (including
	 * markers and columns), is that animation is performed on updates.
	 * On the other hand, when the series contains more points than the
	 * crop threshold, the series data is cropped to only contain points
	 * that fall within the plot area. The advantage of cropping away invisible
	 * points is to increase performance on large series. .
	 *
	 * @type {Number}
	 * @default 50
	 * @product highcharts highstock
	 */
	cropThreshold: 50,

	/**
	 * The X axis range that each point is valid for. This determines the
	 * width of the column. On a categorized axis, the range will be 1
	 * by default (one category unit). On linear and datetime axes, the
	 * range will be computed as the distance between the two closest data
	 * points.
	 *
	 * The default `null` means it is computed automatically, but this option
	 * can be used to override the automatic value.
	 *
	 * @type {Number}
	 * @sample {highcharts} highcharts/plotoptions/column-pointrange/
	 *         Set the point range to one day on a data set with one week
	 *         between the points
	 * @default null
	 * @since 2.3
	 * @product highcharts highstock
	 */
	pointRange: null,

	states: {

		/**
		 * Options for the hovered point. These settings override the normal
		 * state options when a point is moused over or touched.
		 * 
		 * @extends   plotOptions.series.states.hover
		 * @excluding halo,lineWidth,lineWidthPlus,marker
		 * @product   highcharts highstock
		 */
		hover: {

			/**
			 * @ignore-option
			 */
			halo: false,
			/**
			 * A specific border color for the hovered point. Defaults to
			 * inherit the normal state border color.
			 *
			 * @type      {Color}
			 * @product   highcharts
			 * @apioption plotOptions.column.states.hover.borderColor
			 */

			/**
			 * A specific color for the hovered point.
			 *
			 * @type      {Color}
			 * @default   undefined
			 * @product   highcharts
			 * @apioption plotOptions.column.states.hover.color
			 */

			

			/**
			 * How much to brighten the point on interaction. Requires the main
			 * color to be defined in hex or rgb(a) format.
			 *
			 * In styled mode, the hover brightening is by default replaced
			 * with a fill-opacity set in the `.highcharts-point:hover` rule.
			 *
			 * @sample  {highcharts}
			 *          highcharts/plotoptions/column-states-hover-brightness/
			 *          Brighten by 0.5
			 * @product highcharts highstock
			 */
			brightness: 0.1

			
		},
		

		/**
		 * Options for the selected point. These settings override the normal
		 * state options when a point is selected.
		 *
		 * @excluding halo,lineWidth,lineWidthPlus,marker
		 * @product highcharts highstock
		 */
		select: {
			/**
			 * A specific color for the selected point.
			 *
			 * @type    {Color}
			 * @default #cccccc
			 * @product highcharts highstock
			 */
			color: '#cccccc',

			/**
			 * A specific border color for the selected point.
			 *
			 * @type    {Color}
			 * @default #000000
			 * @product highcharts highstock
			 */
			borderColor: '#000000'
		}
		
	},

	dataLabels: {
		align: null, // auto
		verticalAlign: null, // auto
		y: null
	},

	/**
	 * When this is true, the series will not cause the Y axis to cross
	 * the zero plane (or [threshold](#plotOptions.series.threshold) option)
	 * unless the data actually crosses the plane.
	 *
	 * For example, if `softThreshold` is `false`, a series of 0, 1, 2,
	 * 3 will make the Y axis show negative values according to the `minPadding`
	 * option. If `softThreshold` is `true`, the Y axis starts at 0.
	 *
	 * @type {Boolean}
	 * @default {highcharts} true
	 * @default {highstock} false
	 * @since 4.1.9
	 * @product highcharts highstock
	 */
	softThreshold: false,

	// false doesn't work well: http://jsfiddle.net/highcharts/hz8fopan/14/
	/**	@ignore */
	startFromThreshold: true,

	stickyTracking: false,

	tooltip: {
		distance: 6
	},

	/**
	 * The Y axis value to serve as the base for the columns, for distinguishing
	 * between values above and below a threshold. If `null`, the columns
	 * extend from the padding Y axis minimum.
	 *
	 * @type {Number}
	 * @default 0
	 * @since 2.0
	 * @product highcharts
	 */
	threshold: 0,
	

	/**
	 * The color of the border surrounding each column or bar.
	 *
	 * In styled mode, the border stroke can be set with the `.highcharts-point`
	 * rule.
	 *
	 * @type {Color}
	 * @sample {highcharts} highcharts/plotoptions/column-bordercolor/
	 *         Dark gray border
	 * @default #ffffff
	 * @product highcharts highstock
	 */
	borderColor: '#ffffff'
	// borderWidth: 1
	

}, /** @lends seriesTypes.column.prototype */ {
	cropShoulder: 0,
	// When tooltip is not shared, this series (and derivatives) requires direct
	// touch/hover. KD-tree does not apply.
	directTouch: true,
	trackerGroups: ['group', 'dataLabelsGroup'],
	// use separate negative stacks, unlike area stacks where a negative point
	// is substracted from previous (#1910)
	negStacks: true,

	/**
	 * Initialize the series. Extends the basic Series.init method by
	 * marking other series of the same type as dirty.
	 *
	 * @function #init
	 * @memberOf seriesTypes.column
	 *
	 */
	init: function () {
		Series.prototype.init.apply(this, arguments);

		var series = this,
			chart = series.chart;

		// if the series is added dynamically, force redraw of other
		// series affected by a new column
		if (chart.hasRendered) {
			each(chart.series, function (otherSeries) {
				if (otherSeries.type === series.type) {
					otherSeries.isDirty = true;
				}
			});
		}
	},

	/**
	 * Return the width and x offset of the columns adjusted for grouping,
	 * groupPadding, pointPadding, pointWidth etc.
	 */
	getColumnMetrics: function () {

		var series = this,
			options = series.options,
			xAxis = series.xAxis,
			yAxis = series.yAxis,
			reversedXAxis = xAxis.reversed,
			stackKey,
			stackGroups = {},
			columnCount = 0;

		// Get the total number of column type series. This is called on every
		// series. Consider moving this logic to a chart.orderStacks() function
		// and call it on init, addSeries and removeSeries
		if (options.grouping === false) {
			columnCount = 1;
		} else {
			each(series.chart.series, function (otherSeries) {
				var otherOptions = otherSeries.options,
					otherYAxis = otherSeries.yAxis,
					columnIndex;
				if (
					otherSeries.type === series.type &&
					(
						otherSeries.visible ||
						!series.chart.options.chart.ignoreHiddenSeries
					) &&
					yAxis.len === otherYAxis.len &&
					yAxis.pos === otherYAxis.pos
				) {  // #642, #2086
					if (otherOptions.stacking) {
						stackKey = otherSeries.stackKey;
						if (stackGroups[stackKey] === undefined) {
							stackGroups[stackKey] = columnCount++;
						}
						columnIndex = stackGroups[stackKey];
					} else if (otherOptions.grouping !== false) { // #1162
						columnIndex = columnCount++;
					}
					otherSeries.columnIndex = columnIndex;
				}
			});
		}

		var categoryWidth = Math.min(
				Math.abs(xAxis.transA) * (
					xAxis.ordinalSlope ||
					options.pointRange ||
					xAxis.closestPointRange ||
					xAxis.tickInterval ||
					1
				), // #2610
				xAxis.len // #1535
			),
			groupPadding = categoryWidth * options.groupPadding,
			groupWidth = categoryWidth - 2 * groupPadding,
			pointOffsetWidth = groupWidth / (columnCount || 1),
			pointWidth = Math.min(
				options.maxPointWidth || xAxis.len,
				pick(
					options.pointWidth,
					pointOffsetWidth * (1 - 2 * options.pointPadding)
				)
			),
			pointPadding = (pointOffsetWidth - pointWidth) / 2,
			// #1251, #3737
			colIndex = (series.columnIndex || 0) + (reversedXAxis ? 1 : 0),
			pointXOffset =
				pointPadding +
				(
					groupPadding +
					colIndex * pointOffsetWidth -
					(categoryWidth / 2)
				) *	(reversedXAxis ? -1 : 1);

		// Save it for reading in linked series (Error bars particularly)
		series.columnMetrics = {
			width: pointWidth,
			offset: pointXOffset
		};
		return series.columnMetrics;

	},

	/**
	 * Make the columns crisp. The edges are rounded to the nearest full pixel.
	 */
	crispCol: function (x, y, w, h) {
		var chart = this.chart,
			borderWidth = this.borderWidth,
			xCrisp = -(borderWidth % 2 ? 0.5 : 0),
			yCrisp = borderWidth % 2 ? 0.5 : 1,
			right,
			bottom,
			fromTop;

		if (chart.inverted && chart.renderer.isVML) {
			yCrisp += 1;
		}

		// Horizontal. We need to first compute the exact right edge, then round
		// it and compute the width from there.
		if (this.options.crisp) {
			right = Math.round(x + w) + xCrisp;
			x = Math.round(x) + xCrisp;
			w = right - x;
		}

		// Vertical
		bottom = Math.round(y + h) + yCrisp;
		fromTop = Math.abs(y) <= 0.5 && bottom > 0.5; // #4504, #4656
		y = Math.round(y) + yCrisp;
		h = bottom - y;

		// Top edges are exceptions
		if (fromTop && h) { // #5146
			y -= 1;
			h += 1;
		}

		return {
			x: x,
			y: y,
			width: w,
			height: h
		};
	},

	/**
	 * Translate each point to the plot area coordinate system and find shape
	 * positions
	 */
	translate: function () {
		var series = this,
			chart = series.chart,
			options = series.options,
			dense = series.dense =
				series.closestPointRange * series.xAxis.transA < 2,
			borderWidth = series.borderWidth = pick(
				options.borderWidth,
				dense ? 0 : 1  // #3635
			),
			yAxis = series.yAxis,
			threshold = options.threshold,
			translatedThreshold = series.translatedThreshold =
				yAxis.getThreshold(threshold),
			minPointLength = pick(options.minPointLength, 5),
			metrics = series.getColumnMetrics(),
			pointWidth = metrics.width,
			// postprocessed for border width
			seriesBarW = series.barW =
				Math.max(pointWidth, 1 + 2 * borderWidth),
			pointXOffset = series.pointXOffset = metrics.offset;

		if (chart.inverted) {
			translatedThreshold -= 0.5; // #3355
		}

		// When the pointPadding is 0, we want the columns to be packed tightly,
		// so we allow individual columns to have individual sizes. When
		// pointPadding is greater, we strive for equal-width columns (#2694).
		if (options.pointPadding) {
			seriesBarW = Math.ceil(seriesBarW);
		}

		Series.prototype.translate.apply(series);

		// Record the new values
		each(series.points, function (point) {
			var yBottom = pick(point.yBottom, translatedThreshold),
				safeDistance = 999 + Math.abs(yBottom),
				plotY = Math.min(
					Math.max(-safeDistance, point.plotY),
					yAxis.len + safeDistance
				), // Don't draw too far outside plot area (#1303, #2241, #4264)
				barX = point.plotX + pointXOffset,
				barW = seriesBarW,
				barY = Math.min(plotY, yBottom),
				up,
				barH = Math.max(plotY, yBottom) - barY;

			// Handle options.minPointLength
			if (minPointLength && Math.abs(barH) < minPointLength) {
				barH = minPointLength;
				up = (!yAxis.reversed && !point.negative) ||
					(yAxis.reversed && point.negative);

				// Reverse zeros if there's no positive value in the series
				// in visible range (#7046)
				if (
					point.y === threshold &&
					series.dataMax <= threshold &&
					yAxis.min < threshold // and if there's room for it (#7311)
				) {
					up = !up;
				}

				// If stacked...
				barY = Math.abs(barY - translatedThreshold) > minPointLength ?
						// ...keep position
						yBottom - minPointLength :
						// #1485, #4051
						translatedThreshold - (up ? minPointLength : 0);
			}

			// Cache for access in polar
			point.barX = barX;
			point.pointWidth = pointWidth;

			// Fix the tooltip on center of grouped columns (#1216, #424, #3648)
			point.tooltipPos = chart.inverted ?
			[
				yAxis.len + yAxis.pos - chart.plotLeft - plotY,
				series.xAxis.len - barX - barW / 2, barH
			] :
			[barX + barW / 2, plotY + yAxis.pos - chart.plotTop, barH];

			// Register shape type and arguments to be used in drawPoints
			point.shapeType = 'rect';
			point.shapeArgs = series.crispCol.apply(
				series,
				point.isNull ?
					// #3169, drilldown from null must have a position to work
					// from #6585, dataLabel should be placed on xAxis, not
					// floating in the middle of the chart
					[barX, translatedThreshold, barW, 0] :
					[barX, barY, barW, barH]
			);
		});

	},

	getSymbol: noop,

	/**
	 * Use a solid rectangle like the area series types
	 */
	drawLegendSymbol: LegendSymbolMixin.drawRectangle,


	/**
	 * Columns have no graph
	 */
	drawGraph: function () {
		this.group[
			this.dense ? 'addClass' : 'removeClass'
		]('highcharts-dense-data');
	},

	
	/**
	 * Get presentational attributes
	 */
	pointAttribs: function (point, state) {
		var options = this.options,
			stateOptions,
			ret,
			p2o = this.pointAttrToOptions || {},
			strokeOption = p2o.stroke || 'borderColor',
			strokeWidthOption = p2o['stroke-width'] || 'borderWidth',
			fill = (point && point.color) || this.color,
			stroke = (point && point[strokeOption]) || options[strokeOption] ||
				this.color || fill, // set to fill when borderColor null
			strokeWidth = (point && point[strokeWidthOption]) ||
				options[strokeWidthOption] || this[strokeWidthOption] || 0,
			dashstyle = options.dashStyle,
			zone,
			brightness;

		// Handle zone colors
		if (point && this.zones.length) {
			zone = point.getZone();
			// When zones are present, don't use point.color (#4267). Changed
			// order (#6527)
			fill = point.options.color || (zone && zone.color) || this.color;
		}

		// Select or hover states
		if (state) {
			stateOptions = merge(
				options.states[state],
				// #6401
				point.options.states && point.options.states[state] || {}
			);
			brightness = stateOptions.brightness;
			fill = stateOptions.color ||
				(
					brightness !== undefined &&
					color(fill).brighten(stateOptions.brightness).get()
				) ||
				fill;
			stroke = stateOptions[strokeOption] || stroke;
			strokeWidth = stateOptions[strokeWidthOption] || strokeWidth;
			dashstyle = stateOptions.dashStyle || dashstyle;
		}

		ret = {
			'fill': fill,
			'stroke': stroke,
			'stroke-width': strokeWidth
		};

		if (dashstyle) {
			ret.dashstyle = dashstyle;
		}

		return ret;
	},
	

	/**
	 * Draw the columns. For bars, the series.group is rotated, so the same
	 * coordinates apply for columns and bars. This method is inherited by
	 * scatter series.
	 */
	drawPoints: function () {
		var series = this,
			chart = this.chart,
			options = series.options,
			renderer = chart.renderer,
			animationLimit = options.animationLimit || 250,
			shapeArgs;

		// draw the columns
		each(series.points, function (point) {
			var plotY = point.plotY,
				graphic = point.graphic;

			if (isNumber(plotY) && point.y !== null) {
				shapeArgs = point.shapeArgs;

				if (graphic) { // update
					graphic[
						chart.pointCount < animationLimit ? 'animate' : 'attr'
					](
						merge(shapeArgs)
					);

				} else {
					point.graphic = graphic =
						renderer[point.shapeType](shapeArgs)
							.add(point.group || series.group);
				}

				// Border radius is not stylable (#6900)
				if (options.borderRadius) {
					graphic.attr({
						r: options.borderRadius
					});
				}

				
				// Presentational
				graphic
					.attr(series.pointAttribs(
						point,
						point.selected && 'select'
					))
					.shadow(
						options.shadow,
						null,
						options.stacking && !options.borderRadius
					);
				

				graphic.addClass(point.getClassName(), true);


			} else if (graphic) {
				point.graphic = graphic.destroy(); // #1269
			}
		});
	},

	/**
	 * Animate the column heights one by one from zero
	 * @param {Boolean} init Whether to initialize the animation or run it
	 */
	animate: function (init) {
		var series = this,
			yAxis = this.yAxis,
			options = series.options,
			inverted = this.chart.inverted,
			attr = {},
			translateProp = inverted ? 'translateX' : 'translateY',
			translateStart,
			translatedThreshold;

		if (svg) { // VML is too slow anyway
			if (init) {
				attr.scaleY = 0.001;
				translatedThreshold = Math.min(
					yAxis.pos + yAxis.len,
					Math.max(yAxis.pos, yAxis.toPixels(options.threshold))
				);
				if (inverted) {
					attr.translateX = translatedThreshold - yAxis.len;
				} else {
					attr.translateY = translatedThreshold;
				}
				series.group.attr(attr);

			} else { // run the animation
				translateStart = series.group.attr(translateProp);
				series.group.animate(
					{ scaleY: 1 },
					extend(animObject(series.options.animation
				), {
					// Do the scale synchronously to ensure smooth updating
					// (#5030, #7228)
					step: function (val, fx) {

						attr[translateProp] =
							translateStart +
							fx.pos * (yAxis.pos - translateStart);
						series.group.attr(attr);
					}
				}));

				// delete this function to allow it only once
				series.animate = null;
			}
		}
	},

	/**
	 * Remove this series from the chart
	 */
	remove: function () {
		var series = this,
			chart = series.chart;

		// column and bar series affects other series of the same type
		// as they are either stacked or grouped
		if (chart.hasRendered) {
			each(chart.series, function (otherSeries) {
				if (otherSeries.type === series.type) {
					otherSeries.isDirty = true;
				}
			});
		}

		Series.prototype.remove.apply(series, arguments);
	}
});


/**
 * A `column` series. If the [type](#series.column.type) option is
 * not specified, it is inherited from [chart.type](#chart.type).
 *
 * For options that apply to multiple series, it is recommended to add
 * them to the [plotOptions.series](#plotOptions.series) options structure.
 * To apply to all series of this specific type, apply it to [plotOptions.
 * column](#plotOptions.column).
 *
 * @type      {Object}
 * @extends   series,plotOptions.column
 * @excluding dataParser,dataURL,marker
 * 
 * @product   highcharts highstock
 * @apioption series.column
 */

/**
 * @excluding halo,lineWidth,lineWidthPlus,marker
 * @product   highcharts highstock
 * @apioption series.column.states.hover
 */

/**
 * @excluding halo,lineWidth,lineWidthPlus,marker
 * @product   highcharts highstock
 * @apioption series.column.states.select
 */

/**
 * An array of data points for the series. For the `column` series type,
 * points can be given in the following ways:
 *
 * 1.  An array of numerical values. In this case, the numerical values
 * will be interpreted as `y` options. The `x` values will be automatically
 * calculated, either starting at 0 and incremented by 1, or from `pointStart`
 * and `pointInterval` given in the series options. If the axis has
 * categories, these will be used. Example:
 *
 *  ```js
 *  data: [0, 5, 3, 5]
 *  ```
 *
 * 2.  An array of arrays with 2 values. In this case, the values correspond
 * to `x,y`. If the first value is a string, it is applied as the name
 * of the point, and the `x` value is inferred.
 *
 *  ```js
 *     data: [
 *         [0, 6],
 *         [1, 2],
 *         [2, 6]
 *     ]
 *  ```
 *
 * 3.  An array of objects with named values. The objects are point
 * configuration objects as seen below. If the total number of data
 * points exceeds the series' [turboThreshold](#series.column.turboThreshold),
 * this option is not available.
 *
 *  ```js
 *     data: [{
 *         x: 1,
 *         y: 9,
 *         name: "Point2",
 *         color: "#00FF00"
 *     }, {
 *         x: 1,
 *         y: 6,
 *         name: "Point1",
 *         color: "#FF00FF"
 *     }]
 *  ```
 *
 * @type {Array<Object|Array|Number>}
 * @extends series.line.data
 * @excluding marker
 * @sample {highcharts} highcharts/chart/reflow-true/ Numerical values
 * @sample {highcharts} highcharts/series/data-array-of-arrays/
 *         Arrays of numeric x and y
 * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/
 *         Arrays of datetime x and y
 * @sample {highcharts} highcharts/series/data-array-of-name-value/
 *         Arrays of point.name and y
 * @sample {highcharts} highcharts/series/data-array-of-objects/
 *         Config objects
 * @product highcharts highstock
 * @apioption series.column.data
 */


}(Highcharts));
(function (H) {
/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */

var seriesType = H.seriesType;

/**
 * The Bar series class
 */
seriesType('bar', 'column', null, {
	inverted: true
});
/**
 * A bar series is a special type of column series where the columns are
 * horizontal.
 *
 * @sample highcharts/demo/bar-basic/ Bar chart
 * @extends {plotOptions.column}
 * @product highcharts
 * @optionparent plotOptions.bar
 */


/**
 * A `bar` series. If the [type](#series.bar.type) option is not specified,
 * it is inherited from [chart.type](#chart.type).
 * 
 * For options that apply to multiple series, it is recommended to add
 * them to the [plotOptions.series](#plotOptions.series) options structure.
 * To apply to all series of this specific type, apply it to [plotOptions.
 * bar](#plotOptions.bar).
 * 
 * @type {Object}
 * @extends series,plotOptions.bar
 * @excluding dataParser,dataURL
 * @product highcharts
 * @apioption series.bar
 */

/**
 * An array of data points for the series. For the `bar` series type,
 * points can be given in the following ways:
 * 
 * 1.  An array of numerical values. In this case, the numerical values
 * will be interpreted as `y` options. The `x` values will be automatically
 * calculated, either starting at 0 and incremented by 1, or from `pointStart`
 * and `pointInterval` given in the series options. If the axis has
 * categories, these will be used. Example:
 * 
 *  ```js
 *  data: [0, 5, 3, 5]
 *  ```
 * 
 * 2.  An array of arrays with 2 values. In this case, the values correspond
 * to `x,y`. If the first value is a string, it is applied as the name
 * of the point, and the `x` value is inferred.
 * 
 *  ```js
 *     data: [
 *         [0, 5],
 *         [1, 10],
 *         [2, 3]
 *     ]
 *  ```
 * 
 * 3.  An array of objects with named values. The objects are point
 * configuration objects as seen below. If the total number of data
 * points exceeds the series' [turboThreshold](#series.bar.turboThreshold),
 * this option is not available.
 * 
 *  ```js
 *     data: [{
 *         x: 1,
 *         y: 1,
 *         name: "Point2",
 *         color: "#00FF00"
 *     }, {
 *         x: 1,
 *         y: 10,
 *         name: "Point1",
 *         color: "#FF00FF"
 *     }]
 *  ```
 * 
 * @type {Array<Object|Array|Number>}
 * @extends series.column.data
 * @sample {highcharts} highcharts/chart/reflow-true/ Numerical values
 * @sample {highcharts} highcharts/series/data-array-of-arrays/ Arrays of numeric x and y
 * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/ Arrays of datetime x and y
 * @sample {highcharts} highcharts/series/data-array-of-name-value/ Arrays of point.name and y
 * @sample {highcharts} highcharts/series/data-array-of-objects/ Config objects
 * @product highcharts
 * @apioption series.bar.data
 */

/**
 * Alignment of the data label relative to the data point.
 * 
 * @type {String}
 * @sample {highcharts} highcharts/plotoptions/bar-datalabels-align-inside-bar/
 *         Data labels inside the bar
 * @default left
 * @product highcharts
 * @apioption plotOptions.bar.dataLabels.align
 */

/**
 * The x position of the data label relative to the data point.
 * 
 * @type {Number}
 * @sample {highcharts} highcharts/plotoptions/bar-datalabels-align-inside-bar/
 *         Data labels inside the bar
 * @default 5
 * @product highcharts
 * @apioption plotOptions.bar.dataLabels.x
 */

}(Highcharts));
(function (H) {
/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var Series = H.Series,
	seriesType = H.seriesType;

/**
 * A scatter plot uses cartesian coordinates to display values for two variables
 * for a set of data.
 *
 * @sample {highcharts} highcharts/demo/scatter/ Scatter plot
 * 
 * @extends {plotOptions.line}
 * @product highcharts highstock
 * @optionparent plotOptions.scatter
 */
seriesType('scatter', 'line', {

	/**
	 * The width of the line connecting the data points.
	 * 
	 * @type {Number}
	 * @sample {highcharts} highcharts/plotoptions/scatter-linewidth-none/
	 *         0 by default
	 * @sample {highcharts} highcharts/plotoptions/scatter-linewidth-1/
	 *         1px
	 * @default 0
	 * @product highcharts highstock
	 */
	lineWidth: 0,

	findNearestPointBy: 'xy',
	marker: {
		enabled: true // Overrides auto-enabling in line series (#3647)
	},

	/**
	 * Sticky tracking of mouse events. When true, the `mouseOut` event
	 * on a series isn't triggered until the mouse moves over another series,
	 * or out of the plot area. When false, the `mouseOut` event on a series
	 * is triggered when the mouse leaves the area around the series' graph
	 * or markers. This also implies the tooltip. When `stickyTracking`
	 * is false and `tooltip.shared` is false, the tooltip will be hidden
	 * when moving the mouse between series.
	 * 
	 * @type {Boolean}
	 * @default false
	 * @product highcharts highstock
	 * @apioption plotOptions.scatter.stickyTracking
	 */

	/**
	 * A configuration object for the tooltip rendering of each single
	 * series. Properties are inherited from <a class="internal">#tooltip</a>.
	 * Overridable properties are `headerFormat`, `pointFormat`, `yDecimals`,
	 * `xDateFormat`, `yPrefix` and `ySuffix`. Unlike other series, in
	 * a scatter plot the series.name by default shows in the headerFormat
	 * and point.x and point.y in the pointFormat.
	 * 
	 * @product highcharts highstock
	 */
	tooltip: {
		
		headerFormat:
			'<span style="color:{point.color}">\u25CF</span> ' +
			'<span style="font-size: 0.85em"> {series.name}</span><br/>',
		

		pointFormat: 'x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>'
	}

// Prototype members
}, {
	sorted: false,
	requireSorting: false,
	noSharedTooltip: true,
	trackerGroups: ['group', 'markerGroup', 'dataLabelsGroup'],
	takeOrdinalPosition: false, // #2342
	drawGraph: function () {
		if (this.options.lineWidth) {
			Series.prototype.drawGraph.call(this);
		}
	}
});

/**
 * A `scatter` series. If the [type](#series.scatter.type) option is
 * not specified, it is inherited from [chart.type](#chart.type).
 * 
 * For options that apply to multiple series, it is recommended to add
 * them to the [plotOptions.series](#plotOptions.series) options structure.
 * To apply to all series of this specific type, apply it to [plotOptions.
 * scatter](#plotOptions.scatter).
 * 
 * @type {Object}
 * @extends series,plotOptions.scatter
 * @excluding dataParser,dataURL,stack
 * @product highcharts highstock
 * @apioption series.scatter
 */

/**
 * An array of data points for the series. For the `scatter` series
 * type, points can be given in the following ways:
 * 
 * 1.  An array of numerical values. In this case, the numerical values
 * will be interpreted as `y` options. The `x` values will be automatically
 * calculated, either starting at 0 and incremented by 1, or from `pointStart`
 * and `pointInterval` given in the series options. If the axis has
 * categories, these will be used. Example:
 * 
 *  ```js
 *  data: [0, 5, 3, 5]
 *  ```
 * 
 * 2.  An array of arrays with 2 values. In this case, the values correspond
 * to `x,y`. If the first value is a string, it is applied as the name
 * of the point, and the `x` value is inferred.
 * 
 *  ```js
 *     data: [
 *         [0, 0],
 *         [1, 8],
 *         [2, 9]
 *     ]
 *  ```
 * 
 * 3.  An array of objects with named values. The objects are point
 * configuration objects as seen below. If the total number of data
 * points exceeds the series' [turboThreshold](#series.scatter.turboThreshold),
 * this option is not available.
 * 
 *  ```js
 *     data: [{
 *         x: 1,
 *         y: 2,
 *         name: "Point2",
 *         color: "#00FF00"
 *     }, {
 *         x: 1,
 *         y: 4,
 *         name: "Point1",
 *         color: "#FF00FF"
 *     }]
 *  ```
 * 
 * @type {Array<Object|Array|Number>}
 * @extends series.line.data
 * @sample {highcharts} highcharts/chart/reflow-true/
 *         Numerical values
 * @sample {highcharts} highcharts/series/data-array-of-arrays/
 *         Arrays of numeric x and y
 * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/
 *         Arrays of datetime x and y
 * @sample {highcharts} highcharts/series/data-array-of-name-value/
 *         Arrays of point.name and y
 * @sample {highcharts} highcharts/series/data-array-of-objects/
 *         Config objects
 * @product highcharts highstock
 * @apioption series.scatter.data
 */


}(Highcharts));
(function (H) {
/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var deg2rad = H.deg2rad,
	isNumber = H.isNumber,
	pick = H.pick,
	relativeLength = H.relativeLength;
H.CenteredSeriesMixin = {
	/**
	 * Get the center of the pie based on the size and center options relative to the
	 * plot area. Borrowed by the polar and gauge series types.
	 */
	getCenter: function () {

		var options = this.options,
			chart = this.chart,
			slicingRoom = 2 * (options.slicedOffset || 0),
			handleSlicingRoom,
			plotWidth = chart.plotWidth - 2 * slicingRoom,
			plotHeight = chart.plotHeight - 2 * slicingRoom,
			centerOption = options.center,
			positions = [pick(centerOption[0], '50%'), pick(centerOption[1], '50%'), options.size || '100%', options.innerSize || 0],
			smallestSize = Math.min(plotWidth, plotHeight),
			i,
			value;

		for (i = 0; i < 4; ++i) {
			value = positions[i];
			handleSlicingRoom = i < 2 || (i === 2 && /%$/.test(value));

			// i == 0: centerX, relative to width
			// i == 1: centerY, relative to height
			// i == 2: size, relative to smallestSize
			// i == 3: innerSize, relative to size
			positions[i] = relativeLength(value, [plotWidth, plotHeight, smallestSize, positions[2]][i]) +
				(handleSlicingRoom ? slicingRoom : 0);

		}
		// innerSize cannot be larger than size (#3632)
		if (positions[3] > positions[2]) {
			positions[3] = positions[2];
		}
		return positions;
	},
	/**
	 * getStartAndEndRadians - Calculates start and end angles in radians.
	 * Used in series types such as pie and sunburst.
	 *
	 * @param  {Number} start Start angle in degrees.
	 * @param  {Number} end Start angle in degrees.
	 * @return {object} Returns an object containing start and end angles as
	 * radians.
	 */
	getStartAndEndRadians: function getStartAndEndRadians(start, end) {
		var startAngle = isNumber(start) ? start : 0, // must be a number
			endAngle = (
				(
					isNumber(end) && // must be a number
					end > startAngle && // must be larger than the start angle
					// difference must be less than 360 degrees
					(end - startAngle) < 360
				) ?
				end :
				startAngle + 360
			),
			correction = -90;
		return {
			start: deg2rad * (startAngle + correction),
			end: deg2rad * (endAngle + correction)
		};
	}
};

}(Highcharts));
(function (H) {
/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var addEvent = H.addEvent,
	CenteredSeriesMixin = H.CenteredSeriesMixin,
	defined = H.defined,
	each = H.each,
	extend = H.extend,
	getStartAndEndRadians = CenteredSeriesMixin.getStartAndEndRadians,
	inArray = H.inArray,
	LegendSymbolMixin = H.LegendSymbolMixin,
	noop = H.noop,
	pick = H.pick,
	Point = H.Point,
	Series = H.Series,
	seriesType = H.seriesType,
	seriesTypes = H.seriesTypes,
	setAnimation = H.setAnimation;

/**
 * The pie series type.
 *
 * @constructor seriesTypes.pie
 * @augments Series
 */

/**
 * A pie chart is a circular graphic which is divided into slices to illustrate
 * numerical proportion.
 *
 * @sample highcharts/demo/pie-basic/ Pie chart
 * 
 * @extends {plotOptions.line}
 * @excluding animationLimit,boostThreshold,connectEnds,connectNulls,
 *          cropThreshold,dashStyle,findNearestPointBy,getExtremesFromAll,
 *          lineWidth,marker,negativeColor,pointInterval,pointIntervalUnit,
 *          pointPlacement,pointStart,softThreshold,stacking,step,threshold,
 *          turboThreshold,zoneAxis,zones
 * @product highcharts
 * @optionparent plotOptions.pie
 */
seriesType('pie', 'line', {

	/**
	 * The center of the pie chart relative to the plot area. Can be percentages
	 * or pixel values. The default behaviour (as of 3.0) is to center
	 * the pie so that all slices and data labels are within the plot area.
	 * As a consequence, the pie may actually jump around in a chart with
	 * dynamic values, as the data labels move. In that case, the center
	 * should be explicitly set, for example to `["50%", "50%"]`.
	 * 
	 * @type {Array<String|Number>}
	 * @sample {highcharts} highcharts/plotoptions/pie-center/ Centered at 100, 100
	 * @default [null, null]
	 * @product highcharts
	 */
	center: [null, null],

	clip: false,

	/** @ignore */
	colorByPoint: true, // always true for pies

	/**
	 * A series specific or series type specific color set to use instead
	 * of the global [colors](#colors).
	 * 
	 * @type {Array<Color>}
	 * @sample {highcharts} highcharts/demo/pie-monochrome/ Set default colors for all pies
	 * @since 3.0
	 * @product highcharts
	 * @apioption plotOptions.pie.colors
	 */

	/**
	 * @extends plotOptions.series.dataLabels
	 * @excluding align,allowOverlap,staggerLines,step
	 * @product highcharts
	 */
	dataLabels: {
		/**
		 * The color of the line connecting the data label to the pie slice.
		 * The default color is the same as the point's color.
		 * 
		 * In styled mode, the connector stroke is given in the
		 * `.highcharts-data-label-connector` class.
		 * 
		 * @type {String}
		 * @sample {highcharts} highcharts/plotoptions/pie-datalabels-connectorcolor/ Blue connectors
		 * @sample {highcharts} highcharts/css/pie-point/ Styled connectors
		 * @default {point.color}
		 * @since 2.1
		 * @product highcharts
		 * @apioption plotOptions.pie.dataLabels.connectorColor
		 */
		
		/**
		 * The distance from the data label to the connector.
		 * 
		 * @type {Number}
		 * @sample {highcharts} highcharts/plotoptions/pie-datalabels-connectorpadding/ No padding
		 * @default 5
		 * @since 2.1
		 * @product highcharts
		 * @apioption plotOptions.pie.dataLabels.connectorPadding
		 */

		/**
		 * The width of the line connecting the data label to the pie slice.
		 * 
		 * 
		 * In styled mode, the connector stroke width is given in the
		 * `.highcharts-data-label-connector` class.
		 * 
		 * @type {Number}
		 * @sample {highcharts} highcharts/plotoptions/pie-datalabels-connectorwidth-disabled/ Disable the connector
		 * @sample {highcharts} highcharts/css/pie-point/ Styled connectors
		 * @default 1
		 * @since 2.1
		 * @product highcharts
		 * @apioption plotOptions.pie.dataLabels.connectorWidth
		 */

		/**
		 * The distance of the data label from the pie's edge. Negative numbers
		 * put the data label on top of the pie slices. Connectors are only
		 * shown for data labels outside the pie.
		 * 
		 * @type {Number}
		 * @sample {highcharts} highcharts/plotoptions/pie-datalabels-distance/ Data labels on top of the pie
		 * @default 30
		 * @since 2.1
		 * @product highcharts
		 */
		distance: 30,

		/**
		 * Enable or disable the data labels.
		 * 
		 * @type {Boolean}
		 * @since 2.1
		 * @product highcharts
		 */
		enabled: true,

		formatter: function () { // #2945
			return this.point.isNull ? undefined : this.point.name;
		},
		
		/**
		 * Whether to render the connector as a soft arc or a line with sharp
		 * break.
		 * 
		 * @type {Number}
		 * @sample {highcharts} highcharts/plotoptions/pie-datalabels-softconnector-true/ Soft
		 * @sample {highcharts} highcharts/plotoptions/pie-datalabels-softconnector-false/ Non soft
		 * @since 2.1.7
		 * @product highcharts
		 * @apioption plotOptions.pie.dataLabels.softConnector
		 */

		x: 0
		// y: 0
	},

	/**
	 * The end angle of the pie in degrees where 0 is top and 90 is right.
	 * Defaults to `startAngle` plus 360.
	 * 
	 * @type {Number}
	 * @sample {highcharts} highcharts/demo/pie-semi-circle/ Semi-circle donut
	 * @default null
	 * @since 1.3.6
	 * @product highcharts
	 * @apioption plotOptions.pie.endAngle
	 */

	/**
	 * Equivalent to [chart.ignoreHiddenSeries](#chart.ignoreHiddenSeries),
	 * this option tells whether the series shall be redrawn as if the
	 * hidden point were `null`.
	 * 
	 * The default value changed from `false` to `true` with Highcharts
	 * 3.0.
	 * 
	 * @type {Boolean}
	 * @sample {highcharts} highcharts/plotoptions/pie-ignorehiddenpoint/ True, the hiddden point is ignored
	 * @default true
	 * @since 2.3.0
	 * @product highcharts
	 */
	ignoreHiddenPoint: true,
	
	/**
	 * The size of the inner diameter for the pie. A size greater than 0
	 * renders a donut chart. Can be a percentage or pixel value. Percentages
	 * are relative to the pie size. Pixel values are given as integers.
	 * 
	 * 
	 * Note: in Highcharts < 4.1.2, the percentage was relative to the plot
	 * area, not the pie size.
	 * 
	 * @type {String|Number}
	 * @sample {highcharts} highcharts/plotoptions/pie-innersize-80px/ 80px inner size
	 * @sample {highcharts} highcharts/plotoptions/pie-innersize-50percent/ 50% of the plot area
	 * @sample {highcharts} highcharts/demo/3d-pie-donut/ 3D donut
	 * @default 0
	 * @since 2.0
	 * @product highcharts
	 * @apioption plotOptions.pie.innerSize
	 */

	/** @ignore */
	legendType: 'point',

	/**	 @ignore */
	marker: null, // point options are specified in the base options

	/**
	 * The minimum size for a pie in response to auto margins. The pie will
	 * try to shrink to make room for data labels in side the plot area,
	 *  but only to this size.
	 * 
	 * @type {Number}
	 * @default 80
	 * @since 3.0
	 * @product highcharts
	 * @apioption plotOptions.pie.minSize
	 */

	/**
	 * The diameter of the pie relative to the plot area. Can be a percentage
	 * or pixel value. Pixel values are given as integers. The default
	 * behaviour (as of 3.0) is to scale to the plot area and give room
	 * for data labels within the plot area. As a consequence, the size
	 * of the pie may vary when points are updated and data labels more
	 * around. In that case it is best to set a fixed value, for example
	 * `"75%"`.
	 * 
	 * @type {String|Number}
	 * @sample {highcharts} highcharts/plotoptions/pie-size/ Smaller pie
	 * @default  
	 * @product highcharts
	 */
	size: null,

	/**
	 * Whether to display this particular series or series type in the
	 * legend. Since 2.1, pies are not shown in the legend by default.
	 * 
	 * @type {Boolean}
	 * @sample {highcharts} highcharts/plotoptions/series-showinlegend/ One series in the legend, one hidden
	 * @product highcharts
	 */
	showInLegend: false,

	/**
	 * If a point is sliced, moved out from the center, how many pixels
	 * should it be moved?.
	 * 
	 * @type {Number}
	 * @sample {highcharts} highcharts/plotoptions/pie-slicedoffset-20/ 20px offset
	 * @default 10
	 * @product highcharts
	 */
	slicedOffset: 10,

	/**
	 * The start angle of the pie slices in degrees where 0 is top and 90
	 * right.
	 * 
	 * @type {Number}
	 * @sample {highcharts} highcharts/plotoptions/pie-startangle-90/ Start from right
	 * @default 0
	 * @since 2.3.4
	 * @product highcharts
	 * @apioption plotOptions.pie.startAngle
	 */

	/**
	 * Sticky tracking of mouse events. When true, the `mouseOut` event
	 * on a series isn't triggered until the mouse moves over another series,
	 * or out of the plot area. When false, the `mouseOut` event on a
	 * series is triggered when the mouse leaves the area around the series'
	 * graph or markers. This also implies the tooltip. When `stickyTracking`
	 * is false and `tooltip.shared` is false, the tooltip will be hidden
	 * when moving the mouse between series.
	 * 
	 * @product highcharts
	 */
	stickyTracking: false,

	tooltip: {
		followPointer: true
	},
	

	/**
	 * The color of the border surrounding each slice. When `null`, the
	 * border takes the same color as the slice fill. This can be used
	 * together with a `borderWidth` to fill drawing gaps created by antialiazing
	 * artefacts in borderless pies.
	 * 
	 * In styled mode, the border stroke is given in the `.highcharts-point` class.
	 * 
	 * @type {Color}
	 * @sample {highcharts} highcharts/plotoptions/pie-bordercolor-black/ Black border
	 * @default #ffffff
	 * @product highcharts
	 */
	borderColor: '#ffffff',

	/**
	 * The width of the border surrounding each slice.
	 * 
	 * When setting the border width to 0, there may be small gaps between
	 * the slices due to SVG antialiasing artefacts. To work around this,
	 * keep the border width at 0.5 or 1, but set the `borderColor` to
	 * `null` instead.
	 * 
	 * In styled mode, the border stroke width is given in the `.highcharts-point` class.
	 * 
	 * @type {Number}
	 * @sample {highcharts} highcharts/plotoptions/pie-borderwidth/ 3px border
	 * @default 1
	 * @product highcharts
	 */
	borderWidth: 1,

	states: {

		/**
		 * @extends plotOptions.series.states.hover
		 * @product highcharts
		 */
		hover: {

			/**
			 * How much to brighten the point on interaction. Requires the main
			 * color to be defined in hex or rgb(a) format.
			 * 
			 * In styled mode, the hover brightness is by default replaced
			 * by a fill-opacity given in the `.highcharts-point-hover` class.
			 * 
			 * @type {Number}
			 * @sample {highcharts} highcharts/plotoptions/pie-states-hover-brightness/ Brightened by 0.5
			 * @default 0.1
			 * @product highcharts
			 */
			brightness: 0.1,

			shadow: false
		}
	}
	

}, /** @lends seriesTypes.pie.prototype */ {
	isCartesian: false,
	requireSorting: false,
	directTouch: true,
	noSharedTooltip: true,
	trackerGroups: ['group', 'dataLabelsGroup'],
	axisTypes: [],
	pointAttribs: seriesTypes.column.prototype.pointAttribs,
	/**
	 * Animate the pies in
	 */
	animate: function (init) {
		var series = this,
			points = series.points,
			startAngleRad = series.startAngleRad;

		if (!init) {
			each(points, function (point) {
				var graphic = point.graphic,
					args = point.shapeArgs;

				if (graphic) {
					// start values
					graphic.attr({
						r: point.startR || (series.center[3] / 2), // animate from inner radius (#779)
						start: startAngleRad,
						end: startAngleRad
					});

					// animate
					graphic.animate({
						r: args.r,
						start: args.start,
						end: args.end
					}, series.options.animation);
				}
			});

			// delete this function to allow it only once
			series.animate = null;
		}
	},

	/**
	 * Recompute total chart sum and update percentages of points.
	 */
	updateTotals: function () {
		var i,
			total = 0,
			points = this.points,
			len = points.length,
			point,
			ignoreHiddenPoint = this.options.ignoreHiddenPoint;

		// Get the total sum
		for (i = 0; i < len; i++) {
			point = points[i];
			total += (ignoreHiddenPoint && !point.visible) ?
				0 :
				point.isNull ? 0 : point.y;
		}
		this.total = total;

		// Set each point's properties
		for (i = 0; i < len; i++) {
			point = points[i];
			point.percentage = (total > 0 && (point.visible || !ignoreHiddenPoint)) ? point.y / total * 100 : 0;
			point.total = total;
		}
	},

	/**
	 * Extend the generatePoints method by adding total and percentage properties to each point
	 */
	generatePoints: function () {
		Series.prototype.generatePoints.call(this);
		this.updateTotals();
	},

	/**
	 * Do translation for pie slices
	 */
	translate: function (positions) {
		this.generatePoints();

		var series = this,
			cumulative = 0,
			precision = 1000, // issue #172
			options = series.options,
			slicedOffset = options.slicedOffset,
			connectorOffset = slicedOffset + (options.borderWidth || 0),
			finalConnectorOffset,
			start,
			end,
			angle,
			radians = getStartAndEndRadians(options.startAngle, options.endAngle),
			startAngleRad = series.startAngleRad = radians.start,
			endAngleRad = series.endAngleRad = radians.end,
			circ = endAngleRad - startAngleRad, // 2 * Math.PI,
			points = series.points,
			radiusX, // the x component of the radius vector for a given point
			radiusY,
			labelDistance = options.dataLabels.distance,
			ignoreHiddenPoint = options.ignoreHiddenPoint,
			i,
			len = points.length,
			point;

		// Get positions - either an integer or a percentage string must be given.
		// If positions are passed as a parameter, we're in a recursive loop for adjusting
		// space for data labels.
		if (!positions) {
			series.center = positions = series.getCenter();
		}

		// Utility for getting the x value from a given y, used for anticollision
		// logic in data labels.
		// Added point for using specific points' label distance.
		series.getX = function (y, left, point) {
			angle = Math.asin(Math.min((y - positions[1]) / (positions[2] / 2 + point.labelDistance), 1));
			return positions[0] +
				(left ? -1 : 1) *
				(Math.cos(angle) * (positions[2] / 2 + point.labelDistance));
		};

		// Calculate the geometry for each point
		for (i = 0; i < len; i++) {

			point = points[i];

			// Used for distance calculation for specific point.
			point.labelDistance = pick(
				point.options.dataLabels && point.options.dataLabels.distance,
				labelDistance
			);

			// Saved for later dataLabels distance calculation.
			series.maxLabelDistance = Math.max(series.maxLabelDistance || 0, point.labelDistance);

			// set start and end angle
			start = startAngleRad + (cumulative * circ);
			if (!ignoreHiddenPoint || point.visible) {
				cumulative += point.percentage / 100;
			}
			end = startAngleRad + (cumulative * circ);

			// set the shape
			point.shapeType = 'arc';
			point.shapeArgs = {
				x: positions[0],
				y: positions[1],
				r: positions[2] / 2,
				innerR: positions[3] / 2,
				start: Math.round(start * precision) / precision,
				end: Math.round(end * precision) / precision
			};

			// The angle must stay within -90 and 270 (#2645)
			angle = (end + start) / 2;
			if (angle > 1.5 * Math.PI) {
				angle -= 2 * Math.PI;
			} else if (angle < -Math.PI / 2) {
				angle += 2 * Math.PI;
			}

			// Center for the sliced out slice
			point.slicedTranslation = {
				translateX: Math.round(Math.cos(angle) * slicedOffset),
				translateY: Math.round(Math.sin(angle) * slicedOffset)
			};

			// set the anchor point for tooltips
			radiusX = Math.cos(angle) * positions[2] / 2;
			radiusY = Math.sin(angle) * positions[2] / 2;
			point.tooltipPos = [
				positions[0] + radiusX * 0.7,
				positions[1] + radiusY * 0.7
			];
			
			point.half = angle < -Math.PI / 2 || angle > Math.PI / 2 ? 1 : 0;
			point.angle = angle;

			// Set the anchor point for data labels. Use point.labelDistance 
			// instead of labelDistance // #1174
			// finalConnectorOffset - not override connectorOffset value.
			finalConnectorOffset = Math.min(connectorOffset, point.labelDistance / 5); // #1678
			point.labelPos = [
				positions[0] + radiusX + Math.cos(angle) * point.labelDistance, // first break of connector
				positions[1] + radiusY + Math.sin(angle) * point.labelDistance, // a/a
				positions[0] + radiusX + Math.cos(angle) * finalConnectorOffset, // second break, right outside pie
				positions[1] + radiusY + Math.sin(angle) * finalConnectorOffset, // a/a
				positions[0] + radiusX, // landing point for connector
				positions[1] + radiusY, // a/a
				point.labelDistance < 0 ? // alignment
					'center' :
					point.half ? 'right' : 'left', // alignment
				angle // center angle
			];

		}
	},

	drawGraph: null,

	/**
	 * Draw the data points
	 */
	drawPoints: function () {
		var series = this,
			chart = series.chart,
			renderer = chart.renderer,
			groupTranslation,
			graphic,
			pointAttr,
			shapeArgs;

		
		var shadow = series.options.shadow;
		if (shadow && !series.shadowGroup) {
			series.shadowGroup = renderer.g('shadow')
				.add(series.group);
		}
		

		// draw the slices
		each(series.points, function (point) {
			graphic = point.graphic;
			if (!point.isNull) {
				shapeArgs = point.shapeArgs;


				// If the point is sliced, use special translation, else use
				// plot area traslation
				groupTranslation = point.getTranslate();

				
				// Put the shadow behind all points
				var shadowGroup = point.shadowGroup;
				if (shadow && !shadowGroup) {
					shadowGroup = point.shadowGroup = renderer.g('shadow')
						.add(series.shadowGroup);
				}

				if (shadowGroup) {
					shadowGroup.attr(groupTranslation);
				}
				pointAttr = series.pointAttribs(point, point.selected && 'select');
				

				// Draw the slice
				if (graphic) {
					graphic
						.setRadialReference(series.center)
						
						.attr(pointAttr)
						
						.animate(extend(shapeArgs, groupTranslation));
				} else {

					point.graphic = graphic = renderer[point.shapeType](shapeArgs)
						.setRadialReference(series.center)
						.attr(groupTranslation)
						.add(series.group);

					if (!point.visible) {
						graphic.attr({ visibility: 'hidden' });
					}

					
					graphic
						.attr(pointAttr)
						.attr({ 'stroke-linejoin': 'round' })
						.shadow(shadow, shadowGroup);
					
				}

				graphic.addClass(point.getClassName());
						
			} else if (graphic) {
				point.graphic = graphic.destroy();
			}
		});

	},


	searchPoint: noop,

	/**
	 * Utility for sorting data labels
	 */
	sortByAngle: function (points, sign) {
		points.sort(function (a, b) {
			return a.angle !== undefined && (b.angle - a.angle) * sign;
		});
	},

	/**
	 * Use a simple symbol from LegendSymbolMixin
	 */
	drawLegendSymbol: LegendSymbolMixin.drawRectangle,

	/**
	 * Use the getCenter method from drawLegendSymbol
	 */
	getCenter: CenteredSeriesMixin.getCenter,

	/**
	 * Pies don't have point marker symbols
	 */
	getSymbol: noop


/**
 * @constructor seriesTypes.pie.prototype.pointClass
 * @extends {Point}
 */
}, /** @lends seriesTypes.pie.prototype.pointClass.prototype */ {
	/**
	 * Initiate the pie slice
	 */
	init: function () {

		Point.prototype.init.apply(this, arguments);

		var point = this,
			toggleSlice;

		point.name = pick(point.name, 'Slice');

		// add event listener for select
		toggleSlice = function (e) {
			point.slice(e.type === 'select');
		};
		addEvent(point, 'select', toggleSlice);
		addEvent(point, 'unselect', toggleSlice);

		return point;
	},

	/**
	 * Negative points are not valid (#1530, #3623, #5322)
	 */
	isValid: function () {
		return H.isNumber(this.y, true) && this.y >= 0;
	},

	/**
	 * Toggle the visibility of the pie slice
	 * @param {Boolean} vis Whether to show the slice or not. If undefined, the
	 *    visibility is toggled
	 */
	setVisible: function (vis, redraw) {
		var point = this,
			series = point.series,
			chart = series.chart,
			ignoreHiddenPoint = series.options.ignoreHiddenPoint;

		redraw = pick(redraw, ignoreHiddenPoint);

		if (vis !== point.visible) {

			// If called without an argument, toggle visibility
			point.visible = point.options.visible = vis = vis === undefined ? !point.visible : vis;
			series.options.data[inArray(point, series.data)] = point.options; // update userOptions.data

			// Show and hide associated elements. This is performed regardless of redraw or not,
			// because chart.redraw only handles full series.
			each(['graphic', 'dataLabel', 'connector', 'shadowGroup'], function (key) {
				if (point[key]) {
					point[key][vis ? 'show' : 'hide'](true);
				}
			});

			if (point.legendItem) {
				chart.legend.colorizeItem(point, vis);
			}

			// #4170, hide halo after hiding point
			if (!vis && point.state === 'hover') {
				point.setState('');
			}

			// Handle ignore hidden slices
			if (ignoreHiddenPoint) {
				series.isDirty = true;
			}

			if (redraw) {
				chart.redraw();
			}
		}
	},

	/**
	 * Set or toggle whether the slice is cut out from the pie
	 * @param {Boolean} sliced When undefined, the slice state is toggled
	 * @param {Boolean} redraw Whether to redraw the chart. True by default.
	 */
	slice: function (sliced, redraw, animation) {
		var point = this,
			series = point.series,
			chart = series.chart;

		setAnimation(animation, chart);

		// redraw is true by default
		redraw = pick(redraw, true);

		// if called without an argument, toggle
		point.sliced = point.options.sliced = sliced = defined(sliced) ? sliced : !point.sliced;
		series.options.data[inArray(point, series.data)] = point.options; // update userOptions.data

		point.graphic.animate(this.getTranslate());
		
		
		if (point.shadowGroup) {
			point.shadowGroup.animate(this.getTranslate());
		}
		
	},

	getTranslate: function () {
		return this.sliced ? this.slicedTranslation : {
			translateX: 0,
			translateY: 0
		};
	},

	haloPath: function (size) {
		var shapeArgs = this.shapeArgs;

		return this.sliced || !this.visible ? 
			[] :
			this.series.chart.renderer.symbols.arc(
				shapeArgs.x,
				shapeArgs.y,
				shapeArgs.r + size,
				shapeArgs.r + size, {
					// Substract 1px to ensure the background is not bleeding
					// through between the halo and the slice (#7495).
					innerR: this.shapeArgs.r - 1,
					start: shapeArgs.start,
					end: shapeArgs.end
				}
			);
	}
});

/**
 * A `pie` series. If the [type](#series.pie.type) option is not specified,
 * it is inherited from [chart.type](#chart.type).
 * 
 * For options that apply to multiple series, it is recommended to add
 * them to the [plotOptions.series](#plotOptions.series) options structure.
 * To apply to all series of this specific type, apply it to [plotOptions.
 * pie](#plotOptions.pie).
 * 
 * @type {Object}
 * @extends series,plotOptions.pie
 * @excluding dataParser,dataURL,stack,xAxis,yAxis
 * @product highcharts
 * @apioption series.pie
 */

/**
 * An array of data points for the series. For the `pie` series type,
 * points can be given in the following ways:
 * 
 * 1.  An array of numerical values. In this case, the numerical values
 * will be interpreted as `y` options. Example:
 * 
 *  ```js
 *  data: [0, 5, 3, 5]
 *  ```
 * 
 * 2.  An array of objects with named values. The objects are point
 * configuration objects as seen below. If the total number of data
 * points exceeds the series' [turboThreshold](#series.pie.turboThreshold),
 * this option is not available.
 * 
 *  ```js
 *     data: [{
 *     y: 1,
 *     name: "Point2",
 *     color: "#00FF00"
 * }, {
 *     y: 7,
 *     name: "Point1",
 *     color: "#FF00FF"
 * }]</pre>
 * 
 * @type {Array<Object|Number>}
 * @extends series.line.data
 * @excluding marker,x
 * @sample {highcharts} highcharts/chart/reflow-true/ Numerical values
 * @sample {highcharts} highcharts/series/data-array-of-arrays/ Arrays of numeric x and y
 * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/ Arrays of datetime x and y
 * @sample {highcharts} highcharts/series/data-array-of-name-value/ Arrays of point.name and y
 * @sample {highcharts} highcharts/series/data-array-of-objects/ Config objects
 * @product highcharts
 * @apioption series.pie.data
 */

/**
 * The sequential index of the data point in the legend.
 * 
 * @type {Number}
 * @product highcharts
 * @apioption series.pie.data.legendIndex
 */

/**
 * Whether to display a slice offset from the center.
 * 
 * @type {Boolean}
 * @sample {highcharts} highcharts/point/sliced/ One sliced point
 * @product highcharts
 * @apioption series.pie.data.sliced
 */

/**
 * Fires when the checkbox next to the point name in the legend is clicked.
 * One parameter, event, is passed to the function. The state of the
 * checkbox is found by event.checked. The checked item is found by
 * event.item. Return false to prevent the default action which is to
 * toggle the select state of the series.
 * 
 * @type {Function}
 * @context Point
 * @sample {highcharts} highcharts/plotoptions/series-events-checkboxclick/
 *         Alert checkbox status
 * @since 1.2.0
 * @product highcharts
 * @apioption plotOptions.pie.events.checkboxClick
 */

/**
 * Not applicable to pies, as the legend item is per point. See point.
 * events.
 * 
 * @type {Function}
 * @since 1.2.0
 * @product highcharts
 * @apioption plotOptions.pie.events.legendItemClick
 */

/**
 * Fires when the legend item belonging to the pie point (slice) is
 * clicked. The `this` keyword refers to the point itself. One parameter,
 * `event`, is passed to the function, containing common event information. The
 * default action is to toggle the visibility of the point. This can be
 * prevented by calling `event.preventDefault()`.
 * 
 * @type {Function}
 * @sample {highcharts} highcharts/plotoptions/pie-point-events-legenditemclick/
 *         Confirm toggle visibility
 * @since 1.2.0
 * @product highcharts
 * @apioption plotOptions.pie.point.events.legendItemClick
 */

}(Highcharts));
(function (H) {
/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var addEvent = H.addEvent,
	arrayMax = H.arrayMax,
	defined = H.defined,
	each = H.each,
	extend = H.extend,
	format = H.format,
	map = H.map,
	merge = H.merge,
	noop = H.noop,
	pick = H.pick,
	relativeLength = H.relativeLength,
	Series = H.Series,
	seriesTypes = H.seriesTypes,
	stableSort = H.stableSort;

/* eslint max-len: ["warn", 80, 4] */
/**
 * General distribution algorithm for distributing labels of differing size
 * along a confined length in two dimensions. The algorithm takes an array of
 * objects containing a size, a target and a rank. It will place the labels as
 * close as possible to their targets, skipping the lowest ranked labels if
 * necessary.
 */
H.distribute = function (boxes, len) {
	
	var i, 
		overlapping = true,
		origBoxes = boxes, // Original array will be altered with added .pos
		restBoxes = [], // The outranked overshoot
		box,
		target,
		total = 0;

	function sortByTarget(a, b) {
		return a.target - b.target;
	}
	
	// If the total size exceeds the len, remove those boxes with the lowest
	// rank
	i = boxes.length;
	while (i--) {
		total += boxes[i].size;
	}

	// Sort by rank, then slice away overshoot
	if (total > len) {
		stableSort(boxes, function (a, b) {
			return (b.rank || 0) - (a.rank || 0);
		});
		i = 0;
		total = 0;
		while (total <= len) {
			total += boxes[i].size;
			i++;
		}
		restBoxes = boxes.splice(i - 1, boxes.length);
	}
	
	// Order by target
	stableSort(boxes, sortByTarget);


	// So far we have been mutating the original array. Now
	// create a copy with target arrays
	boxes = map(boxes, function (box) {
		return {
			size: box.size,
			targets: [box.target],
			align: pick(box.align, 0.5)
		};
	});
	
	while (overlapping) {
		// Initial positions: target centered in box
		i = boxes.length;
		while (i--) {
			box = boxes[i];
			// Composite box, average of targets
			target = (
				Math.min.apply(0, box.targets) +
				Math.max.apply(0, box.targets)
			) / 2;
			box.pos = Math.min(
				Math.max(0, target - box.size * box.align),
				len - box.size
			);
		}

		// Detect overlap and join boxes
		i = boxes.length;
		overlapping = false;
		while (i--) {
			// Overlap
			if (i > 0 && boxes[i - 1].pos + boxes[i - 1].size > boxes[i].pos) {
				// Add this size to the previous box
				boxes[i - 1].size += boxes[i].size;
				boxes[i - 1].targets = boxes[i - 1]
					.targets
					.concat(boxes[i].targets);
				boxes[i - 1].align = 0.5;
				
				// Overlapping right, push left
				if (boxes[i - 1].pos + boxes[i - 1].size > len) {
					boxes[i - 1].pos = len - boxes[i - 1].size;
				}
				boxes.splice(i, 1); // Remove this item
				overlapping = true;
			}
		}
	}

	// Now the composite boxes are placed, we need to put the original boxes
	// within them
	i = 0;
	each(boxes, function (box) {
		var posInCompositeBox = 0;
		each(box.targets, function () {
			origBoxes[i].pos = box.pos + posInCompositeBox;
			posInCompositeBox += origBoxes[i].size;
			i++;
		});
	});
	
	// Add the rest (hidden) boxes and sort by target
	origBoxes.push.apply(origBoxes, restBoxes);
	stableSort(origBoxes, sortByTarget);
};


/**
 * Draw the data labels
 */
Series.prototype.drawDataLabels = function () {
	var series = this,
		chart = series.chart,
		seriesOptions = series.options,
		options = seriesOptions.dataLabels,
		points = series.points,
		pointOptions,
		generalOptions,
		hasRendered = series.hasRendered || 0,
		str,
		dataLabelsGroup,
		defer = pick(options.defer, !!seriesOptions.animation),
		renderer = chart.renderer;

	/*
	 * Handle the dataLabels.filter option.
	 */
	function applyFilter(point, options) {
		var filter = options.filter,
			op,
			prop,
			val;
		if (filter) {
			op = filter.operator;
			prop = point[filter.property];
			val = filter.value;
			if (
				(op === '>' && prop > val) ||
				(op === '<' && prop < val) ||
				(op === '>=' && prop >= val) ||
				(op === '<=' && prop <= val) ||
				(op === '==' && prop == val) || // eslint-disable-line eqeqeq
				(op === '===' && prop === val)
			) {
				return true;
			}
			return false;
		}
		return true;
	}

	if (options.enabled || series._hasPointLabels) {

		// Process default alignment of data labels for columns
		if (series.dlProcessOptions) {
			series.dlProcessOptions(options);
		}

		// Create a separate group for the data labels to avoid rotation
		dataLabelsGroup = series.plotGroup(
			'dataLabelsGroup',
			'data-labels',
			defer && !hasRendered ? 'hidden' : 'visible', // #5133
			options.zIndex || 6
		);

		if (defer) {
			dataLabelsGroup.attr({ opacity: +hasRendered }); // #3300
			if (!hasRendered) {
				addEvent(series, 'afterAnimate', function () {
					if (series.visible) { // #2597, #3023, #3024
						dataLabelsGroup.show(true);
					}
					dataLabelsGroup[
						seriesOptions.animation ? 'animate' : 'attr'
					]({ opacity: 1 }, { duration: 200 });
				});
			}
		}

		// Make the labels for each point
		generalOptions = options;
		each(points, function (point) {
			var enabled,
				dataLabel = point.dataLabel,
				labelConfig,
				attr,
				rotation,
				connector = point.connector,
				isNew = !dataLabel,
				style,
				formatString;

			// Determine if each data label is enabled
			// @note dataLabelAttribs (like pointAttribs) would eradicate
			// the need for dlOptions, and simplify the section below.
			pointOptions = point.dlOptions || // dlOptions is used in treemaps
				(point.options && point.options.dataLabels);
			enabled = pick(
				pointOptions && pointOptions.enabled,
				generalOptions.enabled
			) && !point.isNull; // #2282, #4641, #7112

			if (enabled) {
				enabled = applyFilter(point, pointOptions || options) === true;
			}

			if (enabled) {
				// Create individual options structure that can be extended
				// without affecting others
				options = merge(generalOptions, pointOptions);
				labelConfig = point.getLabelConfig();
				formatString = (
					options[point.formatPrefix + 'Format'] ||
					options.format
				);

				str = defined(formatString) ?
					format(formatString, labelConfig, chart.time) :
					(
						options[point.formatPrefix + 'Formatter'] ||
						options.formatter
					).call(labelConfig, options);
				
				style = options.style;
				rotation = options.rotation;
				
				// Determine the color
				style.color = pick(
					options.color,
					style.color,
					series.color,
					'#000000'
				);
				// Get automated contrast color
				if (style.color === 'contrast') {
					point.contrastColor =
						renderer.getContrast(point.color || series.color);
					style.color = options.inside ||
						pick(point.labelDistance, options.distance) < 0 ||
						!!seriesOptions.stacking ?
							point.contrastColor :
							'#000000';
				}
				if (seriesOptions.cursor) {
					style.cursor = seriesOptions.cursor;
				}
				
				
				attr = {
					
					fill: options.backgroundColor,
					stroke: options.borderColor,
					'stroke-width': options.borderWidth,
					
					r: options.borderRadius || 0,
					rotation: rotation,
					padding: options.padding,
					zIndex: 1
				};

				// Remove unused attributes (#947)
				H.objectEach(attr, function (val, name) {
					if (val === undefined) {
						delete attr[name];
					}
				});
			}
			// If the point is outside the plot area, destroy it. #678, #820
			if (dataLabel && (!enabled || !defined(str))) {
				point.dataLabel = dataLabel = dataLabel.destroy();
				if (connector) {
					point.connector = connector.destroy();
				}
			// Individual labels are disabled if the are explicitly disabled
			// in the point options, or if they fall outside the plot area.
			} else if (enabled && defined(str)) {
				// create new label
				if (!dataLabel) {
					dataLabel = point.dataLabel = rotation ?

						renderer.text(str, 0, -9999) // labels don't rotate
							.addClass('highcharts-data-label') :

						renderer.label(
							str,
							0,
							-9999,
							options.shape,
							null,
							null,
							options.useHTML,
							null, 
							'data-label'
						);
					
					dataLabel.addClass(
						' highcharts-data-label-color-' + point.colorIndex +
						' ' + (options.className || '') +
						(options.useHTML ? 'highcharts-tracker' : '') // #3398
					);
				} else {
					attr.text = str;
				}
				dataLabel.attr(attr);
				
				// Styles must be applied before add in order to read text
				// bounding box
				dataLabel.css(style).shadow(options.shadow);
				

				if (!dataLabel.added) {
					dataLabel.add(dataLabelsGroup);
				}
				// Now the data label is created and placed at 0,0, so we need
				// to align it
				series.alignDataLabel(point, dataLabel, options, null, isNew);
			}
		});
	}
};

/**
 * Align each individual data label
 */
Series.prototype.alignDataLabel = function (
	point,
	dataLabel,
	options,
	alignTo,
	isNew
) {
	var chart = this.chart,
		inverted = chart.inverted,
		plotX = pick(point.dlBox && point.dlBox.centerX, point.plotX, -9999),
		plotY = pick(point.plotY, -9999),
		bBox = dataLabel.getBBox(),
		fontSize,
		baseline,
		rotation = options.rotation,
		normRotation,
		negRotation,
		align = options.align,
		rotCorr, // rotation correction
		// Math.round for rounding errors (#2683), alignTo to allow column
		// labels (#2700)
		visible = 
			this.visible &&
			(
				point.series.forceDL ||
				chart.isInsidePlot(plotX, Math.round(plotY), inverted) ||
				(
					alignTo && chart.isInsidePlot(
						plotX,
						inverted ?
							alignTo.x + 1 :
							alignTo.y + alignTo.height - 1,
						inverted
					)
				)
			),
		alignAttr, // the final position;
		justify = pick(options.overflow, 'justify') === 'justify';

	if (visible) {

		
		fontSize = options.style.fontSize;
		

		baseline = chart.renderer.fontMetrics(fontSize, dataLabel).b;

		// The alignment box is a singular point
		alignTo = extend({
			x: inverted ? this.yAxis.len - plotY : plotX,
			y: Math.round(inverted ? this.xAxis.len - plotX : plotY),
			width: 0,
			height: 0
		}, alignTo);

		// Add the text size for alignment calculation
		extend(options, {
			width: bBox.width,
			height: bBox.height
		});

		// Allow a hook for changing alignment in the last moment, then do the
		// alignment
		if (rotation) {
			justify = false; // Not supported for rotated text
			rotCorr = chart.renderer.rotCorr(baseline, rotation); // #3723
			alignAttr = {
				x: alignTo.x + options.x + alignTo.width / 2 + rotCorr.x,
				y: (
					alignTo.y +
					options.y +
					{ top: 0, middle: 0.5, bottom: 1 }[options.verticalAlign] *
						alignTo.height
				)
			};
			dataLabel[isNew ? 'attr' : 'animate'](alignAttr)
				.attr({ // #3003
					align: align
				});

			// Compensate for the rotated label sticking out on the sides
			normRotation = (rotation + 720) % 360;
			negRotation = normRotation > 180 && normRotation < 360;

			if (align === 'left') {
				alignAttr.y -= negRotation ? bBox.height : 0;
			} else if (align === 'center') {
				alignAttr.x -= bBox.width / 2;
				alignAttr.y -= bBox.height / 2;
			} else if (align === 'right') {
				alignAttr.x -= bBox.width;
				alignAttr.y -= negRotation ? 0 : bBox.height;
			}
			

		} else {
			dataLabel.align(options, null, alignTo);
			alignAttr = dataLabel.alignAttr;
		}

		// Handle justify or crop
		if (justify) {
			point.isLabelJustified = this.justifyDataLabel(
				dataLabel,
				options,
				alignAttr,
				bBox,
				alignTo,
				isNew
			);
			
		// Now check that the data label is within the plot area
		} else if (pick(options.crop, true)) {
			visible = 
				chart.isInsidePlot(
					alignAttr.x,
					alignAttr.y
				) &&
				chart.isInsidePlot(
					alignAttr.x + bBox.width,
					alignAttr.y + bBox.height
				);
		}

		// When we're using a shape, make it possible with a connector or an
		// arrow pointing to thie point
		if (options.shape && !rotation) {
			dataLabel[isNew ? 'attr' : 'animate']({
				anchorX: inverted ? chart.plotWidth - point.plotY : point.plotX,
				anchorY: inverted ? chart.plotHeight - point.plotX : point.plotY
			});
		}
	}

	// Show or hide based on the final aligned position
	if (!visible) {
		dataLabel.attr({ y: -9999 });
		dataLabel.placed = false; // don't animate back in
	}

};

/**
 * If data labels fall partly outside the plot area, align them back in, in a
 * way that doesn't hide the point.
 */
Series.prototype.justifyDataLabel = function (
	dataLabel,
	options,
	alignAttr,
	bBox,
	alignTo,
	isNew
) {
	var chart = this.chart,
		align = options.align,
		verticalAlign = options.verticalAlign,
		off,
		justified,
		padding = dataLabel.box ? 0 : (dataLabel.padding || 0);

	// Off left
	off = alignAttr.x + padding;
	if (off < 0) {
		if (align === 'right') {
			options.align = 'left';
		} else {
			options.x = -off;
		}
		justified = true;
	}

	// Off right
	off = alignAttr.x + bBox.width - padding;
	if (off > chart.plotWidth) {
		if (align === 'left') {
			options.align = 'right';
		} else {
			options.x = chart.plotWidth - off;
		}
		justified = true;
	}

	// Off top
	off = alignAttr.y + padding;
	if (off < 0) {
		if (verticalAlign === 'bottom') {
			options.verticalAlign = 'top';
		} else {
			options.y = -off;
		}
		justified = true;
	}

	// Off bottom
	off = alignAttr.y + bBox.height - padding;
	if (off > chart.plotHeight) {
		if (verticalAlign === 'top') {
			options.verticalAlign = 'bottom';
		} else {
			options.y = chart.plotHeight - off;
		}
		justified = true;
	}

	if (justified) {
		dataLabel.placed = !isNew;
		dataLabel.align(options, null, alignTo);
	}

	return justified;
};

/**
 * Override the base drawDataLabels method by pie specific functionality
 */
if (seriesTypes.pie) {
	seriesTypes.pie.prototype.drawDataLabels = function () {
		var series = this,
			data = series.data,
			point,
			chart = series.chart,
			options = series.options.dataLabels,
			connectorPadding = pick(options.connectorPadding, 10),
			connectorWidth = pick(options.connectorWidth, 1),
			plotWidth = chart.plotWidth,
			plotHeight = chart.plotHeight,
			connector,
			seriesCenter = series.center,
			radius = seriesCenter[2] / 2,
			centerY = seriesCenter[1],
			dataLabel,
			dataLabelWidth,
			labelPos,
			labelHeight,
			// divide the points into right and left halves for anti collision
			halves = [
				[], // right
				[]  // left
			],
			x,
			y,
			visibility,
			j,
			overflow = [0, 0, 0, 0]; // top, right, bottom, left

		// get out if not enabled
		if (!series.visible || (!options.enabled && !series._hasPointLabels)) {
			return;
		}

		// Reset all labels that have been shortened
		each(data, function (point) {
			if (point.dataLabel && point.visible && point.dataLabel.shortened) {
				point.dataLabel
					.attr({
						width: 'auto'
					}).css({
						width: 'auto',					
						textOverflow: 'clip'
					});
				point.dataLabel.shortened = false;
			}
		});
		

		// run parent method
		Series.prototype.drawDataLabels.apply(series);

		each(data, function (point) {
			if (point.dataLabel && point.visible) { // #407, #2510

				// Arrange points for detection collision
				halves[point.half].push(point);

				// Reset positions (#4905)
				point.dataLabel._pos = null;
			}
		});

		/* Loop over the points in each half, starting from the top and bottom
		 * of the pie to detect overlapping labels.
		 */
		each(halves, function (points, i) {

			var top,
				bottom,
				length = points.length,
				positions = [],
				naturalY,
				sideOverflow,
				positionsIndex, // Point index in positions array.
				size;

			if (!length) {
				return;
			}

			// Sort by angle
			series.sortByAngle(points, i - 0.5);
			// Only do anti-collision when we have dataLabels outside the pie 
			// and have connectors. (#856)
			if (series.maxLabelDistance > 0) {
				top = Math.max(
					0,
					centerY - radius - series.maxLabelDistance
				);
				bottom = Math.min(
					centerY + radius + series.maxLabelDistance,
					chart.plotHeight
				);
				each(points, function (point) {
					// check if specific points' label is outside the pie
					if (point.labelDistance > 0 && point.dataLabel) {
						// point.top depends on point.labelDistance value
						// Used for calculation of y value in getX method 
						point.top = Math.max(
							0,
							centerY - radius - point.labelDistance
						);
						point.bottom = Math.min(
							centerY + radius + point.labelDistance,
							chart.plotHeight
						);
						size = point.dataLabel.getBBox().height || 21;

						// point.positionsIndex is needed for getting index of 
						// parameter related to specific point inside positions 
						// array - not every point is in positions array.
						point.positionsIndex = positions.push({
							target: point.labelPos[1] - point.top + size / 2,
							size: size,
							rank: point.y
						}) - 1;
					}
				});
				H.distribute(positions, bottom + size - top);
			}

			// Now the used slots are sorted, fill them up sequentially
			for (j = 0; j < length; j++) {

				point = points[j];
				positionsIndex = point.positionsIndex;
				labelPos = point.labelPos;
				dataLabel = point.dataLabel;
				visibility = point.visible === false ? 'hidden' : 'inherit';
				naturalY = labelPos[1];
				y = naturalY;

				if (positions && defined(positions[positionsIndex])) {
					if (positions[positionsIndex].pos === undefined) {
						visibility = 'hidden';
					} else {
						labelHeight = positions[positionsIndex].size;
						y = point.top + positions[positionsIndex].pos;
					}
				}

				// It is needed to delete point.positionIndex for 
				// dynamically added points etc.
				
				delete point.positionIndex;

				// get the x - use the natural x position for labels near the 
				// top and bottom, to prevent the top and botton slice
				// connectors from touching each other on either side
				if (options.justify) {
					x = seriesCenter[0] +
						(i ? -1 : 1) * (radius + point.labelDistance);
				} else {
					x = series.getX(
						y < point.top + 2 || y > point.bottom - 2 ?
							naturalY :
							y,
						i,
						point
					);
				}


				// Record the placement and visibility
				dataLabel._attr = {
					visibility: visibility,
					align: labelPos[6]
				};
				dataLabel._pos = {
					x: (
						x +
						options.x +
						({
							left: connectorPadding,
							right: -connectorPadding
						}[labelPos[6]] || 0)
					),

					// 10 is for the baseline (label vs text)
					y: y + options.y - 10
				};
				labelPos.x = x;
				labelPos.y = y;


				// Detect overflowing data labels
				if (pick(options.crop, true)) {
					dataLabelWidth = dataLabel.getBBox().width;

					sideOverflow = null;
					// Overflow left
					if (x - dataLabelWidth < connectorPadding) {
						sideOverflow = Math.round(
							dataLabelWidth - x + connectorPadding
						);
						overflow[3] = Math.max(sideOverflow, overflow[3]);

					// Overflow right
					} else if (
						x + dataLabelWidth >
						plotWidth - connectorPadding
					) {
						sideOverflow = Math.round(
							x + dataLabelWidth - plotWidth + connectorPadding
						);
						overflow[1] = Math.max(sideOverflow, overflow[1]);
					}

					// Overflow top
					if (y - labelHeight / 2 < 0) {
						overflow[0] = Math.max(
							Math.round(-y + labelHeight / 2),
							overflow[0]
						);

					// Overflow left
					} else if (y + labelHeight / 2 > plotHeight) {
						overflow[2] = Math.max(
							Math.round(y + labelHeight / 2 - plotHeight),
							overflow[2]
						);
					}
					dataLabel.sideOverflow = sideOverflow;
				}
			} // for each point
		}); // for each half

		// Do not apply the final placement and draw the connectors until we
		// have verified that labels are not spilling over.
		if (
			arrayMax(overflow) === 0 ||
			this.verifyDataLabelOverflow(overflow)
		) {

			// Place the labels in the final position
			this.placeDataLabels();

			// Draw the connectors
			if (connectorWidth) {
				each(this.points, function (point) {
					var isNew;

					connector = point.connector;
					dataLabel = point.dataLabel;

					if (
						dataLabel &&
						dataLabel._pos &&
						point.visible &&
						point.labelDistance > 0
					) {
						visibility = dataLabel._attr.visibility;

						isNew = !connector;

						if (isNew) {
							point.connector = connector = chart.renderer.path()
								.addClass('highcharts-data-label-connector ' +
									' highcharts-color-' + point.colorIndex)
								.add(series.dataLabelsGroup);

							
							connector.attr({
								'stroke-width': connectorWidth,
								'stroke': (
									options.connectorColor ||
									point.color ||
									'#666666'
								)
							});
							
						}
						connector[isNew ? 'attr' : 'animate']({
							d: series.connectorPath(point.labelPos)
						});
						connector.attr('visibility', visibility);

					} else if (connector) {
						point.connector = connector.destroy();
					}
				});
			}
		}
	};

	/**
	 * Extendable method for getting the path of the connector between the data
	 * label and the pie slice.
	 */
	seriesTypes.pie.prototype.connectorPath = function (labelPos) {
		var x = labelPos.x,
			y = labelPos.y;
		return pick(this.options.dataLabels.softConnector, true) ? [
			'M',
			// end of the string at the label
			x + (labelPos[6] === 'left' ? 5 : -5), y,
			'C',
			x, y, // first break, next to the label
			2 * labelPos[2] - labelPos[4], 2 * labelPos[3] - labelPos[5],
			labelPos[2], labelPos[3], // second break
			'L',
			labelPos[4], labelPos[5] // base
		] : [
			'M',
			// end of the string at the label
			x + (labelPos[6] === 'left' ? 5 : -5), y, 
			'L',
			labelPos[2], labelPos[3], // second break
			'L',
			labelPos[4], labelPos[5] // base
		];
	};

	/**
	 * Perform the final placement of the data labels after we have verified
	 * that they fall within the plot area.
	 */
	seriesTypes.pie.prototype.placeDataLabels = function () {
		each(this.points, function (point) {
			var dataLabel = point.dataLabel,
				_pos;
			if (dataLabel && point.visible) {
				_pos = dataLabel._pos;
				if (_pos) {

					// Shorten data labels with ellipsis if they still overflow
					// after the pie has reached minSize (#223).
					if (dataLabel.sideOverflow) {
						dataLabel._attr.width =
							dataLabel.getBBox().width - dataLabel.sideOverflow;
						dataLabel.css({
							width: dataLabel._attr.width + 'px',
							textOverflow: 'ellipsis'
						});
						dataLabel.shortened = true;
					}

					dataLabel.attr(dataLabel._attr);
					dataLabel[dataLabel.moved ? 'animate' : 'attr'](_pos);
					dataLabel.moved = true;
				} else if (dataLabel) {
					dataLabel.attr({ y: -9999 });
				}
			}
		}, this);
	};

	seriesTypes.pie.prototype.alignDataLabel =  noop;

	/**
	 * Verify whether the data labels are allowed to draw, or we should run more
	 * translation and data label positioning to keep them inside the plot area.
	 * Returns true when data labels are ready to draw.
	 */
	seriesTypes.pie.prototype.verifyDataLabelOverflow = function (overflow) {

		var center = this.center,
			options = this.options,
			centerOption = options.center,
			minSize = options.minSize || 80,
			newSize = minSize,
			// If a size is set, return true and don't try to shrink the pie
			// to fit the labels.
			ret = options.size !== null;

		if (!ret) {
			// Handle horizontal size and center
			if (centerOption[0] !== null) { // Fixed center
				newSize = Math.max(center[2] -
					Math.max(overflow[1], overflow[3]), minSize);

			} else { // Auto center
				newSize = Math.max(
					// horizontal overflow
					center[2] - overflow[1] - overflow[3],
					minSize
				);
				// horizontal center
				center[0] += (overflow[3] - overflow[1]) / 2;
			}

			// Handle vertical size and center
			if (centerOption[1] !== null) { // Fixed center
				newSize = Math.max(Math.min(newSize, center[2] -
					Math.max(overflow[0], overflow[2])), minSize);

			} else { // Auto center
				newSize = Math.max(
					Math.min(
						newSize,
						// vertical overflow
						center[2] - overflow[0] - overflow[2]
					),
					minSize
				);
				// vertical center
				center[1] += (overflow[0] - overflow[2]) / 2;
			}

			// If the size must be decreased, we need to run translate and
			// drawDataLabels again
			if (newSize < center[2]) {
				center[2] = newSize;
				center[3] = Math.min( // #3632
					relativeLength(options.innerSize || 0, newSize),
					newSize
				);
				this.translate(center);
				
				if (this.drawDataLabels) {
					this.drawDataLabels();
				}
			// Else, return true to indicate that the pie and its labels is
			// within the plot area
			} else {
				ret = true;
			}
		}
		return ret;
	};
}

if (seriesTypes.column) {

	/**
	 * Override the basic data label alignment by adjusting for the position of
	 * the column
	 */
	seriesTypes.column.prototype.alignDataLabel = function (
		point,
		dataLabel,
		options,
		alignTo,
		isNew
	) {
		var inverted = this.chart.inverted,
			series = point.series,
			// data label box for alignment
			dlBox = point.dlBox || point.shapeArgs,
			below = pick(
				point.below, // range series
				point.plotY > pick(this.translatedThreshold, series.yAxis.len)
			),
			// draw it inside the box?
			inside = pick(options.inside, !!this.options.stacking),
			overshoot;

		// Align to the column itself, or the top of it
		if (dlBox) { // Area range uses this method but not alignTo
			alignTo = merge(dlBox);

			if (alignTo.y < 0) {
				alignTo.height += alignTo.y;
				alignTo.y = 0;
			}
			overshoot = alignTo.y + alignTo.height - series.yAxis.len;
			if (overshoot > 0) {
				alignTo.height -= overshoot;
			}

			if (inverted) {
				alignTo = {
					x: series.yAxis.len - alignTo.y - alignTo.height,
					y: series.xAxis.len - alignTo.x - alignTo.width,
					width: alignTo.height,
					height: alignTo.width
				};
			}

			// Compute the alignment box
			if (!inside) {
				if (inverted) {
					alignTo.x += below ? 0 : alignTo.width;
					alignTo.width = 0;
				} else {
					alignTo.y += below ? alignTo.height : 0;
					alignTo.height = 0;
				}
			}
		}


		// When alignment is undefined (typically columns and bars), display the
		// individual point below or above the point depending on the threshold
		options.align = pick(
			options.align,
			!inverted || inside ? 'center' : below ? 'right' : 'left'
		);
		options.verticalAlign = pick(
			options.verticalAlign,
			inverted || inside ? 'middle' : below ? 'top' : 'bottom'
		);

		// Call the parent method
		Series.prototype.alignDataLabel.call(
			this,
			point,
			dataLabel,
			options,
			alignTo,
			isNew
		);

		// If label was justified and we have contrast, set it:
		if (point.isLabelJustified && point.contrastColor) {
			point.dataLabel.css({
				color: point.contrastColor
			});
		}
	};
}

}(Highcharts));
(function (H) {
/**
 * (c) 2009-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
/**
 * Highcharts module to hide overlapping data labels. This module is included in
 * Highcharts.
 */
var Chart = H.Chart,
	each = H.each,
	objectEach = H.objectEach,
	pick = H.pick,
	addEvent = H.addEvent;

// Collect potensial overlapping data labels. Stack labels probably don't need
// to be considered because they are usually accompanied by data labels that lie
// inside the columns.
addEvent(Chart.prototype, 'render', function collectAndHide() {
	var labels = [];

	// Consider external label collectors
	each(this.labelCollectors || [], function (collector) {
		labels = labels.concat(collector());
	});

	each(this.yAxis || [], function (yAxis) {
		if (
			yAxis.options.stackLabels &&
			!yAxis.options.stackLabels.allowOverlap
		) {
			objectEach(yAxis.stacks, function (stack) {
				objectEach(stack, function (stackItem) {
					labels.push(stackItem.label);
				});
			});
		}
	});

	each(this.series || [], function (series) {
		var dlOptions = series.options.dataLabels,
			// Range series have two collections
			collections = series.dataLabelCollections || ['dataLabel'];
		
		if (
			(dlOptions.enabled || series._hasPointLabels) &&
			!dlOptions.allowOverlap &&
			series.visible
		) { // #3866
			each(collections, function (coll) {
				each(series.points, function (point) {
					if (point[coll]) {
						point[coll].labelrank = pick(
							point.labelrank,
							point.shapeArgs && point.shapeArgs.height
						); // #4118
						labels.push(point[coll]);
					}
				});
			});
		}
	});
	this.hideOverlappingLabels(labels);
});

/**
 * Hide overlapping labels. Labels are moved and faded in and out on zoom to
 * provide a smooth visual imression.
 */		
Chart.prototype.hideOverlappingLabels = function (labels) {

	var len = labels.length,
		label,
		i,
		j,
		label1,
		label2,
		isIntersecting,
		pos1,
		pos2,
		parent1,
		parent2,
		padding,
		bBox,
		intersectRect = function (x1, y1, w1, h1, x2, y2, w2, h2) {
			return !(
				x2 > x1 + w1 ||
				x2 + w2 < x1 ||
				y2 > y1 + h1 ||
				y2 + h2 < y1
			);
		};

	for (i = 0; i < len; i++) {
		label = labels[i];
		if (label) {

			// Mark with initial opacity
			label.oldOpacity = label.opacity;
			label.newOpacity = 1;

			// Get width and height if pure text nodes (stack labels)
			if (!label.width) {
				bBox = label.getBBox();
				label.width = bBox.width;
				label.height = bBox.height;
			}
		}
	}

	// Prevent a situation in a gradually rising slope, that each label will
	// hide the previous one because the previous one always has lower rank.
	labels.sort(function (a, b) {
		return (b.labelrank || 0) - (a.labelrank || 0);
	});

	// Detect overlapping labels
	for (i = 0; i < len; i++) {
		label1 = labels[i];

		for (j = i + 1; j < len; ++j) {
			label2 = labels[j];
			if (
				label1 && label2 &&
				label1 !== label2 && // #6465, polar chart with connectEnds
				label1.placed && label2.placed &&
				label1.newOpacity !== 0 && label2.newOpacity !== 0
			) {
				pos1 = label1.alignAttr;
				pos2 = label2.alignAttr;
				// Different panes have different positions
				parent1 = label1.parentGroup;
				parent2 = label2.parentGroup;
				// Substract the padding if no background or border (#4333)
				padding = 2 * (label1.box ? 0 : (label1.padding || 0));
				isIntersecting = intersectRect(
					pos1.x + parent1.translateX,
					pos1.y + parent1.translateY,
					label1.width - padding,
					label1.height - padding,
					pos2.x + parent2.translateX,
					pos2.y + parent2.translateY,
					label2.width - padding,
					label2.height - padding
				);

				if (isIntersecting) {
					(label1.labelrank < label2.labelrank ? label1 : label2)
						.newOpacity = 0;
				}
			}
		}
	}

	// Hide or show
	each(labels, function (label) {
		var complete,
			newOpacity;

		if (label) {
			newOpacity = label.newOpacity;

			if (label.oldOpacity !== newOpacity && label.placed) {

				// Make sure the label is completely hidden to avoid catching
				// clicks (#4362)
				if (newOpacity) {
					label.show(true);
				} else {
					complete = function () {
						label.hide();
					};
				}

				// Animate or set the opacity					
				label.alignAttr.opacity = newOpacity;
				label[label.isOld ? 'animate' : 'attr'](
					label.alignAttr,
					null,
					complete
				);
				
			}
			label.isOld = true;
		}
	});
};

}(Highcharts));
(function (H) {
/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var addEvent = H.addEvent,
	Chart = H.Chart,
	createElement = H.createElement,
	css = H.css,
	defaultOptions = H.defaultOptions,
	defaultPlotOptions = H.defaultPlotOptions,
	each = H.each,
	extend = H.extend,
	fireEvent = H.fireEvent,
	hasTouch = H.hasTouch,
	inArray = H.inArray,
	isObject = H.isObject,
	Legend = H.Legend,
	merge = H.merge,
	pick = H.pick,
	Point = H.Point,
	Series = H.Series,
	seriesTypes = H.seriesTypes,
	svg = H.svg,
	TrackerMixin;

/**
 * TrackerMixin for points and graphs.
 */
TrackerMixin = H.TrackerMixin = {

	/**
	 * Draw the tracker for a point.
	 */
	drawTrackerPoint: function () {
		var series = this,
			chart = series.chart,
			pointer = chart.pointer,
			onMouseOver = function (e) {
				var point = pointer.getPointFromEvent(e);
				// undefined on graph in scatterchart
				if (point !== undefined) { 
					pointer.isDirectTouch = true;
					point.onMouseOver(e);
				}
			};

		// Add reference to the point
		each(series.points, function (point) {
			if (point.graphic) {
				point.graphic.element.point = point;
			}
			if (point.dataLabel) {
				if (point.dataLabel.div) {
					point.dataLabel.div.point = point;
				} else {
					point.dataLabel.element.point = point;
				}
			}
		});

		// Add the event listeners, we need to do this only once
		if (!series._hasTracking) {
			each(series.trackerGroups, function (key) {
				if (series[key]) { // we don't always have dataLabelsGroup
					series[key]
						.addClass('highcharts-tracker')
						.on('mouseover', onMouseOver)
						.on('mouseout', function (e) {
							pointer.onTrackerMouseOut(e);
						});
					if (hasTouch) {
						series[key].on('touchstart', onMouseOver);
					}

					
					if (series.options.cursor) {
						series[key]
							.css(css)
							.css({ cursor: series.options.cursor });
					}
					
				}
			});
			series._hasTracking = true;
		}
	},

	/**
	 * Draw the tracker object that sits above all data labels and markers to
	 * track mouse events on the graph or points. For the line type charts
	 * the tracker uses the same graphPath, but with a greater stroke width
	 * for better control.
	 */
	drawTrackerGraph: function () {
		var series = this,
			options = series.options,
			trackByArea = options.trackByArea,
			trackerPath = [].concat(trackByArea ? series.areaPath : series.graphPath),
			trackerPathLength = trackerPath.length,
			chart = series.chart,
			pointer = chart.pointer,
			renderer = chart.renderer,
			snap = chart.options.tooltip.snap,
			tracker = series.tracker,
			i,
			onMouseOver = function () {
				if (chart.hoverSeries !== series) {
					series.onMouseOver();
				}
			},
			/*
			 * Empirical lowest possible opacities for TRACKER_FILL for an element to stay invisible but clickable
			 * IE6: 0.002
			 * IE7: 0.002
			 * IE8: 0.002
			 * IE9: 0.00000000001 (unlimited)
			 * IE10: 0.0001 (exporting only)
			 * FF: 0.00000000001 (unlimited)
			 * Chrome: 0.000001
			 * Safari: 0.000001
			 * Opera: 0.00000000001 (unlimited)
			 */
			TRACKER_FILL = 'rgba(192,192,192,' + (svg ? 0.0001 : 0.002) + ')';

		// Extend end points. A better way would be to use round linecaps,
		// but those are not clickable in VML.
		if (trackerPathLength && !trackByArea) {
			i = trackerPathLength + 1;
			while (i--) {
				if (trackerPath[i] === 'M') { // extend left side
					trackerPath.splice(i + 1, 0, trackerPath[i + 1] - snap, trackerPath[i + 2], 'L');
				}
				if ((i && trackerPath[i] === 'M') || i === trackerPathLength) { // extend right side
					trackerPath.splice(i, 0, 'L', trackerPath[i - 2] + snap, trackerPath[i - 1]);
				}
			}
		}

		// draw the tracker
		if (tracker) {
			tracker.attr({ d: trackerPath });
		} else if (series.graph) { // create

			series.tracker = renderer.path(trackerPath)
			.attr({
				'stroke-linejoin': 'round', // #1225
				visibility: series.visible ? 'visible' : 'hidden',
				stroke: TRACKER_FILL,
				fill: trackByArea ? TRACKER_FILL : 'none',
				'stroke-width': series.graph.strokeWidth() + (trackByArea ? 0 : 2 * snap),
				zIndex: 2
			})
			.add(series.group);

			// The tracker is added to the series group, which is clipped, but is covered
			// by the marker group. So the marker group also needs to capture events.
			each([series.tracker, series.markerGroup], function (tracker) {
				tracker.addClass('highcharts-tracker')
					.on('mouseover', onMouseOver)
					.on('mouseout', function (e) {
						pointer.onTrackerMouseOut(e);
					});

				
				if (options.cursor) {
					tracker.css({ cursor: options.cursor });
				}
				

				if (hasTouch) {
					tracker.on('touchstart', onMouseOver);
				}
			});
		}
	}
};
/* End TrackerMixin */


/**
 * Add tracking event listener to the series group, so the point graphics
 * themselves act as trackers
 */

if (seriesTypes.column) {
	seriesTypes.column.prototype.drawTracker = TrackerMixin.drawTrackerPoint;	
}

if (seriesTypes.pie) {
	seriesTypes.pie.prototype.drawTracker = TrackerMixin.drawTrackerPoint;
}

if (seriesTypes.scatter) {
	seriesTypes.scatter.prototype.drawTracker = TrackerMixin.drawTrackerPoint;
}

/*
 * Extend Legend for item events
 */
extend(Legend.prototype, {

	setItemEvents: function (item, legendItem, useHTML) {
		var legend = this,
			boxWrapper = legend.chart.renderer.boxWrapper,
			activeClass = 'highcharts-legend-' +
				(item instanceof Point ? 'point' : 'series') + '-active';

		// Set the events on the item group, or in case of useHTML, the item itself (#1249)
		(useHTML ? legendItem : item.legendGroup).on('mouseover', function () {
			item.setState('hover');
			
			// A CSS class to dim or hide other than the hovered series
			boxWrapper.addClass(activeClass);
			
			
			legendItem.css(legend.options.itemHoverStyle);
			
		})
		.on('mouseout', function () {
			
			legendItem.css(merge(item.visible ? legend.itemStyle : legend.itemHiddenStyle));
			

			// A CSS class to dim or hide other than the hovered series
			boxWrapper.removeClass(activeClass);
			
			item.setState();
		})
		.on('click', function (event) {
			var strLegendItemClick = 'legendItemClick',
				fnLegendItemClick = function () {
					if (item.setVisible) {
						item.setVisible();
					}
				};

			// A CSS class to dim or hide other than the hovered series. Event
			// handling in iOS causes the activeClass to be added prior to click
			// in some cases (#7418).
			boxWrapper.removeClass(activeClass);

			// Pass over the click/touch event. #4.
			event = {
				browserEvent: event
			};

			// click the name or symbol
			if (item.firePointEvent) { // point
				item.firePointEvent(strLegendItemClick, event, fnLegendItemClick);
			} else {
				fireEvent(item, strLegendItemClick, event, fnLegendItemClick);
			}
		});
	},

	createCheckboxForItem: function (item) {
		var legend = this;

		item.checkbox = createElement('input', {
			type: 'checkbox',
			checked: item.selected,
			defaultChecked: item.selected // required by IE7
		}, legend.options.itemCheckboxStyle, legend.chart.container);

		addEvent(item.checkbox, 'click', function (event) {
			var target = event.target;
			fireEvent(
				item.series || item, 
				'checkboxClick', 
				{ // #3712
					checked: target.checked,
					item: item
				},
				function () {
					item.select();
				}
			);
		});
	}
});



// Add pointer cursor to legend itemstyle in defaultOptions
defaultOptions.legend.itemStyle.cursor = 'pointer';



/*
 * Extend the Chart object with interaction
 */

extend(Chart.prototype, /** @lends Chart.prototype */ {
	/**
	 * Display the zoom button.
	 *
	 * @private
	 */
	showResetZoom: function () {
		var chart = this,
			lang = defaultOptions.lang,
			btnOptions = chart.options.chart.resetZoomButton,
			theme = btnOptions.theme,
			states = theme.states,
			alignTo = btnOptions.relativeTo === 'chart' ? null : 'plotBox';

		function zoomOut() {
			chart.zoomOut();
		}

		this.resetZoomButton = chart.renderer.button(lang.resetZoom, null, null, zoomOut, theme, states && states.hover)
			.attr({
				align: btnOptions.position.align,
				title: lang.resetZoomTitle
			})
			.addClass('highcharts-reset-zoom')
			.add()
			.align(btnOptions.position, false, alignTo);

	},

	/**
	 * Zoom out to 1:1.
	 *
	 * @private
	 */
	zoomOut: function () {
		var chart = this;
		fireEvent(chart, 'selection', { resetSelection: true }, function () {
			chart.zoom();
		});
	},

	/**
	 * Zoom into a given portion of the chart given by axis coordinates.
	 * @param {Object} event
	 *
	 * @private
	 */
	zoom: function (event) {
		var chart = this,
			hasZoomed,
			pointer = chart.pointer,
			displayButton = false,
			resetZoomButton;

		// If zoom is called with no arguments, reset the axes
		if (!event || event.resetSelection) {
			each(chart.axes, function (axis) {
				hasZoomed = axis.zoom();
			});
			pointer.initiated = false; // #6804

		} else { // else, zoom in on all axes
			each(event.xAxis.concat(event.yAxis), function (axisData) {
				var axis = axisData.axis,
					isXAxis = axis.isXAxis;

				// don't zoom more than minRange
				if (pointer[isXAxis ? 'zoomX' : 'zoomY']) {
					hasZoomed = axis.zoom(axisData.min, axisData.max);
					if (axis.displayBtn) {
						displayButton = true;
					}
				}
			});
		}

		// Show or hide the Reset zoom button
		resetZoomButton = chart.resetZoomButton;
		if (displayButton && !resetZoomButton) {
			chart.showResetZoom();
		} else if (!displayButton && isObject(resetZoomButton)) {
			chart.resetZoomButton = resetZoomButton.destroy();
		}


		// Redraw
		if (hasZoomed) {
			chart.redraw(
				pick(chart.options.chart.animation, event && event.animation, chart.pointCount < 100) // animation
			);
		}
	},

	/**
	 * Pan the chart by dragging the mouse across the pane. This function is
	 * called on mouse move, and the distance to pan is computed from chartX
	 * compared to the first chartX position in the dragging operation.
	 *
	 * @private
	 */
	pan: function (e, panning) {

		var chart = this,
			hoverPoints = chart.hoverPoints,
			doRedraw;

		// remove active points for shared tooltip
		if (hoverPoints) {
			each(hoverPoints, function (point) {
				point.setState();
			});
		}

		each(panning === 'xy' ? [1, 0] : [1], function (isX) { // xy is used in maps
			var axis = chart[isX ? 'xAxis' : 'yAxis'][0],
				horiz = axis.horiz,
				mousePos = e[horiz ? 'chartX' : 'chartY'],
				mouseDown = horiz ? 'mouseDownX' : 'mouseDownY',
				startPos = chart[mouseDown],
				halfPointRange = (axis.pointRange || 0) / 2,
				extremes = axis.getExtremes(),
				panMin = axis.toValue(startPos - mousePos, true) +
					halfPointRange,
				panMax = axis.toValue(startPos + axis.len - mousePos, true) -
					halfPointRange,
				flipped = panMax < panMin,
				newMin = flipped ? panMax : panMin,
				newMax = flipped ? panMin : panMax,
				paddedMin = Math.min(
					extremes.dataMin, 
					halfPointRange ?
						extremes.min :
						axis.toValue(
							axis.toPixels(extremes.min) - axis.minPixelPadding
						)
				),
				paddedMax = Math.max(
					extremes.dataMax,
					halfPointRange ?
						extremes.max :
						axis.toValue(
							axis.toPixels(extremes.max) + axis.minPixelPadding
						)
				),
				spill;

			// If the new range spills over, either to the min or max, adjust
			// the new range.
			spill = paddedMin - newMin;
			if (spill > 0) {
				newMax += spill;
				newMin = paddedMin;
			}
			spill = newMax - paddedMax;
			if (spill > 0) {
				newMax = paddedMax;
				newMin -= spill;
			}

			// Set new extremes if they are actually new
			if (axis.series.length && newMin !== extremes.min && newMax !== extremes.max) {
				axis.setExtremes(
					newMin,
					newMax,
					false,
					false,
					{ trigger: 'pan' }
				);
				doRedraw = true;
			}

			chart[mouseDown] = mousePos; // set new reference for next run
		});

		if (doRedraw) {
			chart.redraw(false);
		}
		css(chart.container, { cursor: 'move' });
	}
});

/*
 * Extend the Point object with interaction
 */
extend(Point.prototype, /** @lends Highcharts.Point.prototype */ {
	/**
	 * Toggle the selection status of a point.
	 * @param  {Boolean} [selected]
	 *         When `true`, the point is selected. When `false`, the point is
	 *         unselected. When `null` or `undefined`, the selection state is
	 *         toggled.
	 * @param  {Boolean} [accumulate=false]
	 *         When `true`, the selection is added to other selected points.
	 *         When `false`, other selected points are deselected. Internally in
	 *         Highcharts, when {@link http://api.highcharts.com/highcharts/plotOptions.series.allowPointSelect|allowPointSelect}
	 *         is `true`, selected points are accumulated on Control, Shift or
	 *         Cmd clicking the point.
	 *
	 * @see    Highcharts.Chart#getSelectedPoints
	 *
	 * @sample highcharts/members/point-select/
	 *         Select a point from a button
	 * @sample highcharts/chart/events-selection-points/
	 *         Select a range of points through a drag selection
	 * @sample maps/series/data-id/
	 *         Select a point in Highmaps
	 */
	select: function (selected, accumulate) {
		var point = this,
			series = point.series,
			chart = series.chart;

		selected = pick(selected, !point.selected);

		// fire the event with the default handler
		point.firePointEvent(selected ? 'select' : 'unselect', { accumulate: accumulate }, function () {
			
			/**
			 * Whether the point is selected or not. 
			 * @see Point#select
			 * @see Chart#getSelectedPoints
			 * @memberof Point
			 * @name selected
			 * @type {Boolean}
			 */
			point.selected = point.options.selected = selected;
			series.options.data[inArray(point, series.data)] = point.options;

			point.setState(selected && 'select');

			// unselect all other points unless Ctrl or Cmd + click
			if (!accumulate) {
				each(chart.getSelectedPoints(), function (loopPoint) {
					if (loopPoint.selected && loopPoint !== point) {
						loopPoint.selected = loopPoint.options.selected = false;
						series.options.data[inArray(loopPoint, series.data)] = loopPoint.options;
						loopPoint.setState('');
						loopPoint.firePointEvent('unselect');
					}
				});
			}
		});
	},

	/**
	 * Runs on mouse over the point. Called internally from mouse and touch
	 * events.
	 * 
	 * @param {Object} e The event arguments
	 */
	onMouseOver: function (e) {
		var point = this,
			series = point.series,
			chart = series.chart,
			pointer = chart.pointer;
		e = e ?
			pointer.normalize(e) :
			// In cases where onMouseOver is called directly without an event
			pointer.getChartCoordinatesFromPoint(point, chart.inverted);
		pointer.runPointActions(e, point);
	},

	/**
	 * Runs on mouse out from the point. Called internally from mouse and touch
	 * events.
	 */
	onMouseOut: function () {
		var point = this,
			chart = point.series.chart;
		point.firePointEvent('mouseOut');
		each(chart.hoverPoints || [], function (p) {
			p.setState();
		});
		chart.hoverPoints = chart.hoverPoint = null;
	},

	/**
	 * Import events from the series' and point's options. Only do it on
	 * demand, to save processing time on hovering.
	 *
	 * @private
	 */
	importEvents: function () {
		if (!this.hasImportedEvents) {
			var point = this,
				options = merge(point.series.options.point, point.options),
				events = options.events;

			point.events = events;

			H.objectEach(events, function (event, eventType) {
				addEvent(point, eventType, event);
			});
			this.hasImportedEvents = true;

		}
	},

	/**
	 * Set the point's state.
	 * @param  {String} [state]
	 *         The new state, can be one of `''` (an empty string), `hover` or
	 *         `select`.
	 */
	setState: function (state, move) {
		var point = this,
			plotX = Math.floor(point.plotX), // #4586
			plotY = point.plotY,
			series = point.series,
			stateOptions = series.options.states[state] || {},
			markerOptions = defaultPlotOptions[series.type].marker &&
				series.options.marker,
			normalDisabled = markerOptions && markerOptions.enabled === false,
			markerStateOptions = (markerOptions && markerOptions.states &&
				markerOptions.states[state]) || {},
			stateDisabled = markerStateOptions.enabled === false,
			stateMarkerGraphic = series.stateMarkerGraphic,
			pointMarker = point.marker || {},
			chart = series.chart,
			halo = series.halo,
			haloOptions,
			markerAttribs,
			hasMarkers = markerOptions && series.markerAttribs,
			newSymbol;

		state = state || ''; // empty string

		if (
			// already has this state
			(state === point.state && !move) ||
			
			// selected points don't respond to hover
			(point.selected && state !== 'select') ||
			
			// series' state options is disabled
			(stateOptions.enabled === false) ||
			
			// general point marker's state options is disabled
			(state && (
				stateDisabled || 
				(normalDisabled && markerStateOptions.enabled === false)
			)) ||
			
			// individual point marker's state options is disabled
			(
				state &&
				pointMarker.states &&
				pointMarker.states[state] &&
				pointMarker.states[state].enabled === false
			) // #1610

		) {
			return;
		}

		if (hasMarkers) {
			markerAttribs = series.markerAttribs(point, state);
		}

		// Apply hover styles to the existing point
		if (point.graphic) {

			if (point.state) {
				point.graphic.removeClass('highcharts-point-' + point.state);
			}
			if (state) {
				point.graphic.addClass('highcharts-point-' + state);
			}

			
			point.graphic.animate(
				series.pointAttribs(point, state),
				pick(
					chart.options.chart.animation,
					stateOptions.animation
				)
			);
			

			if (markerAttribs) {
				point.graphic.animate(
					markerAttribs,
					pick(
						chart.options.chart.animation, // Turn off globally
						markerStateOptions.animation,
						markerOptions.animation
					)
				);
			}

			// Zooming in from a range with no markers to a range with markers
			if (stateMarkerGraphic) {
				stateMarkerGraphic.hide();
			}
		} else {
			// if a graphic is not applied to each point in the normal state, create a shared
			// graphic for the hover state
			if (state && markerStateOptions) {
				newSymbol = pointMarker.symbol || series.symbol;

				// If the point has another symbol than the previous one, throw away the
				// state marker graphic and force a new one (#1459)
				if (stateMarkerGraphic && stateMarkerGraphic.currentSymbol !== newSymbol) {
					stateMarkerGraphic = stateMarkerGraphic.destroy();
				}

				// Add a new state marker graphic
				if (!stateMarkerGraphic) {
					if (newSymbol) {
						series.stateMarkerGraphic = stateMarkerGraphic = chart.renderer.symbol(
							newSymbol,
							markerAttribs.x,
							markerAttribs.y,
							markerAttribs.width,
							markerAttribs.height
						)
						.add(series.markerGroup);
						stateMarkerGraphic.currentSymbol = newSymbol;
					}

				// Move the existing graphic
				} else {
					stateMarkerGraphic[move ? 'animate' : 'attr']({ // #1054
						x: markerAttribs.x,
						y: markerAttribs.y
					});
				}
				
				if (stateMarkerGraphic) {
					stateMarkerGraphic.attr(series.pointAttribs(point, state));
				}
				
			}

			if (stateMarkerGraphic) {
				stateMarkerGraphic[state && chart.isInsidePlot(plotX, plotY, chart.inverted) ? 'show' : 'hide'](); // #2450
				stateMarkerGraphic.element.point = point; // #4310
			}
		}

		// Show me your halo
		haloOptions = stateOptions.halo;
		if (haloOptions && haloOptions.size) {
			if (!halo) {
				series.halo = halo = chart.renderer.path()
					// #5818, #5903, #6705
					.add((point.graphic || stateMarkerGraphic).parentGroup);
			}
			halo[move ? 'animate' : 'attr']({
				d: point.haloPath(haloOptions.size)
			});
			halo.attr({
				'class': 'highcharts-halo highcharts-color-' +
					pick(point.colorIndex, series.colorIndex) 
			});
			halo.point = point; // #6055

			
			halo.attr(extend({
				'fill': point.color || series.color,
				'fill-opacity': haloOptions.opacity,
				'zIndex': -1 // #4929, IE8 added halo above everything
			}, haloOptions.attributes));
			

		} else if (halo && halo.point && halo.point.haloPath) {
			// Animate back to 0 on the current halo point (#6055)
			halo.animate({ d: halo.point.haloPath(0) });
		}

		point.state = state;
	},

	/**
	 * Get the path definition for the halo, which is usually a shadow-like
	 * circle around the currently hovered point.
	 * @param  {Number} size
	 *         The radius of the circular halo.
	 * @return {Array} The path definition
	 */
	haloPath: function (size) {
		var series = this.series,
			chart = series.chart;

		return chart.renderer.symbols.circle(
			Math.floor(this.plotX) - size,
			this.plotY - size,
			size * 2, 
			size * 2
		);
	}
});

/*
 * Extend the Series object with interaction
 */

extend(Series.prototype, /** @lends Highcharts.Series.prototype */ {
	/**
	 * Runs on mouse over the series graphical items.
	 */
	onMouseOver: function () {
		var series = this,
			chart = series.chart,
			hoverSeries = chart.hoverSeries;

		// set normal state to previous series
		if (hoverSeries && hoverSeries !== series) {
			hoverSeries.onMouseOut();
		}

		// trigger the event, but to save processing time,
		// only if defined
		if (series.options.events.mouseOver) {
			fireEvent(series, 'mouseOver');
		}

		// hover this
		series.setState('hover');
		chart.hoverSeries = series;
	},

	/**
	 * Runs on mouse out of the series graphical items.
	 */
	onMouseOut: function () {
		// trigger the event only if listeners exist
		var series = this,
			options = series.options,
			chart = series.chart,
			tooltip = chart.tooltip,
			hoverPoint = chart.hoverPoint;

		chart.hoverSeries = null; // #182, set to null before the mouseOut event fires

		// trigger mouse out on the point, which must be in this series
		if (hoverPoint) {
			hoverPoint.onMouseOut();
		}

		// fire the mouse out event
		if (series && options.events.mouseOut) {
			fireEvent(series, 'mouseOut');
		}


		// hide the tooltip
		if (tooltip && !series.stickyTracking && (!tooltip.shared || series.noSharedTooltip)) {
			tooltip.hide();
		}

		// set normal state
		series.setState();
	},

	/**
	 * Set the state of the series. Called internally on mouse interaction
	 * operations, but it can also be called directly to visually
	 * highlight a series.
	 *
	 * @param  {String} [state]
	 *         Can be either `hover` or undefined to set to normal
	 *         state.
	 */
	setState: function (state) {
		var series = this,
			options = series.options,
			graph = series.graph,
			stateOptions = options.states,
			lineWidth = options.lineWidth,
			attribs,
			i = 0;

		state = state || '';

		if (series.state !== state) {

			// Toggle class names
			each([
				series.group,
				series.markerGroup,
				series.dataLabelsGroup
			], function (group) {
				if (group) {
					// Old state
					if (series.state) {
						group.removeClass('highcharts-series-' + series.state);	
					}
					// New state
					if (state) {
						group.addClass('highcharts-series-' + state);
					}
				}
			});

			series.state = state;

			

			if (stateOptions[state] && stateOptions[state].enabled === false) {
				return;
			}

			if (state) {
				lineWidth = stateOptions[state].lineWidth || lineWidth + (stateOptions[state].lineWidthPlus || 0); // #4035
			}

			if (graph && !graph.dashstyle) { // hover is turned off for dashed lines in VML
				attribs = {
					'stroke-width': lineWidth
				};
				
				// Animate the graph stroke-width. By default a quick animation
				// to hover, slower to un-hover.
				graph.animate(
					attribs,
					pick(
						series.chart.options.chart.animation,
						stateOptions[state] && stateOptions[state].animation
					)
				);
				while (series['zone-graph-' + i]) {
					series['zone-graph-' + i].attr(attribs);
					i = i + 1;
				}
			}
			
		}
	},

	/**
	 * Show or hide the series.
	 *
	 * @param  {Boolean} [visible]
	 *         True to show the series, false to hide. If undefined, the
	 *         visibility is toggled.
	 * @param  {Boolean} [redraw=true]
	 *         Whether to redraw the chart after the series is altered. If doing
	 *         more operations on the chart, it is a good idea to set redraw to
	 *         false and call {@link Chart#redraw|chart.redraw()} after.
	 */
	setVisible: function (vis, redraw) {
		var series = this,
			chart = series.chart,
			legendItem = series.legendItem,
			showOrHide,
			ignoreHiddenSeries = chart.options.chart.ignoreHiddenSeries,
			oldVisibility = series.visible;

		// if called without an argument, toggle visibility
		series.visible = vis = series.options.visible = series.userOptions.visible = vis === undefined ? !oldVisibility : vis; // #5618
		showOrHide = vis ? 'show' : 'hide';

		// show or hide elements
		each(['group', 'dataLabelsGroup', 'markerGroup', 'tracker', 'tt'], function (key) {
			if (series[key]) {
				series[key][showOrHide]();				
			}
		});


		// hide tooltip (#1361)
		if (chart.hoverSeries === series || (chart.hoverPoint && chart.hoverPoint.series) === series) {
			series.onMouseOut();
		}


		if (legendItem) {
			chart.legend.colorizeItem(series, vis);
		}


		// rescale or adapt to resized chart
		series.isDirty = true;
		// in a stack, all other series are affected
		if (series.options.stacking) {
			each(chart.series, function (otherSeries) {
				if (otherSeries.options.stacking && otherSeries.visible) {
					otherSeries.isDirty = true;
				}
			});
		}

		// show or hide linked series
		each(series.linkedSeries, function (otherSeries) {
			otherSeries.setVisible(vis, false);
		});

		if (ignoreHiddenSeries) {
			chart.isDirtyBox = true;
		}
		if (redraw !== false) {
			chart.redraw();
		}

		fireEvent(series, showOrHide);
	},

	/**
	 * Show the series if hidden.
	 *
	 * @sample highcharts/members/series-hide/
	 *         Toggle visibility from a button
	 */
	show: function () {
		this.setVisible(true);
	},

	/**
	 * Hide the series if visible. If the {@link
	 * https://api.highcharts.com/highcharts/chart.ignoreHiddenSeries|
	 * chart.ignoreHiddenSeries} option is true, the chart is redrawn without
	 * this series.
	 *
	 * @sample highcharts/members/series-hide/
	 *         Toggle visibility from a button
	 */
	hide: function () {
		this.setVisible(false);
	},


	/**
	 * Select or unselect the series. This means its {@link
	 * Highcharts.Series.selected|selected} property is set, the checkbox in the
	 * legend is toggled and when selected, the series is returned by the
	 * {@link Highcharts.Chart#getSelectedSeries} function.
	 *
	 * @param  {Boolean} [selected]
	 *         True to select the series, false to unselect. If	undefined, the
	 *         selection state is toggled.
	 *
	 * @sample highcharts/members/series-select/
	 *         Select a series from a button
	 */
	select: function (selected) {
		var series = this;
		
		series.selected = selected = (selected === undefined) ?
			!series.selected :
			selected;

		if (series.checkbox) {
			series.checkbox.checked = selected;
		}

		fireEvent(series, selected ? 'select' : 'unselect');
	},

	drawTracker: TrackerMixin.drawTrackerGraph
});

}(Highcharts));
(function (H) {
/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var Chart = H.Chart,
	each = H.each,
	inArray = H.inArray,
	isArray = H.isArray,
	isObject = H.isObject,
	pick = H.pick,
	splat = H.splat;


/**
 * Allows setting a set of rules to apply for different screen or chart
 * sizes. Each rule specifies additional chart options.
 * 
 * @sample {highstock} stock/demo/responsive/ Stock chart
 * @sample highcharts/responsive/axis/ Axis
 * @sample highcharts/responsive/legend/ Legend
 * @sample highcharts/responsive/classname/ Class name
 * @since 5.0.0
 * @apioption responsive
 */

/**
 * A set of rules for responsive settings. The rules are executed from
 * the top down.
 * 
 * @type {Array<Object>}
 * @sample {highcharts} highcharts/responsive/axis/ Axis changes
 * @sample {highstock} highcharts/responsive/axis/ Axis changes
 * @sample {highmaps} highcharts/responsive/axis/ Axis changes
 * @since 5.0.0
 * @apioption responsive.rules
 */

/**
 * A full set of chart options to apply as overrides to the general
 * chart options. The chart options are applied when the given rule
 * is active.
 * 
 * A special case is configuration objects that take arrays, for example
 * [xAxis](#xAxis), [yAxis](#yAxis) or [series](#series). For these
 * collections, an `id` option is used to map the new option set to
 * an existing object. If an existing object of the same id is not found,
 * the item of the same indexupdated. So for example, setting `chartOptions`
 * with two series items without an `id`, will cause the existing chart's
 * two series to be updated with respective options.
 * 
 * @type {Object}
 * @sample {highstock} stock/demo/responsive/ Stock chart
 * @sample highcharts/responsive/axis/ Axis
 * @sample highcharts/responsive/legend/ Legend
 * @sample highcharts/responsive/classname/ Class name
 * @since 5.0.0
 * @apioption responsive.rules.chartOptions
 */

/**
 * Under which conditions the rule applies.
 * 
 * @type {Object}
 * @since 5.0.0
 * @apioption responsive.rules.condition
 */

/**
 * A callback function to gain complete control on when the responsive
 * rule applies. Return `true` if it applies. This opens for checking
 * against other metrics than the chart size, or example the document
 * size or other elements.
 * 
 * @type {Function}
 * @context Chart
 * @since 5.0.0
 * @apioption responsive.rules.condition.callback
 */

/**
 * The responsive rule applies if the chart height is less than this.
 * 
 * @type {Number}
 * @since 5.0.0
 * @apioption responsive.rules.condition.maxHeight
 */

/**
 * The responsive rule applies if the chart width is less than this.
 * 
 * @type {Number}
 * @sample highcharts/responsive/axis/ Max width is 500
 * @since 5.0.0
 * @apioption responsive.rules.condition.maxWidth
 */

/**
 * The responsive rule applies if the chart height is greater than this.
 * 
 * @type {Number}
 * @default 0
 * @since 5.0.0
 * @apioption responsive.rules.condition.minHeight
 */

/**
 * The responsive rule applies if the chart width is greater than this.
 * 
 * @type {Number}
 * @default 0
 * @since 5.0.0
 * @apioption responsive.rules.condition.minWidth
 */

/**
 * Update the chart based on the current chart/document size and options for
 * responsiveness.
 */
Chart.prototype.setResponsive = function (redraw) {
	var options = this.options.responsive,
		ruleIds = [],
		currentResponsive = this.currentResponsive,
		currentRuleIds;

	if (options && options.rules) {
		each(options.rules, function (rule) {
			if (rule._id === undefined) {
				rule._id = H.uniqueKey();
			}
			
			this.matchResponsiveRule(rule, ruleIds, redraw);
		}, this);
	}

	// Merge matching rules
	var mergedOptions = H.merge.apply(0, H.map(ruleIds, function (ruleId) {
		return H.find(options.rules, function (rule) {
			return rule._id === ruleId;
		}).chartOptions;
	}));

	// Stringified key for the rules that currently apply.
	ruleIds = ruleIds.toString() || undefined;
	currentRuleIds = currentResponsive && currentResponsive.ruleIds;


	// Changes in what rules apply
	if (ruleIds !== currentRuleIds) {

		// Undo previous rules. Before we apply a new set of rules, we need to
		// roll back completely to base options (#6291).
		if (currentResponsive) {
			this.update(currentResponsive.undoOptions, redraw);
		}

		if (ruleIds) {
			// Get undo-options for matching rules
			this.currentResponsive = {
				ruleIds: ruleIds,
				mergedOptions: mergedOptions,
				undoOptions: this.currentOptions(mergedOptions)
			};

			this.update(mergedOptions, redraw);
		
		} else {
			this.currentResponsive = undefined;	
		}
	}
};

/**
 * Handle a single responsiveness rule
 */
Chart.prototype.matchResponsiveRule = function (rule, matches) {
	var condition = rule.condition,
		fn = condition.callback || function () {
			return this.chartWidth <= pick(condition.maxWidth, Number.MAX_VALUE) &&
				this.chartHeight <= pick(condition.maxHeight, Number.MAX_VALUE) &&
				this.chartWidth >= pick(condition.minWidth, 0) &&
				this.chartHeight >= pick(condition.minHeight, 0);
		};		

	if (fn.call(this)) {
		matches.push(rule._id);
	}

};

/**
 * Get the current values for a given set of options. Used before we update
 * the chart with a new responsiveness rule.
 * TODO: Restore axis options (by id?)
 */
Chart.prototype.currentOptions = function (options) {

	var ret = {};

	/**
	 * Recurse over a set of options and its current values,
	 * and store the current values in the ret object.
	 */
	function getCurrent(options, curr, ret, depth) {
		var i;
		H.objectEach(options, function (val, key) {
			if (!depth && inArray(key, ['series', 'xAxis', 'yAxis']) > -1) {
				val = splat(val);
				
				ret[key] = [];
				
				// Iterate over collections like series, xAxis or yAxis and map
				// the items by index.
				for (i = 0; i < val.length; i++) {
					if (curr[key][i]) { // Item exists in current data (#6347)
						ret[key][i] = {};
						getCurrent(
							val[i],
							curr[key][i],
							ret[key][i],
							depth + 1
						);
					}
				}
			} else if (isObject(val)) {
				ret[key] = isArray(val) ? [] : {};
				getCurrent(val, curr[key] || {}, ret[key], depth + 1);
			} else {
				ret[key] = curr[key] || null;
			}
		});
	}

	getCurrent(options, this.options, ret, 0);
	return ret;
};

}(Highcharts));
var Highcharts = (function (Highcharts) {

return Highcharts;
}(Highcharts));
(function (H) {
/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var addEvent = H.addEvent,
	Axis = H.Axis,
	Chart = H.Chart,
	css = H.css,
	defined = H.defined,
	each = H.each,
	extend = H.extend,
	noop = H.noop,
	pick = H.pick,
	Series = H.Series,
	timeUnits = H.timeUnits,
	wrap = H.wrap;

/* ****************************************************************************
 * Start ordinal axis logic                                                   *
 *****************************************************************************/


wrap(Series.prototype, 'init', function (proceed) {
	var series = this,
		xAxis;

	// call the original function
	proceed.apply(this, Array.prototype.slice.call(arguments, 1));

	xAxis = series.xAxis;

	// Destroy the extended ordinal index on updated data
	if (xAxis && xAxis.options.ordinal) {
		addEvent(series, 'updatedData', function () {
			delete xAxis.ordinalIndex;
		});
	}
});

/**
 * In an ordinal axis, there might be areas with dense consentrations of points, then large
 * gaps between some. Creating equally distributed ticks over this entire range
 * may lead to a huge number of ticks that will later be removed. So instead, break the
 * positions up in segments, find the tick positions for each segment then concatenize them.
 * This method is used from both data grouping logic and X axis tick position logic.
 */
wrap(Axis.prototype, 'getTimeTicks', function (proceed, normalizedInterval, min, max, startOfWeek, positions, closestDistance, findHigherRanks) {

	var start = 0,
		end,
		segmentPositions,
		higherRanks = {},
		hasCrossedHigherRank,
		info,
		posLength,
		outsideMax,
		groupPositions = [],
		lastGroupPosition = -Number.MAX_VALUE,
		tickPixelIntervalOption = this.options.tickPixelInterval,
		time = this.chart.time;

	// The positions are not always defined, for example for ordinal positions when data
	// has regular interval (#1557, #2090)
	if ((!this.options.ordinal && !this.options.breaks) || !positions || positions.length < 3 || min === undefined) {
		return proceed.call(this, normalizedInterval, min, max, startOfWeek);
	}

	// Analyze the positions array to split it into segments on gaps larger than 5 times
	// the closest distance. The closest distance is already found at this point, so
	// we reuse that instead of computing it again.
	posLength = positions.length;

	for (end = 0; end < posLength; end++) {

		outsideMax = end && positions[end - 1] > max;

		if (positions[end] < min) { // Set the last position before min
			start = end;
		}

		if (end === posLength - 1 || positions[end + 1] - positions[end] > closestDistance * 5 || outsideMax) {

			// For each segment, calculate the tick positions from the getTimeTicks utility
			// function. The interval will be the same regardless of how long the segment is.
			if (positions[end] > lastGroupPosition) { // #1475

				segmentPositions = proceed.call(this, normalizedInterval, positions[start], positions[end], startOfWeek);

				// Prevent duplicate groups, for example for multiple segments within one larger time frame (#1475)
				while (segmentPositions.length && segmentPositions[0] <= lastGroupPosition) {
					segmentPositions.shift();
				}
				if (segmentPositions.length) {
					lastGroupPosition = segmentPositions[segmentPositions.length - 1];
				}

				groupPositions = groupPositions.concat(segmentPositions);
			}
			// Set start of next segment
			start = end + 1;
		}

		if (outsideMax) {
			break;
		}
	}

	// Get the grouping info from the last of the segments. The info is the same for
	// all segments.
	info = segmentPositions.info;

	// Optionally identify ticks with higher rank, for example when the ticks
	// have crossed midnight.
	if (findHigherRanks && info.unitRange <= timeUnits.hour) {
		end = groupPositions.length - 1;

		// Compare points two by two
		for (start = 1; start < end; start++) {
			if (
				time.dateFormat('%d', groupPositions[start]) !==
				time.dateFormat('%d', groupPositions[start - 1])
			) {
				higherRanks[groupPositions[start]] = 'day';
				hasCrossedHigherRank = true;
			}
		}

		// If the complete array has crossed midnight, we want to mark the first
		// positions also as higher rank
		if (hasCrossedHigherRank) {
			higherRanks[groupPositions[0]] = 'day';
		}
		info.higherRanks = higherRanks;
	}

	// Save the info
	groupPositions.info = info;



	// Don't show ticks within a gap in the ordinal axis, where the space between
	// two points is greater than a portion of the tick pixel interval
	if (findHigherRanks && defined(tickPixelIntervalOption)) { // check for squashed ticks

		var length = groupPositions.length,
			i = length,
			itemToRemove,
			translated,
			translatedArr = [],
			lastTranslated,
			medianDistance,
			distance,
			distances = [];

		// Find median pixel distance in order to keep a reasonably even distance between
		// ticks (#748)
		while (i--) {
			translated = this.translate(groupPositions[i]);
			if (lastTranslated) {
				distances[i] = lastTranslated - translated;
			}
			translatedArr[i] = lastTranslated = translated;
		}
		distances.sort();
		medianDistance = distances[Math.floor(distances.length / 2)];
		if (medianDistance < tickPixelIntervalOption * 0.6) {
			medianDistance = null;
		}

		// Now loop over again and remove ticks where needed
		i = groupPositions[length - 1] > max ? length - 1 : length; // #817
		lastTranslated = undefined;
		while (i--) {
			translated = translatedArr[i];
			distance = Math.abs(lastTranslated - translated); 
			// #4175 - when axis is reversed, the distance, is negative but 
			// tickPixelIntervalOption positive, so we need to compare the same values

			// Remove ticks that are closer than 0.6 times the pixel interval from the one to the right,
			// but not if it is close to the median distance (#748).
			if (lastTranslated && distance < tickPixelIntervalOption * 0.8 &&
					(medianDistance === null || distance < medianDistance * 0.8)) {

				// Is this a higher ranked position with a normal position to the right?
				if (higherRanks[groupPositions[i]] && !higherRanks[groupPositions[i + 1]]) {

					// Yes: remove the lower ranked neighbour to the right
					itemToRemove = i + 1;
					lastTranslated = translated; // #709

				} else {

					// No: remove this one
					itemToRemove = i;
				}

				groupPositions.splice(itemToRemove, 1);

			} else {
				lastTranslated = translated;
			}
		}
	}
	return groupPositions;
});

// Extend the Axis prototype
extend(Axis.prototype, /** @lends Axis.prototype */ {

	/**
	 * Calculate the ordinal positions before tick positions are calculated.
	 */
	beforeSetTickPositions: function () {
		var axis = this,
			len,
			ordinalPositions = [],
			useOrdinal = false,
			dist,
			extremes = axis.getExtremes(),
			min = extremes.min,
			max = extremes.max,
			minIndex,
			maxIndex,
			slope,
			hasBreaks = axis.isXAxis && !!axis.options.breaks,
			isOrdinal = axis.options.ordinal,
			overscrollPointsRange = Number.MAX_VALUE,
			ignoreHiddenSeries = axis.chart.options.chart.ignoreHiddenSeries,
			isNavigatorAxis = axis.options.className === 'highcharts-navigator-xaxis',
			i;

		if (
			axis.options.overscroll &&
			axis.max === axis.dataMax &&
			(
				// Panning is an execption,
				// We don't want to apply overscroll when panning over the dataMax
				!axis.chart.mouseIsDown ||
				isNavigatorAxis
			) && (
				// Scrollbar buttons are the other execption:
				!axis.eventArgs ||
				axis.eventArgs && axis.eventArgs.trigger !== 'navigator'
			)
		) {
			axis.max += axis.options.overscroll;

			// Live data and buttons require translation for the min:
			if (!isNavigatorAxis && defined(axis.userMin)) {
				axis.min += axis.options.overscroll;
			}
		}

		// Apply the ordinal logic
		if (isOrdinal || hasBreaks) { // #4167 YAxis is never ordinal ?

			each(axis.series, function (series, i) {

				if (
					(!ignoreHiddenSeries || series.visible !== false) &&
					(series.takeOrdinalPosition !== false || hasBreaks)
				) {

					// concatenate the processed X data into the existing positions, or the empty array
					ordinalPositions = ordinalPositions.concat(series.processedXData);
					len = ordinalPositions.length;

					// remove duplicates (#1588)
					ordinalPositions.sort(function (a, b) {
						return a - b; // without a custom function it is sorted as strings
					});

					overscrollPointsRange = Math.min(
						overscrollPointsRange,
						pick(
							// Check for a single-point series:
							series.closestPointRange,
							overscrollPointsRange
						)
					);

					if (len) {
						i = len - 1;
						while (i--) {
							if (ordinalPositions[i] === ordinalPositions[i + 1]) {
								ordinalPositions.splice(i, 1);
							}
						}
					}
				}

			});

			// cache the length
			len = ordinalPositions.length;

			// Check if we really need the overhead of mapping axis data against the ordinal positions.
			// If the series consist of evenly spaced data any way, we don't need any ordinal logic.
			if (len > 2) { // two points have equal distance by default
				dist = ordinalPositions[1] - ordinalPositions[0];
				i = len - 1;
				while (i-- && !useOrdinal) {
					if (ordinalPositions[i + 1] - ordinalPositions[i] !== dist) {
						useOrdinal = true;
					}
				}

				// When zooming in on a week, prevent axis padding for weekends even though the data within
				// the week is evenly spaced.
				if (
					!axis.options.keepOrdinalPadding &&
					(
						ordinalPositions[0] - min > dist ||
						max - ordinalPositions[ordinalPositions.length - 1] > dist
					)
				) {
					useOrdinal = true;
				}
			} else if (axis.options.overscroll) {
				if (len === 2) {
					// Exactly two points, distance for overscroll is fixed:
					overscrollPointsRange = ordinalPositions[1] - ordinalPositions[0];
				} else if (len === 1) {
					// We have just one point, closest distance is unknown.
					// Assume then it is last point and overscrolled range:
					overscrollPointsRange = axis.options.overscroll;
					ordinalPositions = [ordinalPositions[0], ordinalPositions[0] + overscrollPointsRange];
				} else {
					// In case of zooming in on overscrolled range, stick to the old range:
					overscrollPointsRange = axis.overscrollPointsRange;
				}
			}

			// Record the slope and offset to compute the linear values from the array index.
			// Since the ordinal positions may exceed the current range, get the start and
			// end positions within it (#719, #665b)
			if (useOrdinal) {

				if (axis.options.overscroll) {
					axis.overscrollPointsRange = overscrollPointsRange;
					ordinalPositions = ordinalPositions.concat(axis.getOverscrollPositions());
				}

				// Register
				axis.ordinalPositions = ordinalPositions;

				// This relies on the ordinalPositions being set. Use Math.max
				// and Math.min to prevent padding on either sides of the data.
				minIndex = axis.ordinal2lin( // #5979
					Math.max(
						min,
						ordinalPositions[0]
					),
					true
				);
				maxIndex = Math.max(axis.ordinal2lin(
					Math.min(
						max,
						ordinalPositions[ordinalPositions.length - 1]
					),
					true
				), 1); // #3339

				// Set the slope and offset of the values compared to the indices in the ordinal positions
				axis.ordinalSlope = slope = (max - min) / (maxIndex - minIndex);
				axis.ordinalOffset = min - (minIndex * slope);

			} else {
				axis.overscrollPointsRange = pick(axis.closestPointRange, axis.overscrollPointsRange);
				axis.ordinalPositions = axis.ordinalSlope = axis.ordinalOffset = undefined;
			}
		}
				
		axis.isOrdinal = isOrdinal && useOrdinal; // #3818, #4196, #4926
		axis.groupIntervalFactor = null; // reset for next run
	},
	/**
	 * Translate from a linear axis value to the corresponding ordinal axis position. If there
	 * are no gaps in the ordinal axis this will be the same. The translated value is the value
	 * that the point would have if the axis were linear, using the same min and max.
	 *
	 * @param Number val The axis value
	 * @param Boolean toIndex Whether to return the index in the ordinalPositions or the new value
	 */
	val2lin: function (val, toIndex) {
		var axis = this,
			ordinalPositions = axis.ordinalPositions,
			ret;

		if (!ordinalPositions) {
			ret = val;

		} else {

			var ordinalLength = ordinalPositions.length,
				i,
				distance,
				ordinalIndex;

			// first look for an exact match in the ordinalpositions array
			i = ordinalLength;
			while (i--) {
				if (ordinalPositions[i] === val) {
					ordinalIndex = i;
					break;
				}
			}

			// if that failed, find the intermediate position between the two nearest values
			i = ordinalLength - 1;
			while (i--) {
				if (val > ordinalPositions[i] || i === 0) { // interpolate
					distance = (val - ordinalPositions[i]) / (ordinalPositions[i + 1] - ordinalPositions[i]); // something between 0 and 1
					ordinalIndex = i + distance;
					break;
				}
			}
			ret = toIndex ?
				ordinalIndex :
				axis.ordinalSlope * (ordinalIndex || 0) + axis.ordinalOffset;
		}
		return ret;
	},
	/**
	 * Translate from linear (internal) to axis value
	 *
	 * @param Number val The linear abstracted value
	 * @param Boolean fromIndex Translate from an index in the ordinal positions rather than a value
	 */
	lin2val: function (val, fromIndex) {
		var axis = this,
			ordinalPositions = axis.ordinalPositions,
			ret;

		if (!ordinalPositions) { // the visible range contains only equally spaced values
			ret = val;

		} else {

			var ordinalSlope = axis.ordinalSlope,
				ordinalOffset = axis.ordinalOffset,
				i = ordinalPositions.length - 1,
				linearEquivalentLeft,
				linearEquivalentRight,
				distance;


			// Handle the case where we translate from the index directly, used only
			// when panning an ordinal axis
			if (fromIndex) {

				if (val < 0) { // out of range, in effect panning to the left
					val = ordinalPositions[0];
				} else if (val > i) { // out of range, panning to the right
					val = ordinalPositions[i];
				} else { // split it up
					i = Math.floor(val);
					distance = val - i; // the decimal
				}

			// Loop down along the ordinal positions. When the linear equivalent of i matches
			// an ordinal position, interpolate between the left and right values.
			} else {
				while (i--) {
					linearEquivalentLeft = (ordinalSlope * i) + ordinalOffset;
					if (val >= linearEquivalentLeft) {
						linearEquivalentRight = (ordinalSlope * (i + 1)) + ordinalOffset;
						distance = (val - linearEquivalentLeft) / (linearEquivalentRight - linearEquivalentLeft); // something between 0 and 1
						break;
					}
				}
			}

			// If the index is within the range of the ordinal positions, return the associated
			// or interpolated value. If not, just return the value
			return distance !== undefined && ordinalPositions[i] !== undefined ?
				ordinalPositions[i] + (distance ? distance * (ordinalPositions[i + 1] - ordinalPositions[i]) : 0) :
				val;
		}
		return ret;
	},
	/**
	 * Get the ordinal positions for the entire data set. This is necessary in chart panning
	 * because we need to find out what points or data groups are available outside the
	 * visible range. When a panning operation starts, if an index for the given grouping
	 * does not exists, it is created and cached. This index is deleted on updated data, so
	 * it will be regenerated the next time a panning operation starts.
	 */
	getExtendedPositions: function () {
		var axis = this,
			chart = axis.chart,
			grouping = axis.series[0].currentDataGrouping,
			ordinalIndex = axis.ordinalIndex,
			key = grouping ? grouping.count + grouping.unitName : 'raw',
			overscroll = axis.options.overscroll,
			extremes = axis.getExtremes(),
			fakeAxis,
			fakeSeries;

		// If this is the first time, or the ordinal index is deleted by updatedData,
		// create it.
		if (!ordinalIndex) {
			ordinalIndex = axis.ordinalIndex = {};
		}


		if (!ordinalIndex[key]) {

			// Create a fake axis object where the extended ordinal positions are emulated
			fakeAxis = {
				series: [],
				chart: chart,
				getExtremes: function () {
					return {
						min: extremes.dataMin,
						max: extremes.dataMax + overscroll
					};
				},
				options: {
					ordinal: true
				},
				val2lin: Axis.prototype.val2lin, // #2590
				ordinal2lin: Axis.prototype.ordinal2lin // #6276
			};

			// Add the fake series to hold the full data, then apply processData to it
			each(axis.series, function (series) {
				fakeSeries = {
					xAxis: fakeAxis,
					xData: series.xData.slice(),
					chart: chart,
					destroyGroupedData: noop
				};

				fakeSeries.xData = fakeSeries.xData.concat(axis.getOverscrollPositions());

				fakeSeries.options = {
					dataGrouping: grouping ? {
						enabled: true,
						forced: true,
						approximation: 'open', // doesn't matter which, use the fastest
						units: [[grouping.unitName, [grouping.count]]]
					} : {
						enabled: false
					}
				};
				series.processData.apply(fakeSeries);


				fakeAxis.series.push(fakeSeries);
			});

			// Run beforeSetTickPositions to compute the ordinalPositions
			axis.beforeSetTickPositions.apply(fakeAxis);

			// Cache it
			ordinalIndex[key] = fakeAxis.ordinalPositions;
		}
		return ordinalIndex[key];
	},

	/**
	 * Get ticks for an ordinal axis within a range where points don't exist.
	 * It is required when overscroll is enabled. We can't base on points,
	 * because we may not have any, so we use approximated pointRange and
	 * generate these ticks between <Axis.dataMax, Axis.dataMax + Axis.overscroll>
	 * evenly spaced. Used in panning and navigator scrolling.
	 *
	 * @returns positions {Array} Generated ticks
	 * @private
	 */
	getOverscrollPositions: function () {
		var axis = this,
			extraRange = axis.options.overscroll,
			distance = axis.overscrollPointsRange,
			positions = [],
			max = axis.dataMax;

		if (H.defined(distance)) {
			// Max + pointRange because we need to scroll to the last

			positions.push(max);

			while (max <= axis.dataMax + extraRange) {
				max += distance; 
				positions.push(max);
			}

		}

		return positions;
	},

	/**
	 * Find the factor to estimate how wide the plot area would have been if ordinal
	 * gaps were included. This value is used to compute an imagined plot width in order
	 * to establish the data grouping interval.
	 *
	 * A real world case is the intraday-candlestick
	 * example. Without this logic, it would show the correct data grouping when viewing
	 * a range within each day, but once moving the range to include the gap between two
	 * days, the interval would include the cut-away night hours and the data grouping
	 * would be wrong. So the below method tries to compensate by identifying the most
	 * common point interval, in this case days.
	 *
	 * An opposite case is presented in issue #718. We have a long array of daily data,
	 * then one point is appended one hour after the last point. We expect the data grouping
	 * not to change.
	 *
	 * In the future, if we find cases where this estimation doesn't work optimally, we
	 * might need to add a second pass to the data grouping logic, where we do another run
	 * with a greater interval if the number of data groups is more than a certain fraction
	 * of the desired group count.
	 */
	getGroupIntervalFactor: function (xMin, xMax, series) {
		var i,
			processedXData = series.processedXData,
			len = processedXData.length,
			distances = [],
			median,
			groupIntervalFactor = this.groupIntervalFactor;

		// Only do this computation for the first series, let the other inherit it (#2416)
		if (!groupIntervalFactor) {

			// Register all the distances in an array
			for (i = 0; i < len - 1; i++) {
				distances[i] = processedXData[i + 1] - processedXData[i];
			}

			// Sort them and find the median
			distances.sort(function (a, b) {
				return a - b;
			});
			median = distances[Math.floor(len / 2)];

			// Compensate for series that don't extend through the entire axis extent. #1675.
			xMin = Math.max(xMin, processedXData[0]);
			xMax = Math.min(xMax, processedXData[len - 1]);

			this.groupIntervalFactor = groupIntervalFactor = (len * median) / (xMax - xMin);
		}

		// Return the factor needed for data grouping
		return groupIntervalFactor;
	},

	/**
	 * Make the tick intervals closer because the ordinal gaps make the ticks spread out or cluster
	 */
	postProcessTickInterval: function (tickInterval) {
		// Problem: http://jsfiddle.net/highcharts/FQm4E/1/
		// This is a case where this algorithm doesn't work optimally. In this case, the
		// tick labels are spread out per week, but all the gaps reside within weeks. So
		// we have a situation where the labels are courser than the ordinal gaps, and
		// thus the tick interval should not be altered
		var ordinalSlope = this.ordinalSlope,
			ret;


		if (ordinalSlope) {
			if (!this.options.breaks) {
				ret = tickInterval / (ordinalSlope / this.closestPointRange);
			} else {
				ret = this.closestPointRange || tickInterval; // #7275
			}
		} else {
			ret = tickInterval;
		}
		return ret;
	}
});

// Record this to prevent overwriting by broken-axis module (#5979)
Axis.prototype.ordinal2lin = Axis.prototype.val2lin;

// Extending the Chart.pan method for ordinal axes
wrap(Chart.prototype, 'pan', function (proceed, e) {
	var chart = this,
		xAxis = chart.xAxis[0],
		overscroll = xAxis.options.overscroll,
		chartX = e.chartX,
		runBase = false;

	if (xAxis.options.ordinal && xAxis.series.length) {

		var mouseDownX = chart.mouseDownX,
			extremes = xAxis.getExtremes(),
			dataMax = extremes.dataMax,
			min = extremes.min,
			max = extremes.max,
			trimmedRange,
			hoverPoints = chart.hoverPoints,
			closestPointRange = xAxis.closestPointRange || xAxis.overscrollPointsRange,
			pointPixelWidth = xAxis.translationSlope * (xAxis.ordinalSlope || closestPointRange),
			movedUnits = (mouseDownX - chartX) / pointPixelWidth, // how many ordinal units did we move?
			extendedAxis = { ordinalPositions: xAxis.getExtendedPositions() }, // get index of all the chart's points
			ordinalPositions,
			searchAxisLeft,
			lin2val = xAxis.lin2val,
			val2lin = xAxis.val2lin,
			searchAxisRight;

		if (!extendedAxis.ordinalPositions) { // we have an ordinal axis, but the data is equally spaced
			runBase = true;

		} else if (Math.abs(movedUnits) > 1) {

			// Remove active points for shared tooltip
			if (hoverPoints) {
				each(hoverPoints, function (point) {
					point.setState();
				});
			}

			if (movedUnits < 0) {
				searchAxisLeft = extendedAxis;
				searchAxisRight = xAxis.ordinalPositions ? xAxis : extendedAxis;
			} else {
				searchAxisLeft = xAxis.ordinalPositions ? xAxis : extendedAxis;
				searchAxisRight = extendedAxis;
			}

			// In grouped data series, the last ordinal position represents the grouped data, which is
			// to the left of the real data max. If we don't compensate for this, we will be allowed
			// to pan grouped data series passed the right of the plot area.
			ordinalPositions = searchAxisRight.ordinalPositions;
			if (dataMax > ordinalPositions[ordinalPositions.length - 1]) {
				ordinalPositions.push(dataMax);
			}

			// Get the new min and max values by getting the ordinal index for the current extreme,
			// then add the moved units and translate back to values. This happens on the
			// extended ordinal positions if the new position is out of range, else it happens
			// on the current x axis which is smaller and faster.
			chart.fixedRange = max - min;
			trimmedRange = xAxis.toFixedRange(null, null,
				lin2val.apply(searchAxisLeft, [
					val2lin.apply(searchAxisLeft, [min, true]) + movedUnits, // the new index
					true // translate from index
				]),
				lin2val.apply(searchAxisRight, [
					val2lin.apply(searchAxisRight, [max, true]) + movedUnits, // the new index
					true // translate from index
				])
			);

			// Apply it if it is within the available data range
			if (
				trimmedRange.min >= Math.min(extremes.dataMin, min) &&
				trimmedRange.max <= Math.max(dataMax, max) + overscroll
			) {
				xAxis.setExtremes(trimmedRange.min, trimmedRange.max, true, false, { trigger: 'pan' });
			}

			chart.mouseDownX = chartX; // set new reference for next run
			css(chart.container, { cursor: 'move' });
		}

	} else {
		runBase = true;
	}

	// revert to the linear chart.pan version
	if (runBase) {
		if (overscroll) {
			xAxis.max = xAxis.dataMax + overscroll;
		}
		// call the original function
		proceed.apply(this, Array.prototype.slice.call(arguments, 1));
	}
});

/* ****************************************************************************
 * End ordinal axis logic                                                   *
 *****************************************************************************/

}(Highcharts));
(function (H) {
/**
 * (c) 2009-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */

var pick = H.pick,
	wrap = H.wrap,
	each = H.each,
	extend = H.extend,
	isArray = H.isArray,
	fireEvent = H.fireEvent,
	Axis = H.Axis,
	Series = H.Series;

function stripArguments() {
	return Array.prototype.slice.call(arguments, 1);
}

extend(Axis.prototype, {
	isInBreak: function (brk, val) {
		var ret,
			repeat = brk.repeat || Infinity,
			from = brk.from,
			length = brk.to - brk.from,
			test = (val >= from ? (val - from) % repeat :  repeat - ((from - val) % repeat));

		if (!brk.inclusive) {
			ret = test < length && test !== 0;
		} else {
			ret = test <= length;
		}
		return ret;
	},

	isInAnyBreak: function (val, testKeep) {

		var breaks = this.options.breaks,
			i = breaks && breaks.length,
			inbrk,
			keep,
			ret;

		
		if (i) { 

			while (i--) {
				if (this.isInBreak(breaks[i], val)) {
					inbrk = true;
					if (!keep) {
						keep = pick(breaks[i].showPoints, this.isXAxis ? false : true);
					}
				}
			}

			if (inbrk && testKeep) {
				ret = inbrk && !keep;
			} else {
				ret = inbrk;
			}
		}
		return ret;
	}
});

wrap(Axis.prototype, 'setTickPositions', function (proceed) {
	proceed.apply(this, Array.prototype.slice.call(arguments, 1));
	
	if (this.options.breaks) {
		var axis = this,
			tickPositions = this.tickPositions,
			info = this.tickPositions.info,
			newPositions = [],
			i;

		for (i = 0; i < tickPositions.length; i++) {
			if (!axis.isInAnyBreak(tickPositions[i])) {
				newPositions.push(tickPositions[i]);
			}
		}

		this.tickPositions = newPositions;
		this.tickPositions.info = info;
	}
});

wrap(Axis.prototype, 'init', function (proceed, chart, userOptions) {
	var axis = this,
		breaks;
	// Force Axis to be not-ordinal when breaks are defined
	if (userOptions.breaks && userOptions.breaks.length) {
		userOptions.ordinal = false;
	}
	proceed.call(this, chart, userOptions);
	breaks = this.options.breaks;
	axis.isBroken = (isArray(breaks) && !!breaks.length);
	if (axis.isBroken) {
		axis.val2lin = function (val) {
			var nval = val,
				brk,
				i;

			for (i = 0; i < axis.breakArray.length; i++) {
				brk = axis.breakArray[i];
				if (brk.to <= val) {
					nval -= brk.len;
				} else if (brk.from >= val) {
					break;
				} else if (axis.isInBreak(brk, val)) {
					nval -= (val - brk.from);
					break;
				}
			}

			return nval;
		};
		
		axis.lin2val = function (val) {
			var nval = val,
				brk,
				i;

			for (i = 0; i < axis.breakArray.length; i++) {
				brk = axis.breakArray[i];
				if (brk.from >= nval) {
					break;
				} else if (brk.to < nval) {
					nval += brk.len;
				} else if (axis.isInBreak(brk, nval)) {
					nval += brk.len;
				}
			}
			return nval;
		};

		axis.setExtremes = function (newMin, newMax, redraw, animation, eventArguments) {
			// If trying to set extremes inside a break, extend it to before and after the break ( #3857 )
			while (this.isInAnyBreak(newMin)) {
				newMin -= this.closestPointRange;
			}				
			while (this.isInAnyBreak(newMax)) {
				newMax -= this.closestPointRange;
			}
			Axis.prototype.setExtremes.call(this, newMin, newMax, redraw, animation, eventArguments);
		};

		axis.setAxisTranslation = function (saveOld) {
			Axis.prototype.setAxisTranslation.call(this, saveOld);

			var breaks = axis.options.breaks,
				breakArrayT = [],	// Temporary one
				breakArray = [],
				length = 0, 
				inBrk,
				repeat,
				min = axis.userMin || axis.min,
				max = axis.userMax || axis.max,
				pointRangePadding = pick(axis.pointRangePadding, 0),
				start,
				i;

			// Min & max check (#4247)
			each(breaks, function (brk) {
				repeat = brk.repeat || Infinity;
				if (axis.isInBreak(brk, min)) {
					min += (brk.to % repeat) - (min % repeat);
				}
				if (axis.isInBreak(brk, max)) {
					max -= (max % repeat) - (brk.from % repeat);
				}
			});

			// Construct an array holding all breaks in the axis
			each(breaks, function (brk) {
				start = brk.from;
				repeat = brk.repeat || Infinity;
				
				while (start - repeat > min) {
					start -= repeat;
				}
				while (start < min) {
					start += repeat;
				}
				
				for (i = start; i < max; i += repeat) {
					breakArrayT.push({
						value: i,
						move: 'in'
					});
					breakArrayT.push({
						value: i + (brk.to - brk.from),
						move: 'out',
						size: brk.breakSize
					});
				}
			});

			breakArrayT.sort(function (a, b) {
				var ret;
				if (a.value === b.value) {
					ret = (a.move === 'in' ? 0 : 1) - (b.move === 'in' ? 0 : 1);
				} else {
					ret = a.value - b.value;
				}
				return ret;
			});
			
			// Simplify the breaks
			inBrk = 0;
			start = min;

			each(breakArrayT, function (brk) {
				inBrk += (brk.move === 'in' ? 1 : -1);
				
				if (inBrk === 1 && brk.move === 'in') {
					start = brk.value;
				}
				if (inBrk === 0) {
					breakArray.push({
						from: start,
						to: brk.value,
						len: brk.value - start - (brk.size || 0)
					});
					length += brk.value - start - (brk.size || 0);
				}
			});

			axis.breakArray = breakArray;

			// Used with staticScale, and below, the actual axis length when
			// breaks are substracted.
			axis.unitLength = max - min - length + pointRangePadding;

			fireEvent(axis, 'afterBreaks');
			
			if (axis.options.staticScale) {
				axis.transA = axis.options.staticScale;
			} else if (axis.unitLength) {
				axis.transA *= (max - axis.min + pointRangePadding) /
					axis.unitLength;
			}
				
			if (pointRangePadding) {
				axis.minPixelPadding = axis.transA * axis.minPointOffset;
			}
			
			axis.min = min;
			axis.max = max;
		};
	}
});

wrap(Series.prototype, 'generatePoints', function (proceed) {

	proceed.apply(this, stripArguments(arguments));

	var series = this,
		xAxis = series.xAxis,
		yAxis = series.yAxis,
		points = series.points,
		point,
		i = points.length,
		connectNulls = series.options.connectNulls,
		nullGap;


	if (xAxis && yAxis && (xAxis.options.breaks || yAxis.options.breaks)) {
		while (i--) {
			point = points[i];

			nullGap = point.y === null && connectNulls === false; // respect nulls inside the break (#4275)
			if (!nullGap && (xAxis.isInAnyBreak(point.x, true) || yAxis.isInAnyBreak(point.y, true))) {
				points.splice(i, 1);
				if (this.data[i]) {
					this.data[i].destroyElements(); // removes the graphics for this point if they exist
				}
			}
		}
	}

});

function drawPointsWrapped(proceed) {
	proceed.apply(this);
	this.drawBreaks(this.xAxis, ['x']);
	this.drawBreaks(this.yAxis, pick(this.pointArrayMap, ['y']));
}

H.Series.prototype.drawBreaks = function (axis, keys) {
	var series = this,
		points = series.points,
		breaks,
		threshold,
		eventName,
		y;

	if (!axis) {
		return; // #5950
	}

	each(keys, function (key) {
		breaks = axis.breakArray || [];
		threshold = axis.isXAxis ? axis.min : pick(series.options.threshold, axis.min);
		each(points, function (point) {
			y = pick(point['stack' + key.toUpperCase()], point[key]);
			each(breaks, function (brk) {
				eventName = false;

				if ((threshold < brk.from && y > brk.to) || (threshold > brk.from && y < brk.from)) { 
					eventName = 'pointBreak';
				} else if ((threshold < brk.from && y > brk.from && y < brk.to) || (threshold > brk.from && y > brk.to && y < brk.from)) { // point falls inside the break
					eventName = 'pointInBreak';
				} 
				if (eventName) {
					fireEvent(axis, eventName, { point: point, brk: brk });
				}
			});
		});
	});
};


/**
 * Extend getGraphPath by identifying gaps in the data so that we can draw a gap
 * in the line or area. This was moved from ordinal axis module to broken axis
 * module as of #5045.
 */
H.Series.prototype.gappedPath = function () {
	var gapSize = this.options.gapSize,
		points = this.points.slice(),
		i = points.length - 1,
		yAxis = this.yAxis,
		xRange,
		stack;

	/**
	 * Defines when to display a gap in the graph, together with the
	 * [gapUnit](plotOptions.series.gapUnit) option.
	 * 
	 * In practice, this option is most often used to visualize gaps in
	 * time series. In a stock chart, intraday data is available for daytime
	 * hours, while gaps will appear in nights and weekends.
	 * 
	 * @type {Number}
	 * @see [gapUnit](plotOptions.series.gapUnit) and [xAxis.breaks](#xAxis.breaks)
	 * @sample {highstock} stock/plotoptions/series-gapsize/
	 *         Setting the gap size to 2 introduces gaps for weekends in daily
	 *         datasets.
	 * @default 0
	 * @product highstock
	 * @apioption plotOptions.series.gapSize
	 */
	
	/**
	 * Together with [gapSize](plotOptions.series.gapSize), this option defines
	 * where to draw gaps in the graph.
	 * 
	 * When the `gapUnit` is `relative` (default), a gap size of 5 means
	 * that if the distance between two points is greater than five times
	 * that of the two closest points, the graph will be broken.
	 *
	 * When the `gapUnit` is `value`, the gap is based on absolute axis values,
	 * which on a datetime axis is milliseconds. Note that this may give 
	 * unexpected results if `dataGrouping` is enabled (as it is by default),
	 * because if a series of points are grouped into a larger time span, the
	 * grouped points may have a greater distance than the absolute `gapSize`.
	 * This will cause the whole graph to disappear. This also applies to the
	 * navigator series that inherits gap options from the base series.
	 *
	 * @type {String}
	 * @see [gapSize](plotOptions.series.gapSize)
	 * @default relative
	 * @validvalue ["relative", "value"]
	 * @since 5.0.13
	 * @product highstock
	 * @apioption plotOptions.series.gapUnit
	 */

	if (gapSize && i > 0) { // #5008

		// Gap unit is relative
		if (this.options.gapUnit !== 'value') {
			gapSize *= this.closestPointRange;
		}

		// extension for ordinal breaks
		while (i--) {
			if (points[i + 1].x - points[i].x > gapSize) {
				xRange = (points[i].x + points[i + 1].x) / 2;

				points.splice( // insert after this one
					i + 1,
					0,
					{
						isNull: true,
						x: xRange
					}
				);

				// For stacked chart generate empty stack items, #6546
				if (this.options.stacking) {
					stack = yAxis.stacks[this.stackKey][xRange] = new H.StackItem(
						yAxis,
						yAxis.options.stackLabels,
						false,
						xRange,
						this.stack
					);
					stack.total = 0;
				}
			}
		}
	}

	// Call base method
	return this.getGraphPath(points);
};

wrap(H.seriesTypes.column.prototype, 'drawPoints', drawPointsWrapped);
wrap(H.Series.prototype, 'drawPoints', drawPointsWrapped);

}(Highcharts));
(function () {


}());
(function (H) {
/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var arrayMax = H.arrayMax,
	arrayMin = H.arrayMin,
	Axis = H.Axis,
	defaultPlotOptions = H.defaultPlotOptions,
	defined = H.defined,
	each = H.each,
	extend = H.extend,
	format = H.format,
	isNumber = H.isNumber,
	merge = H.merge,
	pick = H.pick,
	Point = H.Point,
	Series = H.Series,
	Tooltip = H.Tooltip,
	wrap = H.wrap;
	
/* ****************************************************************************
 * Start data grouping module												 *
 ******************************************************************************/

/**
 * Data grouping is the concept of sampling the data values into larger
 * blocks in order to ease readability and increase performance of the
 * JavaScript charts. Highstock by default applies data grouping when
 * the points become closer than a certain pixel value, determined by
 * the `groupPixelWidth` option.
 * 
 * If data grouping is applied, the grouping information of grouped
 * points can be read from the [Point.dataGroup](#Point.dataGroup).
 * 
 * @product highstock
 * @apioption plotOptions.series.dataGrouping
 */

/**
 * The method of approximation inside a group. When for example 30 days
 * are grouped into one month, this determines what value should represent
 * the group. Possible values are "average", "averages", "open", "high",
 * "low", "close" and "sum". For OHLC and candlestick series the approximation
 * is "ohlc" by default, which finds the open, high, low and close values
 * within all the grouped data. For ranges, the approximation is "range",
 * which finds the low and high values. For multi-dimensional data,
 * like ranges and OHLC, "averages" will compute the average for each
 * dimension.
 * 
 * Custom aggregate methods can be added by assigning a callback function
 * as the approximation. This function takes a numeric array as the
 * argument and should return a single numeric value or `null`. Note
 * that the numeric array will never contain null values, only true
 * numbers. Instead, if null values are present in the raw data, the
 * numeric array will have an `.hasNulls` property set to `true`. For
 * single-value data sets the data is available in the first argument
 * of the callback function. For OHLC data sets, all the open values
 * are in the first argument, all high values in the second etc.
 * 
 * Since v4.2.7, grouping meta data is available in the approximation
 * callback from `this.dataGroupInfo`. It can be used to extract information
 * from the raw data.
 * 
 * Defaults to `average` for line-type series, `sum` for columns, `range`
 * for range series and `ohlc` for OHLC and candlestick.
 * 
 * @validvalue ["average", "averages", "open", "high", "low", "close", "sum"]
 * @type {String|Function}
 * @sample {highstock} stock/plotoptions/series-datagrouping-approximation Approximation callback with custom data
 * @product highstock
 * @apioption plotOptions.series.dataGrouping.approximation
 */

/**
 * Datetime formats for the header of the tooltip in a stock chart.
 * The format can vary within a chart depending on the currently selected
 * time range and the current data grouping.
 * 
 * The default formats are:
 * 
 * <pre>{
 *     millisecond: ['%A, %b %e, %H:%M:%S.%L', '%A, %b %e, %H:%M:%S.%L', '-%H:%M:%S.%L'],
 *     second: ['%A, %b %e, %H:%M:%S', '%A, %b %e, %H:%M:%S', '-%H:%M:%S'],
 *     minute: ['%A, %b %e, %H:%M', '%A, %b %e, %H:%M', '-%H:%M'],
 *     hour: ['%A, %b %e, %H:%M', '%A, %b %e, %H:%M', '-%H:%M'],
 *     day: ['%A, %b %e, %Y', '%A, %b %e', '-%A, %b %e, %Y'],
 *     week: ['Week from %A, %b %e, %Y', '%A, %b %e', '-%A, %b %e, %Y'],
 *     month: ['%B %Y', '%B', '-%B %Y'],
 *     year: ['%Y', '%Y', '-%Y']
 * }</pre>
 * 
 * For each of these array definitions, the first item is the format
 * used when the active time span is one unit. For instance, if the
 * current data applies to one week, the first item of the week array
 * is used. The second and third items are used when the active time
 * span is more than two units. For instance, if the current data applies
 * to two weeks, the second and third item of the week array are used,
 *  and applied to the start and end date of the time span.
 * 
 * @type {Object}
 * @product highstock
 * @apioption plotOptions.series.dataGrouping.dateTimeLabelFormats
 */

/**
 * Enable or disable data grouping.
 * 
 * @type {Boolean}
 * @default true
 * @product highstock
 * @apioption plotOptions.series.dataGrouping.enabled
 */

/**
 * When data grouping is forced, it runs no matter how small the intervals
 * are. This can be handy for example when the sum should be calculated
 * for values appearing at random times within each hour.
 * 
 * @type {Boolean}
 * @default false
 * @product highstock
 * @apioption plotOptions.series.dataGrouping.forced
 */

/**
 * The approximate pixel width of each group. If for example a series
 * with 30 points is displayed over a 600 pixel wide plot area, no grouping
 * is performed. If however the series contains so many points that
 * the spacing is less than the groupPixelWidth, Highcharts will try
 * to group it into appropriate groups so that each is more or less
 * two pixels wide. If multiple series with different group pixel widths
 * are drawn on the same x axis, all series will take the greatest width.
 * For example, line series have 2px default group width, while column
 * series have 10px. If combined, both the line and the column will
 * have 10px by default.
 * 
 * @type {Number}
 * @default 2
 * @product highstock
 * @apioption plotOptions.series.dataGrouping.groupPixelWidth
 */

/**
 * Normally, a group is indexed by the start of that group, so for example
 * when 30 daily values are grouped into one month, that month's x value
 * will be the 1st of the month. This apparently shifts the data to
 * the left. When the smoothed option is true, this is compensated for.
 * The data is shifted to the middle of the group, and min and max
 * values are preserved. Internally, this is used in the Navigator series.
 * 
 * @type {Boolean}
 * @default false
 * @product highstock
 * @apioption plotOptions.series.dataGrouping.smoothed
 */

/**
 * An array determining what time intervals the data is allowed to be
 * grouped to. Each array item is an array where the first value is
 * the time unit and the second value another array of allowed multiples.
 * Defaults to:
 * 
 * <pre>units: [[
 *     'millisecond', // unit name
 *     [1, 2, 5, 10, 20, 25, 50, 100, 200, 500] // allowed multiples
 * ], [
 *     'second',
 *     [1, 2, 5, 10, 15, 30]
 * ], [
 *     'minute',
 *     [1, 2, 5, 10, 15, 30]
 * ], [
 *     'hour',
 *     [1, 2, 3, 4, 6, 8, 12]
 * ], [
 *     'day',
 *     [1]
 * ], [
 *     'week',
 *     [1]
 * ], [
 *     'month',
 *     [1, 3, 6]
 * ], [
 *     'year',
 *     null
 * ]]</pre>
 * 
 * @type {Array}
 * @product highstock
 * @apioption plotOptions.series.dataGrouping.units
 */

/**
 * The approximate pixel width of each group. If for example a series
 * with 30 points is displayed over a 600 pixel wide plot area, no grouping
 * is performed. If however the series contains so many points that
 * the spacing is less than the groupPixelWidth, Highcharts will try
 * to group it into appropriate groups so that each is more or less
 * two pixels wide. Defaults to `10`.
 * 
 * @type {Number}
 * @sample {highstock} stock/plotoptions/series-datagrouping-grouppixelwidth/
 *         Two series with the same data density but different groupPixelWidth
 * @default 10
 * @product highstock
 * @apioption plotOptions.column.dataGrouping.groupPixelWidth
 */

var seriesProto = Series.prototype,
	baseProcessData = seriesProto.processData,
	baseGeneratePoints = seriesProto.generatePoints,

	/** 
	 * 
	 */
	commonOptions = {
		approximation: 'average', // average, open, high, low, close, sum
		// enabled: null, // (true for stock charts, false for basic),
		// forced: undefined,
		groupPixelWidth: 2,
		// the first one is the point or start value, the second is the start value if we're dealing with range,
		// the third one is the end value if dealing with a range
		dateTimeLabelFormats: {
			millisecond: ['%A, %b %e, %H:%M:%S.%L', '%A, %b %e, %H:%M:%S.%L', '-%H:%M:%S.%L'],
			second: ['%A, %b %e, %H:%M:%S', '%A, %b %e, %H:%M:%S', '-%H:%M:%S'],
			minute: ['%A, %b %e, %H:%M', '%A, %b %e, %H:%M', '-%H:%M'],
			hour: ['%A, %b %e, %H:%M', '%A, %b %e, %H:%M', '-%H:%M'],
			day: ['%A, %b %e, %Y', '%A, %b %e', '-%A, %b %e, %Y'],
			week: ['Week from %A, %b %e, %Y', '%A, %b %e', '-%A, %b %e, %Y'],
			month: ['%B %Y', '%B', '-%B %Y'],
			year: ['%Y', '%Y', '-%Y']
		}
		// smoothed = false, // enable this for navigator series only
	},

	specificOptions = { // extends common options
		line: {},
		spline: {},
		area: {},
		areaspline: {},
		column: {
			approximation: 'sum',
			groupPixelWidth: 10
		},
		arearange: {
			approximation: 'range'
		},
		areasplinerange: {
			approximation: 'range'
		},
		columnrange: {
			approximation: 'range',
			groupPixelWidth: 10
		},
		candlestick: {
			approximation: 'ohlc',
			groupPixelWidth: 10
		},
		ohlc: {
			approximation: 'ohlc',
			groupPixelWidth: 5
		}
	},

	// units are defined in a separate array to allow complete overriding in case of a user option
	defaultDataGroupingUnits = H.defaultDataGroupingUnits = [
		[
			'millisecond', // unit name
			[1, 2, 5, 10, 20, 25, 50, 100, 200, 500] // allowed multiples
		], [
			'second',
			[1, 2, 5, 10, 15, 30]
		], [
			'minute',
			[1, 2, 5, 10, 15, 30]
		], [
			'hour',
			[1, 2, 3, 4, 6, 8, 12]
		], [
			'day',
			[1]
		], [
			'week',
			[1]
		], [
			'month',
			[1, 3, 6]
		], [
			'year',
			null
		]
	],


	/**
	 * Define the available approximation types. The data grouping
	 * approximations takes an array or numbers as the first parameter. In case
	 * of ohlc, four arrays are sent in as four parameters. Each array consists
	 * only of numbers. In case null values belong to the group, the property
	 * .hasNulls will be set to true on the array.
	 */
	approximations = H.approximations = {
		sum: function (arr) {
			var len = arr.length,
				ret;

			// 1. it consists of nulls exclusively
			if (!len && arr.hasNulls) {
				ret = null;
			// 2. it has a length and real values
			} else if (len) {
				ret = 0;
				while (len--) {
					ret += arr[len];
				}
			}
			// 3. it has zero length, so just return undefined
			// => doNothing()

			return ret;
		},
		average: function (arr) {
			var len = arr.length,
				ret = approximations.sum(arr);

			// If we have a number, return it divided by the length. If not,
			// return null or undefined based on what the sum method finds.
			if (isNumber(ret) && len) {
				ret = ret / len;
			}

			return ret;
		},
		// The same as average, but for series with multiple values, like area
		// ranges.
		averages: function () { // #5479
			var ret = [];

			each(arguments, function (arr) {
				ret.push(approximations.average(arr));
			});

			// Return undefined when first elem. is undefined and let
			// sum method handle null (#7377)
			return ret[0] === undefined ? undefined : ret;
		},
		open: function (arr) {
			return arr.length ? arr[0] : (arr.hasNulls ? null : undefined);
		},
		high: function (arr) {
			return arr.length ? arrayMax(arr) : (arr.hasNulls ? null : undefined);
		},
		low: function (arr) {
			return arr.length ? arrayMin(arr) : (arr.hasNulls ? null : undefined);
		},
		close: function (arr) {
			return arr.length ? arr[arr.length - 1] : (arr.hasNulls ? null : undefined);
		},
		// ohlc and range are special cases where a multidimensional array is input and an array is output
		ohlc: function (open, high, low, close) {
			open = approximations.open(open);
			high = approximations.high(high);
			low = approximations.low(low);
			close = approximations.close(close);

			if (isNumber(open) || isNumber(high) || isNumber(low) || isNumber(close)) {
				return [open, high, low, close];
			}
			// else, return is undefined
		},
		range: function (low, high) {
			low = approximations.low(low);
			high = approximations.high(high);

			if (isNumber(low) || isNumber(high)) {
				return [low, high];
			} else if (low === null && high === null) {
				return null;
			}
			// else, return is undefined
		}
	};

/**
 * Takes parallel arrays of x and y data and groups the data into intervals 
 * defined by groupPositions, a collection of starting x values for each group.
 */
seriesProto.groupData = function (xData, yData, groupPositions, approximation) {
	var series = this,
		data = series.data,
		dataOptions = series.options.data,
		groupedXData = [],
		groupedYData = [],
		groupMap = [],
		dataLength = xData.length,
		pointX,
		pointY,
		groupedY,
		// when grouping the fake extended axis for panning,
		// we don't need to consider y
		handleYData = !!yData,
		values = [],
		approximationFn = typeof approximation === 'function' ?
			approximation :
			approximations[approximation] ||
				// if the approximation is not found use default series type
				// approximation (#2914)
				(
					specificOptions[series.type] &&
					approximations[specificOptions[series.type].approximation]
				) || approximations[commonOptions.approximation],
		pointArrayMap = series.pointArrayMap,
		pointArrayMapLength = pointArrayMap && pointArrayMap.length,
		pos = 0,
		start = 0,
		valuesLen,
		i, j;

	// Calculate values array size from pointArrayMap length
	if (pointArrayMapLength) {
		each(pointArrayMap, function () {
			values.push([]);
		});
	} else {
		values.push([]);
	}
	valuesLen = pointArrayMapLength || 1;

	// Start with the first point within the X axis range (#2696)
	for (i = 0; i <= dataLength; i++) {
		if (xData[i] >= groupPositions[0]) {
			break;
		}
	}

	for (i; i <= dataLength; i++) {

		// when a new group is entered, summarize and initiate 
		// the previous group
		while ((
					groupPositions[pos + 1] !== undefined &&
					xData[i] >= groupPositions[pos + 1]
				) || i === dataLength) { // get the last group

			// get group x and y
			pointX = groupPositions[pos];
			series.dataGroupInfo = { start: start, length: values[0].length };
			groupedY = approximationFn.apply(series, values);

			// push the grouped data
			if (groupedY !== undefined) {
				groupedXData.push(pointX);
				groupedYData.push(groupedY);
				groupMap.push(series.dataGroupInfo);
			}

			// reset the aggregate arrays
			start = i;
			for (j = 0; j < valuesLen; j++) {
				values[j].length = 0; // faster than values[j] = []
				values[j].hasNulls = false;
			}

			// Advance on the group positions
			pos += 1;

			// don't loop beyond the last group
			if (i === dataLength) {
				break;
			}
		}

		// break out
		if (i === dataLength) {
			break;
		}

		// for each raw data point, push it to an array that contains all values
		// for this specific group
		if (pointArrayMap) {

			var index = series.cropStart + i,
				point = (data && data[index]) ||
					series.pointClass.prototype.applyOptions.apply({
						series: series
					}, [dataOptions[index]]),
				val;

			for (j = 0; j < pointArrayMapLength; j++) {
				val = point[pointArrayMap[j]];
				if (isNumber(val)) {
					values[j].push(val);
				} else if (val === null) {
					values[j].hasNulls = true;
				}
			}

		} else {
			pointY = handleYData ? yData[i] : null;

			if (isNumber(pointY)) {
				values[0].push(pointY);
			} else if (pointY === null) {
				values[0].hasNulls = true;
			}
		}
	}

	return [groupedXData, groupedYData, groupMap];
};

/**
 * Extend the basic processData method, that crops the data to the current zoom
 * range, with data grouping logic.
 */
seriesProto.processData = function () {
	var series = this,
		chart = series.chart,
		options = series.options,
		dataGroupingOptions = options.dataGrouping,
		groupingEnabled = series.allowDG !== false && dataGroupingOptions &&
			pick(dataGroupingOptions.enabled, chart.options.isStock),
		visible = series.visible || !chart.options.chart.ignoreHiddenSeries,
		hasGroupedData,
		skip,
		lastDataGrouping = this.currentDataGrouping,
		currentDataGrouping;

	// run base method
	series.forceCrop = groupingEnabled; // #334
	series.groupPixelWidth = null; // #2110
	series.hasProcessed = true; // #2692

	// skip if processData returns false or if grouping is disabled (in that order)
	skip = baseProcessData.apply(series, arguments) === false || !groupingEnabled;
	if (!skip) {
		series.destroyGroupedData();

		var i,
			processedXData = series.processedXData,
			processedYData = series.processedYData,
			plotSizeX = chart.plotSizeX,
			xAxis = series.xAxis,
			ordinal = xAxis.options.ordinal,
			groupPixelWidth = series.groupPixelWidth = xAxis.getGroupPixelWidth && xAxis.getGroupPixelWidth();

		// Execute grouping if the amount of points is greater than the limit defined in groupPixelWidth
		if (groupPixelWidth) {
			hasGroupedData = true;

			series.isDirty = true; // force recreation of point instances in series.translate, #5699
			series.points = null; // #6709

			var extremes = xAxis.getExtremes(),
				xMin = extremes.min,
				xMax = extremes.max,
				groupIntervalFactor = (ordinal && xAxis.getGroupIntervalFactor(xMin, xMax, series)) || 1,
				interval = (groupPixelWidth * (xMax - xMin) / plotSizeX) * groupIntervalFactor,
				groupPositions = xAxis.getTimeTicks(
					xAxis.normalizeTimeTickInterval(interval, dataGroupingOptions.units || defaultDataGroupingUnits),
					Math.min(xMin, processedXData[0]), // Processed data may extend beyond axis (#4907)
					Math.max(xMax, processedXData[processedXData.length - 1]),
					xAxis.options.startOfWeek,
					processedXData,
					series.closestPointRange
				),
				groupedData = seriesProto.groupData.apply(series, [processedXData, processedYData, groupPositions, dataGroupingOptions.approximation]),
				groupedXData = groupedData[0],
				groupedYData = groupedData[1];

			// prevent the smoothed data to spill out left and right, and make
			// sure data is not shifted to the left
			if (dataGroupingOptions.smoothed && groupedXData.length) {
				i = groupedXData.length - 1;
				groupedXData[i] = Math.min(groupedXData[i], xMax);
				while (i-- && i > 0) {
					groupedXData[i] += interval / 2;
				}
				groupedXData[0] = Math.max(groupedXData[0], xMin);
			}

			// record what data grouping values were used
			currentDataGrouping = groupPositions.info;
			series.closestPointRange = groupPositions.info.totalRange;
			series.groupMap = groupedData[2];

			// Make sure the X axis extends to show the first group (#2533)
			// But only for visible series (#5493, #6393)
			if (defined(groupedXData[0]) && groupedXData[0] < xAxis.dataMin && visible) {
				if (xAxis.min === xAxis.dataMin) {
					xAxis.min = groupedXData[0];
				}
				xAxis.dataMin = groupedXData[0];
			}

			// set series props
			series.processedXData = groupedXData;
			series.processedYData = groupedYData;
		} else {
			series.groupMap = null;
		}
		series.hasGroupedData = hasGroupedData;
		series.currentDataGrouping = currentDataGrouping;

		series.preventGraphAnimation = 
			(lastDataGrouping && lastDataGrouping.totalRange) !==
			(currentDataGrouping && currentDataGrouping.totalRange);
	}
};

/**
 * Destroy the grouped data points. #622, #740
 */
seriesProto.destroyGroupedData = function () {

	var groupedData = this.groupedData;

	// clear previous groups
	each(groupedData || [], function (point, i) {
		if (point) {
			groupedData[i] = point.destroy ? point.destroy() : null;
		}
	});
	this.groupedData = null;
};

/**
 * Override the generatePoints method by adding a reference to grouped data
 */
seriesProto.generatePoints = function () {

	baseGeneratePoints.apply(this);

	// record grouped data in order to let it be destroyed the next time processData runs
	this.destroyGroupedData(); // #622
	this.groupedData = this.hasGroupedData ? this.points : null;
};

/**
 * Override point prototype to throw a warning when trying to update grouped points
 */
wrap(Point.prototype, 'update', function (proceed) {
	if (this.dataGroup) {
		H.error(24);
	} else {
		proceed.apply(this, [].slice.call(arguments, 1));
	}
});

/**
 * Extend the original method, make the tooltip's header reflect the grouped range
 */
wrap(Tooltip.prototype, 'tooltipFooterHeaderFormatter', function (proceed, labelConfig, isFooter) {
	var tooltip = this,
		time = this.chart.time,
		series = labelConfig.series,
		options = series.options,
		tooltipOptions = series.tooltipOptions,
		dataGroupingOptions = options.dataGrouping,
		xDateFormat = tooltipOptions.xDateFormat,
		xDateFormatEnd,
		xAxis = series.xAxis,
		currentDataGrouping,
		dateTimeLabelFormats,
		labelFormats,
		formattedKey;

	// apply only to grouped series
	if (xAxis && xAxis.options.type === 'datetime' && dataGroupingOptions && isNumber(labelConfig.key)) {

		// set variables
		currentDataGrouping = series.currentDataGrouping;
		dateTimeLabelFormats = dataGroupingOptions.dateTimeLabelFormats;

		// if we have grouped data, use the grouping information to get the right format
		if (currentDataGrouping) {
			labelFormats = dateTimeLabelFormats[currentDataGrouping.unitName];
			if (currentDataGrouping.count === 1) {
				xDateFormat = labelFormats[0];
			} else {
				xDateFormat = labelFormats[1];
				xDateFormatEnd = labelFormats[2];
			}
		// if not grouped, and we don't have set the xDateFormat option, get the best fit,
		// so if the least distance between points is one minute, show it, but if the
		// least distance is one day, skip hours and minutes etc.
		} else if (!xDateFormat && dateTimeLabelFormats) {
			xDateFormat = tooltip.getXDateFormat(labelConfig, tooltipOptions, xAxis);
		}

		// now format the key
		formattedKey = time.dateFormat(xDateFormat, labelConfig.key);
		if (xDateFormatEnd) {
			formattedKey += time.dateFormat(
				xDateFormatEnd,
				labelConfig.key + currentDataGrouping.totalRange - 1
			);
		}

		// return the replaced format
		return format(tooltipOptions[(isFooter ? 'footer' : 'header') + 'Format'], {
			point: extend(labelConfig.point, { key: formattedKey }),
			series: series
		}, time);
	
	}

	// else, fall back to the regular formatter
	return proceed.call(tooltip, labelConfig, isFooter);
});

/**
 * Destroy grouped data on series destroy
 */
wrap(seriesProto, 'destroy', function (proceed) {
	this.destroyGroupedData();
	proceed.call(this);
});


// Handle default options for data grouping. This must be set at runtime because some series types are
// defined after this.
wrap(seriesProto, 'setOptions', function (proceed, itemOptions) {

	var options = proceed.call(this, itemOptions),
		type = this.type,
		plotOptions = this.chart.options.plotOptions,
		defaultOptions = defaultPlotOptions[type].dataGrouping;

	if (specificOptions[type]) { // #1284
		if (!defaultOptions) {
			defaultOptions = merge(commonOptions, specificOptions[type]);
		}

		options.dataGrouping = merge(
			defaultOptions,
			plotOptions.series && plotOptions.series.dataGrouping, // #1228
			plotOptions[type].dataGrouping, // Set by the StockChart constructor
			itemOptions.dataGrouping
		);
	}

	if (this.chart.options.isStock) {
		this.requireSorting = true;
	}

	return options;
});


/**
 * When resetting the scale reset the hasProccessed flag to avoid taking previous data grouping
 * of neighbour series into accound when determining group pixel width (#2692).
 */
wrap(Axis.prototype, 'setScale', function (proceed) {
	proceed.call(this);
	each(this.series, function (series) {
		series.hasProcessed = false;
	});
});

/**
 * Get the data grouping pixel width based on the greatest defined individual width
 * of the axis' series, and if whether one of the axes need grouping.
 */
Axis.prototype.getGroupPixelWidth = function () {

	var series = this.series,
		len = series.length,
		i,
		groupPixelWidth = 0,
		doGrouping = false,
		dataLength,
		dgOptions;

	// If multiple series are compared on the same x axis, give them the same
	// group pixel width (#334)
	i = len;
	while (i--) {
		dgOptions = series[i].options.dataGrouping;
		if (dgOptions) {
			groupPixelWidth = Math.max(groupPixelWidth, dgOptions.groupPixelWidth);

		}
	}

	// If one of the series needs grouping, apply it to all (#1634)
	i = len;
	while (i--) {
		dgOptions = series[i].options.dataGrouping;

		if (dgOptions && series[i].hasProcessed) { // #2692

			dataLength = (series[i].processedXData || series[i].data).length;

			// Execute grouping if the amount of points is greater than the limit defined in groupPixelWidth
			if (series[i].groupPixelWidth || dataLength > (this.chart.plotSizeX / groupPixelWidth) || (dataLength && dgOptions.forced)) {
				doGrouping = true;
			}
		}
	}

	return doGrouping ? groupPixelWidth : 0;
};

/**
 * Highstock only. Force data grouping on all the axis' series.
 *
 * @param  {SeriesDatagroupingOptions} [dataGrouping]
 *         A `dataGrouping` configuration. Use `false` to disable data grouping
 *         dynamically.
 * @param  {Boolean} [redraw=true]
 *         Whether to redraw the chart or wait for a later call to {@link
 *         Chart#redraw}.
 *
 * @function setDataGrouping
 * @memberOf Axis.prototype
 */
Axis.prototype.setDataGrouping = function (dataGrouping, redraw) {
	var i;

	redraw = pick(redraw, true);

	if (!dataGrouping) {
		dataGrouping = {
			forced: false,
			units: null
		};
	}

	// Axis is instantiated, update all series
	if (this instanceof Axis) {
		i = this.series.length;
		while (i--) {
			this.series[i].update({
				dataGrouping: dataGrouping
			}, false);
		}

	// Axis not yet instanciated, alter series options
	} else {
		each(this.chart.options.series, function (seriesOptions) {
			seriesOptions.dataGrouping = dataGrouping;
		}, false);
	}

	if (redraw) {
		this.chart.redraw();
	}
};



/* ****************************************************************************
 * End data grouping module												   *
 ******************************************************************************/

}(Highcharts));
(function (H) {
/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var each = H.each,
	Point = H.Point,
	seriesType = H.seriesType,
	seriesTypes = H.seriesTypes;

/**
 * The ohlc series type.
 *
 * @constructor seriesTypes.ohlc
 * @augments seriesTypes.column
 */
/**
 * An OHLC chart is a style of financial chart used to describe price
 * movements over time. It displays open, high, low and close values per data
 * point.
 *
 * @sample stock/demo/ohlc/ OHLC chart
 * @extends {plotOptions.column}
 * @excluding borderColor,borderRadius,borderWidth,crisp
 * @product highstock
 * @optionparent plotOptions.ohlc
 */
seriesType('ohlc', 'column', {

	/**
	 * The approximate pixel width of each group. If for example a series
	 * with 30 points is displayed over a 600 pixel wide plot area, no grouping
	 * is performed. If however the series contains so many points that
	 * the spacing is less than the groupPixelWidth, Highcharts will try
	 * to group it into appropriate groups so that each is more or less
	 * two pixels wide. Defaults to `5`.
	 * 
	 * @type {Number}
	 * @default 5
	 * @product highstock
	 * @apioption plotOptions.ohlc.dataGrouping.groupPixelWidth
	 */

	/**
	 * The pixel width of the line/border. Defaults to `1`.
	 * 
	 * @type {Number}
	 * @sample {highstock} stock/plotoptions/ohlc-linewidth/
	 *         A greater line width
	 * @default 1
	 * @product highstock
	 */
	lineWidth: 1,

	tooltip: {
		

		pointFormat: '<span style="color:{point.color}">\u25CF</span> <b> {series.name}</b><br/>' + // eslint-disable-line max-len
			'Open: {point.open}<br/>' +
			'High: {point.high}<br/>' +
			'Low: {point.low}<br/>' +
			'Close: {point.close}<br/>'
		
	},

	threshold: null,
	

	states: {

		/**
		 * @extends plotOptions.column.states.hover
		 * @product highstock
		 */
		hover: {

			/**
			 * The pixel width of the line representing the OHLC point.
			 * 
			 * @type {Number}
			 * @default 3
			 * @product highstock
			 */
			lineWidth: 3
		}
	},

	
	/**
	 * Line color for up points.
	 * 
	 * @type {Color}
	 * @product highstock
	 * @apioption plotOptions.ohlc.upColor
	 */
	
	

	stickyTracking: true

}, /** @lends seriesTypes.ohlc */ {
	directTouch: false,
	pointArrayMap: ['open', 'high', 'low', 'close'],
	toYData: function (point) { // return a plain array for speedy calculation
		return [point.open, point.high, point.low, point.close];
	},
	pointValKey: 'close',

	
	pointAttrToOptions: {
		'stroke': 'color',
		'stroke-width': 'lineWidth'
	},

	/**
	 * Postprocess mapping between options and SVG attributes
	 */
	pointAttribs: function (point, state) {
		var attribs = seriesTypes.column.prototype.pointAttribs.call(
				this,
				point,
				state
			),
			options = this.options;

		delete attribs.fill;

		if (
			!point.options.color &&
			options.upColor &&
			point.open < point.close
		) {
			attribs.stroke = options.upColor;
		}

		return attribs;
	},
	

	/**
	 * Translate data points from raw values x and y to plotX and plotY
	 */
	translate: function () {
		var series = this,
			yAxis = series.yAxis,
			hasModifyValue = !!series.modifyValue,
			translated = [
				'plotOpen',
				'plotHigh',
				'plotLow',
				'plotClose',
				'yBottom'
			]; // translate OHLC for

		seriesTypes.column.prototype.translate.apply(series);

		// Do the translation
		each(series.points, function (point) {
			each(
				[point.open, point.high, point.low, point.close, point.low],
				function (value, i) {
					if (value !== null) {
						if (hasModifyValue) {
							value = series.modifyValue(value);
						}
						point[translated[i]] = yAxis.toPixels(value, true);
					}
				}
			);

			// Align the tooltip to the high value to avoid covering the point
			point.tooltipPos[1] =
				point.plotHigh + yAxis.pos - series.chart.plotTop;
		});
	},

	/**
	 * Draw the data points
	 */
	drawPoints: function () {
		var series = this,
			points = series.points,
			chart = series.chart;


		each(points, function (point) {
			var plotOpen,
				plotClose,
				crispCorr,
				halfWidth,
				path,
				graphic = point.graphic,
				crispX,
				isNew = !graphic;

			if (point.plotY !== undefined) {

				// Create and/or update the graphic
				if (!graphic) {
					point.graphic = graphic = chart.renderer.path()
						.add(series.group);
				}

				
				graphic.attr(
					series.pointAttribs(point, point.selected && 'select')
				); // #3897
				

				// crisp vector coordinates
				crispCorr = (graphic.strokeWidth() % 2) / 2;
				crispX = Math.round(point.plotX) - crispCorr;  // #2596
				halfWidth = Math.round(point.shapeArgs.width / 2);

				// the vertical stem
				path = [
					'M',
					crispX, Math.round(point.yBottom),
					'L',
					crispX, Math.round(point.plotHigh)
				];

				// open
				if (point.open !== null) {
					plotOpen = Math.round(point.plotOpen) + crispCorr;
					path.push(
						'M',
						crispX,
						plotOpen,
						'L',
						crispX - halfWidth,
						plotOpen
					);
				}

				// close
				if (point.close !== null) {
					plotClose = Math.round(point.plotClose) + crispCorr;
					path.push(
						'M',
						crispX,
						plotClose,
						'L',
						crispX + halfWidth,
						plotClose
					);
				}

				graphic[isNew ? 'attr' : 'animate']({ d: path })
					.addClass(point.getClassName(), true);

			}


		});

	},

	animate: null // Disable animation

/**
 * @constructor seriesTypes.ohlc.prototype.pointClass
 * @extends {Point}
 */
}, /** @lends seriesTypes.ohlc.prototype.pointClass.prototype */ {
	/**
 	 * Extend the parent method by adding up or down to the class name.
 	 */
	getClassName: function () {
		return Point.prototype.getClassName.call(this) +
			(
				this.open < this.close ?
					' highcharts-point-up' :
					' highcharts-point-down'
			);
	}
});

/**
 * A `ohlc` series. If the [type](#series.ohlc.type) option is not
 * specified, it is inherited from [chart.type](#chart.type).
 * 
 * For options that apply to multiple series, it is recommended to add
 * them to the [plotOptions.series](#plotOptions.series) options structure.
 * To apply to all series of this specific type, apply it to [plotOptions.
 * ohlc](#plotOptions.ohlc).
 * 
 * @type {Object}
 * @extends series,plotOptions.ohlc
 * @excluding dataParser,dataURL
 * @product highstock
 * @apioption series.ohlc
 */

/**
 * An array of data points for the series. For the `ohlc` series type,
 * points can be given in the following ways:
 * 
 * 1.  An array of arrays with 5 or 4 values. In this case, the values
 * correspond to `x,open,high,low,close`. If the first value is a string,
 * it is applied as the name of the point, and the `x` value is inferred.
 * The `x` value can also be omitted, in which case the inner arrays
 * should be of length 4\. Then the `x` value is automatically calculated,
 * either starting at 0 and incremented by 1, or from `pointStart`
 * and `pointInterval` given in the series options.
 * 
 *  ```js
 *     data: [
 *         [0, 6, 5, 6, 7],
 *         [1, 9, 4, 8, 2],
 *         [2, 6, 3, 4, 10]
 *     ]
 *  ```
 * 
 * 2.  An array of objects with named values. The objects are point
 * configuration objects as seen below. If the total number of data
 * points exceeds the series' [turboThreshold](#series.ohlc.turboThreshold),
 * this option is not available.
 * 
 *  ```js
 *     data: [{
 *         x: 1,
 *         open: 3,
 *         high: 4,
 *         low: 5,
 *         close: 2,
 *         name: "Point2",
 *         color: "#00FF00"
 *     }, {
 *         x: 1,
 *         open: 4,
 *         high: 3,
 *         low: 6,
 *         close: 7,
 *         name: "Point1",
 *         color: "#FF00FF"
 *     }]
 *  ```
 * 
 * @type {Array<Object|Array>}
 * @extends series.arearange.data
 * @excluding y,marker
 * @product highstock
 * @apioption series.ohlc.data
 */

/**
 * The closing value of each data point.
 * 
 * @type {Number}
 * @product highstock
 * @apioption series.ohlc.data.close
 */

/**
 * The opening value of each data point.
 * 
 * @type {Number}
 * @product highstock
 * @apioption series.ohlc.data.open
 */

}(Highcharts));
(function (H) {
/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var defaultPlotOptions = H.defaultPlotOptions,
	each = H.each,
	merge = H.merge,
	seriesType = H.seriesType,
	seriesTypes = H.seriesTypes;

/**
 * A candlestick chart is a style of financial chart used to describe price
 * movements over time.
 *
 * @sample stock/demo/candlestick/ Candlestick chart
 * 
 * @extends {plotOptions.ohlc}
 * @excluding borderColor,borderRadius,borderWidth
 * @product highstock
 * @optionparent plotOptions.candlestick
 */
var candlestickOptions = {

	states: {

		/**
		 * @extends plotOptions.column.states.hover
		 * @product highstock
		 */
		hover: {

			/**
			 * The pixel width of the line/border around the candlestick.
			 * 
			 * @type {Number}
			 * @default 2
			 * @product highstock
			 */
			lineWidth: 2
		}
	},

	/**
	 * @extends {plotOptions.ohlc.tooltip}
	 */
	tooltip: defaultPlotOptions.ohlc.tooltip,

	threshold: null,
	

	/**
	 * The color of the line/border of the candlestick.
	 * 
	 * In styled mode, the line stroke can be set with the `.highcharts-
	 * candlestick-series .highcahrts-point` rule.
	 * 
	 * @type {Color}
	 * @see [upLineColor](#plotOptions.candlestick.upLineColor)
	 * @sample {highstock} stock/plotoptions/candlestick-linecolor/
	 *         Candlestick line colors
	 * @default #000000
	 * @product highstock
	 */
	lineColor: '#000000',

	/**
	 * The pixel width of the candlestick line/border. Defaults to `1`.
	 * 
	 * 
	 * In styled mode, the line stroke width can be set with the `.
	 * highcharts-candlestick-series .highcahrts-point` rule.
	 * 
	 * @type {Number}
	 * @default 1
	 * @product highstock
	 */
	lineWidth: 1,

	/**
	 * The fill color of the candlestick when values are rising.
	 * 
	 * In styled mode, the up color can be set with the `.highcharts-
	 * candlestick-series .highcharts-point-up` rule.
	 * 
	 * @type {Color}
	 * @sample {highstock} stock/plotoptions/candlestick-color/ Custom colors
	 * @sample {highstock} highcharts/css/candlestick/ Colors in styled mode
	 * @default #ffffff
	 * @product highstock
	 */
	upColor: '#ffffff',

	stickyTracking: true
	
	/**
	 * The specific line color for up candle sticks. The default is to inherit
	 * the general `lineColor` setting.
	 * 
	 * @type {Color}
	 * @sample {highstock} stock/plotoptions/candlestick-linecolor/ Candlestick line colors
	 * @default null
	 * @since 1.3.6
	 * @product highstock
	 * @apioption plotOptions.candlestick.upLineColor
	 */
	

	/**
	 * @default ohlc
	 * @apioption plotOptions.candlestick.dataGrouping.approximation
	 */

};

/**
 * The candlestick series type.
 *
 * @constructor seriesTypes.candlestick
 * @augments seriesTypes.ohlc
 */
seriesType('candlestick', 'ohlc', merge(
	defaultPlotOptions.column, 
	candlestickOptions
), /** @lends seriesTypes.candlestick */ {
	
	/**
	 * Postprocess mapping between options and SVG attributes
	 */
	pointAttribs: function (point, state) {
		var attribs = seriesTypes.column.prototype.pointAttribs.call(this, point, state),
			options = this.options,
			isUp = point.open < point.close,
			stroke = options.lineColor || this.color,
			stateOptions;

		attribs['stroke-width'] = options.lineWidth;

		attribs.fill = point.options.color || (isUp ? (options.upColor || this.color) : this.color);
		attribs.stroke = point.lineColor || (isUp ? (options.upLineColor || stroke) : stroke);

		// Select or hover states
		if (state) {
			stateOptions = options.states[state];
			attribs.fill = stateOptions.color || attribs.fill;
			attribs.stroke = stateOptions.lineColor || attribs.stroke;
			attribs['stroke-width'] =
				stateOptions.lineWidth || attribs['stroke-width'];
		}


		return attribs;
	},
	
	/**
	 * Draw the data points
	 */
	drawPoints: function () {
		var series = this,
			points = series.points,
			chart = series.chart;


		each(points, function (point) {

			var graphic = point.graphic,
				plotOpen,
				plotClose,
				topBox,
				bottomBox,
				hasTopWhisker,
				hasBottomWhisker,
				crispCorr,
				crispX,
				path,
				halfWidth,
				isNew = !graphic;

			if (point.plotY !== undefined) {

				if (!graphic) {
					point.graphic = graphic = chart.renderer.path()
						.add(series.group);
				}

				
				graphic
					.attr(series.pointAttribs(point, point.selected && 'select')) // #3897
					.shadow(series.options.shadow);
				

				// Crisp vector coordinates
				crispCorr = (graphic.strokeWidth() % 2) / 2;
				crispX = Math.round(point.plotX) - crispCorr; // #2596
				plotOpen = point.plotOpen;
				plotClose = point.plotClose;
				topBox = Math.min(plotOpen, plotClose);
				bottomBox = Math.max(plotOpen, plotClose);
				halfWidth = Math.round(point.shapeArgs.width / 2);
				hasTopWhisker = Math.round(topBox) !== Math.round(point.plotHigh);
				hasBottomWhisker = bottomBox !== point.yBottom;
				topBox = Math.round(topBox) + crispCorr;
				bottomBox = Math.round(bottomBox) + crispCorr;

				// Create the path. Due to a bug in Chrome 49, the path is first instanciated
				// with no values, then the values pushed. For unknown reasons, instanciated
				// the path array with all the values would lead to a crash when updating
				// frequently (#5193).
				path = [];
				path.push(
					'M',
					crispX - halfWidth, bottomBox,
					'L',
					crispX - halfWidth, topBox,
					'L',
					crispX + halfWidth, topBox,
					'L',
					crispX + halfWidth, bottomBox,
					'Z', // Use a close statement to ensure a nice rectangle #2602
					'M',
					crispX, topBox,
					'L',
					crispX, hasTopWhisker ? Math.round(point.plotHigh) : topBox, // #460, #2094
					'M',
					crispX, bottomBox,
					'L',
					crispX, hasBottomWhisker ? Math.round(point.yBottom) : bottomBox // #460, #2094
				);

				graphic[isNew ? 'attr' : 'animate']({ d: path })
					.addClass(point.getClassName(), true);

			}
		});

	}


});

/**
 * A `candlestick` series. If the [type](#series.candlestick.type)
 * option is not specified, it is inherited from [chart.type](#chart.
 * type).
 * 
 * For options that apply to multiple series, it is recommended to add
 * them to the [plotOptions.series](#plotOptions.series) options structure.
 * To apply to all series of this specific type, apply it to [plotOptions.
 * candlestick](#plotOptions.candlestick).
 * 
 * @type {Object}
 * @extends series,plotOptions.candlestick
 * @excluding dataParser,dataURL
 * @product highstock
 * @apioption series.candlestick
 */

/**
 * An array of data points for the series. For the `candlestick` series
 * type, points can be given in the following ways:
 * 
 * 1.  An array of arrays with 5 or 4 values. In this case, the values
 * correspond to `x,open,high,low,close`. If the first value is a string,
 * it is applied as the name of the point, and the `x` value is inferred.
 * The `x` value can also be omitted, in which case the inner arrays
 * should be of length 4\. Then the `x` value is automatically calculated,
 * either starting at 0 and incremented by 1, or from `pointStart`
 * and `pointInterval` given in the series options.
 * 
 *  ```js
 *     data: [
 *         [0, 7, 2, 0, 4],
 *         [1, 1, 4, 2, 8],
 *         [2, 3, 3, 9, 3]
 *     ]
 *  ```
 * 
 * 2.  An array of objects with named values. The objects are point
 * configuration objects as seen below. If the total number of data
 * points exceeds the series' [turboThreshold](#series.candlestick.
 * turboThreshold), this option is not available.
 * 
 *  ```js
 *     data: [{
 *         x: 1,
 *         open: 9,
 *         high: 2,
 *         low: 4,
 *         close: 6,
 *         name: "Point2",
 *         color: "#00FF00"
 *     }, {
 *         x: 1,
 *         open: 1,
 *         high: 4,
 *         low: 7,
 *         close: 7,
 *         name: "Point1",
 *         color: "#FF00FF"
 *     }]
 *  ```
 * 
 * @type {Array<Object|Array>}
 * @extends series.ohlc.data
 * @excluding y
 * @product highstock
 * @apioption series.candlestick.data
 */

}(Highcharts));
var onSeriesMixin = (function (H) {
/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */

var each = H.each,
	seriesTypes = H.seriesTypes,
	stableSort = H.stableSort;

var onSeriesMixin = {
	/**
	 * Extend the translate method by placing the point on the related series
	 */
	translate: function () {

		seriesTypes.column.prototype.translate.apply(this);

		var series = this,
			options = series.options,
			chart = series.chart,
			points = series.points,
			cursor = points.length - 1,
			point,
			lastPoint,
			optionsOnSeries = options.onSeries,
			onSeries = optionsOnSeries && chart.get(optionsOnSeries),
			onKey = options.onKey || 'y',
			step = onSeries && onSeries.options.step,
			onData = onSeries && onSeries.points,
			i = onData && onData.length,
			xAxis = series.xAxis,
			yAxis = series.yAxis,
			xAxisExt = xAxis.getExtremes(),
			xOffset = 0,
			leftPoint,
			lastX,
			rightPoint,
			currentDataGrouping,
			distanceRatio;

		// relate to a master series
		if (onSeries && onSeries.visible && i) {
			xOffset = (onSeries.pointXOffset || 0) + (onSeries.barW || 0) / 2;
			currentDataGrouping = onSeries.currentDataGrouping;
			lastX = (
				onData[i - 1].x +
				(currentDataGrouping ? currentDataGrouping.totalRange : 0)
			); // #2374

			// sort the data points
			stableSort(points, function (a, b) {
				return (a.x - b.x);
			});

			onKey = 'plot' + onKey[0].toUpperCase() + onKey.substr(1);
			while (i-- && points[cursor]) {
				leftPoint = onData[i];
				point = points[cursor];
				point.y = leftPoint.y;
				
				if (leftPoint.x <= point.x && leftPoint[onKey] !== undefined) {
					if (point.x <= lastX) { // #803

						point.plotY = leftPoint[onKey];

						// interpolate between points, #666
						if (leftPoint.x < point.x && !step) {
							rightPoint = onData[i + 1];
							if (rightPoint && rightPoint[onKey] !== undefined) {
								// the distance ratio, between 0 and 1
								distanceRatio = (point.x - leftPoint.x) /
									(rightPoint.x - leftPoint.x);
								point.plotY +=
									distanceRatio * 
									// the plotY distance
									(rightPoint[onKey] - leftPoint[onKey]);
								point.y += 
									distanceRatio *
									(rightPoint.y - leftPoint.y);
							}
						}
					}
					cursor--;
					i++; // check again for points in the same x position
					if (cursor < 0) {
						break;
					}
				}
			}
		}

		// Add plotY position and handle stacking
		each(points, function (point, i) {

			var stackIndex;

			// Undefined plotY means the point is either on axis, outside series
			// range or hidden series. If the series is outside the range of the
			// x axis it should fall through with an undefined plotY, but then
			// we must remove the shapeArgs (#847).
			if (point.plotY === undefined) {
				if (point.x >= xAxisExt.min && point.x <= xAxisExt.max) {
					// we're inside xAxis range
					point.plotY = chart.chartHeight - xAxis.bottom -
						(xAxis.opposite ? xAxis.height : 0) +
						xAxis.offset - yAxis.top; // #3517
				} else {
					point.shapeArgs = {}; // 847
				}
			}
			point.plotX += xOffset; // #2049
			// if multiple flags appear at the same x, order them into a stack
			lastPoint = points[i - 1];
			if (lastPoint && lastPoint.plotX === point.plotX) {
				if (lastPoint.stackIndex === undefined) {
					lastPoint.stackIndex = 0;
				}
				stackIndex = lastPoint.stackIndex + 1;
			}
			point.stackIndex = stackIndex; // #3639
		});


	}
};
return onSeriesMixin;
}(Highcharts));
(function (H, onSeriesMixin) {
/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var addEvent = H.addEvent,
	each = H.each,
	merge = H.merge,
	noop = H.noop,
	Renderer = H.Renderer,
	Series = H.Series,
	seriesType = H.seriesType,
	SVGRenderer = H.SVGRenderer,
	TrackerMixin = H.TrackerMixin,
	VMLRenderer = H.VMLRenderer,
	symbols = SVGRenderer.prototype.symbols;

/**
 * The Flags series.
 * @constructor seriesTypes.flags
 * @augments seriesTypes.column
 */
/**
 * Flags are used to mark events in stock charts. They can be added on the
 * timeline, or attached to a specific series.
 *
 * @sample stock/demo/flags-general/ Flags on a line series
 * @extends {plotOptions.column}
 * @excluding animation,borderColor,borderRadius,borderWidth,colorByPoint,dataGrouping,pointPadding,pointWidth,turboThreshold
 * @product highstock
 * @optionparent plotOptions.flags
 */
seriesType('flags', 'column', {

	/**
	 * In case the flag is placed on a series, on what point key to place
	 * it. Line and columns have one key, `y`. In range or OHLC-type series,
	 * however, the flag can optionally be placed on the `open`, `high`,
	 *  `low` or `close` key.
	 * 
	 * @validvalue ["y", "open", "high", "low", "close"]
	 * @type {String}
	 * @sample {highstock} stock/plotoptions/flags-onkey/ Range series, flag on high
	 * @default y
	 * @since 4.2.2
	 * @product highstock
	 * @apioption plotOptions.flags.onKey
	 */

	/**
	 * The id of the series that the flags should be drawn on. If no id
	 * is given, the flags are drawn on the x axis.
	 * 
	 * @type {String}
	 * @sample {highstock} stock/plotoptions/flags/ Flags on series and on x axis
	 * @default undefined
	 * @product highstock
	 * @apioption plotOptions.flags.onSeries
	 */
	
	pointRange: 0, // #673

	/**
	 * Whether the flags are allowed to overlap sideways. If `false`, the flags
	 * are moved sideways using an algorithm that seeks to place every flag as
	 * close as possible to its original position.
	 *
	 * @sample {highstock} stock/plotoptions/flags-allowoverlapx
	 *         Allow sideways overlap
	 *
	 * @since 6.0.4
	 */
	allowOverlapX: false,

	/**
	 * The shape of the marker. Can be one of "flag", "circlepin", "squarepin",
	 * or an image on the format `url(/path-to-image.jpg)`. Individual
	 * shapes can also be set for each point.
	 * 
	 * @validvalue ["flag", "circlepin", "squarepin"]
	 * @type {String}
	 * @sample {highstock} stock/plotoptions/flags/ Different shapes
	 * @default flag
	 * @product highstock
	 */
	shape: 'flag',

	/**
	 * When multiple flags in the same series fall on the same value, this
	 * number determines the vertical offset between them.
	 * 
	 * @type {Number}
	 * @sample {highstock} stock/plotoptions/flags-stackdistance/ A greater stack distance
	 * @default 12
	 * @product highstock
	 */
	stackDistance: 12,

	/**
	 * Text alignment for the text inside the flag.
	 * 
	 * @validvalue ["left", "center", "right"]
	 * @type {String}
	 * @default center
	 * @since 5.0.0
	 * @product highstock
	 */
	textAlign: 'center',

	/**
	 * Specific tooltip options for flag series. Flag series tooltips are
	 * different from most other types in that a flag doesn't have a data
	 * value, so the tooltip rather displays the `text` option for each
	 * point.
	 * 
	 * @type {Object}
	 * @extends plotOptions.series.tooltip
	 * @excluding changeDecimals,valueDecimals,valuePrefix,valueSuffix
	 * @product highstock
	 */
	tooltip: {
		pointFormat: '{point.text}<br/>'
	},

	threshold: null,

	/**
	 * The text to display on each flag. This can be defined on series level,
	 *  or individually for each point. Defaults to `"A"`.
	 * 
	 * @type {String}
	 * @default A
	 * @product highstock
	 * @apioption plotOptions.flags.title
	 */

	/**
	 * The y position of the top left corner of the flag relative to either
	 * the series (if onSeries is defined), or the x axis. Defaults to
	 * `-30`.
	 * 
	 * @type {Number}
	 * @default -30
	 * @product highstock
	 */
	y: -30,

	/**
	 * Whether to use HTML to render the flag texts. Using HTML allows for
	 * advanced formatting, images and reliable bi-directional text rendering.
	 * Note that exported images won't respect the HTML, and that HTML
	 * won't respect Z-index settings.
	 * 
	 * @type {Boolean}
	 * @default false
	 * @since 1.3
	 * @product highstock
	 * @apioption plotOptions.flags.useHTML
	 */

	

	/**
	 * The fill color for the flags.
	 */
	fillColor: '#ffffff',
	
	/**
	 * The color of the line/border of the flag.
	 * 
	 * In styled mode, the stroke is set in the `.highcharts-flag-series
	 * .highcharts-point` rule.
	 * 
	 * @type {Color}
	 * @default #000000
	 * @product highstock
	 * @apioption plotOptions.flags.lineColor
	 */

	/**
	 * The pixel width of the flag's line/border.
	 * 
	 * @type {Number}
	 * @default 1
	 * @product highstock
	 */
	lineWidth: 1,

	states: {

		/**
		 * @extends plotOptions.column.states.hover
		 * @product highstock
		 */
		hover: {

			/**
			 * The color of the line/border of the flag.
			 * 
			 * @product highstock
			 */
			lineColor: '#000000',

			/**
			 * The fill or background color of the flag.
			 * 
			 * @product highstock
			 */
			fillColor: '#ccd6eb'
		}
	},

	/**
	 * The text styles of the flag.
	 * 
	 * In styled mode, the styles are set in the `.highcharts-flag-
	 * series .highcharts-point` rule.
	 * 
	 * @type {CSSObject}
	 * @default { "fontSize": "11px", "fontWeight": "bold" }
	 * @product highstock
	 */
	style: {
		fontSize: '11px',
		fontWeight: 'bold'
	}
	

}, /** @lends seriesTypes.flags.prototype */ {
	sorted: false,
	noSharedTooltip: true,
	allowDG: false,
	takeOrdinalPosition: false, // #1074
	trackerGroups: ['markerGroup'],
	forceCrop: true,
	/**
	 * Inherit the initialization from base Series.
	 */
	init: Series.prototype.init,

	
	/**
	 * Get presentational attributes
	 */
	pointAttribs: function (point, state) {
		var options = this.options,
			color = (point && point.color) || this.color,
			lineColor = options.lineColor,
			lineWidth = (point && point.lineWidth),
			fill = (point && point.fillColor) || options.fillColor;

		if (state) {
			fill = options.states[state].fillColor;
			lineColor = options.states[state].lineColor;
			lineWidth = options.states[state].lineWidth;
		}

		return {
			'fill': fill || color,
			'stroke': lineColor || color,
			'stroke-width': lineWidth || options.lineWidth || 0
		};
	},
	

	translate: onSeriesMixin.translate,

	/**
	 * Draw the markers
	 */
	drawPoints: function () {
		var series = this,
			points = series.points,
			chart = series.chart,
			renderer = chart.renderer,
			plotX,
			plotY,
			options = series.options,
			optionsY = options.y,
			shape,
			i,
			point,
			graphic,
			stackIndex,
			anchorY,
			attribs,
			outsideRight,
			yAxis = series.yAxis,
			boxesMap = {},
			boxes = [];

		i = points.length;
		while (i--) {
			point = points[i];
			outsideRight = point.plotX > series.xAxis.len;
			plotX = point.plotX;
			stackIndex = point.stackIndex;
			shape = point.options.shape || options.shape;
			plotY = point.plotY;

			if (plotY !== undefined) {
				plotY = point.plotY + optionsY - (stackIndex !== undefined && stackIndex * options.stackDistance);
			}
			point.anchorX = stackIndex ? undefined : point.plotX; // skip connectors for higher level stacked points
			anchorY = stackIndex ? undefined : point.plotY;

			graphic = point.graphic;

			// Only draw the point if y is defined and the flag is within the visible area
			if (plotY !== undefined && plotX >= 0 && !outsideRight) {
				
				// Create the flag
				if (!graphic) {
					graphic = point.graphic = renderer.label(
						'',
						null,
						null,
						shape,
						null,
						null,
						options.useHTML
					)
					
					.attr(series.pointAttribs(point))
					.css(merge(options.style, point.style))
					
					.attr({
						align: shape === 'flag' ? 'left' : 'center',
						width: options.width,
						height: options.height,
						'text-align': options.textAlign
					})
					.addClass('highcharts-point')
					.add(series.markerGroup);

					// Add reference to the point for tracker (#6303)
					if (point.graphic.div) {
						point.graphic.div.point = point;
					}

					
					graphic.shadow(options.shadow);
					
					graphic.isNew = true;
				}

				if (plotX > 0) { // #3119
					plotX -= graphic.strokeWidth() % 2; // #4285
				}

				// Plant the flag
				attribs = {
					y: plotY,
					anchorY: anchorY
				};
				if (options.allowOverlapX) {
					attribs.x = plotX;
					attribs.anchorX = point.anchorX;
				}
				graphic.attr({
					text: point.options.title || options.title || 'A'
				})[graphic.isNew ? 'attr' : 'animate'](attribs);

				// Rig for the distribute function
				if (!options.allowOverlapX) {
					if (!boxesMap[point.plotX]) {
						boxesMap[point.plotX] = {
							align: 0,
							size: graphic.width,
							target: plotX,
							anchorX: plotX
						};
					} else {
						boxesMap[point.plotX].size = Math.max(
							boxesMap[point.plotX].size,
							graphic.width
						);
					}
				}

				// Set the tooltip anchor position
				point.tooltipPos = chart.inverted ? 
					[yAxis.len + yAxis.pos - chart.plotLeft - plotY, series.xAxis.len - plotX] :
					[plotX, plotY + yAxis.pos - chart.plotTop]; // #6327

			} else if (graphic) {
				point.graphic = graphic.destroy();
			}

		}
		
		// Handle X-dimension overlapping
		if (!options.allowOverlapX) {
			H.objectEach(boxesMap, function (box) {
				box.plotX = box.anchorX;
				boxes.push(box);
			});

			H.distribute(boxes, this.xAxis.len);

			each(points, function (point) {
				var box = point.graphic && boxesMap[point.plotX];
				if (box) {
					point.graphic[point.graphic.isNew ? 'attr' : 'animate']({
						x: box.pos,
						anchorX: point.anchorX
					});
					point.graphic.isNew = false;
				}
			});
		}

		// Might be a mix of SVG and HTML and we need events for both (#6303)
		if (options.useHTML) {
			H.wrap(series.markerGroup, 'on', function (proceed) {
				return H.SVGElement.prototype.on.apply(
					proceed.apply(this, [].slice.call(arguments, 1)), // for HTML
					[].slice.call(arguments, 1)); // and for SVG
			});
		}

	},

	/**
	 * Extend the column trackers with listeners to expand and contract stacks
	 */
	drawTracker: function () {
		var series = this,
			points = series.points;

		TrackerMixin.drawTrackerPoint.apply(this);

		// Bring each stacked flag up on mouse over, this allows readability of vertically
		// stacked elements as well as tight points on the x axis. #1924.
		each(points, function (point) {
			var graphic = point.graphic;
			if (graphic) {
				addEvent(graphic.element, 'mouseover', function () {

					// Raise this point
					if (point.stackIndex > 0 && !point.raised) {
						point._y = graphic.y;
						graphic.attr({
							y: point._y - 8
						});
						point.raised = true;
					}

					// Revert other raised points
					each(points, function (otherPoint) {
						if (otherPoint !== point && otherPoint.raised && otherPoint.graphic) {
							otherPoint.graphic.attr({
								y: otherPoint._y
							});
							otherPoint.raised = false;
						}
					});
				});
			}
		});
	},

	animate: noop, // Disable animation
	buildKDTree: noop,
	setClip: noop

});

// create the flag icon with anchor
symbols.flag = function (x, y, w, h, options) {
	var anchorX = (options && options.anchorX) || x,
		anchorY = (options &&  options.anchorY) || y;

	return symbols.circle(anchorX - 1, anchorY - 1, 2, 2).concat(
		[
			'M', anchorX, anchorY,
			'L', x, y + h,
			x, y,
			x + w, y,
			x + w, y + h,
			x, y + h,
			'Z'
		]
	);
};

/*
 * Create the circlepin and squarepin icons with anchor
 */
function createPinSymbol(shape) {
	symbols[shape + 'pin'] = function (x, y, w, h, options) {

		var anchorX = options && options.anchorX,
			anchorY = options &&  options.anchorY,
			path,
			labelTopOrBottomY;

		// For single-letter flags, make sure circular flags are not taller than their width
		if (shape === 'circle' && h > w) {
			x -= Math.round((h - w) / 2);
			w = h;
		}

		path = symbols[shape](x, y, w, h);

		if (anchorX && anchorY) {
			// if the label is below the anchor, draw the connecting line from the top edge of the label
			// otherwise start drawing from the bottom edge
			labelTopOrBottomY = (y > anchorY) ? y : y + h;
			path.push(
				'M',
				shape === 'circle' ? path[1] - path[4] : path[1] + path[4] / 2,
				labelTopOrBottomY,
				'L',
				anchorX,
				anchorY
			);
			path = path.concat(
				symbols.circle(anchorX - 1, anchorY - 1, 2, 2)
			);
		}

		return path;
	};
}
createPinSymbol('circle');
createPinSymbol('square');


// The symbol callbacks are generated on the SVGRenderer object in all browsers. Even
// VML browsers need this in order to generate shapes in export. Now share
// them with the VMLRenderer.
if (Renderer === VMLRenderer) {
	each(['flag', 'circlepin', 'squarepin'], function (shape) {
		VMLRenderer.prototype.symbols[shape] = symbols[shape];
	});
}


/**
 * A `flags` series. If the [type](#series.flags.type) option is not
 * specified, it is inherited from [chart.type](#chart.type).
 * 
 * For options that apply to multiple series, it is recommended to add
 * them to the [plotOptions.series](#plotOptions.series) options structure.
 * To apply to all series of this specific type, apply it to [plotOptions.
 * flags](#plotOptions.flags).
 * 
 * @type {Object}
 * @extends series,plotOptions.flags
 * @excluding dataParser,dataURL
 * @product highstock
 * @apioption series.flags
 */

/**
 * An array of data points for the series. For the `flags` series type,
 * points can be given in the following ways:
 * 
 * 1.  An array of objects with named values. The objects are point
 * configuration objects as seen below. If the total number of data
 * points exceeds the series' [turboThreshold](#series.flags.turboThreshold),
 * this option is not available.
 * 
 *  ```js
 *     data: [{
 *     x: 1,
 *     title: "A",
 *     text: "First event"
 * }, {
 *     x: 1,
 *     title: "B",
 *     text: "Second event"
 * }]</pre>
 * 
 * @type {Array<Object>}
 * @extends series.line.data
 * @excluding y,dataLabels,marker,name
 * @product highstock
 * @apioption series.flags.data
 */

/**
 * The fill color of an individual flag. By default it inherits from
 * the series color.
 * 
 * @type {Color}
 * @product highstock
 * @apioption series.flags.data.fillColor
 */

/**
 * The longer text to be shown in the flag's tooltip.
 * 
 * @type {String}
 * @product highstock
 * @apioption series.flags.data.text
 */

/**
 * The short text to be shown on the flag.
 * 
 * @type {String}
 * @product highstock
 * @apioption series.flags.data.title
 */


}(Highcharts, onSeriesMixin));
(function (H) {
/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var addEvent = H.addEvent,
	Axis = H.Axis,
	correctFloat = H.correctFloat,
	defaultOptions = H.defaultOptions,
	defined = H.defined,
	destroyObjectProperties = H.destroyObjectProperties,
	each = H.each,
	fireEvent = H.fireEvent,
	hasTouch = H.hasTouch,
	isTouchDevice = H.isTouchDevice,
	merge = H.merge,
	pick = H.pick,
	removeEvent = H.removeEvent,
	svg = H.svg,
	wrap = H.wrap,
	swapXY;

/**
 * 
 * The scrollbar is a means of panning over the X axis of a stock chart.
 * 
 * In styled mode, all the presentational options for the
 * scrollbar are replaced by the classes `.highcharts-scrollbar-thumb`,
 * `.highcharts-scrollbar-arrow`, `.highcharts-scrollbar-button`,
 * `.highcharts-scrollbar-rifles` and `.highcharts-scrollbar-track`.
 * 
 * @product highstock
 * @optionparent scrollbar
 */
var defaultScrollbarOptions =  {

	/**
	 * The height of the scrollbar. The height also applies to the width
	 * of the scroll arrows so that they are always squares. Defaults to
	 * 20 for touch devices and 14 for mouse devices.
	 * 
	 * @type {Number}
	 * @sample {highstock} stock/scrollbar/height/ A 30px scrollbar
	 * @product highstock
	 */
	height: isTouchDevice ? 20 : 14,
	
	/**
	 * The border rounding radius of the bar.
	 * 
	 * @type {Number}
	 * @sample {highstock} stock/scrollbar/style/ Scrollbar styling
	 * @default 0
	 * @product highstock
	 */
	barBorderRadius: 0,

	/**
	 * The corner radius of the scrollbar buttons.
	 * 
	 * @type {Number}
	 * @sample {highstock} stock/scrollbar/style/ Scrollbar styling
	 * @default 0
	 * @product highstock
	 */
	buttonBorderRadius: 0,

	/**
	 * Whether to redraw the main chart as the scrollbar or the navigator
	 * zoomed window is moved. Defaults to `true` for modern browsers and
	 * `false` for legacy IE browsers as well as mobile devices.
	 * 
	 * @type {Boolean}
	 * @since 1.3
	 * @product highstock
	 */
	liveRedraw: svg && !isTouchDevice,

	/**
	 * The margin between the scrollbar and its axis when the scrollbar is
	 * applied directly to an axis.
	 */
	margin: 10,

	/**
	 * The minimum width of the scrollbar.
	 * 
	 * @type {Number}
	 * @default 6
	 * @since 1.2.5
	 * @product highstock
	 */
	minWidth: 6,
	
	step: 0.2,

	/**
	 * The z index of the scrollbar group.
	 */
	zIndex: 3,
	

	/**
	 * The background color of the scrollbar itself.
	 * 
	 * @type {Color}
	 * @sample {highstock} stock/scrollbar/style/ Scrollbar styling
	 * @default #cccccc
	 * @product highstock
	 */
	barBackgroundColor: '#cccccc',

	/**
	 * The width of the bar's border.
	 * 
	 * @type {Number}
	 * @sample {highstock} stock/scrollbar/style/ Scrollbar styling
	 * @default 1
	 * @product highstock
	 */
	barBorderWidth: 1,

	/**
	 * The color of the scrollbar's border.
	 * 
	 * @type {Color}
	 * @default #cccccc
	 * @product highstock
	 */
	barBorderColor: '#cccccc',

	/**
	 * The color of the small arrow inside the scrollbar buttons.
	 * 
	 * @type {Color}
	 * @sample {highstock} stock/scrollbar/style/ Scrollbar styling
	 * @default #333333
	 * @product highstock
	 */
	buttonArrowColor: '#333333',

	/**
	 * The color of scrollbar buttons.
	 * 
	 * @type {Color}
	 * @sample {highstock} stock/scrollbar/style/ Scrollbar styling
	 * @default #e6e6e6
	 * @product highstock
	 */
	buttonBackgroundColor: '#e6e6e6',

	/**
	 * The color of the border of the scrollbar buttons.
	 * 
	 * @type {Color}
	 * @sample {highstock} stock/scrollbar/style/ Scrollbar styling
	 * @default #cccccc
	 * @product highstock
	 */
	buttonBorderColor: '#cccccc',

	/**
	 * The border width of the scrollbar buttons.
	 * 
	 * @type {Number}
	 * @sample {highstock} stock/scrollbar/style/ Scrollbar styling
	 * @default 1
	 * @product highstock
	 */
	buttonBorderWidth: 1,

	/**
	 * The color of the small rifles in the middle of the scrollbar.
	 * 
	 * @type {Color}
	 * @default #333333
	 * @product highstock
	 */
	rifleColor: '#333333',

	/**
	 * The color of the track background.
	 * 
	 * @type {Color}
	 * @sample {highstock} stock/scrollbar/style/ Scrollbar styling
	 * @default #f2f2f2
	 * @product highstock
	 */
	trackBackgroundColor: '#f2f2f2',

	/**
	 * The color of the border of the scrollbar track.
	 * 
	 * @type {Color}
	 * @sample {highstock} stock/scrollbar/style/ Scrollbar styling
	 * @default #f2f2f2
	 * @product highstock
	 */
	trackBorderColor: '#f2f2f2',

	/**
	 * The width of the border of the scrollbar track.
	 * 
	 * @type {Number}
	 * @sample {highstock} stock/scrollbar/style/ Scrollbar styling
	 * @default 1
	 * @product highstock
	 */
	trackBorderWidth: 1
	
};

defaultOptions.scrollbar = merge(true, defaultScrollbarOptions, defaultOptions.scrollbar);

/**
* When we have vertical scrollbar, rifles and arrow in buttons should be rotated.
* The same method is used in Navigator's handles, to rotate them.
* @param {Array} path - path to be rotated
* @param {Boolean} vertical - if vertical scrollbar, swap x-y values
*/
H.swapXY = swapXY = function (path, vertical) {
	var i,
		len = path.length,
		temp;

	if (vertical) {
		for (i = 0; i < len; i += 3) {
			temp = path[i + 1];
			path[i + 1] = path[i + 2];
			path[i + 2] = temp;
		}
	}

	return path;
};

/**
 * A reusable scrollbar, internally used in Highstock's navigator and optionally
 * on individual axes.
 *
 * @class
 * @param {Object} renderer
 * @param {Object} options
 * @param {Object} chart
 */
function Scrollbar(renderer, options, chart) { // docs
	this.init(renderer, options, chart);
}

Scrollbar.prototype = {

	init: function (renderer, options, chart) {

		this.scrollbarButtons = [];

		this.renderer = renderer;

		this.userOptions = options;
		this.options = merge(defaultScrollbarOptions, options);

		this.chart = chart;

		this.size = pick(this.options.size, this.options.height); // backward compatibility

		// Init
		if (options.enabled) {
			this.render();
			this.initEvents();
			this.addEvents();
		}
	},

	/**
	* Render scrollbar with all required items.
	*/
	render: function () {
		var scroller = this,
			renderer = scroller.renderer,
			options = scroller.options,
			size = scroller.size,
			group;

		// Draw the scrollbar group
		scroller.group = group = renderer.g('scrollbar').attr({
			zIndex: options.zIndex,
			translateY: -99999
		}).add();

		// Draw the scrollbar track:
		scroller.track = renderer.rect()
			.addClass('highcharts-scrollbar-track')
			.attr({
				x: 0,
				r: options.trackBorderRadius || 0,
				height: size,
				width: size
			}).add(group);

		
		scroller.track.attr({
			fill: options.trackBackgroundColor,
			stroke: options.trackBorderColor,
			'stroke-width': options.trackBorderWidth
		});
		
		this.trackBorderWidth = scroller.track.strokeWidth();
		scroller.track.attr({
			y: -this.trackBorderWidth % 2 / 2
		});


		// Draw the scrollbar itself
		scroller.scrollbarGroup = renderer.g().add(group);

		scroller.scrollbar = renderer.rect()
			.addClass('highcharts-scrollbar-thumb')
			.attr({
				height: size,
				width: size,
				r: options.barBorderRadius || 0
			}).add(scroller.scrollbarGroup);

		scroller.scrollbarRifles = renderer.path(
			swapXY([
				'M',
				-3, size / 4,
				'L',
				-3, 2 * size / 3,
				'M',
				0, size / 4,
				'L',
				0, 2 * size / 3,
				'M',
				3, size / 4,
				'L',
				3, 2 * size / 3
			], options.vertical))
			.addClass('highcharts-scrollbar-rifles')
			.add(scroller.scrollbarGroup);

		
		scroller.scrollbar.attr({
			fill: options.barBackgroundColor,
			stroke: options.barBorderColor,
			'stroke-width': options.barBorderWidth
		});
		scroller.scrollbarRifles.attr({
			stroke: options.rifleColor,
			'stroke-width': 1
		});
		
		scroller.scrollbarStrokeWidth = scroller.scrollbar.strokeWidth();
		scroller.scrollbarGroup.translate(
			-scroller.scrollbarStrokeWidth % 2 / 2,
			-scroller.scrollbarStrokeWidth % 2 / 2
		);

		// Draw the buttons:
		scroller.drawScrollbarButton(0);
		scroller.drawScrollbarButton(1);
	},

	/**
	 * Position the scrollbar, method called from a parent with defined dimensions
	 * @param {Number} x - x-position on the chart
	 * @param {Number} y - y-position on the chart
	 * @param {Number} width - width of the scrollbar
	 * @param {Number} height - height of the scorllbar
	 */
	position: function (x, y, width, height) {
		var scroller = this,
			options = scroller.options,
			vertical = options.vertical,
			xOffset = height,
			yOffset = 0,
			method = scroller.rendered ? 'animate' : 'attr';

		scroller.x = x;
		scroller.y = y + this.trackBorderWidth;
		scroller.width = width; // width with buttons
		scroller.height = height;
		scroller.xOffset = xOffset;
		scroller.yOffset = yOffset;

		// If Scrollbar is a vertical type, swap options:
		if (vertical) {
			scroller.width = scroller.yOffset = width = yOffset = scroller.size;
			scroller.xOffset = xOffset = 0;
			scroller.barWidth = height - width * 2; // width without buttons
			scroller.x = x = x + scroller.options.margin;
		} else {
			scroller.height = scroller.xOffset = height = xOffset = scroller.size;
			scroller.barWidth = width - height * 2; // width without buttons
			scroller.y = scroller.y + scroller.options.margin;
		}

		// Set general position for a group:
		scroller.group[method]({
			translateX: x,
			translateY: scroller.y
		});

		// Resize background/track:
		scroller.track[method]({
			width: width,
			height: height
		});

		// Move right/bottom button ot it's place:
		scroller.scrollbarButtons[1][method]({
			translateX: vertical ? 0 : width - xOffset,
			translateY: vertical ? height - yOffset : 0
		});
	},

	/**
	 * Draw the scrollbar buttons with arrows
	 * @param {Number} index 0 is left, 1 is right
	 */
	drawScrollbarButton: function (index) {
		var scroller = this,
			renderer = scroller.renderer,
			scrollbarButtons = scroller.scrollbarButtons,
			options = scroller.options,
			size = scroller.size,
			group,
			tempElem;

		group = renderer.g().add(scroller.group);
		scrollbarButtons.push(group);

		// Create a rectangle for the scrollbar button
		tempElem = renderer.rect()
			.addClass('highcharts-scrollbar-button')
			.add(group);

		
		// Presentational attributes
		tempElem.attr({
			stroke: options.buttonBorderColor,
			'stroke-width': options.buttonBorderWidth,
			fill: options.buttonBackgroundColor
		});
		

		// Place the rectangle based on the rendered stroke width
		tempElem.attr(tempElem.crisp({
			x: -0.5,
			y: -0.5,
			width: size + 1, // +1 to compensate for crispifying in rect method
			height: size + 1,
			r: options.buttonBorderRadius
		}, tempElem.strokeWidth()));

		// Button arrow
		tempElem = renderer
			.path(swapXY([
				'M',
				size / 2 + (index ? -1 : 1), 
				size / 2 - 3,
				'L',
				size / 2 + (index ? -1 : 1), 
				size / 2 + 3,
				'L',
				size / 2 + (index ? 2 : -2), 
				size / 2
			], options.vertical))
			.addClass('highcharts-scrollbar-arrow')
			.add(scrollbarButtons[index]);

		
		tempElem.attr({
			fill: options.buttonArrowColor
		});
		
	},

	/**
	* Set scrollbar size, with a given scale.
	* @param {Number} from - scale (0-1) where bar should start
	* @param {Number} to - scale (0-1) where bar should end
	*/
	setRange: function (from, to) {
		var scroller = this,
			options = scroller.options,
			vertical = options.vertical,
			minWidth = options.minWidth,
			fullWidth = scroller.barWidth,
			fromPX,
			toPX,
			newPos,
			newSize,
			newRiflesPos,
			method = this.rendered && !this.hasDragged ? 'animate' : 'attr';

		if (!defined(fullWidth)) {
			return;
		}

		from = Math.max(from, 0);
		fromPX = Math.ceil(fullWidth * from);
		toPX = fullWidth * Math.min(to, 1);
		scroller.calculatedWidth = newSize = correctFloat(toPX - fromPX);

		// We need to recalculate position, if minWidth is used
		if (newSize < minWidth) {
			fromPX = (fullWidth - minWidth + newSize) * from;
			newSize = minWidth;
		}
		newPos = Math.floor(fromPX + scroller.xOffset + scroller.yOffset);
		newRiflesPos = newSize / 2 - 0.5; // -0.5 -> rifle line width / 2

		// Store current position:
		scroller.from = from;
		scroller.to = to;

		if (!vertical) {
			scroller.scrollbarGroup[method]({
				translateX: newPos
			});
			scroller.scrollbar[method]({
				width: newSize
			});
			scroller.scrollbarRifles[method]({
				translateX: newRiflesPos
			});
			scroller.scrollbarLeft = newPos;
			scroller.scrollbarTop = 0;
		} else {
			scroller.scrollbarGroup[method]({
				translateY: newPos
			});
			scroller.scrollbar[method]({
				height: newSize
			});
			scroller.scrollbarRifles[method]({
				translateY: newRiflesPos
			});
			scroller.scrollbarTop = newPos;
			scroller.scrollbarLeft = 0;
		}

		if (newSize <= 12) {
			scroller.scrollbarRifles.hide();
		} else {
			scroller.scrollbarRifles.show(true);
		}

		// Show or hide the scrollbar based on the showFull setting
		if (options.showFull === false) {
			if (from <= 0 && to >= 1) {
				scroller.group.hide();
			} else {
				scroller.group.show();
			}
		}

		scroller.rendered = true;
	},

	/**
	* Init events methods, so we have an access to the Scrollbar itself
	*/
	initEvents: function () {
		var scroller = this;
		/**
		 * Event handler for the mouse move event.
		 */
		scroller.mouseMoveHandler = function (e) {
			var normalizedEvent = scroller.chart.pointer.normalize(e),
				options = scroller.options,
				direction = options.vertical ? 'chartY' : 'chartX',
				initPositions = scroller.initPositions,
				scrollPosition,
				chartPosition,
				change;

			// In iOS, a mousemove event with e.pageX === 0 is fired when holding the finger
			// down in the center of the scrollbar. This should be ignored.
			if (scroller.grabbedCenter && (!e.touches || e.touches[0][direction] !== 0)) { // #4696, scrollbar failed on Android
				chartPosition = scroller.cursorToScrollbarPosition(normalizedEvent)[direction];
				scrollPosition = scroller[direction];

				change = chartPosition - scrollPosition;

				scroller.hasDragged = true;
				scroller.updatePosition(initPositions[0] + change, initPositions[1] + change);

				if (scroller.hasDragged) {
					fireEvent(scroller, 'changed', {
						from: scroller.from,
						to: scroller.to,
						trigger: 'scrollbar',
						DOMType: e.type,
						DOMEvent: e
					});
				}
			}
		};

		/**
		 * Event handler for the mouse up event.
		 */
		scroller.mouseUpHandler = function (e) {
			if (scroller.hasDragged) {
				fireEvent(scroller, 'changed', {
					from: scroller.from,
					to: scroller.to,
					trigger: 'scrollbar',
					DOMType: e.type,
					DOMEvent: e
				});
			}
			scroller.grabbedCenter = scroller.hasDragged = scroller.chartX = scroller.chartY = null;
		};

		scroller.mouseDownHandler = function (e) {
			var normalizedEvent = scroller.chart.pointer.normalize(e),
				mousePosition = scroller.cursorToScrollbarPosition(normalizedEvent);

			scroller.chartX = mousePosition.chartX;
			scroller.chartY = mousePosition.chartY;
			scroller.initPositions = [scroller.from, scroller.to];

			scroller.grabbedCenter = true;
		};

		scroller.buttonToMinClick = function (e) {
			var range = correctFloat(scroller.to - scroller.from) * scroller.options.step;
			scroller.updatePosition(correctFloat(scroller.from - range), correctFloat(scroller.to - range));
			fireEvent(scroller, 'changed', {
				from: scroller.from,
				to: scroller.to,
				trigger: 'scrollbar',
				DOMEvent: e
			});
		};

		scroller.buttonToMaxClick = function (e) {
			var range = (scroller.to - scroller.from) * scroller.options.step;
			scroller.updatePosition(scroller.from + range, scroller.to + range);
			fireEvent(scroller, 'changed', {
				from: scroller.from,
				to: scroller.to,
				trigger: 'scrollbar',
				DOMEvent: e
			});
		};

		scroller.trackClick = function (e) {
			var normalizedEvent = scroller.chart.pointer.normalize(e),
				range = scroller.to - scroller.from,
				top = scroller.y + scroller.scrollbarTop,
				left = scroller.x + scroller.scrollbarLeft;

			if ((scroller.options.vertical && normalizedEvent.chartY > top) || 
				(!scroller.options.vertical && normalizedEvent.chartX > left)) {
				// On the top or on the left side of the track:
				scroller.updatePosition(scroller.from + range, scroller.to + range);
			} else {
				// On the bottom or the right side of the track:
				scroller.updatePosition(scroller.from - range, scroller.to - range);
			}

			fireEvent(scroller, 'changed', {
				from: scroller.from,
				to: scroller.to,
				trigger: 'scrollbar',
				DOMEvent: e
			});
		};
	},

	/**
	 * Get normalized (0-1) cursor position over the scrollbar
	 * @param {Event} normalizedEvent - normalized event, with chartX and chartY values
	 * @return {Object} Local position {chartX, chartY}
	 */
	cursorToScrollbarPosition: function (normalizedEvent) {
		var scroller = this,
			options = scroller.options,
			minWidthDifference = options.minWidth > scroller.calculatedWidth ? options.minWidth : 0; // minWidth distorts translation

		return {
			chartX: (normalizedEvent.chartX - scroller.x - scroller.xOffset) / (scroller.barWidth - minWidthDifference),
			chartY: (normalizedEvent.chartY - scroller.y - scroller.yOffset) / (scroller.barWidth - minWidthDifference)
		};
	},

	/**
	* Update position option in the Scrollbar, with normalized 0-1 scale
	*/
	updatePosition: function (from, to) {
		if (to > 1) {
			from = correctFloat(1 - correctFloat(to - from));
			to = 1;
		}

		if (from < 0) {
			to = correctFloat(to - from);
			from = 0;
		}

		this.from = from;
		this.to = to;
	},

	/**
	 * Update the scrollbar with new options
	 */
	update: function (options) {
		this.destroy();
		this.init(this.chart.renderer, merge(true, this.options, options), this.chart);
	},

	/**
	 * Set up the mouse and touch events for the Scrollbar
	 */
	addEvents: function () {
		var buttonsOrder = this.options.inverted ? [1, 0] : [0, 1],
			buttons = this.scrollbarButtons,
			bar = this.scrollbarGroup.element,
			track = this.track.element,
			mouseDownHandler = this.mouseDownHandler,
			mouseMoveHandler = this.mouseMoveHandler,
			mouseUpHandler = this.mouseUpHandler,
			_events;

		// Mouse events
		_events = [
			[buttons[buttonsOrder[0]].element, 'click', this.buttonToMinClick],
			[buttons[buttonsOrder[1]].element, 'click', this.buttonToMaxClick],
			[track, 'click', this.trackClick],
			[bar, 'mousedown', mouseDownHandler],
			[bar.ownerDocument, 'mousemove', mouseMoveHandler],
			[bar.ownerDocument, 'mouseup', mouseUpHandler]
		];

		// Touch events
		if (hasTouch) {
			_events.push(
				[bar, 'touchstart', mouseDownHandler],
				[bar.ownerDocument, 'touchmove', mouseMoveHandler],
				[bar.ownerDocument, 'touchend', mouseUpHandler]
			);
		}

		// Add them all
		each(_events, function (args) {
			addEvent.apply(null, args);
		});
		this._events = _events;
	},

	/**
	 * Removes the event handlers attached previously with addEvents.
	 */
	removeEvents: function () {
		each(this._events, function (args) {
			removeEvent.apply(null, args);
		});
		this._events.length = 0;
	},

	/**
	 * Destroys allocated elements.
	 */
	destroy: function () {

		var scroller = this.chart.scroller;

		// Disconnect events added in addEvents
		this.removeEvents();

		// Destroy properties
		each(['track', 'scrollbarRifles', 'scrollbar', 'scrollbarGroup', 'group'], function (prop) {
			if (this[prop] && this[prop].destroy) {
				this[prop] = this[prop].destroy();
			}
		}, this);

		if (scroller && this === scroller.scrollbar) { // #6421, chart may have more scrollbars
			scroller.scrollbar = null;

			// Destroy elements in collection
			destroyObjectProperties(scroller.scrollbarButtons);
		}
	}
};

/**
* Wrap axis initialization and create scrollbar if enabled:
*/
wrap(Axis.prototype, 'init', function (proceed) {
	var axis = this;
	proceed.apply(axis, Array.prototype.slice.call(arguments, 1));

	if (axis.options.scrollbar && axis.options.scrollbar.enabled) {
		// Predefined options:
		axis.options.scrollbar.vertical = !axis.horiz;
		axis.options.startOnTick = axis.options.endOnTick = false;

		axis.scrollbar = new Scrollbar(axis.chart.renderer, axis.options.scrollbar, axis.chart);

		addEvent(axis.scrollbar, 'changed', function (e) {
			var unitedMin = Math.min(pick(axis.options.min, axis.min), axis.min, axis.dataMin),
				unitedMax = Math.max(pick(axis.options.max, axis.max), axis.max, axis.dataMax),
				range = unitedMax - unitedMin,
				to,
				from;

			if ((axis.horiz && !axis.reversed) || (!axis.horiz && axis.reversed)) {
				to = unitedMin + range * this.to;
				from = unitedMin + range * this.from;
			} else {
				// y-values in browser are reversed, but this also applies for reversed horizontal axis:
				to = unitedMin + range * (1 - this.from);
				from = unitedMin + range * (1 - this.to);
			}

			axis.setExtremes(from, to, true, false, e);
		});
	}
});

/**
* Wrap rendering axis, and update scrollbar if one is created:
*/
wrap(Axis.prototype, 'render', function (proceed) {
	var axis = this,		
		scrollMin = Math.min(
			pick(axis.options.min, axis.min),
			axis.min,
			pick(axis.dataMin, axis.min) // #6930
		),
		scrollMax = Math.max(
			pick(axis.options.max, axis.max),
			axis.max,
			pick(axis.dataMax, axis.max) // #6930
		),
		scrollbar = axis.scrollbar,
		titleOffset = axis.titleOffset || 0,
		offsetsIndex,
		from,
		to;

	proceed.apply(axis, Array.prototype.slice.call(arguments, 1));

	if (scrollbar) {

		if (axis.horiz) {
			scrollbar.position(
				axis.left, 
				axis.top + axis.height + 2 + axis.chart.scrollbarsOffsets[1] +
					(axis.opposite ?
						0 :
						titleOffset + axis.axisTitleMargin + axis.offset
					),
				axis.width,
				axis.height
			);
			offsetsIndex = 1;
		} else {
			scrollbar.position(
				axis.left + axis.width + 2 + axis.chart.scrollbarsOffsets[0] +
					(axis.opposite ? 
						titleOffset + axis.axisTitleMargin + axis.offset :
						0
					),
				axis.top, 
				axis.width, 
				axis.height
			);
			offsetsIndex = 0;
		}

		if ((!axis.opposite && !axis.horiz) || (axis.opposite && axis.horiz)) {
			axis.chart.scrollbarsOffsets[offsetsIndex] +=
				axis.scrollbar.size + axis.scrollbar.options.margin;
		}

		if (isNaN(scrollMin) || isNaN(scrollMax) || !defined(axis.min) || !defined(axis.max)) {
			scrollbar.setRange(0, 0); // default action: when there is not extremes on the axis, but scrollbar exists, make it full size
		} else {
			from = (axis.min - scrollMin) / (scrollMax - scrollMin);
			to = (axis.max - scrollMin) / (scrollMax - scrollMin);

			if ((axis.horiz && !axis.reversed) || (!axis.horiz && axis.reversed)) {
				scrollbar.setRange(from, to);
			} else {
				scrollbar.setRange(1 - to, 1 - from); // inverse vertical axis
			}
		}
	}
});

/**
* Make space for a scrollbar
*/
wrap(Axis.prototype, 'getOffset', function (proceed) {
	var axis = this,
		index = axis.horiz ? 2 : 1,
		scrollbar = axis.scrollbar;

	proceed.apply(axis, Array.prototype.slice.call(arguments, 1));

	if (scrollbar) {
		axis.chart.scrollbarsOffsets = [0, 0]; // reset scrollbars offsets
		axis.chart.axisOffset[index] += scrollbar.size + scrollbar.options.margin;
	}
});

/**
* Destroy scrollbar when connected to the specific axis
*/
wrap(Axis.prototype, 'destroy', function (proceed) {
	if (this.scrollbar) {
		this.scrollbar = this.scrollbar.destroy();
	}

	proceed.apply(this, Array.prototype.slice.call(arguments, 1));
});

H.Scrollbar = Scrollbar;

}(Highcharts));
(function (H) {
/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
/* eslint max-len: ["warn", 80, 4] */

/**
 * Options for the corresponding navigator series if `showInNavigator`
 * is `true` for this series. Available options are the same as any
 * series, documented at [plotOptions](#plotOptions.series) and
 * [series](#series).
 *
 *
 * These options are merged with options in [navigator.series](#navigator.
 * series), and will take precedence if the same option is defined both
 * places.
 *
 * @type {Object}
 * @see [navigator.series](#navigator.series)
 * @default undefined
 * @since 5.0.0
 * @product highstock
 * @apioption plotOptions.series.navigatorOptions
 */

/**
 * Whether or not to show the series in the navigator. Takes precedence
 * over [navigator.baseSeries](#navigator.baseSeries) if defined.
 *
 * @type {Boolean}
 * @default undefined
 * @since 5.0.0
 * @product highstock
 * @apioption plotOptions.series.showInNavigator
 */

var addEvent = H.addEvent,
	Axis = H.Axis,
	Chart = H.Chart,
	color = H.color,
	defaultDataGroupingUnits = H.defaultDataGroupingUnits,
	defaultOptions = H.defaultOptions,
	defined = H.defined,
	destroyObjectProperties = H.destroyObjectProperties,
	each = H.each,
	erase = H.erase,
	error = H.error,
	extend = H.extend,
	grep = H.grep,
	hasTouch = H.hasTouch,
	isArray = H.isArray,
	isNumber = H.isNumber,
	isObject = H.isObject,
	merge = H.merge,
	pick = H.pick,
	removeEvent = H.removeEvent,
	Scrollbar = H.Scrollbar,
	Series = H.Series,
	seriesTypes = H.seriesTypes,
	wrap = H.wrap,

	units = [].concat(defaultDataGroupingUnits), // copy
	defaultSeriesType,

	// Finding the min or max of a set of variables where we don't know if they
	// are defined, is a pattern that is repeated several places in Highcharts.
	// Consider making this a global utility method.
	numExt = function (extreme) {
		var numbers = grep(arguments, isNumber);
		if (numbers.length) {
			return Math[extreme].apply(0, numbers);
		}
	};

// add more resolution to units
units[4] = ['day', [1, 2, 3, 4]]; // allow more days
units[5] = ['week', [1, 2, 3]]; // allow more weeks

defaultSeriesType = seriesTypes.areaspline === undefined ?
	'line' :
	'areaspline';

extend(defaultOptions, {

	/**
	 * The navigator is a small series below the main series, displaying
	 * a view of the entire data set. It provides tools to zoom in and
	 * out on parts of the data as well as panning across the dataset.
	 *
	 * @product highstock
	 * @optionparent navigator
	 */
	navigator: {
		/**
		 * The height of the navigator.
		 *
		 * @type {Number}
		 * @sample {highstock} stock/navigator/height/ A higher navigator
		 * @default 40
		 * @product highstock
		 */
		height: 40,

		/**
		 * The distance from the nearest element, the X axis or X axis labels.
		 *
		 * @type {Number}
		 * @sample {highstock} stock/navigator/margin/
		 *         A margin of 2 draws the navigator closer to the X axis labels
		 * @default 25
		 * @product highstock
		 */
		margin: 25,

		/**
		 * Whether the mask should be inside the range marking the zoomed
		 * range, or outside. In Highstock 1.x it was always `false`.
		 *
		 * @type {Boolean}
		 * @sample {highstock} stock/navigator/maskinside-false/
		 *         False, mask outside
		 * @default true
		 * @since 2.0
		 * @product highstock
		 */
		maskInside: true,

		/**
		 * Options for the handles for dragging the zoomed area.
		 *
		 * @type {Object}
		 * @sample {highstock} stock/navigator/handles/ Colored handles
		 * @product highstock
		 */
		handles: {
			/**
			 * Width for handles.
			 *
			 * @type {Number}
			 * @default 7
			 * @product highstock
			 * @sample {highstock} stock/navigator/styled-handles/
			 *         Styled handles
			 * @since 6.0.0
			 */
			width: 7,

			/**
			 * Height for handles.
			 *
			 * @type {Number}
			 * @default 15
			 * @product highstock
			 * @sample {highstock} stock/navigator/styled-handles/
			 *         Styled handles
			 * @since 6.0.0
			 */
			height: 15,

			/**
			 * Array to define shapes of handles. 0-index for left, 1-index for
			 * right.
			 *
			 * Additionally, the URL to a graphic can be given on this form:
			 * `url(graphic.png)`. Note that for the image to be applied to
			 * exported charts, its URL needs to be accessible by the export
			 * server.
			 *
			 * Custom callbacks for symbol path generation can also be added to
			 * `Highcharts.SVGRenderer.prototype.symbols`. The callback is then
			 * used by its method name, as shown in the demo.
			 *
			 * @type {Array}
			 * @default ['navigator-handle', 'navigator-handle']
			 * @product highstock
			 * @sample {highstock} stock/navigator/styled-handles/
			 *         Styled handles
			 * @since 6.0.0
			 */
			symbols: ['navigator-handle', 'navigator-handle'],

			/**
			 * Allows to enable/disable handles.
			 *
			 * @type {Boolean}
			 * @default true
			 * @product highstock
			 * @since 6.0.0
			 */
			enabled: true,

			
			/**
			 * The width for the handle border and the stripes inside.
			 *
			 * @type {Number}
			 * @default 7
			 * @product highstock
			 * @sample {highstock} stock/navigator/styled-handles/
			 *         Styled handles
			 * @since 6.0.0
			 */
			lineWidth: 1,

			/**
			 * The fill for the handle.
			 *
			 * @type {Color}
			 * @product highstock
			 */
			backgroundColor: '#f2f2f2',

			/**
			 * The stroke for the handle border and the stripes inside.
			 *
			 * @type {Color}
			 * @product highstock
			 */
			borderColor: '#999999'

			
		},

		

		/**
		 * The color of the mask covering the areas of the navigator series
		 * that are currently not visible in the main series. The default
		 * color is bluish with an opacity of 0.3 to see the series below.
		 *
		 * @type {Color}
		 * @see     In styled mode, the mask is styled with the
		 *          `.highcharts-navigator-mask` and
		 *          `.highcharts-navigator-mask-inside` classes.
		 * @sample  {highstock} stock/navigator/maskfill/
		 *          Blue, semi transparent mask
		 * @default rgba(102,133,194,0.3)
		 * @product highstock
		 */
		maskFill: color('#6685c2').setOpacity(0.3).get(),

		/**
		 * The color of the line marking the currently zoomed area in the
		 * navigator.
		 *
		 * @type {Color}
		 * @sample {highstock} stock/navigator/outline/ 2px blue outline
		 * @default #cccccc
		 * @product highstock
		 */
		outlineColor: '#cccccc',

		/**
		 * The width of the line marking the currently zoomed area in the
		 * navigator.
		 *
		 * @type {Number}
		 * @see In styled mode, the outline stroke width is set with the `.
		 * highcharts-navigator-outline` class.
		 * @sample {highstock} stock/navigator/outline/ 2px blue outline
		 * @default 2
		 * @product highstock
		 */
		outlineWidth: 1,
		

		/**
		 * Options for the navigator series. Available options are the same
		 * as any series, documented at [plotOptions](#plotOptions.series)
		 * and [series](#series).
		 *
		 * Unless data is explicitly defined on navigator.series, the data
		 * is borrowed from the first series in the chart.
		 *
		 * Default series options for the navigator series are:
		 *
		 * <pre>series: {
		 *     type: 'areaspline',
		 *     fillOpacity: 0.05,
		 *     dataGrouping: {
		 *         smoothed: true
		 *     },
		 *     lineWidth: 1,
		 *     marker: {
		 *         enabled: false
		 *     }
		 * }</pre>
		 *
		 * @type {Object}
		 * @see In styled mode, the navigator series is styled with the `.
		 * highcharts-navigator-series` class.
		 * @sample {highstock} stock/navigator/series-data/
		 *         Using a separate data set for the navigator
		 * @sample {highstock} stock/navigator/series/
		 *         A green navigator series
		 * @product highstock
		 */
		series: {

			/**
			 * The type of the navigator series. Defaults to `areaspline` if
			 * defined, otherwise `line`.
			 *
			 * @type {String}
			 */
			type: defaultSeriesType,
			


			/**
			 * The fill opacity of the navigator series.
			 */
			fillOpacity: 0.05,

			/**
			 * The pixel line width of the navigator series.
			 */
			lineWidth: 1,
			

			/**
			 * @ignore
			 */
			compare: null,

			/**
			 * Data grouping options for the navigator series.
			 *
			 * @extends {plotOptions.series.dataGrouping}
			 */
			dataGrouping: {
				approximation: 'average',
				enabled: true,
				groupPixelWidth: 2,
				smoothed: true,
				units: units
			},

			/**
			 * Data label options for the navigator series. Data labels are
			 * disabled by default on the navigator series.
			 *
			 * @extends {plotOptions.series.dataLabels}
			 */
			dataLabels: {
				enabled: false,
				zIndex: 2 // #1839
			},

			id: 'highcharts-navigator-series',
			className: 'highcharts-navigator-series',

			/**
			 * Line color for the navigator series. Allows setting the color
			 * while disallowing the default candlestick setting.
			 *
			 * @type {Color}
			 */
			lineColor: null, // #4602

			marker: {
				enabled: false
			},

			pointRange: 0,
			/**
			 * The threshold option. Setting it to 0 will make the default
			 * navigator area series draw its area from the 0 value and up.
			 * @type {Number}
			 */
			threshold: null
		},

		/**
		 * Options for the navigator X axis. Default series options
		 * for the navigator xAxis are:
		 *
		 * <pre>xAxis: {
		 *     tickWidth: 0,
		 *     lineWidth: 0,
		 *     gridLineWidth: 1,
		 *     tickPixelInterval: 200,
		 *     labels: {
		 *     	   align: 'left',
		 *         style: {
		 *             color: '#888'
		 *         },
		 *         x: 3,
		 *         y: -4
		 *     }
		 * }</pre>
		 *
		 * @type {Object}
		 * @extends {xAxis}
		 * @excluding linkedTo,maxZoom,minRange,opposite,range,scrollbar,
		 *          showEmpty,maxRange
		 * @product highstock
		 */
		xAxis: {
			/**
			 * Additional range on the right side of the xAxis. Works similar to
			 * xAxis.maxPadding, but value is set in milliseconds.
			 * Can be set for both, main xAxis and navigator's xAxis.
			 *
			 * @type {Number}
			 * @default 0
			 * @since 6.0.0
			 * @product highstock
			 * @apioption xAxis.overscroll
			 */
			overscroll: 0,

			className: 'highcharts-navigator-xaxis',
			tickLength: 0,

			
			lineWidth: 0,
			gridLineColor: '#e6e6e6',
			gridLineWidth: 1,
			

			tickPixelInterval: 200,

			labels: {
				align: 'left',

				
				style: {
					color: '#999999'
				},
				

				x: 3,
				y: -4
			},

			crosshair: false
		},

		/**
		 * Options for the navigator Y axis. Default series options
		 * for the navigator yAxis are:
		 *
		 * <pre>yAxis: {
		 *     gridLineWidth: 0,
		 *     startOnTick: false,
		 *     endOnTick: false,
		 *     minPadding: 0.1,
		 *     maxPadding: 0.1,
		 *     labels: {
		 *         enabled: false
		 *     },
		 *     title: {
		 *         text: null
		 *     },
		 *     tickWidth: 0
		 * }</pre>
		 *
		 * @type {Object}
		 * @extends {yAxis}
		 * @excluding height,linkedTo,maxZoom,minRange,ordinal,range,showEmpty,
		 *          scrollbar,top,units,maxRange
		 * @product highstock
		 */
		yAxis: {

			className: 'highcharts-navigator-yaxis',

			
			gridLineWidth: 0,
			

			startOnTick: false,
			endOnTick: false,
			minPadding: 0.1,
			maxPadding: 0.1,
			labels: {
				enabled: false
			},
			crosshair: false,
			title: {
				text: null
			},
			tickLength: 0,
			tickWidth: 0
		}
	}
});

/**
 * Draw one of the handles on the side of the zoomed range in the navigator
 * @param {Boolean} inverted flag for chart.inverted
 * @returns {Array} Path to be used in a handle
 */
H.Renderer.prototype.symbols['navigator-handle'] = function (
	x,
	y,
	w,
	h,
	options
) {
	var halfWidth = options.width / 2,
		markerPosition = Math.round(halfWidth / 3) + 0.5,
		height = options.height;

	return [
		'M',
		-halfWidth - 1, 0.5,
		'L',
		halfWidth, 0.5,
		'L',
		halfWidth, height + 0.5,
		'L',
		-halfWidth - 1, height + 0.5,
		'L',
		-halfWidth - 1, 0.5,
		'M',
		-markerPosition, 4,
		'L',
		-markerPosition, height - 3,
		'M',
		markerPosition - 1, 4,
		'L',
		markerPosition - 1, height - 3
	];
};

/**
 * The Navigator class
 * @param {Object} chart - Chart object
 * @class
 */
function Navigator(chart) {
	this.init(chart);
}

Navigator.prototype = {
	/**
	 * Draw one of the handles on the side of the zoomed range in the navigator
	 * @param {Number} x The x center for the handle
	 * @param {Number} index 0 for left and 1 for right
	 * @param {Boolean} inverted flag for chart.inverted
	 * @param {String} verb use 'animate' or 'attr'
	 */
	drawHandle: function (x, index, inverted, verb) {
		var navigator = this,
			height = navigator.navigatorOptions.handles.height;

		// Place it
		navigator.handles[index][verb](inverted ? {
			translateX: Math.round(navigator.left + navigator.height / 2),
			translateY: Math.round(
				navigator.top + parseInt(x, 10) + 0.5 - height
			)
		} : {
			translateX: Math.round(navigator.left + parseInt(x, 10)),
			translateY: Math.round(
				navigator.top + navigator.height / 2 - height / 2 - 1
			)
		});
	},

	/**
	 * Render outline around the zoomed range
	 * @param {Number} zoomedMin in pixels position where zoomed range starts
	 * @param {Number} zoomedMax in pixels position where zoomed range ends
	 * @param {Boolean} inverted flag if chart is inverted
	 * @param {String} verb use 'animate' or 'attr'
	 */
	drawOutline: function (zoomedMin, zoomedMax, inverted, verb) {
		var navigator = this,
			maskInside = navigator.navigatorOptions.maskInside,
			outlineWidth = navigator.outline.strokeWidth(),
			halfOutline = outlineWidth / 2,
			outlineCorrection = (outlineWidth % 2) / 2, // #5800
			outlineHeight = navigator.outlineHeight,
			scrollbarHeight = navigator.scrollbarHeight,
			navigatorSize = navigator.size,
			left = navigator.left - scrollbarHeight,
			navigatorTop = navigator.top,
			verticalMin,
			path;

		if (inverted) {
			left -= halfOutline;
			verticalMin = navigatorTop + zoomedMax + outlineCorrection;
			zoomedMax = navigatorTop + zoomedMin + outlineCorrection;

			path = [
				'M',
				left + outlineHeight,
				navigatorTop - scrollbarHeight - outlineCorrection, // top edge
				'L',
				left + outlineHeight,
				verticalMin, // top right of zoomed range
				'L',
				left,
				verticalMin, // top left of z.r.
				'L',
				left,
				zoomedMax, // bottom left of z.r.
				'L',
				left + outlineHeight,
				zoomedMax, // bottom right of z.r.
				'L',
				left + outlineHeight,
				navigatorTop + navigatorSize + scrollbarHeight // bottom edge
			].concat(maskInside ? [
				'M',
				left + outlineHeight,
				verticalMin - halfOutline, // upper left of zoomed range
				'L',
				left + outlineHeight,
				zoomedMax + halfOutline // upper right of z.r.
			] : []);
		} else {
			zoomedMin += left + scrollbarHeight - outlineCorrection;
			zoomedMax += left + scrollbarHeight - outlineCorrection;
			navigatorTop += halfOutline;

			path = [
				'M',
				left,
				navigatorTop, // left
				'L',
				zoomedMin,
				navigatorTop, // upper left of zoomed range
				'L',
				zoomedMin,
				navigatorTop + outlineHeight, // lower left of z.r.
				'L',
				zoomedMax,
				navigatorTop + outlineHeight, // lower right of z.r.
				'L',
				zoomedMax,
				navigatorTop, // upper right of z.r.
				'L',
				left + navigatorSize + scrollbarHeight * 2,
				navigatorTop // right
			].concat(maskInside ? [
				'M',
				zoomedMin - halfOutline,
				navigatorTop, // upper left of zoomed range
				'L',
				zoomedMax + halfOutline,
				navigatorTop // upper right of z.r.
			] : []);
		}
		navigator.outline[verb]({
			d: path
		});
	},

	/**
	 * Render outline around the zoomed range
	 * @param {Number} zoomedMin in pixels position where zoomed range starts
	 * @param {Number} zoomedMax in pixels position where zoomed range ends
	 * @param {Boolean} inverted flag if chart is inverted
	 * @param {String} verb use 'animate' or 'attr'
	 */
	drawMasks: function (zoomedMin, zoomedMax, inverted, verb) {
		var navigator = this,
			left = navigator.left,
			top = navigator.top,
			navigatorHeight = navigator.height,
			height,
			width,
			x,
			y;

		// Determine rectangle position & size
		// According to (non)inverted position:
		if (inverted) {
			x = [left, left, left];
			y = [top, top + zoomedMin, top + zoomedMax];
			width = [navigatorHeight, navigatorHeight, navigatorHeight];
			height = [
				zoomedMin,
				zoomedMax - zoomedMin,
				navigator.size - zoomedMax
			];
		} else {
			x = [left, left + zoomedMin, left + zoomedMax];
			y = [top, top, top];
			width = [
				zoomedMin,
				zoomedMax - zoomedMin,
				navigator.size - zoomedMax
			];
			height = [navigatorHeight, navigatorHeight, navigatorHeight];
		}
		each(navigator.shades, function (shade, i) {
			shade[verb]({
				x: x[i],
				y: y[i],
				width: width[i],
				height: height[i]
			});
		});
	},

	/**
	 * Generate DOM elements for a navigator:
	 * - main navigator group
	 * - all shades
	 * - outline
	 * - handles
	 */
	renderElements: function () {
		var navigator = this,
			navigatorOptions = navigator.navigatorOptions,
			maskInside = navigatorOptions.maskInside,
			chart = navigator.chart,
			inverted = chart.inverted,
			renderer = chart.renderer,
			navigatorGroup;

		// Create the main navigator group
		navigator.navigatorGroup = navigatorGroup = renderer.g('navigator')
			.attr({
				zIndex: 8,
				visibility: 'hidden'
			})
			.add();


		
		var mouseCursor = {
			cursor: inverted ? 'ns-resize' : 'ew-resize'
		};
		

		// Create masks, each mask will get events and fill:
		each([!maskInside, maskInside, !maskInside], function (hasMask, index) {
			navigator.shades[index] = renderer.rect()
				.addClass('highcharts-navigator-mask' +
					(index === 1 ? '-inside' : '-outside'))
				
				.attr({
					fill: hasMask ? navigatorOptions.maskFill : 'rgba(0,0,0,0)'
				})
				.css(index === 1 && mouseCursor)
				
				.add(navigatorGroup);
		});

		// Create the outline:
		navigator.outline = renderer.path()
			.addClass('highcharts-navigator-outline')
			
			.attr({
				'stroke-width': navigatorOptions.outlineWidth,
				stroke: navigatorOptions.outlineColor
			})
			
			.add(navigatorGroup);

		// Create the handlers:
		if (navigatorOptions.handles.enabled) {
			each([0, 1], function (index) {
				navigatorOptions.handles.inverted = chart.inverted;
				navigator.handles[index] = renderer.symbol(
					navigatorOptions.handles.symbols[index],
					-navigatorOptions.handles.width / 2 - 1,
					0,
					navigatorOptions.handles.width,
					navigatorOptions.handles.height,
					navigatorOptions.handles
				);
				// zIndex = 6 for right handle, 7 for left.
				// Can't be 10, because of the tooltip in inverted chart #2908
				navigator.handles[index].attr({ zIndex: 7 - index })
					.addClass(
						'highcharts-navigator-handle ' +
						'highcharts-navigator-handle-' +
						['left', 'right'][index]
					).add(navigatorGroup);

				
				var handlesOptions = navigatorOptions.handles;
				navigator.handles[index]
					.attr({
						fill: handlesOptions.backgroundColor,
						stroke: handlesOptions.borderColor,
						'stroke-width': handlesOptions.lineWidth
					})
					.css(mouseCursor);
				
			});
		}
	},

	/**
	 * Update navigator
	 * @param {Object} options Options to merge in when updating navigator
	 */
	update: function (options) {
		// Remove references to old navigator series in base series
		each(this.series || [], function (series) {
			if (series.baseSeries) {
				delete series.baseSeries.navigatorSeries;
			}
		});
		// Destroy and rebuild navigator
		this.destroy();
		var chartOptions = this.chart.options;
		merge(true, chartOptions.navigator, this.options, options);
		this.init(this.chart);
	},

	/**
	 * Render the navigator
	 * @param {Number} min X axis value minimum
	 * @param {Number} max X axis value maximum
	 * @param {Number} pxMin Pixel value minimum
	 * @param {Number} pxMax Pixel value maximum
	 */
	render: function (min, max, pxMin, pxMax) {

		var navigator = this,
			chart = navigator.chart,
			navigatorWidth,
			scrollbarLeft,
			scrollbarTop,
			scrollbarHeight = navigator.scrollbarHeight,
			navigatorSize,
			xAxis = navigator.xAxis,
			scrollbarXAxis = xAxis.fake ? chart.xAxis[0] : xAxis,
			navigatorEnabled = navigator.navigatorEnabled,
			zoomedMin,
			zoomedMax,
			rendered = navigator.rendered,
			inverted = chart.inverted,
			verb,
			newMin,
			newMax,
			currentRange,
			minRange = chart.xAxis[0].minRange,
			maxRange = chart.xAxis[0].options.maxRange;

		// Don't redraw while moving the handles (#4703).
		if (this.hasDragged && !defined(pxMin)) {
			return;
		}

		// Don't render the navigator until we have data (#486, #4202, #5172).
		if (!isNumber(min) || !isNumber(max)) {
			// However, if navigator was already rendered, we may need to resize
			// it. For example hidden series, but visible navigator (#6022).
			if (rendered) {
				pxMin = 0;
				pxMax = pick(xAxis.width, scrollbarXAxis.width);
			} else {
				return;
			}
		}

		navigator.left = pick(
			xAxis.left,
			// in case of scrollbar only, without navigator
			chart.plotLeft + scrollbarHeight + (inverted ? chart.plotWidth : 0)
		);

		navigator.size = zoomedMax = navigatorSize = pick(
			xAxis.len,
			(inverted ? chart.plotHeight : chart.plotWidth) -
				2 * scrollbarHeight
		);

		if (inverted) {
			navigatorWidth = scrollbarHeight;
		} else {
			navigatorWidth = navigatorSize + 2 * scrollbarHeight;
		}

		// Get the pixel position of the handles
		pxMin = pick(pxMin, xAxis.toPixels(min, true));
		pxMax = pick(pxMax, xAxis.toPixels(max, true));

		// Verify (#1851, #2238)
		if (!isNumber(pxMin) || Math.abs(pxMin) === Infinity) {
			pxMin = 0;
			pxMax = navigatorWidth;
		}

		// Are we below the minRange? (#2618, #6191)
		newMin = xAxis.toValue(pxMin, true);
		newMax = xAxis.toValue(pxMax, true);
		currentRange = Math.abs(H.correctFloat(newMax - newMin));
		if (currentRange < minRange) {
			if (this.grabbedLeft) {
				pxMin = xAxis.toPixels(newMax - minRange, true);
			} else if (this.grabbedRight) {
				pxMax = xAxis.toPixels(newMin + minRange, true);
			}
		} else if (defined(maxRange) && currentRange > maxRange) {
			/**
			 * Maximum range which can be set using the navigator's handles.
			 * Opposite of [xAxis.minRange](#xAxis.minRange).
			 *
			 * @type {Number}
			 * @default undefined
			 * @product highstock
			 * @sample {highstock} stock/navigator/maxrange/
			 *         Defined max and min range
			 * @since 6.0.0
			 * @apioption xAxis.maxRange
			 */
			if (this.grabbedLeft) {
				pxMin = xAxis.toPixels(newMax - maxRange, true);
			} else if (this.grabbedRight) {
				pxMax = xAxis.toPixels(newMin + maxRange, true);
			}
		}

		// Handles are allowed to cross, but never exceed the plot area
		navigator.zoomedMax = Math.min(Math.max(pxMin, pxMax, 0), zoomedMax);
		navigator.zoomedMin = Math.min(
			Math.max(
				navigator.fixedWidth ?
					navigator.zoomedMax - navigator.fixedWidth :
					Math.min(pxMin, pxMax),
				0
			),
			zoomedMax
		);

		navigator.range = navigator.zoomedMax - navigator.zoomedMin;

		zoomedMax = Math.round(navigator.zoomedMax);
		zoomedMin = Math.round(navigator.zoomedMin);

		if (navigatorEnabled) {
			navigator.navigatorGroup.attr({
				visibility: 'visible'
			});
			// Place elements
			verb = rendered && !navigator.hasDragged ? 'animate' : 'attr';

			navigator.drawMasks(zoomedMin, zoomedMax, inverted, verb);
			navigator.drawOutline(zoomedMin, zoomedMax, inverted, verb);

			if (navigator.navigatorOptions.handles.enabled) {
				navigator.drawHandle(zoomedMin, 0, inverted, verb);
				navigator.drawHandle(zoomedMax, 1, inverted, verb);
			}
		}

		if (navigator.scrollbar) {
			if (inverted) {
				scrollbarTop = navigator.top - scrollbarHeight;
				scrollbarLeft = navigator.left - scrollbarHeight +
					(navigatorEnabled || !scrollbarXAxis.opposite ? 0 :
						// Multiple axes has offsets:
						(scrollbarXAxis.titleOffset || 0) +
						// Self margin from the axis.title
						scrollbarXAxis.axisTitleMargin
					);
				scrollbarHeight = navigatorSize + 2 * scrollbarHeight;
			} else {
				scrollbarTop = navigator.top +
					(navigatorEnabled ? navigator.height : -scrollbarHeight);
				scrollbarLeft = navigator.left - scrollbarHeight;
			}
			// Reposition scrollbar
			navigator.scrollbar.position(
				scrollbarLeft,
				scrollbarTop,
				navigatorWidth,
				scrollbarHeight
			);
			// Keep scale 0-1
			navigator.scrollbar.setRange(
				// Use real value, not rounded because range can be very small
				// (#1716)
				navigator.zoomedMin / navigatorSize,
				navigator.zoomedMax / navigatorSize
			);
		}
		navigator.rendered = true;
	},

	/**
	 * Set up the mouse and touch events for the navigator
	 */
	addMouseEvents: function () {
		var navigator = this,
			chart = navigator.chart,
			container = chart.container,
			eventsToUnbind = [],
			mouseMoveHandler,
			mouseUpHandler;

		/**
		 * Create mouse events' handlers.
		 * Make them as separate functions to enable wrapping them:
		 */
		navigator.mouseMoveHandler = mouseMoveHandler = function (e) {
			navigator.onMouseMove(e);
		};
		navigator.mouseUpHandler = mouseUpHandler = function (e) {
			navigator.onMouseUp(e);
		};

		// Add shades and handles mousedown events
		eventsToUnbind = navigator.getPartsEvents('mousedown');
		// Add mouse move and mouseup events. These are bind to doc/container,
		// because Navigator.grabbedSomething flags are stored in mousedown
		// events
		eventsToUnbind.push(
			addEvent(container, 'mousemove', mouseMoveHandler),
			addEvent(container.ownerDocument, 'mouseup', mouseUpHandler)
		);

		// Touch events
		if (hasTouch) {
			eventsToUnbind.push(
				addEvent(container, 'touchmove', mouseMoveHandler),
				addEvent(container.ownerDocument, 'touchend', mouseUpHandler)
			);
			eventsToUnbind.concat(navigator.getPartsEvents('touchstart'));
		}

		navigator.eventsToUnbind = eventsToUnbind;

		// Data events
		if (navigator.series && navigator.series[0]) {
			eventsToUnbind.push(
				addEvent(
					navigator.series[0].xAxis,
					'foundExtremes',
					function () {
						chart.navigator.modifyNavigatorAxisExtremes();
					}
				)
			);
		}
	},

	/**
	 * Generate events for handles and masks
	 * @param {String} eventName Event name handler, 'mousedown' or 'touchstart'
	 * @returns {Array} An array of arrays: [DOMElement, eventName, callback].
	 */
	getPartsEvents: function (eventName) {
		var navigator = this,
			events = [];
		each(['shades', 'handles'], function (name) {
			each(navigator[name], function (navigatorItem, index) {
				events.push(
					addEvent(
						navigatorItem.element,
						eventName,
						function (e) {
							navigator[name + 'Mousedown'](e, index);
						}
					)
				);
			});
		});
		return events;
	},

	/**
	 * Mousedown on a shaded mask, either:
	 * - will be stored for future drag&drop
	 * - will directly shift to a new range
	 *
	 * @param {Object} e Mouse event
	 * @param {Number} index Index of a mask in Navigator.shades array
	 */
	shadesMousedown: function (e, index) {
		e = this.chart.pointer.normalize(e);

		var navigator = this,
			chart = navigator.chart,
			xAxis = navigator.xAxis,
			zoomedMin = navigator.zoomedMin,
			navigatorPosition = navigator.left,
			navigatorSize = navigator.size,
			range = navigator.range,
			chartX = e.chartX,
			fixedMax,
			ext,
			left;

		// For inverted chart, swap some options:
		if (chart.inverted) {
			chartX = e.chartY;
			navigatorPosition = navigator.top;
		}

		if (index === 1) {
			// Store information for drag&drop
			navigator.grabbedCenter = chartX;
			navigator.fixedWidth = range;
			navigator.dragOffset = chartX - zoomedMin;
		} else {
			// Shift the range by clicking on shaded areas
			left = chartX - navigatorPosition - range / 2;
			if (index === 0) {
				left = Math.max(0, left);
			} else if (index === 2 && left + range >= navigatorSize) {
				left = navigatorSize - range;
				fixedMax = navigator.getUnionExtremes().dataMax; // #2293, #3543
			}
			if (left !== zoomedMin) { // it has actually moved
				navigator.fixedWidth = range; // #1370

				ext = xAxis.toFixedRange(left, left + range, null, fixedMax);
				if (defined(ext.min)) { // #7411
					chart.xAxis[0].setExtremes(
						Math.min(ext.min, ext.max),
						Math.max(ext.min, ext.max),
						true,
						null, // auto animation
						{ trigger: 'navigator' }
					);
				}
			}
		}
	},

	/**
	 * Mousedown on a handle mask.
	 * Will store necessary information for drag&drop.
	 *
	 * @param {Object} e Mouse event
	 * @param {Number} index Index of a handle in Navigator.handles array
	 */
	handlesMousedown: function (e, index) {
		e = this.chart.pointer.normalize(e);

		var navigator = this,
			chart = navigator.chart,
			baseXAxis = chart.xAxis[0],
			// For reversed axes, min and max are chagned,
			// so the other extreme should be stored
			reverse = (chart.inverted && !baseXAxis.reversed) ||
				(!chart.inverted && baseXAxis.reversed);

		if (index === 0) {
			// Grab the left handle
			navigator.grabbedLeft = true;
			navigator.otherHandlePos = navigator.zoomedMax;
			navigator.fixedExtreme = reverse ? baseXAxis.min : baseXAxis.max;
		} else {
			// Grab the right handle
			navigator.grabbedRight = true;
			navigator.otherHandlePos = navigator.zoomedMin;
			navigator.fixedExtreme = reverse ? baseXAxis.max : baseXAxis.min;
		}

		chart.fixedRange = null;
	},
	/**
	 * Mouse move event based on x/y mouse position.
	 * @param {Object} e Mouse event
	 */
	onMouseMove: function (e) {
		var navigator = this,
			chart = navigator.chart,
			left = navigator.left,
			navigatorSize = navigator.navigatorSize,
			range = navigator.range,
			dragOffset = navigator.dragOffset,
			inverted = chart.inverted,
			chartX;


		// In iOS, a mousemove event with e.pageX === 0 is fired when holding
		// the finger down in the center of the scrollbar. This should be
		// ignored.
		if (!e.touches || e.touches[0].pageX !== 0) { // #4696

			e = chart.pointer.normalize(e);
			chartX = e.chartX;

			// Swap some options for inverted chart
			if (inverted) {
				left = navigator.top;
				chartX = e.chartY;
			}

			// Drag left handle or top handle
			if (navigator.grabbedLeft) {
				navigator.hasDragged = true;
				navigator.render(
					0,
					0,
					chartX - left,
					navigator.otherHandlePos
				);
			// Drag right handle or bottom handle
			} else if (navigator.grabbedRight) {
				navigator.hasDragged = true;
				navigator.render(
					0,
					0,
					navigator.otherHandlePos,
					chartX - left
				);
			// Drag scrollbar or open area in navigator
			} else if (navigator.grabbedCenter) {
				navigator.hasDragged = true;
				if (chartX < dragOffset) { // outside left
					chartX = dragOffset;
				// outside right
				} else if (chartX > navigatorSize + dragOffset - range) {
					chartX = navigatorSize + dragOffset - range;
				}

				navigator.render(
					0,
					0,
					chartX - dragOffset,
					chartX - dragOffset + range
				);
			}
			if (
				navigator.hasDragged &&
				navigator.scrollbar &&
				navigator.scrollbar.options.liveRedraw
			) {
				e.DOMType = e.type; // DOMType is for IE8
				setTimeout(function () {
					navigator.onMouseUp(e);
				}, 0);
			}
		}
	},

	/**
	 * Mouse up event based on x/y mouse position.
	 * @param {Object} e Mouse event
	 */
	onMouseUp: function (e) {
		var navigator = this,
			chart = navigator.chart,
			xAxis = navigator.xAxis,
			reversed = xAxis && xAxis.reversed,
			scrollbar = navigator.scrollbar,
			unionExtremes,
			fixedMin,
			fixedMax,
			ext,
			DOMEvent = e.DOMEvent || e;

		if (
			// MouseUp is called for both, navigator and scrollbar (that order),
			// which causes calling afterSetExtremes twice. Prevent first call
			// by checking if scrollbar is going to set new extremes (#6334)
			(navigator.hasDragged && (!scrollbar || !scrollbar.hasDragged)) ||
			e.trigger === 'scrollbar'
		) {
			unionExtremes = navigator.getUnionExtremes();

			// When dragging one handle, make sure the other one doesn't change
			if (navigator.zoomedMin === navigator.otherHandlePos) {
				fixedMin = navigator.fixedExtreme;
			} else if (navigator.zoomedMax === navigator.otherHandlePos) {
				fixedMax = navigator.fixedExtreme;
			}
			// Snap to right edge (#4076)
			if (navigator.zoomedMax === navigator.size) {
				fixedMax = reversed ?
					unionExtremes.dataMin : unionExtremes.dataMax;
			}

			// Snap to left edge (#7576)
			if (navigator.zoomedMin === 0) {
				fixedMin = reversed ?
					unionExtremes.dataMax : unionExtremes.dataMin;
			}

			ext = xAxis.toFixedRange(
				navigator.zoomedMin,
				navigator.zoomedMax,
				fixedMin,
				fixedMax
			);

			if (defined(ext.min)) {
				chart.xAxis[0].setExtremes(
					Math.min(ext.min, ext.max),
					Math.max(ext.min, ext.max),
					true,
					// Run animation when clicking buttons, scrollbar track etc,
					// but not when dragging handles or scrollbar
					navigator.hasDragged ? false : null,
					{
						trigger: 'navigator',
						triggerOp: 'navigator-drag',
						DOMEvent: DOMEvent // #1838
					}
				);
			}
		}

		if (e.DOMType !== 'mousemove') {
			navigator.grabbedLeft = navigator.grabbedRight =
				navigator.grabbedCenter = navigator.fixedWidth =
				navigator.fixedExtreme = navigator.otherHandlePos =
				navigator.hasDragged = navigator.dragOffset = null;
		}
	},

	/**
	 * Removes the event handlers attached previously with addEvents.
	 */
	removeEvents: function () {
		if (this.eventsToUnbind) {
			each(this.eventsToUnbind, function (unbind) {
				unbind();
			});
			this.eventsToUnbind = undefined;
		}
		this.removeBaseSeriesEvents();
	},

	/**
	 * Remove data events.
	 */
	removeBaseSeriesEvents: function () {
		var baseSeries = this.baseSeries || [];
		if (this.navigatorEnabled && baseSeries[0]) {
			if (this.navigatorOptions.adaptToUpdatedData !== false) {
				each(baseSeries, function (series) {
					removeEvent(series, 'updatedData', this.updatedDataHandler);
				}, this);
			}

			// We only listen for extremes-events on the first baseSeries
			if (baseSeries[0].xAxis) {
				removeEvent(
					baseSeries[0].xAxis,
					'foundExtremes',
					this.modifyBaseAxisExtremes
				);
			}
		}
	},

	/**
	 * Initiate the Navigator object
	 */
	init: function (chart) {
		var chartOptions = chart.options,
			navigatorOptions = chartOptions.navigator,
			navigatorEnabled = navigatorOptions.enabled,
			scrollbarOptions = chartOptions.scrollbar,
			scrollbarEnabled = scrollbarOptions.enabled,
			height = navigatorEnabled ? navigatorOptions.height : 0,
			scrollbarHeight = scrollbarEnabled ? scrollbarOptions.height : 0;

		this.handles = [];
		this.shades = [];

		this.chart = chart;
		this.setBaseSeries();

		this.height = height;
		this.scrollbarHeight = scrollbarHeight;
		this.scrollbarEnabled = scrollbarEnabled;
		this.navigatorEnabled = navigatorEnabled;
		this.navigatorOptions = navigatorOptions;
		this.scrollbarOptions = scrollbarOptions;
		this.outlineHeight = height + scrollbarHeight;

		this.opposite = pick(
			navigatorOptions.opposite,
			!navigatorEnabled && chart.inverted
		); // #6262

		var navigator = this,
			baseSeries = navigator.baseSeries,
			xAxisIndex = chart.xAxis.length,
			yAxisIndex = chart.yAxis.length,
			baseXaxis = baseSeries && baseSeries[0] && baseSeries[0].xAxis ||
				chart.xAxis[0];

		// Make room for the navigator, can be placed around the chart:
		chart.extraMargin = {
			type: navigator.opposite ? 'plotTop' : 'marginBottom',
			value: (
				navigatorEnabled || !chart.inverted ?
					navigator.outlineHeight :
					0
			) + navigatorOptions.margin
		};
		if (chart.inverted) {
			chart.extraMargin.type = navigator.opposite ?
				'marginRight' :
				'plotLeft';
		}
		chart.isDirtyBox = true;

		if (navigator.navigatorEnabled) {
			// an x axis is required for scrollbar also
			navigator.xAxis = new Axis(chart, merge({
				// inherit base xAxis' break and ordinal options
				breaks: baseXaxis.options.breaks,
				ordinal: baseXaxis.options.ordinal
			}, navigatorOptions.xAxis, {
				id: 'navigator-x-axis',
				yAxis: 'navigator-y-axis',
				isX: true,
				type: 'datetime',
				index: xAxisIndex,
				offset: 0,
				keepOrdinalPadding: true, // #2436
				startOnTick: false,
				endOnTick: false,
				minPadding: 0,
				maxPadding: 0,
				zoomEnabled: false
			}, chart.inverted ? {
				offsets: [scrollbarHeight, 0, -scrollbarHeight, 0],
				width: height
			} : {
				offsets: [0, -scrollbarHeight, 0, scrollbarHeight],
				height: height
			}));

			navigator.yAxis = new Axis(chart, merge(navigatorOptions.yAxis, {
				id: 'navigator-y-axis',
				alignTicks: false,
				offset: 0,
				index: yAxisIndex,
				zoomEnabled: false
			}, chart.inverted ? {
				width: height
			} : {
				height: height
			}));

			// If we have a base series, initialize the navigator series
			if (baseSeries || navigatorOptions.series.data) {
				navigator.updateNavigatorSeries();

			// If not, set up an event to listen for added series
			} else if (chart.series.length === 0) {

				wrap(chart, 'redraw', function (proceed, animation) {
					// We've got one, now add it as base and reset chart.redraw
					if (chart.series.length > 0 && !navigator.series) {
						navigator.setBaseSeries();
						chart.redraw = proceed; // reset
					}
					proceed.call(chart, animation);
				});
			}

			// Render items, so we can bind events to them:
			navigator.renderElements();
			// Add mouse events
			navigator.addMouseEvents();

		// in case of scrollbar only, fake an x axis to get translation
		} else {
			navigator.xAxis = {
				translate: function (value, reverse) {
					var axis = chart.xAxis[0],
						ext = axis.getExtremes(),
						scrollTrackWidth = axis.len - 2 * scrollbarHeight,
						min = numExt('min', axis.options.min, ext.dataMin),
						valueRange = numExt(
							'max',
							axis.options.max,
							ext.dataMax
						) - min;

					return reverse ?
						// from pixel to value
						(value * valueRange / scrollTrackWidth) + min :
						// from value to pixel
						scrollTrackWidth * (value - min) / valueRange;
				},
				toPixels: function (value) {
					return this.translate(value);
				},
				toValue: function (value) {
					return this.translate(value, true);
				},
				toFixedRange: Axis.prototype.toFixedRange,
				fake: true
			};
		}


		// Initialize the scrollbar
		if (chart.options.scrollbar.enabled) {
			chart.scrollbar = navigator.scrollbar = new Scrollbar(
				chart.renderer,
				merge(chart.options.scrollbar, {
					margin: navigator.navigatorEnabled ? 0 : 10,
					vertical: chart.inverted
				}),
				chart
			);
			addEvent(navigator.scrollbar, 'changed', function (e) {
				var range = navigator.size,
					to = range * this.to,
					from = range * this.from;

				navigator.hasDragged = navigator.scrollbar.hasDragged;
				navigator.render(0, 0, from, to);

				if (
					chart.options.scrollbar.liveRedraw ||
					(
						e.DOMType !== 'mousemove' &&
						e.DOMType !== 'touchmove'
					)
				) {
					setTimeout(function () {
						navigator.onMouseUp(e);
					});
				}
			});
		}

		// Add data events
		navigator.addBaseSeriesEvents();
		// Add redraw events
		navigator.addChartEvents();
	},

	/**
	 * Get the union data extremes of the chart - the outer data extremes of the
	 * base X axis and the navigator axis.
	 * @param {boolean} returnFalseOnNoBaseSeries - as the param says.
	 */
	getUnionExtremes: function (returnFalseOnNoBaseSeries) {
		var baseAxis = this.chart.xAxis[0],
			navAxis = this.xAxis,
			navAxisOptions = navAxis.options,
			baseAxisOptions = baseAxis.options,
			ret;

		if (!returnFalseOnNoBaseSeries || baseAxis.dataMin !== null) {
			ret = {
				dataMin: pick( // #4053
					navAxisOptions && navAxisOptions.min,
					numExt(
						'min',
						baseAxisOptions.min,
						baseAxis.dataMin,
						navAxis.dataMin,
						navAxis.min
					)
				),
				dataMax: pick(
					navAxisOptions && navAxisOptions.max,
					numExt(
						'max',
						baseAxisOptions.max,
						baseAxis.dataMax,
						navAxis.dataMax,
						navAxis.max
					)
				)
			};
		}
		return ret;
	},

	/**
	 * Set the base series and update the navigator series from this. With a bit
	 * of modification we should be able to make this an API method to be called
	 * from the outside
	 * @param  {Object} baseSeriesOptions
	 *         Additional series options for a navigator
	 * @param  {Boolean} [redraw]
	 *         Whether to redraw after update.
	 */
	setBaseSeries: function (baseSeriesOptions, redraw) {
		var chart = this.chart,
			baseSeries = this.baseSeries = [];

		baseSeriesOptions = (
			baseSeriesOptions ||
			chart.options && chart.options.navigator.baseSeries ||
			0
		);

		// Iterate through series and add the ones that should be shown in
		// navigator.
		each(chart.series || [], function (series, i) {
			if (
				// Don't include existing nav series
				!series.options.isInternal &&
				(
					series.options.showInNavigator ||
					(
						i === baseSeriesOptions ||
						series.options.id === baseSeriesOptions
					) &&
					series.options.showInNavigator !== false
				)
			) {
				baseSeries.push(series);
			}
		});

		// When run after render, this.xAxis already exists
		if (this.xAxis && !this.xAxis.fake) {
			this.updateNavigatorSeries(redraw);
		}
	},

	/*
	 * Update series in the navigator from baseSeries, adding new if does not
	 * exist.
	 */
	updateNavigatorSeries: function (redraw) {
		var navigator = this,
			chart = navigator.chart,
			baseSeries = navigator.baseSeries,
			baseOptions,
			mergedNavSeriesOptions,
			chartNavigatorSeriesOptions = navigator.navigatorOptions.series,
			baseNavigatorOptions,
			navSeriesMixin = {
				enableMouseTracking: false,
				index: null, // #6162
				linkedTo: null, // #6734
				group: 'nav', // for columns
				padXAxis: false,
				xAxis: 'navigator-x-axis',
				yAxis: 'navigator-y-axis',
				showInLegend: false,
				stacking: false, // #4823
				isInternal: true,
				visible: true
			},
			// Remove navigator series that are no longer in the baseSeries
			navigatorSeries = navigator.series = H.grep(
				navigator.series || [], function (navSeries) {
					var base = navSeries.baseSeries;
					if (H.inArray(base, baseSeries) < 0) { // Not in array
						// If there is still a base series connected to this
						// series, remove event handler and reference.
						if (base) {
							removeEvent(
								base,
								'updatedData',
								navigator.updatedDataHandler
							);
							delete base.navigatorSeries;
						}
						// Kill the nav series
						navSeries.destroy();
						return false;
					}
					return true;
				}
			);

		// Go through each base series and merge the options to create new
		// series
		if (baseSeries && baseSeries.length) {
			each(baseSeries, function eachBaseSeries(base) {
				var linkedNavSeries = base.navigatorSeries,
					userNavOptions = extend(
						// Grab color from base as default
						{
							color: base.color
						},
						!isArray(chartNavigatorSeriesOptions) ?
							chartNavigatorSeriesOptions :
							defaultOptions.navigator.series
					);

				// Don't update if the series exists in nav and we have disabled
				// adaptToUpdatedData.
				if (
					linkedNavSeries &&
					navigator.navigatorOptions.adaptToUpdatedData === false
				) {
					return;
				}

				navSeriesMixin.name = 'Navigator ' + baseSeries.length;

				baseOptions = base.options || {};
				baseNavigatorOptions = baseOptions.navigatorOptions || {};
				mergedNavSeriesOptions = merge(
					baseOptions,
					navSeriesMixin,
					userNavOptions,
					baseNavigatorOptions
				);

				// Merge data separately. Do a slice to avoid mutating the
				// navigator options from base series (#4923).
				var navigatorSeriesData =
					baseNavigatorOptions.data || userNavOptions.data;
				navigator.hasNavigatorData =
					navigator.hasNavigatorData || !!navigatorSeriesData;
				mergedNavSeriesOptions.data =
					navigatorSeriesData ||
					baseOptions.data && baseOptions.data.slice(0);

				// Update or add the series
				if (linkedNavSeries && linkedNavSeries.options) {
					linkedNavSeries.update(mergedNavSeriesOptions, redraw);
				} else {
					base.navigatorSeries = chart.initSeries(
						mergedNavSeriesOptions
					);
					base.navigatorSeries.baseSeries = base; // Store ref
					navigatorSeries.push(base.navigatorSeries);
				}
			});
		}

		// If user has defined data (and no base series) or explicitly defined
		// navigator.series as an array, we create these series on top of any
		// base series.
		if (
			chartNavigatorSeriesOptions.data &&
			!(baseSeries && baseSeries.length) ||
			isArray(chartNavigatorSeriesOptions)
		) {
			navigator.hasNavigatorData = false;
			// Allow navigator.series to be an array
			chartNavigatorSeriesOptions = H.splat(chartNavigatorSeriesOptions);
			each(chartNavigatorSeriesOptions, function (userSeriesOptions, i) {
				navSeriesMixin.name =
					'Navigator ' + (navigatorSeries.length + 1);
				mergedNavSeriesOptions = merge(
					defaultOptions.navigator.series,
					{
						// Since we don't have a base series to pull color from,
						// try to fake it by using color from series with same
						// index. Otherwise pull from the colors array. We need
						// an explicit color as otherwise updates will increment
						// color counter and we'll get a new color for each
						// update of the nav series.
						color: chart.series[i] &&
							!chart.series[i].options.isInternal &&
							chart.series[i].color ||
							chart.options.colors[i] ||
							chart.options.colors[0]
					},
					navSeriesMixin,
					userSeriesOptions
				);
				mergedNavSeriesOptions.data = userSeriesOptions.data;
				if (mergedNavSeriesOptions.data) {
					navigator.hasNavigatorData = true;
					navigatorSeries.push(
						chart.initSeries(mergedNavSeriesOptions)
					);
				}
			});
		}

		this.addBaseSeriesEvents();
	},

	/**
	 * Add data events.
	 * For example when main series is updated we need to recalculate extremes
	 */
	addBaseSeriesEvents: function () {
		var navigator = this,
			baseSeries = navigator.baseSeries || [];

		// Bind modified extremes event to first base's xAxis only.
		// In event of > 1 base-xAxes, the navigator will ignore those.
		// Adding this multiple times to the same axis is no problem, as
		// duplicates should be discarded by the browser.
		if (baseSeries[0] && baseSeries[0].xAxis) {
			addEvent(
				baseSeries[0].xAxis,
				'foundExtremes',
				this.modifyBaseAxisExtremes
			);
		}

		each(baseSeries, function (base) {
			// Link base series show/hide to navigator series visibility
			addEvent(base, 'show', function () {
				if (this.navigatorSeries) {
					this.navigatorSeries.setVisible(true, false);
				}
			});
			addEvent(base, 'hide', function () {
				if (this.navigatorSeries) {
					this.navigatorSeries.setVisible(false, false);
				}
			});

			// Respond to updated data in the base series, unless explicitily
			// not adapting to data changes.
			if (this.navigatorOptions.adaptToUpdatedData !== false) {
				if (base.xAxis) {
					addEvent(base, 'updatedData', this.updatedDataHandler);
				}
			}

			// Handle series removal
			addEvent(base, 'remove', function () {
				if (this.navigatorSeries) {
					erase(navigator.series, this.navigatorSeries);
					this.navigatorSeries.remove(false);
					delete this.navigatorSeries;
				}
			});
		}, this);
	},

	/**
	 * Set the navigator x axis extremes to reflect the total. The navigator
	 * extremes should always be the extremes of the union of all series in the
	 * chart as well as the navigator series.
	 */
	modifyNavigatorAxisExtremes: function () {
		var xAxis = this.xAxis,
			unionExtremes;

		if (xAxis.getExtremes) {
			unionExtremes = this.getUnionExtremes(true);
			if (
				unionExtremes &&
				(
					unionExtremes.dataMin !== xAxis.min ||
					unionExtremes.dataMax !== xAxis.max
				)
			) {
				xAxis.min = unionExtremes.dataMin;
				xAxis.max = unionExtremes.dataMax;
			}
		}
	},

	/**
	 * Hook to modify the base axis extremes with information from the Navigator
	 */
	modifyBaseAxisExtremes: function () {
		var baseXAxis = this,
			navigator = baseXAxis.chart.navigator,
			baseExtremes = baseXAxis.getExtremes(),
			baseMin = baseExtremes.min,
			baseMax = baseExtremes.max,
			baseDataMin = baseExtremes.dataMin,
			baseDataMax = baseExtremes.dataMax,
			range = baseMax - baseMin,
			stickToMin = navigator.stickToMin,
			stickToMax = navigator.stickToMax,
			overscroll = baseXAxis.options.overscroll,
			newMax,
			newMin,
			navigatorSeries = navigator.series && navigator.series[0],
			hasSetExtremes = !!baseXAxis.setExtremes,

			// When the extremes have been set by range selector button, don't
			// stick to min or max. The range selector buttons will handle the
			// extremes. (#5489)
			unmutable = baseXAxis.eventArgs &&
				baseXAxis.eventArgs.trigger === 'rangeSelectorButton';

		if (!unmutable) {

			// If the zoomed range is already at the min, move it to the right
			// as new data comes in
			if (stickToMin) {
				newMin = baseDataMin;
				newMax = newMin + range;
			}

			// If the zoomed range is already at the max, move it to the right
			// as new data comes in
			if (stickToMax) {
				newMax = baseDataMax + overscroll;

				// if stickToMin is true, the new min value is set above
				if (!stickToMin) {
					newMin = Math.max(
						newMax - range,
						navigatorSeries && navigatorSeries.xData ?
							navigatorSeries.xData[0] : -Number.MAX_VALUE
					);
				}
			}

			// Update the extremes
			if (hasSetExtremes && (stickToMin || stickToMax)) {
				if (isNumber(newMin)) {
					baseXAxis.min = baseXAxis.userMin = newMin;
					baseXAxis.max = baseXAxis.userMax = newMax;
				}
			}
		}

		// Reset
		navigator.stickToMin = navigator.stickToMax = null;
	},

	/**
	 * Handler for updated data on the base series. When data is modified, the
	 * navigator series must reflect it. This is called from the Chart.redraw
	 * function before axis and series extremes are computed.
	 */
	updatedDataHandler: function () {
		var navigator = this.chart.navigator,
			baseSeries = this,
			navigatorSeries = this.navigatorSeries;

		// If the scrollbar is scrolled all the way to the right, keep right as
		// new data  comes in.
		navigator.stickToMax =
			Math.round(navigator.zoomedMax) >= Math.round(navigator.size);

		// Detect whether the zoomed area should stick to the minimum or
		// maximum. If the current axis minimum falls outside the new updated
		// dataset, we must adjust.
		navigator.stickToMin = isNumber(baseSeries.xAxis.min) &&
			(baseSeries.xAxis.min <= baseSeries.xData[0]) &&
			(!this.chart.fixedRange || !navigator.stickToMax);

		// Set the navigator series data to the new data of the base series
		if (navigatorSeries && !navigator.hasNavigatorData) {
			navigatorSeries.options.pointStart = baseSeries.xData[0];
			navigatorSeries.setData(
				baseSeries.options.data,
				false,
				null,
				false
			); // #5414
		}
	},

	/**
	 * Add chart events, like redrawing navigator, when chart requires that.
	 */
	addChartEvents: function () {
		addEvent(this.chart, 'redraw', function () {
			// Move the scrollbar after redraw, like after data updata even if
			// axes don't redraw
			var navigator = this.navigator,
				xAxis = navigator && (
					navigator.baseSeries &&
					navigator.baseSeries[0] &&
					navigator.baseSeries[0].xAxis ||
					navigator.scrollbar && this.xAxis[0]
				); // #5709

			if (xAxis) {
				navigator.render(xAxis.min, xAxis.max);
			}
		});
	},

	/**
	 * Destroys allocated elements.
	 */
	destroy: function () {

		// Disconnect events added in addEvents
		this.removeEvents();

		if (this.xAxis) {
			erase(this.chart.xAxis, this.xAxis);
			erase(this.chart.axes, this.xAxis);
		}
		if (this.yAxis) {
			erase(this.chart.yAxis, this.yAxis);
			erase(this.chart.axes, this.yAxis);
		}
		// Destroy series
		each(this.series || [], function (s) {
			if (s.destroy) {
				s.destroy();
			}
		});

		// Destroy properties
		each([
			'series', 'xAxis', 'yAxis', 'shades', 'outline', 'scrollbarTrack',
			'scrollbarRifles', 'scrollbarGroup', 'scrollbar', 'navigatorGroup',
			'rendered'
		], function (prop) {
			if (this[prop] && this[prop].destroy) {
				this[prop].destroy();
			}
			this[prop] = null;
		}, this);

		// Destroy elements in collection
		each([this.handles], function (coll) {
			destroyObjectProperties(coll);
		}, this);
	}
};

H.Navigator = Navigator;

/**
 * For Stock charts, override selection zooming with some special features
 * because X axis zooming is already allowed by the Navigator and Range
 * selector.
 */
wrap(Axis.prototype, 'zoom', function (proceed, newMin, newMax) {
	var chart = this.chart,
		chartOptions = chart.options,
		zoomType = chartOptions.chart.zoomType,
		previousZoom,
		navigator = chartOptions.navigator,
		rangeSelector = chartOptions.rangeSelector,
		ret;

	if (this.isXAxis && ((navigator && navigator.enabled) ||
			(rangeSelector && rangeSelector.enabled))) {

		// For x only zooming, fool the chart.zoom method not to create the zoom
		// button because the property already exists
		if (zoomType === 'x') {
			chart.resetZoomButton = 'blocked';

		// For y only zooming, ignore the X axis completely
		} else if (zoomType === 'y') {
			ret = false;

		// For xy zooming, record the state of the zoom before zoom selection,
		// then when the reset button is pressed, revert to this state. This
		// should apply only if the chart is initialized with a range (#6612),
		// otherwise zoom all the way out.
		} else if (zoomType === 'xy' && this.options.range) {

			previousZoom = this.previousZoom;
			if (defined(newMin)) {
				this.previousZoom = [this.min, this.max];
			} else if (previousZoom) {
				newMin = previousZoom[0];
				newMax = previousZoom[1];
				delete this.previousZoom;
			}
		}

	}
	return ret !== undefined ? ret : proceed.call(this, newMin, newMax);
});

// Initialize navigator for stock charts
wrap(Chart.prototype, 'init', function (proceed, options, callback) {

	addEvent(this, 'beforeRender', function () {
		var options = this.options;
		if (options.navigator.enabled || options.scrollbar.enabled) {
			this.scroller = this.navigator = new Navigator(this);
		}
	});

	proceed.call(this, options, callback);

});

/**
 * For stock charts, extend the Chart.setChartSize method so that we can set the
 * final top position of the navigator once the height of the chart, including
 * the legend, is determined. #367. We can't use Chart.getMargins, because
 * labels offsets are not calculated yet.
 */
wrap(Chart.prototype, 'setChartSize', function (proceed) {

	var legend = this.legend,
		navigator = this.navigator,
		scrollbarHeight,
		legendOptions,
		xAxis,
		yAxis;

	proceed.apply(this, [].slice.call(arguments, 1));

	if (navigator) {
		legendOptions = legend && legend.options;
		xAxis = navigator.xAxis;
		yAxis = navigator.yAxis;
		scrollbarHeight = navigator.scrollbarHeight;

		// Compute the top position
		if (this.inverted) {
			navigator.left = navigator.opposite ?
				this.chartWidth - scrollbarHeight - navigator.height :
				this.spacing[3] + scrollbarHeight;
			navigator.top = this.plotTop + scrollbarHeight;
		} else {
			navigator.left = this.plotLeft + scrollbarHeight;
			navigator.top = navigator.navigatorOptions.top ||
				this.chartHeight -
				navigator.height -
				scrollbarHeight -
				this.spacing[2] -
				(
					this.rangeSelector && this.extraBottomMargin ?
						this.rangeSelector.getHeight() :
						0
				) -
				(
					(
						legendOptions &&
						legendOptions.verticalAlign === 'bottom' &&
						legendOptions.enabled &&
						!legendOptions.floating
					) ?
						legend.legendHeight + pick(legendOptions.margin, 10) :
						0
				);
		}

		if (xAxis && yAxis) { // false if navigator is disabled (#904)

			if (this.inverted) {
				xAxis.options.left = yAxis.options.left = navigator.left;
			} else {
				xAxis.options.top = yAxis.options.top = navigator.top;
			}

			xAxis.setAxisSize();
			yAxis.setAxisSize();
		}
	}
});

// Pick up badly formatted point options to addPoint
wrap(Series.prototype, 'addPoint', function (
	proceed,
	options,
	redraw,
	shift,
	animation
) {
	var turboThreshold = this.options.turboThreshold;
	if (
		turboThreshold &&
		this.xData.length > turboThreshold &&
		isObject(options, true) &&
		this.chart.navigator
	) {
		error(20, true);
	}
	proceed.call(this, options, redraw, shift, animation);
});

// Handle adding new series
wrap(Chart.prototype, 'addSeries', function (
	proceed,
	options,
	redraw,
	animation
) {
	var series = proceed.call(this, options, false, animation);
	if (this.navigator) {
		// Recompute which series should be shown in navigator, and add them
		this.navigator.setBaseSeries(null, false);
	}
	if (pick(redraw, true)) {
		this.redraw();
	}
	return series;
});

// Handle updating series
wrap(Series.prototype, 'update', function (proceed, newOptions, redraw) {
	proceed.call(this, newOptions, false);
	if (this.chart.navigator && !this.options.isInternal) {
		this.chart.navigator.setBaseSeries(null, false);
	}
	if (pick(redraw, true)) {
		this.chart.redraw();
	}
});

Chart.prototype.callbacks.push(function (chart) {
	var extremes,
		navigator = chart.navigator;

	// Initiate the navigator
	if (navigator) {
		extremes = chart.xAxis[0].getExtremes();
		navigator.render(extremes.min, extremes.max);
	}
});


}(Highcharts));
(function (H) {
/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var addEvent = H.addEvent,
	Axis = H.Axis,
	Chart = H.Chart,
	css = H.css,
	createElement = H.createElement,
	defaultOptions = H.defaultOptions,
	defined = H.defined,
	destroyObjectProperties = H.destroyObjectProperties,
	discardElement = H.discardElement,
	each = H.each,
	extend = H.extend,
	fireEvent = H.fireEvent,
	isNumber = H.isNumber,
	merge = H.merge,
	pick = H.pick,
	pInt = H.pInt,
	splat = H.splat,
	wrap = H.wrap;
		
/* ****************************************************************************
 * Start Range Selector code												  *
 *****************************************************************************/
extend(defaultOptions, {

	/**
	 * The range selector is a tool for selecting ranges to display within
	 * the chart. It provides buttons to select preconfigured ranges in
	 * the chart, like 1 day, 1 week, 1 month etc. It also provides input
	 * boxes where min and max dates can be manually input.
	 *
	 * @product highstock
	 * @optionparent rangeSelector
	 */
	rangeSelector: {
		// allButtonsEnabled: false,
		// enabled: true,
		// buttons: {Object}
		// buttonSpacing: 0,

		/**
		 * The vertical alignment of the rangeselector box. Allowed properties are `top`,
		 * `middle`, `bottom`.
		 *
		 * @since 6.0.0
		 *
		 * @sample {highstock} stock/rangeselector/vertical-align-middle/ Middle
		 *
		 * @sample {highstock} stock/rangeselector/vertical-align-bottom/ Bottom
		 */
		verticalAlign: 'top',

		/**
		 * A collection of attributes for the buttons. The object takes SVG
		 * attributes like `fill`, `stroke`, `stroke-width`, as well as `style`,
		 * a collection of CSS properties for the text.
		 * 
		 * The object can also be extended with states, so you can set presentational
		 * options for `hover`, `select` or `disabled` button states.
		 * 
		 * CSS styles for the text label.
		 * 
		 * In styled mode, the buttons are styled by the `.highcharts-
		 * range-selector-buttons .highcharts-button` rule with its different
		 * states.
		 * 
		 * @type {Object}
		 * @sample {highstock} stock/rangeselector/styling/ Styling the buttons and inputs
		 * @product highstock
		 */
		buttonTheme: {
			'stroke-width': 0,
			width: 28,
			height: 18,
			padding: 2,
			zIndex: 7 // #484, #852
		},
		
		/**
		 * When the rangeselector is floating, the plot area does not reserve 
		 * space for it. This opens for positioning anywhere on the chart.
		 * 
		 * @sample {highstock} stock/rangeselector/floating/
		 *         Placing the range selector between the plot area and the
		 *         navigator
		 * @since 6.0.0
		 * @product highstock
		 */
		floating: false,
		
		/**
		 * The x offset of the range selector relative to its horizontal
		 * alignment within `chart.spacingLeft` and `chart.spacingRight`.
		 * 
		 * @since 6.0.0
		 * @product highstock
		 */
		x: 0,

		/**
		 * The y offset of the range selector relative to its horizontal
		 * alignment within `chart.spacingLeft` and `chart.spacingRight`.
		 * 
		 * @since 6.0.0
		 * @product highstock
		 */
		y: 0,

		/**
		 * Deprecated. The height of the range selector. Currently it is
		 * calculated dynamically.
		 * 
		 * @type {Number}
		 * @default undefined
		 * @since 2.1.9
		 * @product highstock
		 * @deprecated true
		 */
		height: undefined, // reserved space for buttons and input

		/**
		 * Positioning for the input boxes. Allowed properties are `align`,
		 *  `x` and `y`.
		 * 
		 * @type {Object}
		 * @default { align: "right" }
		 * @since 1.2.4
		 * @product highstock
		 */
		inputPosition: {
			/**
			 * The alignment of the input box. Allowed properties are `left`,
			 * `center`, `right`.
 			 * @validvalue ["left", "center", "right"]
 			 * @sample {highstock} stock/rangeselector/input-button-position/ 
 			 *         Alignment
 			 * @since 6.0.0
			 */
			align: 'right',
			x: 0,
			y: 0
		},

		/**
		 * Positioning for the button row.
		 * 
		 * @since 1.2.4
		 * @product highstock
		 */
		buttonPosition: {
			/**
			 * The alignment of the input box. Allowed properties are `left`,
			 * `center`, `right`.
 			 *
 			 * @validvalue ["left", "center", "right"]
 			 * @sample {highstock} stock/rangeselector/input-button-position/ 
 			 *         Alignment
 			 * @since 6.0.0
			 */
			align: 'left',
			/**
			 * X offset of the button row.
			 */
			x: 0,
			/**
			 * Y offset of the button row.
			 */
			y: 0
		},
		// inputDateFormat: '%b %e, %Y',
		// inputEditDateFormat: '%Y-%m-%d',
		// inputEnabled: true,
		// selected: undefined,
		
		// inputStyle: {},

		/**
		 * CSS styles for the labels - the Zoom, From and To texts.
		 * 
		 * In styled mode, the labels are styled by the `.highcharts-range-label` class.
		 * 
		 * @type {CSSObject}
		 * @sample {highstock} stock/rangeselector/styling/ Styling the buttons and inputs
		 * @product highstock
		 */
		labelStyle: {
			color: '#666666'
		}
		
	}
});

defaultOptions.lang = merge(
	defaultOptions.lang, 
	/**
	 * Language object. The language object is global and it can't be set
	 * on each chart initiation. Instead, use `Highcharts.setOptions` to
	 * set it before any chart is initialized.
	 * 
	 * <pre>Highcharts.setOptions({
	 *     lang: {
	 *         months: [
	 *             'Janvier', 'Fvrier', 'Mars', 'Avril',
	 *             'Mai', 'Juin', 'Juillet', 'Aot',
	 *             'Septembre', 'Octobre', 'Novembre', 'Dcembre'
	 *         ],
	 *         weekdays: [
	 *             'Dimanche', 'Lundi', 'Mardi', 'Mercredi',
	 *             'Jeudi', 'Vendredi', 'Samedi'
	 *         ]
	 *     }
	 * });</pre>
	 *
	 * @optionparent lang
	 * @product highstock
	 */
	{

		/**
		 * The text for the label for the range selector buttons.
		 * 
		 * @type {String}
		 * @default Zoom
		 * @product highstock
		 */
		rangeSelectorZoom: 'Zoom',

		/**
		 * The text for the label for the "from" input box in the range
		 * selector.
		 * 
		 * @type {String}
		 * @default From
		 * @product highstock
		 */
		rangeSelectorFrom: 'From',

		/**
		 * The text for the label for the "to" input box in the range selector.
		 * 
		 * @type {String}
		 * @default To
		 * @product highstock
		 */
		rangeSelectorTo: 'To'
	}
);

/**
 * The range selector.
 * @class
 * @param {Object} chart
 */
function RangeSelector(chart) {

	// Run RangeSelector
	this.init(chart);
}

RangeSelector.prototype = {
	/**
	 * The method to run when one of the buttons in the range selectors is clicked
	 * @param {Number} i The index of the button
	 * @param {Object} rangeOptions
	 * @param {Boolean} redraw
	 */
	clickButton: function (i, redraw) {
		var rangeSelector = this,
			chart = rangeSelector.chart,
			rangeOptions = rangeSelector.buttonOptions[i],
			baseAxis = chart.xAxis[0],
			unionExtremes = (chart.scroller && chart.scroller.getUnionExtremes()) || baseAxis || {},
			dataMin = unionExtremes.dataMin,
			dataMax = unionExtremes.dataMax,
			newMin,
			newMax = baseAxis && Math.round(Math.min(baseAxis.max, pick(dataMax, baseAxis.max))), // #1568
			type = rangeOptions.type,
			baseXAxisOptions,
			range = rangeOptions._range,
			rangeMin,
			minSetting,
			rangeSetting,
			ctx,
			ytdExtremes,
			dataGrouping = rangeOptions.dataGrouping;

		if (dataMin === null || dataMax === null) { // chart has no data, base series is removed
			return;
		}

		// Set the fixed range before range is altered
		chart.fixedRange = range;
		
		// Apply dataGrouping associated to button
		if (dataGrouping) {
			this.forcedDataGrouping = true;
			Axis.prototype.setDataGrouping.call(baseAxis || { chart: this.chart }, dataGrouping, false);
		}

		// Apply range
		if (type === 'month' || type === 'year') {
			if (!baseAxis) {
				// This is set to the user options and picked up later when the axis is instantiated
				// so that we know the min and max.
				range = rangeOptions;
			} else {
				ctx = {
					range: rangeOptions,
					max: newMax,
					dataMin: dataMin,
					dataMax: dataMax
				};
				newMin = baseAxis.minFromRange.call(ctx);
				if (isNumber(ctx.newMax)) {
					newMax = ctx.newMax;
				}
			}

		// Fixed times like minutes, hours, days
		} else if (range) {
			newMin = Math.max(newMax - range, dataMin);
			newMax = Math.min(newMin + range, dataMax);
		
		} else if (type === 'ytd') {

			// On user clicks on the buttons, or a delayed action running from the beforeRender
			// event (below), the baseAxis is defined.
			if (baseAxis) {
				// When "ytd" is the pre-selected button for the initial view, its calculation
				// is delayed and rerun in the beforeRender event (below). When the series
				// are initialized, but before the chart is rendered, we have access to the xData
				// array (#942).
				if (dataMax === undefined) {
					dataMin = Number.MAX_VALUE;
					dataMax = Number.MIN_VALUE;
					each(chart.series, function (series) {
						var xData = series.xData; // reassign it to the last item
						dataMin = Math.min(xData[0], dataMin);
						dataMax = Math.max(xData[xData.length - 1], dataMax);
					});
					redraw = false;
				}
				ytdExtremes = rangeSelector.getYTDExtremes(
					dataMax,
					dataMin,
					chart.time.useUTC
				);
				newMin = rangeMin = ytdExtremes.min;
				newMax = ytdExtremes.max;

			// "ytd" is pre-selected. We don't yet have access to processed point and extremes data
			// (things like pointStart and pointInterval are missing), so we delay the process (#942)
			} else {
				addEvent(chart, 'beforeRender', function () {
					rangeSelector.clickButton(i);
				});
				return;
			}
		} else if (type === 'all' && baseAxis) {
			newMin = dataMin;
			newMax = dataMax;
		}

		newMin += rangeOptions._offsetMin;
		newMax += rangeOptions._offsetMax;

		rangeSelector.setSelected(i);

		// Update the chart
		if (!baseAxis) {
			// Axis not yet instanciated. Temporarily set min and range
			// options and remove them on chart load (#4317).
			baseXAxisOptions = splat(chart.options.xAxis)[0];
			rangeSetting = baseXAxisOptions.range;
			baseXAxisOptions.range = range;
			minSetting = baseXAxisOptions.min;
			baseXAxisOptions.min = rangeMin;
			addEvent(chart, 'load', function resetMinAndRange() {
				baseXAxisOptions.range = rangeSetting;
				baseXAxisOptions.min = minSetting;
			});
		} else {
			// Existing axis object. Set extremes after render time.
			baseAxis.setExtremes(
				newMin,
				newMax,
				pick(redraw, 1),
				null, // auto animation
				{
					trigger: 'rangeSelectorButton',
					rangeSelectorButton: rangeOptions
				}
			);
		}
	},

	/**
	 * Set the selected option. This method only sets the internal flag, it
	 * doesn't update the buttons or the actual zoomed range.
	 */
	setSelected: function (selected) {
		this.selected = this.options.selected = selected;
	},

	/**
	 * The default buttons for pre-selecting time frames
	 */
	defaultButtons: [{
		type: 'month',
		count: 1,
		text: '1m'
	}, {
		type: 'month',
		count: 3,
		text: '3m'
	}, {
		type: 'month',
		count: 6,
		text: '6m'
	}, {
		type: 'ytd',
		text: 'YTD'
	}, {
		type: 'year',
		count: 1,
		text: '1y'
	}, {
		type: 'all',
		text: 'All'
	}],

	/**
	 * Initialize the range selector
	 */
	init: function (chart) {
		var rangeSelector = this,
			options = chart.options.rangeSelector,
			buttonOptions = options.buttons ||
				[].concat(rangeSelector.defaultButtons),
			selectedOption = options.selected,
			blurInputs = function () {
				var minInput = rangeSelector.minInput,
					maxInput = rangeSelector.maxInput;

				// #3274 in some case blur is not defined
				if (minInput && minInput.blur) {
					fireEvent(minInput, 'blur');
				}
				if (maxInput && maxInput.blur) {
					fireEvent(maxInput, 'blur');
				}
			};

		rangeSelector.chart = chart;
		rangeSelector.options = options;
		rangeSelector.buttons = [];

		chart.extraTopMargin = options.height;
		rangeSelector.buttonOptions = buttonOptions;

		this.unMouseDown = addEvent(chart.container, 'mousedown', blurInputs);
		this.unResize = addEvent(chart, 'resize', blurInputs);

		// Extend the buttonOptions with actual range
		each(buttonOptions, rangeSelector.computeButtonRange);

		// zoomed range based on a pre-selected button index
		if (selectedOption !== undefined && buttonOptions[selectedOption]) {
			this.clickButton(selectedOption, false);
		}


		addEvent(chart, 'load', function () {
			// If a data grouping is applied to the current button, release it
			// when extremes change
			if (chart.xAxis && chart.xAxis[0]) {
				addEvent(chart.xAxis[0], 'setExtremes', function (e) {
					if (
						this.max - this.min !== chart.fixedRange &&
						e.trigger !== 'rangeSelectorButton' &&
						e.trigger !== 'updatedData' &&
						rangeSelector.forcedDataGrouping
					) {
						this.setDataGrouping(false, false);
					}
				});
			}
		});
	},

	/**
	 * Dynamically update the range selector buttons after a new range has been
	 * set
	 */
	updateButtonStates: function () {
		var rangeSelector = this,
			chart = this.chart,
			baseAxis = chart.xAxis[0],
			actualRange = Math.round(baseAxis.max - baseAxis.min),
			hasNoData = !baseAxis.hasVisibleSeries,
			day = 24 * 36e5, // A single day in milliseconds
			unionExtremes = (
				chart.scroller &&
				chart.scroller.getUnionExtremes()
			) || baseAxis,
			dataMin = unionExtremes.dataMin,
			dataMax = unionExtremes.dataMax,
			ytdExtremes = rangeSelector.getYTDExtremes(
				dataMax,
				dataMin,
				chart.time.useUTC
			),
			ytdMin = ytdExtremes.min,
			ytdMax = ytdExtremes.max,
			selected = rangeSelector.selected,
			selectedExists = isNumber(selected),
			allButtonsEnabled = rangeSelector.options.allButtonsEnabled,
			buttons = rangeSelector.buttons;

		each(rangeSelector.buttonOptions, function (rangeOptions, i) {
			var range = rangeOptions._range,
				type = rangeOptions.type,
				count = rangeOptions.count || 1,
				button = buttons[i],
				state = 0,
				disable,
				select,
				offsetRange = rangeOptions._offsetMax - rangeOptions._offsetMin,
				isSelected = i === selected,
				// Disable buttons where the range exceeds what is allowed in
				// the current view
				isTooGreatRange = range > dataMax - dataMin,
				// Disable buttons where the range is smaller than the minimum
				// range
				isTooSmallRange = range < baseAxis.minRange,
				// Do not select the YTD button if not explicitly told so
				isYTDButNotSelected = false,
				// Disable the All button if we're already showing all
				isAllButAlreadyShowingAll = false,
				isSameRange = range === actualRange;
			// Months and years have a variable range so we check the extremes
			if (
				(type === 'month' || type === 'year') &&
				(
					actualRange + 36e5 >=
					{ month: 28, year: 365 }[type] * day * count - offsetRange
				) &&
				(
					actualRange - 36e5 <=
					{ month: 31, year: 366 }[type] * day * count + offsetRange
				)
			) {
				isSameRange = true;
			} else if (type === 'ytd') {
				isSameRange = (ytdMax - ytdMin + offsetRange) === actualRange;
				isYTDButNotSelected = !isSelected;
			} else if (type === 'all') {
				isSameRange = baseAxis.max - baseAxis.min >= dataMax - dataMin;
				isAllButAlreadyShowingAll = (
					!isSelected &&
					selectedExists &&
					isSameRange
				);
			}

			// The new zoom area happens to match the range for a button - mark
			// it selected. This happens when scrolling across an ordinal gap.
			// It can be seen in the intraday demos when selecting 1h and scroll
			// across the night gap.
			disable = (
				!allButtonsEnabled &&
				(
					isTooGreatRange ||
					isTooSmallRange ||
					isAllButAlreadyShowingAll ||
					hasNoData
				)
			);
			select = (
				(isSelected && isSameRange) ||
				(isSameRange && !selectedExists && !isYTDButNotSelected)
			);

			if (disable) {
				state = 3;
			} else if (select) {
				selectedExists = true; // Only one button can be selected
				state = 2;
			}

			// If state has changed, update the button
			if (button.state !== state) {
				button.setState(state);
			}
		});
	},

	/**
	 * Compute and cache the range for an individual button
	 */
	computeButtonRange: function (rangeOptions) {
		var type = rangeOptions.type,
			count = rangeOptions.count || 1,

			// these time intervals have a fixed number of milliseconds, as
			// opposed to month, ytd and year
			fixedTimes = {
				millisecond: 1,
				second: 1000,
				minute: 60 * 1000,
				hour: 3600 * 1000,
				day: 24 * 3600 * 1000,
				week: 7 * 24 * 3600 * 1000
			};

		// Store the range on the button object
		if (fixedTimes[type]) {
			rangeOptions._range = fixedTimes[type] * count;
		} else if (type === 'month' || type === 'year') {
			rangeOptions._range =
				{ month: 30, year: 365 }[type] * 24 * 36e5 * count;
		}

		rangeOptions._offsetMin = pick(rangeOptions.offsetMin, 0);
		rangeOptions._offsetMax = pick(rangeOptions.offsetMax, 0);
		rangeOptions._range +=
			rangeOptions._offsetMax - rangeOptions._offsetMin;
	},

	/**
	 * Set the internal and displayed value of a HTML input for the dates
	 * @param {String} name
	 * @param {Number} inputTime
	 */
	setInputValue: function (name, inputTime) {
		var options = this.chart.options.rangeSelector,
			time = this.chart.time,
			input = this[name + 'Input'];

		if (defined(inputTime)) {
			input.previousValue = input.HCTime;
			input.HCTime = inputTime;
		}

		input.value = time.dateFormat(
			options.inputEditDateFormat || '%Y-%m-%d',
			input.HCTime
		);
		this[name + 'DateBox'].attr({
			text: time.dateFormat(
				options.inputDateFormat || '%b %e, %Y',
				input.HCTime
			)
		});
	},

	showInput: function (name) {
		var inputGroup = this.inputGroup,
			dateBox = this[name + 'DateBox'];

		css(this[name + 'Input'], {
			left: (inputGroup.translateX + dateBox.x) + 'px',
			top: inputGroup.translateY + 'px',
			width: (dateBox.width - 2) + 'px',
			height: (dateBox.height - 2) + 'px',
			border: '2px solid silver'
		});
	},

	hideInput: function (name) {
		css(this[name + 'Input'], {
			border: 0,
			width: '1px',
			height: '1px'
		});
		this.setInputValue(name);
	},

	/**
	 * Draw either the 'from' or the 'to' HTML input box of the range selector
	 * @param {Object} name
	 */
	drawInput: function (name) {
		var rangeSelector = this,
			chart = rangeSelector.chart,
			chartStyle = chart.renderer.style || {},
			renderer = chart.renderer,
			options = chart.options.rangeSelector,
			lang = defaultOptions.lang,
			div = rangeSelector.div,
			isMin = name === 'min',
			input,
			label,
			dateBox,
			inputGroup = this.inputGroup;

		function updateExtremes() {
			var inputValue = input.value,
				value = (options.inputDateParser || Date.parse)(inputValue),
				chartAxis = chart.xAxis[0],
				dataAxis = chart.scroller && chart.scroller.xAxis ? chart.scroller.xAxis : chartAxis,
				dataMin = dataAxis.dataMin,
				dataMax = dataAxis.dataMax;
			if (value !== input.previousValue) {
				input.previousValue = value;
				// If the value isn't parsed directly to a value by the browser's Date.parse method,
				// like YYYY-MM-DD in IE, try parsing it a different way
				if (!isNumber(value)) {
					value = inputValue.split('-');
					value = Date.UTC(pInt(value[0]), pInt(value[1]) - 1, pInt(value[2]));
				}

				if (isNumber(value)) {

					// Correct for timezone offset (#433)
					if (!chart.time.useUTC) {
						value = value + new Date().getTimezoneOffset() * 60 * 1000;
					}

					// Validate the extremes. If it goes beyound the data min or max, use the
					// actual data extreme (#2438).
					if (isMin) {
						if (value > rangeSelector.maxInput.HCTime) {
							value = undefined;
						} else if (value < dataMin) {
							value = dataMin;
						}
					} else {
						if (value < rangeSelector.minInput.HCTime) {
							value = undefined;
						} else if (value > dataMax) {
							value = dataMax;
						}
					}

					// Set the extremes
					if (value !== undefined) {
						chartAxis.setExtremes(
							isMin ? value : chartAxis.min,
							isMin ? chartAxis.max : value,
							undefined,
							undefined,
							{ trigger: 'rangeSelectorInput' }
						);
					}
				}
			}
		}

		// Create the text label
		this[name + 'Label'] = label = renderer.label(lang[isMin ? 'rangeSelectorFrom' : 'rangeSelectorTo'], this.inputGroup.offset)
			.addClass('highcharts-range-label')
			.attr({
				padding: 2
			})
			.add(inputGroup);
		inputGroup.offset += label.width + 5;

		// Create an SVG label that shows updated date ranges and and records click events that
		// bring in the HTML input.
		this[name + 'DateBox'] = dateBox = renderer.label('', inputGroup.offset)
			.addClass('highcharts-range-input')
			.attr({
				padding: 2,
				width: options.inputBoxWidth || 90,
				height: options.inputBoxHeight || 17,
				stroke: options.inputBoxBorderColor || '#cccccc',
				'stroke-width': 1,
				'text-align': 'center'
			})
			.on('click', function () {
				rangeSelector.showInput(name); // If it is already focused, the onfocus event doesn't fire (#3713)
				rangeSelector[name + 'Input'].focus();
			})
			.add(inputGroup);
		inputGroup.offset += dateBox.width + (isMin ? 10 : 0);


		// Create the HTML input element. This is rendered as 1x1 pixel then set to the right size
		// when focused.
		this[name + 'Input'] = input = createElement('input', {
			name: name,
			className: 'highcharts-range-selector',
			type: 'text'
		}, {
			top: chart.plotTop + 'px' // prevent jump on focus in Firefox
		}, div);

		
		// Styles
		label.css(merge(chartStyle, options.labelStyle));

		dateBox.css(merge({
			color: '#333333'
		}, chartStyle, options.inputStyle));

		css(input, extend({
			position: 'absolute',
			border: 0,
			width: '1px', // Chrome needs a pixel to see it
			height: '1px',
			padding: 0,
			textAlign: 'center',
			fontSize: chartStyle.fontSize,
			fontFamily: chartStyle.fontFamily,
			top: '-9999em' // #4798
		}, options.inputStyle));
		

		// Blow up the input box
		input.onfocus = function () {
			rangeSelector.showInput(name);
		};
		// Hide away the input box
		input.onblur = function () {
			rangeSelector.hideInput(name);
		};

		// handle changes in the input boxes
		input.onchange = updateExtremes;

		input.onkeypress = function (event) {
			// IE does not fire onchange on enter
			if (event.keyCode === 13) {
				updateExtremes();
			}
		};
	},

	/**
	 * Get the position of the range selector buttons and inputs. This can be overridden from outside for custom positioning.
	 */
	getPosition: function () {
		var chart = this.chart,
			options = chart.options.rangeSelector,
			top = (options.verticalAlign) === 'top' ? chart.plotTop - chart.axisOffset[0] : 0; // set offset only for varticalAlign top

		return {
			buttonTop: top + options.buttonPosition.y,
			inputTop: top + options.inputPosition.y - 10
		};
	},
	/**
	 * Get the extremes of YTD. 
	 * Will choose dataMax if its value is lower than the current timestamp.
	 * Will choose dataMin if its value is higher than the timestamp for
	 * 	the start of current year.
	 * @param  {number} dataMax
	 * @param  {number} dataMin
	 * @return {object} Returns min and max for the YTD
	 */
	getYTDExtremes: function (dataMax, dataMin, useUTC) {
		var time = this.chart.time,
			min,
			now = new time.Date(dataMax),
			year = now[time.getFullYear](),
			startOfYear = useUTC ? time.Date.UTC(year, 0, 1) : +new time.Date(year, 0, 1); // eslint-disable-line new-cap
		min = Math.max(dataMin || 0, startOfYear);
		now = now.getTime();
		return {
			max: Math.min(dataMax || now, now),
			min: min
		};
	},

	/**
	 * Render the range selector including the buttons and the inputs. The first time render
	 * is called, the elements are created and positioned. On subsequent calls, they are
	 * moved and updated.
	 * @param {Number} min X axis minimum
	 * @param {Number} max X axis maximum
	 */
	render: function (min, max) {

		var rangeSelector = this,
			chart = rangeSelector.chart,
			renderer = chart.renderer,
			container = chart.container,
			chartOptions = chart.options,
			navButtonOptions = chartOptions.exporting && chartOptions.exporting.enabled !== false &&
				chartOptions.navigation && chartOptions.navigation.buttonOptions,
			lang = defaultOptions.lang,
			div = rangeSelector.div,
			options = chartOptions.rangeSelector,
			floating = options.floating,
			buttons = rangeSelector.buttons,
			inputGroup = rangeSelector.inputGroup,
			buttonTheme = options.buttonTheme,
			buttonPosition = options.buttonPosition,
			inputPosition = options.inputPosition,
			inputEnabled = options.inputEnabled,
			states = buttonTheme && buttonTheme.states,
			plotLeft = chart.plotLeft,
			buttonLeft,
			buttonGroup = rangeSelector.buttonGroup,
			group,
			groupHeight,
			rendered = rangeSelector.rendered,
			verticalAlign = rangeSelector.options.verticalAlign,
			legend = chart.legend,
			legendOptions = legend && legend.options,
			buttonPositionY = buttonPosition.y,
			inputPositionY = inputPosition.y,
			animate = rendered || false,
			exportingX = 0,
			alignTranslateY,
			legendHeight,
			minPosition,
			translateY = 0,
			translateX;

		if (options.enabled === false) {
			return;
		}

		// create the elements
		if (!rendered) {

			rangeSelector.group = group = renderer.g('range-selector-group')
				.attr({
					zIndex: 7
				})
				.add();
			
			rangeSelector.buttonGroup = buttonGroup = renderer.g('range-selector-buttons').add(group);

			rangeSelector.zoomText = renderer.text(lang.rangeSelectorZoom, pick(plotLeft + buttonPosition.x, plotLeft), 15)
				.css(options.labelStyle)
				.add(buttonGroup);

			// button start position
			buttonLeft = pick(plotLeft + buttonPosition.x, plotLeft) + rangeSelector.zoomText.getBBox().width + 5;

			each(rangeSelector.buttonOptions, function (rangeOptions, i) {

				buttons[i] = renderer.button(
						rangeOptions.text,
						buttonLeft,
						0,
						function () {

							// extract events from button object and call
							var buttonEvents = rangeOptions.events && rangeOptions.events.click,
								callDefaultEvent;

							if (buttonEvents) {
								callDefaultEvent = buttonEvents.call(rangeOptions);
							}
							
							if (callDefaultEvent !== false) {
								rangeSelector.clickButton(i);
							}
							
							rangeSelector.isActive = true;
						},
						buttonTheme,
						states && states.hover,
						states && states.select,
						states && states.disabled
					)
					.attr({
						'text-align': 'center'
					})
					.add(buttonGroup);

				// increase button position for the next button
				buttonLeft += buttons[i].width + pick(options.buttonSpacing, 5);
			});

			// first create a wrapper outside the container in order to make
			// the inputs work and make export correct
			if (inputEnabled !== false) {
				rangeSelector.div = div = createElement('div', null, {
					position: 'relative',
					height: 0,
					zIndex: 1 // above container
				});

				container.parentNode.insertBefore(div, container);

				// Create the group to keep the inputs
				rangeSelector.inputGroup = inputGroup = renderer.g('input-group')
					.add(group);
				inputGroup.offset = 0;

				rangeSelector.drawInput('min');
				rangeSelector.drawInput('max');
			}
		}

		plotLeft = chart.plotLeft - chart.spacing[3];
		rangeSelector.updateButtonStates();

		// detect collisiton with exporting
		if 
			(
				navButtonOptions && 
				this.titleCollision(chart) &&
				verticalAlign === 'top' && 
				buttonPosition.align === 'right' && 
				(
					(buttonPosition.y + buttonGroup.getBBox().height - 12) < 
					((navButtonOptions.y || 0) + navButtonOptions.height)
				)
			) {
			exportingX = -40; 
		}

		if (buttonPosition.align === 'left') {
			translateX = buttonPosition.x - chart.spacing[3];
		} else if (buttonPosition.align === 'right') {
			translateX = buttonPosition.x + exportingX - chart.spacing[1];
		} 

		// align button group
		buttonGroup.align({
			y: buttonPosition.y,
			width: buttonGroup.getBBox().width,
			align: buttonPosition.align,
			x: translateX
		}, true, chart.spacingBox);

		// skip animation
		rangeSelector.group.placed = animate;
		rangeSelector.buttonGroup.placed = animate;

		if (inputEnabled !== false) {

			var inputGroupX,
				inputGroupWidth,
				buttonGroupX,
				buttonGroupWidth;

			// detect collision with exporting
			if 
				(
					navButtonOptions && 
					this.titleCollision(chart) &&
					verticalAlign === 'top' && 
					inputPosition.align === 'right' && 
					(
						(inputPosition.y - inputGroup.getBBox().height - 12) < 
						((navButtonOptions.y || 0) + navButtonOptions.height + chart.spacing[0])
					)
				) {
				exportingX = -40; 
			} else {
				exportingX = 0;
			}

			if (inputPosition.align === 'left') {
				translateX = plotLeft;
			} else if (inputPosition.align === 'right') { 
				translateX = -Math.max(chart.axisOffset[1], -exportingX); // yAxis offset
			}

			// Update the alignment to the updated spacing box
			inputGroup.align({
				y: inputPosition.y,
				width: inputGroup.getBBox().width,
				align: inputPosition.align,
				x: inputPosition.x + translateX - 2 // fix wrong getBBox() value on right align 
			}, true, chart.spacingBox);

			// detect collision
			inputGroupX = inputGroup.alignAttr.translateX + inputGroup.alignOptions.x - 
							exportingX + inputGroup.getBBox().x + 2; // getBBox for detecing left margin, 2px padding to not overlap input and label

			inputGroupWidth = inputGroup.alignOptions.width;

			buttonGroupX = buttonGroup.alignAttr.translateX + buttonGroup.getBBox().x;
			buttonGroupWidth = buttonGroup.getBBox().width + 20; // 20 is minimal spacing between elements

			if (
					(inputPosition.align === buttonPosition.align) || 
					(
						(buttonGroupX + buttonGroupWidth > inputGroupX) && 
						(inputGroupX + inputGroupWidth > buttonGroupX) && 
						(buttonPositionY < (inputPositionY + inputGroup.getBBox().height))
					)
				)  {
				
				inputGroup.attr({
					translateX: inputGroup.alignAttr.translateX + (chart.axisOffset[1] >= -exportingX ? 0 : -exportingX),
					translateY: inputGroup.alignAttr.translateY + buttonGroup.getBBox().height + 10
				});

			} 

			// Set or reset the input values
			rangeSelector.setInputValue('min', min);
			rangeSelector.setInputValue('max', max);

			// skip animation
			rangeSelector.inputGroup.placed = animate;
		}

		// vertical align
		rangeSelector.group.align({
			verticalAlign: verticalAlign
		}, true, chart.spacingBox);

		// set position 
		groupHeight = rangeSelector.group.getBBox().height + 20; // # 20 padding
		alignTranslateY = rangeSelector.group.alignAttr.translateY;

		// calculate bottom position 
		if (verticalAlign === 'bottom') {
			legendHeight = legendOptions && legendOptions.verticalAlign === 'bottom' && legendOptions.enabled && 
							!legendOptions.floating ? legend.legendHeight + pick(legendOptions.margin, 10) : 0;

			groupHeight = groupHeight + legendHeight - 20;
			translateY = alignTranslateY - groupHeight - (floating ? 0 : options.y) - 10; // 10 spacing

		} 

		if (verticalAlign === 'top') {
			if (floating) {
				translateY = 0;
			} 

			if (chart.titleOffset) {
				translateY = chart.titleOffset + chart.options.title.margin;
			}

			translateY += ((chart.margin[0] - chart.spacing[0]) || 0);

		} else if (verticalAlign === 'middle') {
			if (inputPositionY === buttonPositionY) {
				if (inputPositionY < 0) {
					translateY = alignTranslateY + minPosition;
				} else {
					translateY = alignTranslateY;
				}
			} else if (inputPositionY || buttonPositionY) {
				if (inputPositionY < 0 || buttonPositionY < 0) {
					translateY -= Math.min(inputPositionY, buttonPositionY);
				} else {
					translateY = alignTranslateY - groupHeight + minPosition;
				}
			}
		}

		rangeSelector.group.translate(
			options.x,
			options.y + Math.floor(translateY)
		); 

		// translate HTML inputs
		if (inputEnabled !== false) {
			rangeSelector.minInput.style.marginTop = rangeSelector.group.translateY + 'px';
			rangeSelector.maxInput.style.marginTop = rangeSelector.group.translateY + 'px';
		}

		rangeSelector.rendered = true;
	},

	/** 
	 * Extracts height of range selector 
	 * @return {Number} Returns rangeSelector height
	 */
	getHeight: function () {
		var rangeSelector = this,
			options = rangeSelector.options,
			rangeSelectorGroup = rangeSelector.group,
			inputPosition = options.inputPosition,
			buttonPosition = options.buttonPosition,
			yPosition = options.y,
			buttonPositionY = buttonPosition.y,
			inputPositionY = inputPosition.y,
			rangeSelectorHeight = 0,
			minPosition;

		rangeSelectorHeight = rangeSelectorGroup ? (rangeSelectorGroup.getBBox(true).height) + 13 + yPosition : 0; // 13px to keep back compatibility

		minPosition = Math.min(inputPositionY, buttonPositionY);

		if (
			(inputPositionY < 0 && buttonPositionY < 0) || 
			(inputPositionY > 0 && buttonPositionY > 0)
		) {
			rangeSelectorHeight += Math.abs(minPosition);
		}

		return rangeSelectorHeight;
	},

	/**
	 * Detect collision with title or subtitle
	 * @param {object} chart
	 * @return {Boolean} Returns collision status
	 */
	titleCollision: function (chart) {
		return !(chart.options.title.text || chart.options.subtitle.text);
	},

	/**
	 * Update the range selector with new options
	 * @param {object} options
	 */
	update: function (options) {
		var chart = this.chart;

		merge(true, chart.options.rangeSelector, options);
		this.destroy();
		this.init(chart);
		chart.rangeSelector.render();
	},

	/**
	 * Destroys allocated elements.
	 */
	destroy: function () {
		var rSelector = this,
			minInput = rSelector.minInput,
			maxInput = rSelector.maxInput;

		rSelector.unMouseDown();
		rSelector.unResize();

		// Destroy elements in collections
		destroyObjectProperties(rSelector.buttons);

		// Clear input element events
		if (minInput) {
			minInput.onfocus = minInput.onblur = minInput.onchange = null;
		}
		if (maxInput) {
			maxInput.onfocus = maxInput.onblur = maxInput.onchange = null;
		}

		// Destroy HTML and SVG elements
		H.objectEach(rSelector, function (val, key) {
			if (val && key !== 'chart') {
				if (val.destroy) { // SVGElement
					val.destroy();
				} else if (val.nodeType) { // HTML element
					discardElement(this[key]);
				}
			}
			if (val !== RangeSelector.prototype[key]) {
				rSelector[key] = null;
			}
		}, this);
	}
};

/**
 * Add logic to normalize the zoomed range in order to preserve the pressed state of range selector buttons
 */
Axis.prototype.toFixedRange = function (pxMin, pxMax, fixedMin, fixedMax) {
	var fixedRange = this.chart && this.chart.fixedRange,
		newMin = pick(fixedMin, this.translate(pxMin, true, !this.horiz)),
		newMax = pick(fixedMax, this.translate(pxMax, true, !this.horiz)),
		changeRatio = fixedRange && (newMax - newMin) / fixedRange;

	// If the difference between the fixed range and the actual requested range is
	// too great, the user is dragging across an ordinal gap, and we need to release
	// the range selector button.
	if (changeRatio > 0.7 && changeRatio < 1.3) {
		if (fixedMax) {
			newMin = newMax - fixedRange;
		} else {
			newMax = newMin + fixedRange;
		}
	}
	if (!isNumber(newMin) || !isNumber(newMax)) { // #1195, #7411
		newMin = newMax = undefined;
	}

	return {
		min: newMin,
		max: newMax
	};
};

/**
 * Get the axis min value based on the range option and the current max. For
 * stock charts this is extended via the {@link RangeSelector} so that if the
 * selected range is a multiple of months or years, it is compensated for
 * various month lengths.
 * 
 * @return {number} The new minimum value.
 */
Axis.prototype.minFromRange = function () {
	var rangeOptions = this.range,
		type = rangeOptions.type,
		timeName = { month: 'Month', year: 'FullYear' }[type],
		min,
		max = this.max,
		dataMin,
		range,
		// Get the true range from a start date
		getTrueRange = function (base, count) {
			var date = new Date(base),
				basePeriod = date['get' + timeName]();

			date['set' + timeName](basePeriod + count);

			if (basePeriod === date['get' + timeName]()) {
				date.setDate(0); // #6537
			}

			return date.getTime() - base;
		};

	if (isNumber(rangeOptions)) {
		min = max - rangeOptions;
		range = rangeOptions;
	} else {
		min = max + getTrueRange(max, -rangeOptions.count);

		// Let the fixedRange reflect initial settings (#5930)
		if (this.chart) {
			this.chart.fixedRange = max - min;
		}
	}

	dataMin = pick(this.dataMin, Number.MIN_VALUE);
	if (!isNumber(min)) {
		min = dataMin;
	}
	if (min <= dataMin) {
		min = dataMin;
		if (range === undefined) { // #4501
			range = getTrueRange(min, rangeOptions.count);
		}
		this.newMax = Math.min(min + range, this.dataMax);
	}
	if (!isNumber(max)) {
		min = undefined;
	}
	return min;

};

// Initialize rangeselector for stock charts
wrap(Chart.prototype, 'init', function (proceed, options, callback) {

	addEvent(this, 'init', function () {
		if (this.options.rangeSelector.enabled) {
			this.rangeSelector = new RangeSelector(this);
		}
	});

	proceed.call(this, options, callback);

});

wrap(Chart.prototype, 'render', function (proceed, options, callback) {

	var chart = this,
		axes = chart.axes,
		rangeSelector = chart.rangeSelector,
		verticalAlign;

	if (rangeSelector) {

		each(axes, function (axis) {
			axis.updateNames();
			axis.setScale();
		});

		chart.getAxisMargins();

		rangeSelector.render();
		verticalAlign = rangeSelector.options.verticalAlign;

		if (!rangeSelector.options.floating) {
			if (verticalAlign === 'bottom') {
				this.extraBottomMargin = true;
			} else if (verticalAlign !== 'middle') {
				this.extraTopMargin = true;
			}
		}
	}

	proceed.call(this, options, callback);

});

wrap(Chart.prototype, 'update', function (proceed, options, redraw, oneToOne) {

	var chart = this,
		rangeSelector = chart.rangeSelector,
		verticalAlign;

	this.extraBottomMargin = false;
	this.extraTopMargin = false;

	if (rangeSelector) {

		rangeSelector.render();

		verticalAlign = (options.rangeSelector && options.rangeSelector.verticalAlign) || 
						(rangeSelector.options && rangeSelector.options.verticalAlign);

		if (!rangeSelector.options.floating) {
			if (verticalAlign === 'bottom') {
				this.extraBottomMargin = true;
			} else if (verticalAlign !== 'middle') {
				this.extraTopMargin = true;
			}
		}
	}

	proceed.call(this, H.merge(true, options, {
		chart: {
			marginBottom: pick(options.chart && options.chart.marginBottom, chart.margin.bottom),
			spacingBottom: pick(options.chart && options.chart.spacingBottom, chart.spacing.bottom)
		}
	}), redraw, oneToOne);

});

wrap(Chart.prototype, 'redraw', function (proceed, options, callback) {
	var chart = this,
		rangeSelector = chart.rangeSelector,
		verticalAlign;

	if (rangeSelector && !rangeSelector.options.floating) {

		rangeSelector.render();
		verticalAlign = rangeSelector.options.verticalAlign;

		if (verticalAlign === 'bottom') {
			this.extraBottomMargin = true;
		} else if (verticalAlign !== 'middle') {
			this.extraTopMargin = true;
		}
	}

	proceed.call(this, options, callback);
});

Chart.prototype.adjustPlotArea = function () {
	var chart = this,
		rangeSelector = chart.rangeSelector,
		rangeSelectorHeight;

	if (this.rangeSelector) {

		rangeSelectorHeight = rangeSelector.getHeight();
			
		if (this.extraTopMargin) {
			this.plotTop += rangeSelectorHeight;
		}

		if (this.extraBottomMargin) {
			this.marginBottom += rangeSelectorHeight;
		}
	}
};

Chart.prototype.callbacks.push(function (chart) {
	var extremes,
		rangeSelector = chart.rangeSelector,
		unbindRender,
		unbindSetExtremes;

	function renderRangeSelector() {
		extremes = chart.xAxis[0].getExtremes();
		if (isNumber(extremes.min)) {
			rangeSelector.render(extremes.min, extremes.max);
		}
	}

	if (rangeSelector) {
		// redraw the scroller on setExtremes
		unbindSetExtremes = addEvent(
			chart.xAxis[0],
			'afterSetExtremes',
			function (e) {
				rangeSelector.render(e.min, e.max);
			}
		);

		// redraw the scroller chart resize
		unbindRender = addEvent(chart, 'redraw', renderRangeSelector);

		// do it now
		renderRangeSelector();
	}

	// Remove resize/afterSetExtremes at chart destroy
	addEvent(chart, 'destroy', function destroyEvents() {
		if (rangeSelector) {
			unbindRender();
			unbindSetExtremes();
		}
	});
});


H.RangeSelector = RangeSelector;

/* ****************************************************************************
 * End Range Selector code													 *
 *****************************************************************************/

}(Highcharts));
(function (H) {
/**
 * (c) 2010-2017 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
var arrayMax = H.arrayMax,
	arrayMin = H.arrayMin,
	Axis = H.Axis,
	Chart = H.Chart,
	defined = H.defined,
	each = H.each,
	extend = H.extend,
	format = H.format,
	grep = H.grep,
	inArray = H.inArray,
	isNumber = H.isNumber,
	isString = H.isString,
	map = H.map,
	merge = H.merge,
	pick = H.pick,
	Point = H.Point,
	Renderer = H.Renderer,
	Series = H.Series,
	splat = H.splat,
	SVGRenderer = H.SVGRenderer,
	VMLRenderer = H.VMLRenderer,
	wrap = H.wrap,


	seriesProto = Series.prototype,
	seriesInit = seriesProto.init, 
	seriesProcessData = seriesProto.processData,
	pointTooltipFormatter = Point.prototype.tooltipFormatter;


/**
 * Compare the values of the series against the first non-null, non-
 * zero value in the visible range. The y axis will show percentage
 * or absolute change depending on whether `compare` is set to `"percent"`
 * or `"value"`. When this is applied to multiple series, it allows
 * comparing the development of the series against each other.
 * 
 * @type {String}
 * @see [compareBase](#plotOptions.series.compareBase), [Axis.setCompare()](#Axis.
 * setCompare())
 * @sample {highstock} stock/plotoptions/series-compare-percent/ Percent
 * @sample {highstock} stock/plotoptions/series-compare-value/ Value
 * @default undefined
 * @since 1.0.1
 * @product highstock
 * @apioption plotOptions.series.compare
 */

/**
 * Defines if comparisson should start from the first point within the visible
 * range or should start from the first point <b>before</b> the range.
 * In other words, this flag determines if first point within the visible range
 * will have 0% (`compareStart=true`) or should have been already calculated
 * according to the previous point (`compareStart=false`).
 *
 * @type {Boolean}
 * @sample {highstock} stock/plotoptions/series-comparestart/ Calculate compare within visible range
 * @default false
 * @since 6.0.0
 * @product highstock
 * @apioption plotOptions.series.compareStart
 */

/**
 * When [compare](#plotOptions.series.compare) is `percent`, this option
 * dictates whether to use 0 or 100 as the base of comparison.
 * 
 * @validvalue [0, 100]
 * @type {Number}
 * @sample {highstock} / Compare base is 100
 * @default 0
 * @since 5.0.6
 * @product highstock
 * @apioption plotOptions.series.compareBase
 */

/**
 * Factory function for creating new stock charts. Creates a new {@link Chart|
 * Chart} object with different default options than the basic Chart.
 * 
 * @function #stockChart
 * @memberOf Highcharts
 *
 * @param  {String|HTMLDOMElement} renderTo
 *         The DOM element to render to, or its id.
 * @param  {Options} options
 *         The chart options structure as described in the {@link
 *         https://api.highcharts.com/highstock|options reference}.
 * @param  {Function} callback
 *         A function to execute when the chart object is finished loading and
 *         rendering. In most cases the chart is built in one thread, but in
 *         Internet Explorer version 8 or less the chart is sometimes initialized
 *         before the document is ready, and in these cases the chart object
 *         will not be finished synchronously. As a consequence, code that
 *         relies on the newly built Chart object should always run in the
 *         callback. Defining a {@link https://api.highcharts.com/highstock/chart.events.load|
 *         chart.event.load} handler is equivalent.
 *
 * @return {Chart}
 *         The chart object.
 *
 * @example
 * var chart = Highcharts.stockChart('container', {
 *     series: [{
 *         data: [1, 2, 3, 4, 5, 6, 7, 8, 9],
 *         pointInterval: 24 * 60 * 60 * 1000
 *     }]
 * });
 */
H.StockChart = H.stockChart = function (a, b, c) {
	var hasRenderToArg = isString(a) || a.nodeName,
		options = arguments[hasRenderToArg ? 1 : 0],
		seriesOptions = options.series, // to increase performance, don't merge the data
		defaultOptions = H.getOptions(),
		opposite,

		// Always disable startOnTick:true on the main axis when the navigator
		// is enabled (#1090)
		navigatorEnabled = pick(
			options.navigator && options.navigator.enabled,
			defaultOptions.navigator.enabled,
			true
		),
		disableStartOnTick = navigatorEnabled ? {
			startOnTick: false,
			endOnTick: false
		} : null,

		lineOptions = {

			marker: {
				enabled: false,
				radius: 2
			}
			// gapSize: 0
		},
		columnOptions = {
			shadow: false,
			borderWidth: 0
		};

	// apply X axis options to both single and multi y axes
	options.xAxis = map(splat(options.xAxis || {}), function (xAxisOptions) {
		return merge(
			{ // defaults
				minPadding: 0,
				maxPadding: 0,
				overscroll: 0,
				ordinal: true,
				title: {
					text: null
				},
				labels: {
					overflow: 'justify'
				},
				showLastLabel: true
			}, 
			defaultOptions.xAxis, // #3802
			xAxisOptions, // user options
			{ // forced options
				type: 'datetime',
				categories: null
			},
			disableStartOnTick
		);
	});

	// apply Y axis options to both single and multi y axes
	options.yAxis = map(splat(options.yAxis || {}), function (yAxisOptions) {
		opposite = pick(yAxisOptions.opposite, true);
		return merge({ // defaults
			labels: {
				y: -2
			},
			opposite: opposite,

			/**
			 * @default {highcharts} true
			 * @default {highstock} false
			 * @apioption yAxis.showLastLabel
			 */
			showLastLabel: !!(
				// #6104, show last label by default for category axes
				yAxisOptions.categories ||
				yAxisOptions.type === 'category'
			),

			title: {
				text: null
			}
		}, 
		defaultOptions.yAxis, // #3802
		yAxisOptions // user options
		);
	});

	options.series = null;

	options = merge(
		{
			chart: {
				panning: true,
				pinchType: 'x'
			},
			navigator: {
				enabled: navigatorEnabled
			},
			scrollbar: {
				// #4988 - check if setOptions was called
				enabled: pick(defaultOptions.scrollbar.enabled, true)
			},
			rangeSelector: {
				// #4988 - check if setOptions was called
				enabled: pick(defaultOptions.rangeSelector.enabled, true)
			},
			title: {
				text: null
			},
			tooltip: {
				split: pick(defaultOptions.tooltip.split, true),
				crosshairs: true
			},
			legend: {
				enabled: false
			},

			plotOptions: {
				line: lineOptions,
				spline: lineOptions,
				area: lineOptions,
				areaspline: lineOptions,
				arearange: lineOptions,
				areasplinerange: lineOptions,
				column: columnOptions,
				columnrange: columnOptions,
				candlestick: columnOptions,
				ohlc: columnOptions
			}

		},
		
		options, // user's options

		{ // forced options
			isStock: true // internal flag
		}
	);

	options.series = seriesOptions;

	return hasRenderToArg ? 
		new Chart(a, options, c) :
		new Chart(options, b);
};

// Override the automatic label alignment so that the first Y axis' labels
// are drawn on top of the grid line, and subsequent axes are drawn outside
wrap(Axis.prototype, 'autoLabelAlign', function (proceed) {
	var chart = this.chart,
		options = this.options,
		panes = chart._labelPanes = chart._labelPanes || {},
		key,
		labelOptions = this.options.labels;
	if (this.chart.options.isStock && this.coll === 'yAxis') {
		key = options.top + ',' + options.height;
		if (!panes[key] && labelOptions.enabled) { // do it only for the first Y axis of each pane
			if (labelOptions.x === 15) { // default
				labelOptions.x = 0;
			}
			if (labelOptions.align === undefined) {
				labelOptions.align = 'right';
			}
			panes[key] = this;
			return 'right';
		}
	}
	return proceed.apply(this, [].slice.call(arguments, 1));
});

// Clear axis from label panes (#6071)
wrap(Axis.prototype, 'destroy', function (proceed) {
	var chart = this.chart,
		key = this.options && (this.options.top + ',' + this.options.height);

	if (key && chart._labelPanes && chart._labelPanes[key] === this) {
		delete chart._labelPanes[key];
	}

	return proceed.apply(this, Array.prototype.slice.call(arguments, 1));
});

// Override getPlotLinePath to allow for multipane charts
wrap(Axis.prototype, 'getPlotLinePath', function (proceed, value, lineWidth, old, force, translatedValue) {
	var axis = this,
		series = (this.isLinked && !this.series ? this.linkedParent.series : this.series),
		chart = axis.chart,
		renderer = chart.renderer,
		axisLeft = axis.left,
		axisTop = axis.top,
		x1,
		y1,
		x2,
		y2,
		result = [],
		axes = [], // #3416 need a default array
		axes2,
		uniqueAxes,
		transVal;

	/**
	 * Return the other axis based on either the axis option or on related series.
	 */
	function getAxis(coll) {
		var otherColl = coll === 'xAxis' ? 'yAxis' : 'xAxis',
			opt = axis.options[otherColl];

		// Other axis indexed by number
		if (isNumber(opt)) {
			return [chart[otherColl][opt]];
		}

		// Other axis indexed by id (like navigator)
		if (isString(opt)) {
			return [chart.get(opt)];
		}
		
		// Auto detect based on existing series
		return map(series, function (s) {
			return s[otherColl];
		});
	}

	// Ignore in case of colorAxis or zAxis. #3360, #3524, #6720
	if (axis.coll !== 'xAxis' && axis.coll !== 'yAxis') {
		return proceed.apply(this, [].slice.call(arguments, 1));
	}

	// Get the related axes based on series
	axes = getAxis(axis.coll);

	// Get the related axes based options.*Axis setting #2810
	axes2 = (axis.isXAxis ? chart.yAxis : chart.xAxis);
	each(axes2, function (A) {
		if (defined(A.options.id) ? A.options.id.indexOf('navigator') === -1 : true) {
			var a = (A.isXAxis ? 'yAxis' : 'xAxis'),
				rax = (defined(A.options[a]) ? chart[a][A.options[a]] : chart[a][0]);

			if (axis === rax) {
				axes.push(A);
			}
		}
	});


	// Remove duplicates in the axes array. If there are no axes in the axes array,
	// we are adding an axis without data, so we need to populate this with grid
	// lines (#2796).
	uniqueAxes = axes.length ? [] : [axis.isXAxis ? chart.yAxis[0] : chart.xAxis[0]]; // #3742
	each(axes, function (axis2) {
		if (
			inArray(axis2, uniqueAxes) === -1 &&
			// Do not draw on axis which overlap completely. #5424
			!H.find(uniqueAxes, function (unique) {
				return unique.pos === axis2.pos && unique.len && axis2.len;
			})
		) {
			uniqueAxes.push(axis2);
		}
	});

	transVal = pick(translatedValue, axis.translate(value, null, null, old));
	if (isNumber(transVal)) {
		if (axis.horiz) {
			each(uniqueAxes, function (axis2) {
				var skip;

				y1 = axis2.pos;
				y2 = y1 + axis2.len;
				x1 = x2 = Math.round(transVal + axis.transB);

				if (x1 < axisLeft || x1 > axisLeft + axis.width) { // outside plot area
					if (force) {
						x1 = x2 = Math.min(Math.max(axisLeft, x1), axisLeft + axis.width);
					} else {
						skip = true;
					}
				}
				if (!skip) {
					result.push('M', x1, y1, 'L', x2, y2);
				}
			});
		} else {
			each(uniqueAxes, function (axis2) {
				var skip;

				x1 = axis2.pos;
				x2 = x1 + axis2.len;
				y1 = y2 = Math.round(axisTop + axis.height - transVal);

				if (y1 < axisTop || y1 > axisTop + axis.height) { // outside plot area
					if (force) {
						y1 = y2 = Math.min(Math.max(axisTop, y1), axis.top + axis.height);
					} else {
						skip = true;
					}
				}
				if (!skip) {
					result.push('M', x1, y1, 'L', x2, y2);
				}
			});
		}
	}
	return result.length > 0 ?
		renderer.crispPolyLine(result, lineWidth || 1) :
		null; // #3557 getPlotLinePath in regular Highcharts also returns null
});

// Function to crisp a line with multiple segments
SVGRenderer.prototype.crispPolyLine = function (points, width) {
	// points format: ['M', 0, 0, 'L', 100, 0]		
	// normalize to a crisp line
	var i;
	for (i = 0; i < points.length; i = i + 6) {
		if (points[i + 1] === points[i + 4]) {
			// Substract due to #1129. Now bottom and left axis gridlines behave the same.
			points[i + 1] = points[i + 4] = Math.round(points[i + 1]) - (width % 2 / 2);
		}
		if (points[i + 2] === points[i + 5]) {
			points[i + 2] = points[i + 5] = Math.round(points[i + 2]) + (width % 2 / 2);
		}
	}
	return points;
};

if (Renderer === VMLRenderer) {
	VMLRenderer.prototype.crispPolyLine = SVGRenderer.prototype.crispPolyLine;
}


// Wrapper to hide the label
wrap(Axis.prototype, 'hideCrosshair', function (proceed, i) {
	
	proceed.call(this, i);

	if (this.crossLabel) {
		this.crossLabel = this.crossLabel.hide();
	}
});

// Wrapper to draw the label
wrap(Axis.prototype, 'drawCrosshair', function (proceed, e, point) {
	
	// Draw the crosshair
	proceed.call(this, e, point);

	// Check if the label has to be drawn
	if (
		!defined(this.crosshair.label) ||
		!this.crosshair.label.enabled ||
		!this.cross
	) {
		return;
	}

	var chart = this.chart,
		options = this.options.crosshair.label,		// the label's options
		horiz = this.horiz,							// axis orientation
		opposite = this.opposite,					// axis position
		left = this.left,							// left position
		top = this.top,								// top position
		crossLabel = this.crossLabel,				// reference to the svgElement
		posx,
		posy,
		crossBox,
		formatOption = options.format,
		formatFormat = '',
		limit,
		align,
		tickInside = this.options.tickPosition === 'inside',
		snap = this.crosshair.snap !== false,
		value,
		offset = 0;

	// Use last available event (#5287)
	if (!e) {
		e = this.cross && this.cross.e;
	}

	align = (horiz ? 'center' : opposite ?
		(this.labelAlign === 'right' ? 'right' : 'left') :
		(this.labelAlign === 'left' ? 'left' : 'center'));

	// If the label does not exist yet, create it.
	if (!crossLabel) {
		crossLabel = this.crossLabel = chart.renderer.label(
				null,
				null,
				null,
				options.shape || 'callout'
			)
			.addClass('highcharts-crosshair-label' +
				(this.series[0] && ' highcharts-color-' + this.series[0].colorIndex))
			.attr({
				align: options.align || align,
				padding: pick(options.padding, 8),
				r: pick(options.borderRadius, 3),
				zIndex: 2
			})
			.add(this.labelGroup);

		
		// Presentational
		crossLabel
			.attr({
				fill: options.backgroundColor ||
					(this.series[0] && this.series[0].color) ||
					'#666666',
				stroke: options.borderColor || '',
				'stroke-width': options.borderWidth || 0
			})
			.css(extend({
				color: '#ffffff',
				fontWeight: 'normal',
				fontSize: '11px',
				textAlign: 'center'
			}, options.style));
		
	}

	if (horiz) {
		posx = snap ? point.plotX + left : e.chartX;
		posy = top + (opposite ? 0 : this.height);
	} else {
		posx = opposite ? this.width + left : 0;
		posy = snap ? point.plotY + top : e.chartY;
	}

	if (!formatOption && !options.formatter) {
		if (this.isDatetimeAxis) {
			formatFormat = '%b %d, %Y';
		}
		formatOption = '{value' + (formatFormat ? ':' + formatFormat : '') + '}';
	}

	// Show the label
	value = snap ?
		point[this.isXAxis ? 'x' : 'y'] :
		this.toValue(horiz ? e.chartX : e.chartY);

	crossLabel.attr({
		text: formatOption ?
			format(formatOption, { value: value }, chart.time) :
			options.formatter.call(this, value),
		x: posx,
		y: posy,
		// Crosshair should be rendered within Axis range (#7219)
		visibility: value < this.min || value > this.max ? 'hidden' : 'visible'
	});

	crossBox = crossLabel.getBBox();

	// now it is placed we can correct its position
	if (horiz) {
		if ((tickInside && !opposite) || (!tickInside && opposite)) {
			posy = crossLabel.y - crossBox.height;
		}
	} else {
		posy = crossLabel.y - (crossBox.height / 2);
	}

	// check the edges
	if (horiz) {
		limit = {
			left: left - crossBox.x,
			right: left + this.width - crossBox.x
		};
	} else {
		limit = {
			left: this.labelAlign === 'left' ? left : 0,
			right: this.labelAlign === 'right' ? left + this.width : chart.chartWidth
		};
	}

	// left edge
	if (crossLabel.translateX < limit.left) {
		offset = limit.left - crossLabel.translateX;
	}
	// right edge
	if (crossLabel.translateX + crossBox.width >= limit.right) {
		offset = -(crossLabel.translateX + crossBox.width - limit.right);
	}

	// show the crosslabel
	crossLabel.attr({
		x: posx + offset,
		y: posy,
		// First set x and y, then anchorX and anchorY, when box is actually calculated, #5702
		anchorX: horiz ? posx : (this.opposite ? 0 : chart.chartWidth),
		anchorY: horiz ? (this.opposite ? chart.chartHeight : 0) : posy + crossBox.height / 2
	});
});

/* ****************************************************************************
 * Start value compare logic												  *
 *****************************************************************************/
	
/**
 * Extend series.init by adding a method to modify the y value used for plotting
 * on the y axis. This method is called both from the axis when finding dataMin
 * and dataMax, and from the series.translate method.
 */
seriesProto.init = function () {

	// Call base method
	seriesInit.apply(this, arguments);

	// Set comparison mode
	this.setCompare(this.options.compare);
};

/**
 * Highstock only. Set the {@link
 * http://api.highcharts.com/highstock/plotOptions.series.compare|
 * compare} mode of the series after render time. In most cases it is more
 * useful running {@link Axis#setCompare} on the X axis to update all its
 * series.
 *
 * @function setCompare
 * @memberOf Series.prototype
 *
 * @param  {String} compare
 *         Can be one of `null`, `"percent"` or `"value"`.
 */
seriesProto.setCompare = function (compare) {

	// Set or unset the modifyValue method
	this.modifyValue = (compare === 'value' || compare === 'percent') ? function (value, point) {
		var compareValue = this.compareValue;
		
		if (value !== undefined && compareValue !== undefined) { // #2601, #5814

			// Get the modified value
			if (compare === 'value') {
				value -= compareValue;
			
			// Compare percent
			} else {
				value = 100 * (value / compareValue) - 
					(this.options.compareBase === 100 ? 0 : 100);
			}
			
			// record for tooltip etc.
			if (point) {
				point.change = value;
			}

			return value;
		}
	} : null;

	// Survive to export, #5485
	this.userOptions.compare = compare;

	// Mark dirty
	if (this.chart.hasRendered) {
		this.isDirty = true;
	}

};

/**
 * Extend series.processData by finding the first y value in the plot area,
 * used for comparing the following values
 */
seriesProto.processData = function () {
	var series = this,
		i,
		keyIndex = -1,
		processedXData,
		processedYData,
		compareStart = series.options.compareStart === true ? 0 : 1,
		length,
		compareValue;

	// call base method
	seriesProcessData.apply(this, arguments);

	if (series.xAxis && series.processedYData) { // not pies

		// local variables
		processedXData = series.processedXData;
		processedYData = series.processedYData;
		length = processedYData.length;

		// For series with more than one value (range, OHLC etc), compare against
		// close or the pointValKey (#4922, #3112)
		if (series.pointArrayMap) {
			// Use close if present (#3112)
			keyIndex = inArray('close', series.pointArrayMap);
			if (keyIndex === -1) {
				keyIndex = inArray(series.pointValKey || 'y', series.pointArrayMap);
			}
		}

		// find the first value for comparison
		for (i = 0; i < length - compareStart; i++) {
			compareValue = processedYData[i] && keyIndex > -1 ? 
				processedYData[i][keyIndex] :
				processedYData[i];
			if (
				isNumber(compareValue) &&
				processedXData[i + compareStart] >= series.xAxis.min &&
				compareValue !== 0
			) {
				series.compareValue = compareValue;
				break;
			}
		}
	}
};

/**
 * Modify series extremes
 */
wrap(seriesProto, 'getExtremes', function (proceed) {
	var extremes;

	proceed.apply(this, [].slice.call(arguments, 1));

	if (this.modifyValue) {
		extremes = [this.modifyValue(this.dataMin), this.modifyValue(this.dataMax)];
		this.dataMin = arrayMin(extremes);
		this.dataMax = arrayMax(extremes);
	}
});

/**
 * Highstock only. Set the compare mode on all series belonging to an Y axis
 * after render time.
 *
 * @param  {String} compare
 *         The compare mode. Can be one of `null`, `"value"` or `"percent"`.
 * @param  {Boolean} [redraw=true]
 *         Whether to redraw the chart or to wait for a later call to {@link
 *         Chart#redraw},
 *
 * @function setCompare
 * @memberOf Axis.prototype
 *
 * @see    {@link https://api.highcharts.com/highstock/series.plotOptions.compare|
 *         series.plotOptions.compare}
 *
 * @sample stock/members/axis-setcompare/
 *         Set compoare
 */
Axis.prototype.setCompare = function (compare, redraw) {
	if (!this.isXAxis) {
		each(this.series, function (series) {
			series.setCompare(compare);
		});
		if (pick(redraw, true)) {
			this.chart.redraw();
		}
	}
};

/**
 * Extend the tooltip formatter by adding support for the point.change variable
 * as well as the changeDecimals option
 */
Point.prototype.tooltipFormatter = function (pointFormat) {
	var point = this;

	pointFormat = pointFormat.replace(
		'{point.change}',
		(point.change > 0 ? '+' : '') +
			H.numberFormat(point.change, pick(point.series.tooltipOptions.changeDecimals, 2))
	); 
	
	return pointTooltipFormatter.apply(this, [pointFormat]);
};

/* ****************************************************************************
 * End value compare logic													*
 *****************************************************************************/


/**
 * Extend the Series prototype to create a separate series clip box. This is
 * related to using multiple panes, and a future pane logic should incorporate
 * this feature (#2754).
 */
wrap(Series.prototype, 'render', function (proceed) {
	// Only do this on not 3d (#2939, #5904) nor polar (#6057) charts, and only
	// if the series type handles clipping in the animate method (#2975).
	if (
		!(this.chart.is3d && this.chart.is3d()) &&
		!this.chart.polar &&
		this.xAxis &&
		!this.xAxis.isRadial // Gauge, #6192
	) {

		// First render, initial clip box
		if (!this.clipBox && this.animate) {
			this.clipBox = merge(this.chart.clipBox);
			this.clipBox.width = this.xAxis.len;
			this.clipBox.height = this.yAxis.len;

		// On redrawing, resizing etc, update the clip rectangle
		} else if (this.chart[this.sharedClipKey]) {
			this.chart[this.sharedClipKey].attr({
				width: this.xAxis.len,
				height: this.yAxis.len
			});
		// #3111
		} else if (this.clipBox) {
			this.clipBox.width = this.xAxis.len;
			this.clipBox.height = this.yAxis.len;
		}
	}
	proceed.call(this);
});

wrap(Chart.prototype, 'getSelectedPoints', function (proceed) {
	var points = proceed.call(this);

	each(this.series, function (serie) {
		// series.points - for grouped points (#6445)
		if (serie.hasGroupedData) {
			points = points.concat(grep(serie.points || [], function (point) {
				return point.selected;
			}));
		}
	});
	return points;
});

wrap(Chart.prototype, 'update', function (proceed, options) {
	// Use case: enabling scrollbar from a disabled state.
	// Scrollbar needs to be initialized from a controller, Navigator in this
	// case (#6615)
	if ('scrollbar' in options && this.navigator) {
		merge(true, this.options.scrollbar, options.scrollbar);
		this.navigator.update({}, false);
		delete options.scrollbar;
	}

	return proceed.apply(this, Array.prototype.slice.call(arguments, 1));
});

}(Highcharts));
(function () {


}());
return Highcharts
}));
(function() {
  var f, render;

  Highcharts.setOptions({
    global: {
      useUTC: false
    }
  });

  if (gon.local === "zh-CN") {
    Highcharts.setOptions({
      lang: {
        months: ['', '', '', '', '', '', '', '', '', '', '', ''],
        shortMonths: ['', '', '', '', '', '', '', '', '', '', '', ''],
        weekdays: ['', '', '', '', '', '', '']
      }
    });
  }

  render = Highcharts.RangeSelector.prototype.render;

  Highcharts.RangeSelector.prototype.render = function(min, max) {
    var button, leftPosition, space, topPosition, _i, _len, _ref, _results;
    render.apply(this, [min, max]);
    leftPosition = this.chart.plotLeft;
    topPosition = this.chart.plotTop;
    space = 10;
    this.zoomText.attr({
      x: leftPosition + 2,
      y: topPosition + 15,
      text: gon.i18n.chart.zoom
    });
    leftPosition += this.zoomText.getBBox().width + 15;
    _ref = this.buttons;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      button = _ref[_i];
      button.attr({
        x: leftPosition,
        y: topPosition
      });
      _results.push(leftPosition += button.width + space);
    }
    return _results;
  };

  f = function(callback) {};

  Highcharts.wrap(Highcharts.Tooltip.prototype, 'hide', f);

}).call(this);
(function (H) {

	// create shortcuts
	var defaultOptions = H.getOptions(),
		defaultPlotOptions = defaultOptions.plotOptions,
		seriesTypes = H.seriesTypes;

	// Trendline functionality and default options.
	defaultPlotOptions.trendline = H.merge(defaultPlotOptions.line, {

		marker: {
			enabled: false
		},

		tooltip: {
			valueDecimals: 2
		}
	});

	seriesTypes.trendline = H.extendClass(seriesTypes.line, {
		
		type: 'trendline',
		animate: null,
		requiresSorting: false,
		processData: function() {
			var data;

			if (this.linkedParent) {
				data = [].concat(this.linkedParent.options.data)
				this.setData(this.runAlgorithm(), false);
			}

			H.Series.prototype.processData.call(this);
		},
		runAlgorithm: function () {

			var xData = this.linkedParent.xData,
				yData = this.linkedParent.yData,
				periods = this.options.periods || 100,		// Set this to what default? should be defaults for each algorithm.
				algorithm = this.options.algorithm || 'linear';

			return this[algorithm](xData, yData, periods);
		},


		/* Function that uses the calcMACD function to return the MACD line.
		 * 
		 * @return : the first index of the calcMACD return, the MACD.
		**/
		MACD: function (xData, yData, periods) {

			return calcMACD(xData, yData, periods)[0];
		},

		/* Function that uses the global calcMACD.
		 * 
		 * @return : the second index of the calcMACD return, the signalLine.
		**/
		signalLine: function (xData, yData, periods) {

			return calcMACD(xData, yData, periods)[1];
		},

		/* Function using the global SMA function.
		 * 
		 * @return : an array of SMA data.
		**/
		SMA: function (xData, yData, periods) {

			return SMA(xData, yData, periods);
		},

    MA: function (xData, yData, periods) {

			return MA(xData, yData, periods);
    },


		/* Function using the global EMA function.
		 * 
		 * @return : an array of EMA data.
		**/
		EMA: function (xData, yData, periods) {

			return EMA(xData, yData, periods);
		}, 

		/* Function that uses the global linear function.
		 *
		 * @return : an array of EMA data
		**/
		linear: function (xData, yData, periods) {

			return linear(xData, yData, periods);
		}

	});

	// Setting default options for the Histogram type.
	defaultPlotOptions.histogram = H.merge(defaultPlotOptions.column, {

		borderWidth : 0,

		tooltip: {
			valueDecimals: 2
		}

	});


	seriesTypes.histogram = H.extendClass(seriesTypes.column, {
		
		type: 'histogram',
		animate: null,
		requiresSorting: false,
		processData: function() {
			var data;

			if (this.linkedParent) {
				data = [].concat(this.linkedParent.options.data)
				this.setData(this.runAlgorithm(), false);
			}

			H.Series.prototype.processData.call(this);
		},

		runAlgorithm: function () {

			var xData = this.linkedParent.xData,
				yData = this.linkedParent.yData,
				periods = this.options.periods || 100,		// Set this to what default? should be defaults for each algorithm.
				algorithm = this.options.algorithm || 'histogram';

			return this[algorithm](xData, yData, periods);
		},


		histogram: function (xData, yData, periods) {

			return calcMACD(xData, yData, periods)[2];
		},

	});


	// Global functions.

	/* Function that calculates the MACD (Moving Average Convergance-Divergence).
	 *
	 * @param yData : array of y variables.
	 * @param xData : array of x variables.
	 * @param periods : The amount of "days" to average from.
	 * @return : An array with 3 arrays. (0 : macd, 1 : signalline , 2 : histogram) 
	**/
	function calcMACD (xData, yData, periods) {

		var chart = this,
			shortPeriod = 12,
			longPeriod = 26,
			signalPeriod = 9,
			shortEMA,
			longEMA,
			MACD = [], 
			xMACD = [],
			yMACD = [],
			signalLine = [],
			histogram = [];


		// Calculating the short and long EMA used when calculating the MACD
		shortEMA = EMA(xData, yData, 12);
		longEMA = EMA(xData, yData, 26);

		// subtract each Y value from the EMA's and create the new dataset (MACD)
		for (var i = 0; i < shortEMA.length; i++) {

			if (longEMA[i][1] == null) {

				MACD.push( [xData[i] , null]);

			} else {
				MACD.push( [ xData[i] , (shortEMA[i][1] - longEMA[i][1]) ] );
			}
		}

		// Set the Y and X data of the MACD. This is used in calculating the signal line.
		for (var i = 0; i < MACD.length; i++) {
			xMACD.push(MACD[i][0]);
			yMACD.push(MACD[i][1]);
		}

		// Setting the signalline (Signal Line: X-day EMA of MACD line).
		signalLine = EMA(xMACD, yMACD, signalPeriod);

		// Setting the MACD Histogram. In comparison to the loop with pure MACD this loop uses MACD x value not xData.
		for (var i = 0; i < MACD.length; i++) {

			if (MACD[i][1] == null) {

				histogram.push( [ MACD[i][0], null ] );
			
			} else {

				histogram.push( [ MACD[i][0], (MACD[i][1] - signalLine[i][1]) ] );

			}
		}

		return [MACD, signalLine, histogram];
	}

	/**
	 * Calculating a linear trendline.
	 * The idea of a trendline is to reveal a linear relationship between 
	 * two variables, x and y, in the "y = mx + b" form.
	 * @param yData : array of y variables.
	 * @param xData : array of x variables.
	 * @param periods : Only here for overloading purposes.
	 * @return an array containing the linear trendline. 
	**/
	function linear (xData, yData, periods) {

		var		lineData = [],
				step1,
				step2 = 0,
				step3 = 0,
				step3a = 0,
				step3b = 0,
				step4 = 0,
				step5 = 0,
				step5a = 0,
				step6 = 0,
				step7 = 0,
				step8 = 0,
				step9 = 0;


		// Step 1: The number of data points.
		step1 = xData.length;

		// Step 2: "step1" times the summation of all x-values multiplied by their corresponding y-values.
		// Step 3: Sum of all x-values times the sum of all y-values. 3a and b are used for storing data.
		// Step 4: "step1" times the sum of all squared x-values.
		// Step 5: The squared sum of all x-values. 5a stores data.
		// Step 6: Equation to calculate the slope of the regression line.
		// Step 7: The sum of all y-values.
		// Step 8: "step6" times the sum of all x-values (step5).
		// Step 9: The equation for the y-intercept of the trendline.
		for ( var i = 0; i < step1; i++) {
			step2 = (step2 + (xData[i] * yData[i]));
			step3a = (step3a + xData[i]);
			step3b = (step3b + yData[i]);
			step4 = (step4 + Math.pow(xData[i], 2));
			step5a = (step5a + xData[i]);
			step7 = (step7 + yData[i]);
		}
		step2 = (step1 * step2);
		step3 = (step3a * step3b);
		step4 = (step1 * step4);
		step5 = (Math.pow(step5a, 2));
		step6 = ((step2 - step3) / (step4 - step5));
		step8 = (step6 * step5a);
		step9 = ((step7 - step8) / step1);

		// Step 10: Plotting the trendline. Only two points are calulated.
		// The starting point.
		// This point will have values equal to the first X and Y value in the original dataset.
		lineData.push([xData[0] , yData[0]]);

		// Calculating the ending point.
		// The point X is equal the X in the original dataset.
		// The point Y is calculated using the function of a straight line and our variables found.
		step10 = ( ( step6 * xData[step1 - 1] ) + step9 );
		lineData.push([ ( xData[step1 - 1] ), step10 ]);

		return lineData;
	}

	function MA (xData, yData, periods) {
    var maLine = [],
        periodArr = [],
        length = yData.length;

		for (var i = 0; i < length; i++) {
      periodArr.push(yData[i]);

      if (i >= periods) {
				maLine.push([xData[i] , arrayAvg(periodArr)]);
        periodArr.shift();
      }
      else {
				maLine.push([xData[i] , null]);
      }
    }

    return maLine;
  }


	/* Function based on the idea of an exponential moving average.
	 * 
	 * Formula: EMA = Price(t) * k + EMA(y) * (1 - k)
	 * t = today, y = yesterday, N = number of days in EMA, k = 2/(2N+1)
	 *
	 * @param yData : array of y variables.
	 * @param xData : array of x variables.
	 * @param periods : The amount of "days" to average from.
	 * @return an array containing the EMA.	
	**/
	function EMA (xData, yData, periods) {
		var t,
			y = false,
			n = periods,
			k = (2 / (n + 1)),
			ema,	// exponential moving average.
			emLine = [],
			periodArr = [],
			length = yData.length,
			pointStart = xData[0];

		// loop through data
		for (var i = 0; i < length; i++) {


			// Add the last point to the period arr, but only if its set.
			if (yData[i-1]) {
				periodArr.push(yData[i]);
			}
			

			// 0: runs if the periodArr has enough points.
			// 1: set currentvalue (today).
			// 2: set last value. either by past avg or yesterdays ema.
			// 3: calculate todays ema.
			if (n == periodArr.length) {


				t = yData[i];

				if (!y) {
					y = arrayAvg(periodArr);
				} else {
					ema = (t * k) + (y * (1 - k));
					y = ema;
				}

				emLine.push([xData[i] , y]);

				// remove first value in array.
				periodArr.splice(0,1);

			} else {

				emLine.push([xData[i] , null]);
			}

		}

		return emLine;
	}

	/* Function based on the idea of a simple moving average.
	 * @param yData : array of y variables.
	 * @param xData : array of x variables.
	 * @param periods : The amount of "days" to average from.
	 * @return an array containing the SMA.	
	**/
	function SMA (xData, yData, periods) {
		var periodArr = [],
			smLine = [],
			length = yData.length,
			pointStart = xData[0];

		// Loop through the entire array.
		for (var i = 0; i < length; i++) {

			// add points to the array.
			periodArr.push(yData[i]);

			// 1: Check if array is "filled" else create null point in line.
			// 2: Calculate average.
			// 3: Remove first value.
			if (periods == periodArr.length) {

				smLine.push([ xData[i] , arrayAvg(periodArr)]);
				periodArr.splice(0,1);

			}  else {
				smLine.push([ xData[i] , null]);
			}
		}
		return smLine;
	}

	/* Function that returns average of an array's values.
	 *
	**/
	function arrayAvg (arr) {
		var sum = 0,
			arrLength = arr.length,
			i = arrLength;

		while (i--) {
			sum = sum + arr[i];
		}

		return (sum / arrLength);
	}

}(Highcharts));
(function() {
  var Formatter;

  Formatter = (function() {
    function Formatter() {}

    Formatter.prototype.round = function(str, fixed) {
      return BigNumber(str).round(fixed, BigNumber.ROUND_HALF_UP).toF(fixed);
    };

    Formatter.prototype.fix = function(type, str) {
      if (!$.isNumeric(str)) {
        str = '0';
      }
      if (type === 'ask') {
        return this.round(str, gon.market.ask.fixed);
      } else if (type === 'bid') {
        return this.round(str, gon.market.bid.fixed);
      }
    };

    Formatter.prototype.fixAsk = function(str) {
      return this.fix('ask', str);
    };

    Formatter.prototype.fixBid = function(str) {
      return this.fix('bid', str);
    };

    Formatter.prototype.fixPriceGroup = function(str) {
      if (gon.market.price_group_fixed) {
        if (!$.isNumeric(str)) {
          str = '0';
        }
        return this.round(str, gon.market.price_group_fixed);
      } else {
        return this.fixBid(str);
      }
    };

    Formatter.prototype.check_trend = function(type) {
      if (type === 'up' || type === 'buy' || type === 'bid' || type === true) {
        return true;
      } else if (type === 'down' || type === "sell" || (type = 'ask' || type === false)) {
        return false;
      } else {
        throw "unknown trend smybol " + type;
      }
    };

    Formatter.prototype.market = function(base, quote) {
      return "" + (base.toUpperCase()) + "/" + (quote.toUpperCase());
    };

    Formatter.prototype.market_url = function(market, order_id) {
      if (order_id != null) {
        return "/markets/" + market + "/orders/" + order_id;
      } else {
        return "/markets/" + market;
      }
    };

    Formatter.prototype.trade = function(ask_or_bid) {
      return gon.i18n[ask_or_bid];
    };

    Formatter.prototype.short_trade = function(type) {
      if (type === 'buy' || type === 'bid') {
        return gon.i18n['bid'];
      } else if (type === "sell" || (type = 'ask')) {
        return gon.i18n['ask'];
      } else {
        return 'n/a';
      }
    };

    Formatter.prototype.trade_time = function(timestamp) {
      var m;
      m = moment.unix(timestamp);
      return "" + (m.format("HH:mm")) + (m.format(":ss"));
    };

    Formatter.prototype.fulltime = function(timestamp) {
      var m;
      m = moment.unix(timestamp);
      return "" + (m.format("MM/DD HH:mm"));
    };

    Formatter.prototype.mask_price = function(price) {
      return price.replace(/\..*/, "<g>$&</g>");
    };

    Formatter.prototype.mask_fixed_price = function(price) {
      return this.mask_price(this.fixPriceGroup(price));
    };

    Formatter.prototype.ticker_fill = ['', '0', '00', '000', '0000', '00000', '000000', '0000000', '00000000', '000000000'];

    Formatter.prototype.ticker_price = function(price, fillTo) {
      var fill, fill_length, left, result, right, right_length, _ref;
      if (fillTo == null) {
        fillTo = 9;
      }
      _ref = price.split('.'), left = _ref[0], right = _ref[1];
      fill_length = 8;
      right_length = right.length;
      if (right_length > fill_length) {
        right_length = fill_length;
      }
      result = "";
      if (fill = this.ticker_fill[fill_length - right_length]) {
        result = "" + left + ".<g>" + right + "</g><span class='fill'>" + fill + "</span>";
      } else {
        result = "" + left + ".<g>" + (right.slice(0, fill_length)) + "</g>";
      }
      if (fillTo - right.length === 0) {
        result += "<span class='satoshi'>" + right[fillTo - 1] + "</span>";
      } else {
        result += "<span class='satoshi-hide'>0</span>";
      }
      return result;
    };

    Formatter.prototype.price_change = function(p1, p2) {
      var percent;
      percent = p1 ? this.round(100 * (p2 - p1) / p1, 2) : '0.00';
      return "" + (p1 > p2 ? '' : '+') + percent;
    };

    Formatter.prototype.long_time = function(timestamp) {
      var m;
      m = moment.unix(timestamp);
      return "" + (m.format("YYYY/MM/DD HH:mm"));
    };

    Formatter.prototype.mask_fixed_volume = function(volume) {
      return this.fixAsk(volume).replace(/\..*/, "<g>$&</g>");
    };

    Formatter.prototype.fix_ask = function(volume) {
      return this.fixAsk(volume);
    };

    Formatter.prototype.fix_bid = function(price) {
      return this.fixBid(price);
    };

    Formatter.prototype.amount = function(amount, price) {
      var val;
      val = (new BigNumber(amount)).times(new BigNumber(price));
      return this.fixAsk(val).replace(/\..*/, "<g>$&</g>");
    };

    Formatter.prototype.trend = function(type) {
      if (this.check_trend(type)) {
        return "text-up";
      } else {
        return "text-down";
      }
    };

    Formatter.prototype.trend_icon = function(type) {
      if (this.check_trend(type)) {
        return "<i class='fa fa-caret-up text-up'></i>";
      } else {
        return "<i class='fa fa-caret-down text-down'></i>";
      }
    };

    Formatter.prototype.t = function(key) {
      return gon.i18n[key];
    };

    return Formatter;

  })();

  window.formatter = new Formatter();

}).call(this);
(function() {
  this.ItemListMixin = function() {
    this.attributes({
      tbody: 'table > tbody',
      empty: '.empty-row'
    });
    this.checkEmpty = function(event, data) {
      if (this.select('tbody').find('tr.order').length === 0) {
        return this.select('empty').fadeIn();
      } else {
        return this.select('empty').fadeOut();
      }
    };
    this.addOrUpdateItem = function(item) {
      var existsItem, template;
      template = this.getTemplate(item);
      existsItem = this.select('tbody').find("tr[data-id=" + item.id + "][data-kind=" + item.kind + "]");
      if (existsItem.length) {
        existsItem.html(template.html());
      } else {
        template.prependTo(this.select('tbody')).show('slow');
      }
      return this.checkEmpty();
    };
    this.removeItem = function(id) {
      var item;
      item = this.select('tbody').find("tr[data-id=" + id + "]");
      return item.hide('slow', (function(_this) {
        return function() {
          item.remove();
          return _this.checkEmpty();
        };
      })(this));
    };
    return this.populate = function(event, data) {
      var item, _i, _len, _ref;
      if (!_.isEmpty(data.orders)) {
        _ref = data.orders;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          item = _ref[_i];
          this.addOrUpdateItem(item);
        }
      }
      return this.checkEmpty();
    };
  };

}).call(this);
(function() {
  this.NotificationMixin = function() {
    return this.notify = function(body, title) {
      var notification;
      title || (title = gon.i18n.notification.title);
      return notification = notifier.notify(title, body);
    };
  };

}).call(this);
(function() {
  this.OrderInputMixin = function() {
    this.attributes({
      form: null,
      type: null
    });
    this.reset = function() {
      this.text = '';
      return this.value = null;
    };
    this.rollback = function() {
      return this.$node.val(this.text);
    };
    this.parseText = function() {
      var text, value;
      text = this.$node.val();
      value = BigNumber(text);
      switch (false) {
        case text !== this.text:
          return false;
        case text !== '':
          this.reset();
          this.trigger('place_order::reset', {
            variables: this.attr.variables
          });
          return false;
        case !!$.isNumeric(text):
          this.rollback();
          return false;
        case !((value.c.length - value.e - 1) > this.attr.precision):
          this.rollback();
          return false;
        default:
          this.text = text;
          this.value = value;
          return true;
      }
    };
    this.roundValueToText = function(v) {
      return v.round(this.attr.precision, BigNumber.ROUND_DOWN).toF(this.attr.precision);
    };
    this.setInputValue = function(v) {
      if (v != null) {
        this.text = this.roundValueToText(v);
      } else {
        this.text = '';
      }
      return this.$node.val(this.text);
    };
    this.changeOrder = function(v) {
      return this.trigger('place_order::input', {
        variables: this.attr.variables,
        value: v
      });
    };
    this.process = function(event) {
      if (!this.parseText()) {
        return;
      }
      if (this.validateRange(this.value)) {
        return this.changeOrder(this.value);
      } else {
        return this.setInputValue(this.value);
      }
    };
    this.validateRange = function(v) {
      if (this.max && v.greaterThan(this.max)) {
        this.value = this.max;
        this.changeOrder(this.max);
        return false;
      } else if (v.lessThan(0)) {
        this.value = null;
        return false;
      } else {
        this.value = v;
        return true;
      }
    };
    this.onInput = function(e, data) {
      this.$node.val(this.roundValueToText(data[this.attr.variables.input]));
      return this.process();
    };
    this.onMax = function(e, data) {
      return this.max = data.max;
    };
    this.onReset = function(e) {
      this.$node.val('');
      return this.reset();
    };
    this.onFocus = function(e) {
      return this.$node.focus();
    };
    return this.after('initialize', function() {
      this.orderType = this.attr.type;
      this.text = '';
      this.value = null;
      this.on(this.$node, 'change paste keyup', this.process);
      this.on(this.attr.form, "place_order::max::" + this.attr.variables.input, this.onMax);
      this.on(this.attr.form, "place_order::input::" + this.attr.variables.input, this.onInput);
      this.on(this.attr.form, "place_order::output::" + this.attr.variables.input, this.onOutput);
      this.on(this.attr.form, "place_order::reset::" + this.attr.variables.input, this.onReset);
      return this.on(this.attr.form, "place_order::focus::" + this.attr.variables.input, this.onFocus);
    });
  };

}).call(this);
(function() {
  window.GlobalData = flight.component(function() {
    this.refreshDocumentTitle = function(event, data) {
      var brand, market, price, symbol;
      symbol = gon.currencies[gon.market.bid.currency].symbol;
      price = data.last;
      market = [gon.market.ask.currency, gon.market.bid.currency].join("/").toUpperCase();
      brand = "GRAVIEX Exchange";
      return document.title = "" + symbol + price + " " + market + " - " + brand;
    };
    this.refreshDepth = function(data) {
      var asks, asks_sum, bids, bids_sum, _ref;
      asks = [];
      bids = [];
      _ref = [0, 0], bids_sum = _ref[0], asks_sum = _ref[1];
      _.each(data.asks, function(_arg) {
        var price, volume;
        price = _arg[0], volume = _arg[1];
        return asks.push([parseFloat(price), asks_sum += parseFloat(volume)]);
      });
      _.each(data.bids, function(_arg) {
        var price, volume;
        price = _arg[0], volume = _arg[1];
        return bids.push([parseFloat(price), bids_sum += parseFloat(volume)]);
      });
      return this.trigger('market::depth::response', {
        asks: asks,
        bids: bids
      });
    };
    this.refreshTicker = function(data) {
      var buy, last, last_buy, last_last, last_sell, market, open, sell, ticker, tickers, tickers_sorted;
      if (!this.last_tickers) {
        for (market in data) {
          ticker = data[market];
          data[market]['buy_trend'] = data[market]['sell_trend'] = data[market]['last_trend'] = true;
        }
        this.last_tickers = data;
      }
      tickers = (function() {
        var _results;
        _results = [];
        for (market in data) {
          ticker = data[market];
          buy = parseFloat(ticker.buy);
          sell = parseFloat(ticker.sell);
          last = parseFloat(ticker.last);
          last_buy = parseFloat(this.last_tickers[market].buy);
          last_sell = parseFloat(this.last_tickers[market].sell);
          last_last = parseFloat(this.last_tickers[market].last);
          open = parseFloat(ticker.open);
          ticker.volumeRelFloat = parseFloat(formatter.price_change(open, last));
          ticker.lastFloat = last;
          ticker.volumeAbsFloat = parseFloat(ticker.volume2);
          if (buy !== last_buy) {
            data[market]['buy_trend'] = ticker['buy_trend'] = buy > last_buy;
          } else {
            ticker['buy_trend'] = this.last_tickers[market]['buy_trend'];
          }
          if (sell !== last_sell) {
            data[market]['sell_trend'] = ticker['sell_trend'] = sell > last_sell;
          } else {
            ticker['sell_trend'] = this.last_tickers[market]['sell_trend'];
          }
          if (last !== last_last) {
            data[market]['last_trend'] = ticker['last_trend'] = last > last_last;
          } else {
            ticker['last_trend'] = this.last_tickers[market]['last_trend'];
          }
          if (market === gon.market.id) {
            this.trigger('market::ticker', ticker);
          }
          _results.push({
            market: market,
            data: ticker,
            unit: this.sort_unit,
            order: this.sort_order
          });
        }
        return _results;
      }).call(this);
      tickers_sorted = tickers.sort(this.sorter);
      this.trigger('market::tickers', {
        tickers: tickers_sorted,
        raw: data
      });
      return this.last_tickers = data;
    };
    this.sorter = function(a, b) {
      if (a.order === 'unsorted' || a.unit === 'empty') {
        return 0;
      }
      if (a.data[a.unit] < b.data[a.unit]) {
        if (a.order === 'asc') {
          return -1;
        }
        return 1;
      } else if (a.data[a.unit] > b.data[a.unit]) {
        if (a.order === 'asc') {
          return 1;
        }
        return -1;
      } else {
        return 0;
      }
    };
    this.refreshTickers = function(event, data) {
      if (this.last_tickers) {
        return this.refreshTicker(this.last_tickers);
      } else if (gon.tickers) {
        return this.refreshTicker(gon.tickers);
      }
    };
    this.sortTickers = function(event, data) {
      this.sort_unit = data.unit;
      if (this.sort_unit === 'volume') {
        this.sort_unit = 'volumeRelFloat';
      } else if (this.sort_unit === 'last') {
        this.sort_unit = 'lastFloat';
      } else if (this.sort_unit === 'volume2') {
        this.sort_unit = 'volumeAbsFloat';
      }
      this.sort_order = data.order;
      if (this.last_tickers) {
        return this.refreshTicker(this.last_tickers);
      } else if (gon.tickers) {
        return this.refreshTicker(gon.tickers);
      }
    };
    return this.after('initialize', function() {
      var global_channel, market_channel;
      this.on(document, 'market::ticker', this.refreshDocumentTitle);
      this.on(document, 'market::tickers::force', this.refreshTickers);
      this.on(document, 'market::tickers::sort', this.sortTickers);
      this.sort_unit = 'empty';
      this.sort_order = 'unsorted';
      this.last_tickers = null;
      global_channel = this.attr.pusher.subscribe("market-global");
      market_channel = this.attr.pusher.subscribe("market-" + gon.market.id + "-global");
      global_channel.bind('tickers', (function(_this) {
        return function(data) {
          return _this.refreshTicker(data);
        };
      })(this));
      market_channel.bind('update', (function(_this) {
        return function(data) {
          gon.asks = data.asks;
          gon.bids = data.bids;
          _this.trigger('market::order_book::update', {
            asks: data.asks,
            bids: data.bids
          });
          return _this.refreshDepth({
            asks: data.asks,
            bids: data.bids
          });
        };
      })(this));
      market_channel.bind('trades', (function(_this) {
        return function(data) {
          return _this.trigger('market::trades', {
            trades: data.trades
          });
        };
      })(this));
      if (gon.ticker) {
        this.trigger('market::ticker', gon.ticker);
      }
      if (gon.tickers) {
        this.refreshTicker(gon.tickers);
      }
      if (gon.asks && gon.bids) {
        this.trigger('market::order_book::update', {
          asks: gon.asks,
          bids: gon.bids
        });
        this.refreshDepth({
          asks: gon.asks,
          bids: gon.bids
        });
      }
      if (gon.trades) {
        return this.trigger('market::trades', {
          trades: gon.trades.reverse()
        });
      }
    });
  });

}).call(this);
(function() {
  this.MarketData = flight.component(function() {
    this.load = function(event, data) {
      this.trigger('market::candlestick::request');
      return this.reqK(gon.market.id, data['x']);
    };
    this.reqK = function(market, minutes, limit) {
      var tid, url;
      if (limit == null) {
        limit = 768;
      }
      tid = gon.trades.length > 0 ? gon.trades[0].tid : 0;
      if (this.last_tid) {
        tid = this.last_tid + 1;
      }
      url = "/api/v2/k_with_pending_trades.json?market=" + market + "&limit=" + limit + "&period=" + minutes + "&trade_id=" + tid;
      return $.getJSON(url, (function(_this) {
        return function(data) {
          return _this.handleData(data, minutes);
        };
      })(this));
    };
    this.checkTrend = function(pre, cur) {
      var cur_close, pre_close, _;
      _ = cur[0], _ = cur[1], _ = cur[2], _ = cur[3], cur_close = cur[4], _ = cur[5];
      _ = pre[0], _ = pre[1], _ = pre[2], _ = pre[3], pre_close = pre[4], _ = pre[5];
      return cur_close >= pre_close;
    };
    this.createPoint = function(i, trade) {
      var gap, p, v, x, _ref;
      gap = Math.floor((trade.date - this.next_ts) / (this.minutes * 60));
      if (gap > 100) {
        console.log("failed to update, too wide gap.");
        window.clearInterval(this.interval);
        this.trigger('market::candlestick::request');
        return i;
      }
      while (trade.date >= this.next_ts) {
        x = this.next_ts * 1000;
        this.last_ts = this.next_ts;
        this.next_ts = this.last_ts + this.minutes * 60;
        _ref = trade.date < this.next_ts ? [parseFloat(trade.price), parseFloat(trade.amount)] : [this.points.close[i][1], 0], p = _ref[0], v = _ref[1];
        this.points.close.push([x, p]);
        this.points.candlestick.push([x, p, p, p, p]);
        this.points.volume.push({
          x: x,
          y: v,
          color: p >= this.points.close[i][1] ? 'rgba(0, 255, 0, 0.5)' : 'rgba(255, 0, 0, 0.5)'
        });
        i += 1;
      }
      return i;
    };
    this.updatePoint = function(i, trade) {
      var p, v;
      p = parseFloat(trade.price);
      v = parseFloat(trade.amount);
      this.points.close[i][1] = p;
      if (p > this.points.candlestick[i][2]) {
        this.points.candlestick[i][2] = p;
      } else if (p < this.points.candlestick[i][3]) {
        this.points.candlestick[i][3] = p;
      }
      this.points.candlestick[i][4] = p;
      this.points.volume[i].y += v;
      return this.points.volume[i].color = i > 0 && this.points.close[i][1] >= this.points.close[i - 1][1] ? 'rgba(0, 255, 0, 0.5)' : 'rgba(255, 0, 0, 0.5)';
    };
    this.refreshUpdatedAt = function() {
      return this.updated_at = Math.round(new Date().valueOf() / 1000);
    };
    this.processTrades = function() {
      var i;
      i = this.points.candlestick.length - 1;
      $.each(this.tradesCache, (function(_this) {
        return function(ti, trade) {
          if (trade.tid > _this.last_tid) {
            if (_this.last_ts <= trade.date && trade.date < _this.next_ts) {
              _this.updatePoint(i, trade);
            } else if (_this.next_ts <= trade.date) {
              i = _this.createPoint(i, trade);
            }
            _this.last_tid = trade.tid;
            return _this.refreshUpdatedAt();
          }
        };
      })(this));
      return this.tradesCache = [];
    };
    this.prepare = function(k) {
      var candlestick, close, close_price, cur, high, i, low, open, time, trend, vol, volume, _i, _len, _ref;
      _ref = [[], [], []], volume = _ref[0], candlestick = _ref[1], close_price = _ref[2];
      for (i = _i = 0, _len = k.length; _i < _len; i = ++_i) {
        cur = k[i];
        time = cur[0], open = cur[1], high = cur[2], low = cur[3], close = cur[4], vol = cur[5];
        time = time * 1000;
        trend = i >= 1 ? this.checkTrend(k[i - 1], cur) : true;
        close_price.push([time, close]);
        candlestick.push([time, open, high, low, close]);
        volume.push({
          x: time,
          y: vol,
          color: trend ? 'rgba(0, 255, 0, 0.5)' : 'rgba(255, 0, 0, 0.5)'
        });
      }
      return {
        minutes: this.minutes,
        candlestick: candlestick.slice(0, -1),
        volume: volume.slice(0, -1),
        close: close_price.slice(0, -1)
      };
    };
    this.handleData = function(data, minutes) {
      this.minutes = minutes;
      this.tradesCache = data.trades.concat(this.tradesCache);
      this.points = this.prepare(data.k);
      this.last_tid = 0;
      if (this.points.candlestick.length > 0) {
        this.last_ts = this.points.candlestick[this.points.candlestick.length - 1][0] / 1000;
      } else {
        this.last_ts = 0;
      }
      this.next_ts = this.last_ts + 60 * minutes;
      return this.deliverTrades('market::candlestick::response');
    };
    this.deliverTrades = function(event) {
      this.processTrades();
      this.trigger(event, {
        minutes: this.points.minutes,
        candlestick: this.points.candlestick.slice(1),
        close: this.points.close.slice(1),
        volume: this.points.volume.slice(1)
      });
      this.points.close = this.points.close.slice(-2);
      this.points.candlestick = this.points.candlestick.slice(-2);
      return this.points.volume = this.points.volume.slice(-2);
    };
    this.hardRefresh = function(threshold) {
      var ts;
      ts = Math.round(new Date().valueOf() / 1000);
      if (ts > this.updated_at + threshold) {
        this.refreshUpdatedAt();
        return this.reqK(gon.market.id, this.minutes);
      }
    };
    this.startDeliver = function(event, data) {
      var deliver;
      if (this.interval != null) {
        window.clearInterval(this.interval);
      }
      deliver = (function(_this) {
        return function() {
          if (_this.tradesCache.length > 0) {
            return _this.deliverTrades('market::candlestick::trades');
          } else {
            return _this.hardRefresh(300);
          }
        };
      })(this);
      return this.interval = setInterval(deliver, 999);
    };
    this.cacheTrades = function(event, data) {
      return this.tradesCache = Array.prototype.concat(this.tradesCache, data.trades);
    };
    return this.after('initialize', function() {
      this.tradesCache = [];
      this.on(document, 'market::trades', this.cacheTrades);
      this.on(document, 'switch::range_switch', this.load);
      return this.on(document, 'market::candlestick::created', this.startDeliver);
    });
  });

}).call(this);
(function() {
  this.MemberData = flight.component(function() {
    return this.after('initialize', function() {
      var channel;
      if (!gon.current_user) {
        return;
      }
      channel = this.attr.pusher.subscribe("private-" + gon.current_user.sn);
      channel.bind('account', (function(_this) {
        return function(data) {
          gon.accounts[data.currency] = data;
          return _this.trigger('account::update', gon.accounts);
        };
      })(this));
      channel.bind('order', (function(_this) {
        return function(data) {
          return _this.trigger("order::" + data.state, data);
        };
      })(this));
      channel.bind('trade', (function(_this) {
        return function(data) {
          return _this.trigger('trade', data);
        };
      })(this));
      this.trigger('account::update', gon.accounts);
      if (gon.my_orders) {
        this.trigger('order::wait::populate', {
          orders: gon.my_orders
        });
      }
      if (gon.my_trades) {
        return this.trigger('trade::populate', {
          trades: gon.my_trades
        });
      }
    });
  });

}).call(this);
(function() {
  this.PlaceOrderData = flight.component(function() {
    this.onInput = function(event, data) {
      var _ref;
      _ref = data.variables, this.input = _ref.input, this.known = _ref.known, this.output = _ref.output;
      this.order[this.input] = data.value;
      if (!(this.order[this.input] && this.order[this.known])) {
        return;
      }
      return this.trigger("place_order::output::" + this.output, this.order);
    };
    this.onReset = function(event, data) {
      var _ref;
      _ref = data.variables, this.input = _ref.input, this.known = _ref.known, this.output = _ref.output;
      this.order[this.input] = this.order[this.output] = null;
      this.trigger("place_order::reset::" + this.output);
      return this.trigger("place_order::order::updated", this.order);
    };
    this.onUpdateOrder = function(event, data) {
      return this.order = data;
    };
    return this.after('initialize', function() {
      this.order = {
        price: null,
        volume: null,
        total: null
      };
      this.on('place_order::input', this.onInput);
      this.on('place_order::reset', this.onReset);
      return this.on('place_order::order::total', this.onUpdateOrder);
    });
  });

}).call(this);
(function() {
  this.AccountBalanceUI = flight.component(function() {
    this.updateAccount = function(event, data) {
      var account, currency, symbol, total, _results;
      _results = [];
      for (currency in data) {
        account = data[currency];
        symbol = gon.currencies[currency].symbol || '';
        this.$node.find(".account." + currency + " span.balance").text("" + account.balance);
        this.$node.find(".account." + currency + " span.locked").text("" + account.locked);
        total = (new BigNumber(account.locked)).plus(new BigNumber(account.balance));
        _results.push(this.$node.find(".account." + currency + " span.total").text("" + symbol + (formatter.round(total, 2))));
      }
      return _results;
    };
    this.updateTotalAssets = function(event, data) {
      var account, currency, fiatCurrency, sum, symbol, ticker;
      fiatCurrency = gon.fiat_currency;
      symbol = gon.currencies[fiatCurrency].symbol;
      sum = 0;
      for (currency in data) {
        account = data[currency];
        if (currency === fiatCurrency) {
          sum += +account.balance;
          sum += +account.locked;
        } else if (ticker = gon.tickers["" + currency + fiatCurrency]) {
          sum += +account.balance * +ticker.last;
          sum += +account.locked * +ticker.last;
        }
      }
      return this.$node.find(".total-assets").text("  " + symbol + " " + (formatter.round(sum, 2)));
    };
    return this.after('initialize', function() {
      this.on(document, 'account::update', this.updateAccount);
      return this.on(document, 'account::update', this.updateTotalAssets);
    });
  });

}).call(this);
(function() {
  this.AccountSummaryUI = flight.component(function() {
    this.attributes({
      total_assets: '#total_assets'
    });
    this.updateAccount = function(event, data) {
      var account, amount, currency, _results;
      _results = [];
      for (currency in data) {
        account = data[currency];
        amount = (new BigNumber(account.locked)).plus(new BigNumber(account.balance));
        this.$node.find("tr." + currency + " span.amount").text(formatter.round(amount, 4));
        _results.push(this.$node.find("tr." + currency + " span.locked").text(formatter.round(account.locked, 4)));
      }
      return _results;
    };
    this.updateTotalAssets = function() {
      var account, available, currency, fiatCurrency, sum, symbol, ticker, _ref;
      fiatCurrency = gon.fiat_currency;
      symbol = gon.currencies[fiatCurrency].symbol;
      sum = 0;
      available = 0;
      _ref = this.accounts;
      for (currency in _ref) {
        account = _ref[currency];
        if (currency === fiatCurrency) {
          available += +account.balance;
          sum += +account.balance;
          sum += +account.locked;
        } else if (ticker = this.tickers["" + currency + fiatCurrency]) {
          available += +account.balance * +ticker.last;
          sum += +account.balance * +ticker.last;
          sum += +account.locked * +ticker.last;
        }
      }
      return this.select('total_assets').text("" + (formatter.round(sum, 1)) + "/" + (formatter.round(available, 1)));
    };
    return this.after('initialize', function() {
      this.accounts = gon.accounts;
      this.tickers = gon.tickers;
      this.on(document, 'account::update', this.updateAccount);
      this.on(document, 'account::update', (function(_this) {
        return function(event, data) {
          _this.accounts = data;
          return _this.updateTotalAssets();
        };
      })(this));
      return this.on(document, 'market::tickers', (function(_this) {
        return function(event, data) {
          _this.tickers = data.raw;
          return _this.updateTotalAssets();
        };
      })(this));
    });
  });

}).call(this);
(function() {
  var BORDER_WIDTH, CANDLESTICK_MIN_HEIGHT, CANDLESTICK_MIN_HEIGHT_SPLIT, CANDLESTICK_MIN_WIDTH, GUTTER, ORDER_BOOK_MIN_HEIGHT, PANEL_MARKETS_SEARCH_HIGH, PANEL_PADDING, PANEL_TABLE_HEADER_HIGH, TOTAL_MIN_HEIGHT, TOTAL_MIN_HEIGHT_SPLIT, TOTAL_MIN_WIDTH, TOTAL_MIN_WIDTH_PINNED, TOTAL_MIN_WIDTH_SPLIT;

  GUTTER = 2;

  PANEL_TABLE_HEADER_HIGH = 37;

  PANEL_MARKETS_SEARCH_HIGH = 42;

  PANEL_PADDING = 8;

  BORDER_WIDTH = 1;

  ORDER_BOOK_MIN_HEIGHT = 214;

  CANDLESTICK_MIN_WIDTH = 685;

  CANDLESTICK_MIN_HEIGHT = 700;

  CANDLESTICK_MIN_HEIGHT_SPLIT = 424;

  TOTAL_MIN_HEIGHT = 850;

  TOTAL_MIN_HEIGHT_SPLIT = 670;

  TOTAL_MIN_WIDTH = 1440;

  TOTAL_MIN_WIDTH_SPLIT = 1356;

  TOTAL_MIN_WIDTH_PINNED = 1664;

  this.AutoWindowUI = flight.component(function() {
    return this.after('initialize', function() {
      var candlestick_min_height, candlestick_min_height_split, candlestick_min_width, gutter, gutter_2x, gutter_3x, gutter_4x, gutter_5x, gutter_6x, gutter_7x, gutter_8x, gutter_9x, order_book_min_height, panel_markets_search_high, panel_table_header_high, total_min_height, total_min_height_split, total_min_width, total_min_width_pinned, total_min_width_split;
      gutter = GUTTER;
      gutter_2x = GUTTER * 2;
      gutter_3x = GUTTER * 3;
      gutter_4x = GUTTER * 4;
      gutter_5x = GUTTER * 5;
      gutter_6x = GUTTER * 6;
      gutter_7x = GUTTER * 7;
      gutter_8x = GUTTER * 8;
      gutter_9x = GUTTER * 9;
      panel_table_header_high = PANEL_TABLE_HEADER_HIGH;
      panel_markets_search_high = PANEL_MARKETS_SEARCH_HIGH;
      order_book_min_height = ORDER_BOOK_MIN_HEIGHT;
      candlestick_min_width = CANDLESTICK_MIN_WIDTH;
      candlestick_min_height = CANDLESTICK_MIN_HEIGHT;
      candlestick_min_height_split = CANDLESTICK_MIN_HEIGHT_SPLIT;
      total_min_height = TOTAL_MIN_HEIGHT;
      total_min_height_split = TOTAL_MIN_HEIGHT_SPLIT;
      total_min_width = TOTAL_MIN_WIDTH;
      total_min_width_pinned = TOTAL_MIN_WIDTH_PINNED;
      total_min_width_split = TOTAL_MIN_WIDTH_SPLIT;
      this.$node.resize(function() {
        var content_min_width, current_min_height, depths_h, entry_h, markets_h, markets_inner_h, markets_w, my_orders_h, navbar_h, need_rearrange, order_book_w, order_h, ticker_h, trades_h, trades_top, window_h, window_h_syntetic, window_w;
        navbar_h = $('.navbar').height() + BORDER_WIDTH;
        markets_h = $('#market_list').height() + 2 * BORDER_WIDTH;
        entry_h = $('#ask_entry').height() + 2 * BORDER_WIDTH;
        depths_h = $('#depths_wrapper').height() + 2 * BORDER_WIDTH;
        my_orders_h = $('#my_orders').height() + 2 * BORDER_WIDTH;
        ticker_h = $('#ticker').height() + 2 * BORDER_WIDTH;
        content_min_width = total_min_width_split;
        if (gon.markets_pinned === 'true') {
          total_min_width = total_min_width_pinned;
          content_min_width = total_min_width_pinned;
        }
        $("#markets-show").css("min-width", content_min_width);
        $("#wrap").find(".content").css("min-width", content_min_width);
        window_h = $(this).height();
        $('.content').height(window_h - navbar_h);
        current_min_height = total_min_height;
        order_h = order_book_min_height;
        $('#order_book').css("min-height", order_book_min_height);
        need_rearrange = false;
        if (window.innerWidth <= total_min_width || window.innerHeight < total_min_height_split || (window.innerHeight >= total_min_height_split && window.innerHeight < total_min_height && window.innerWidth > total_min_width)) {
          $('#my_orders').css("min-height", 206);
          $('#my_orders').css("height", 206);
          my_orders_h = $('#my_orders').height();
          order_h = window_h - navbar_h - depths_h - my_orders_h - ticker_h - gutter_6x - 2 * BORDER_WIDTH;
          current_min_height = total_min_height_split;
          need_rearrange = true;
        } else {
          $('#my_orders').css("min-height", 180);
          $('#my_orders').css("height", 180);
          my_orders_h = $('#my_orders').height();
          order_h = window_h - navbar_h - entry_h - depths_h - my_orders_h - ticker_h - gutter_6x - 2 * BORDER_WIDTH;
        }
        if (order_h < order_book_min_height) {
          order_h = order_book_min_height;
        }
        $('#order_book').css("min-height", order_book_min_height);
        $('#order_book').height(order_h);
        $('#order_book .panel-body-content').height(order_h - panel_table_header_high - 2 * PANEL_PADDING);
        $('#ticker').css("top", order_h + gutter_3x);
        $('#depths_wrapper').css("top", order_h + ticker_h + gutter_4x);
        $('#my_orders').css("top", order_h + ticker_h + depths_h + gutter_5x);
        window_w = window.innerWidth;
        markets_w = $('#market_list').width();
        order_book_w = $('#order_book').width();
        $('#market_list .panel panel-default').width(markets_w);
        if (gon.markets_pinned === 'false') {
          $('#candlestick').width(window_w - order_book_w - gutter_2x - 20);
        } else {
          $('#candlestick').width(window_w - order_book_w - markets_w - gutter_4x - 20);
        }
        $('#candlestick').css("min-width", candlestick_min_width);
        $('#candlestick').height(window_h - navbar_h - gutter_3x);
        if (need_rearrange) {
          $('#candlestick').css("min-height", candlestick_min_height_split);
          $('#candlestick').css("height", $('#candlestick').height() - $('.entry-left').height() - gutter_2x);
          $('.entry-right').css("left", ($('#candlestick').position().left + $('#candlestick').width() / 2) - ($('.entry-right').width()));
          $('.entry-right').css("top", $('#candlestick').height() + gutter_3x);
          $('.entry-left').css("left", $('.entry-right').position().left + $('.entry-right').width() + gutter_2x);
          $('.entry-left').css("top", $('#candlestick').height() + gutter_3x);
          $('#my_orders_wrapper').find(".dropdown-wrapper").css("top", $('#candlestick').height() + gutter_3x);
        } else {
          if (window.innerHeight >= total_min_height_split) {
            $('#candlestick').css("min-height", candlestick_min_height);
            $('.entry-left').css("left", "");
            $('.entry-left').css("right", 2);
            $('.entry-left').css("top", order_h + ticker_h + depths_h + my_orders_h + gutter_7x);
            $('.entry-right').css("left", "");
            $('.entry-right').css("right", $('.entry-left').width() + gutter_2x + 2);
            $('.entry-right').css("top", order_h + ticker_h + depths_h + my_orders_h + gutter_7x);
            $('#my_orders_wrapper').find(".dropdown-wrapper").css("top", $('#depths_wrapper').position().top + $('#depths_wrapper').height() + gutter_2x);
          }
        }
        if (true) {
          window_h_syntetic = navbar_h + $('#candlestick').height() + $('.entry-left').height() + gutter_4x;
          if (!need_rearrange) {
            window_h_syntetic = navbar_h + $('#candlestick').height() + gutter_3x;
          }
          markets_h = (window_h_syntetic - navbar_h) / 2;
          markets_inner_h = markets_h - (panel_table_header_high + panel_markets_search_high);
          $('#market_list').css("min-height", markets_h);
          $('#market_list').height(markets_h);
          $('#market_list').find(".panel-default").css("min-height", markets_h);
          $('#market_list').find(".panel-default").height(markets_h);
          $('#market_list').find(".panel-body-content").css("min-height", markets_inner_h);
          $('#market_list').find(".panel-body-content").height(markets_inner_h - 16);
          markets_h = $('#market_list').height() + 2 * BORDER_WIDTH;
          trades_h = window_h_syntetic - navbar_h - markets_h - gutter_2x - 2 * BORDER_WIDTH;
          trades_top = markets_h + 2 * BORDER_WIDTH;
          if (gon.markets_pinned === 'true') {
            trades_top += 2;
          }
          $('#market_trades').css("top", trades_top);
          $('#market_trades').height(trades_h);
          $('#market_trades .panel').height(trades_h - 2 * BORDER_WIDTH);
          $('#market_trades .panel-body-content').height(trades_h - 2 * BORDER_WIDTH - panel_table_header_high - 2 * PANEL_PADDING);
          $("[href='#left_side_content']").css("right", 200 - ((window_h_syntetic - navbar_h) / 2 + 70 / 2));
        }
        if (gon.markets_pinned === 'true') {
          return $('#market_trades_wrapper').find(".dropdown-wrapper").css("top", trades_top + panel_table_header_high);
        } else {
          return $('#market_trades_wrapper').find(".dropdown-wrapper").css("top", trades_top + panel_table_header_high + 35);
        }
      });
      return this.$node.resize();
    });
  });

}).call(this);
(function() {
  var CANDLESTICK_IDX, CLOSE_IDX, COLOR, COLOR_OFF, COLOR_ON, DATETIME_LABEL_FORMAT, DATETIME_LABEL_FORMAT_FOR_TOOLTIP, EMA30_IDX, EMA7_IDX, HIST_IDX, HIST_INDICATOR, INDICATOR, LEGEND_INDICATOR, MA10_IDX, MA5_IDX, MACD_IDX, MACD_INDICATOR, RANGE_DEFAULT, SIG_IDX, SIG_INDICATOR, VOLUME_IDX;

  if (gon.local === "zh-CN") {
    DATETIME_LABEL_FORMAT_FOR_TOOLTIP = {
      millisecond: ['%m%e, %H:%M:%S.%L', '%m%e, %H:%M:%S.%L', '-%H:%M:%S.%L'],
      second: ['%m%e, %H:%M:%S', '%m%e, %H:%M:%S', '-%H:%M:%S'],
      minute: ['%m%e, %H:%M', '%m%e, %H:%M', '-%H:%M'],
      hour: ['%m%e, %H:%M', '%m%e, %H:%M', '-%H:%M'],
      day: ['%m%e, %H:%M', '%m%e, %H:%M', '-%H:%M'],
      week: ['%Y%m%e', '%Y%m%e', '-%m%e'],
      month: ['%Y%m', '%Y%m', '-%m'],
      year: ['%Y', '%Y', '-%Y']
    };
  }

  DATETIME_LABEL_FORMAT = {
    second: '%H:%M:%S',
    minute: '%H:%M',
    hour: '%H:%M',
    day: '%m-%d',
    week: '%m-%d',
    month: '%Y-%m',
    year: '%Y'
  };

  RANGE_DEFAULT = {
    fill: 'none',
    stroke: 'none',
    'stroke-width': 0,
    r: 8,
    style: {
      color: '#333'
    },
    states: {
      hover: {
        fill: '#000',
        style: {
          color: '#ccc'
        }
      },
      select: {
        fill: '#000',
        style: {
          color: '#eee'
        }
      }
    }
  };

  COLOR_ON = {
    candlestick: {
      color: '#990f0f',
      upColor: '#116d0d',
      lineColor: '#cc1414',
      upLineColor: '#49c043'
    },
    close: {
      color: null
    }
  };

  COLOR_OFF = {
    candlestick: {
      color: 'invalid',
      upColor: 'invalid',
      lineColor: 'invalid',
      upLineColor: 'invalid'
    },
    close: {
      color: 'invalid'
    }
  };

  COLOR = {
    candlestick: _.extend({}, COLOR_OFF.candlestick),
    close: _.extend({}, COLOR_OFF.close)
  };

  INDICATOR = {
    MA: false,
    EMA: false,
    OFF: false
  };

  MACD_INDICATOR = {
    MACD: false,
    OFF: false
  };

  SIG_INDICATOR = {
    SIG: false,
    OFF: false
  };

  HIST_INDICATOR = {
    HIST: false,
    OFF: false
  };

  LEGEND_INDICATOR = {
    Legend: false,
    OFF: false
  };

  VOLUME_IDX = 0;

  MA5_IDX = 1;

  MA10_IDX = 2;

  EMA7_IDX = 3;

  EMA30_IDX = 4;

  MACD_IDX = 5;

  SIG_IDX = 6;

  HIST_IDX = 7;

  CANDLESTICK_IDX = 8;

  CLOSE_IDX = 9;

  this.CandlestickUI = flight.component(function() {
    this.mask = function() {
      return this.$node.find('.mask').show();
    };
    this.unmask = function() {
      return this.$node.find('.mask').hide();
    };
    this.request = function() {
      return this.mask();
    };
    this.init = function(event, data) {
      var _ref;
      this.running = true;
      if ((_ref = this.$node.find('#candlestick_chart').highcharts()) != null) {
        _ref.destroy();
      }
      this.initHighStock(data);
      this.adjustChart();
      return this.trigger('market::candlestick::created', data);
    };
    this.switchType = function(event, data) {
      var chart, colors, key, s, type, val, _i, _len, _ref;
      for (key in COLOR) {
        val = COLOR[key];
        _.extend(COLOR[key], COLOR_OFF[key]);
      }
      _.extend(COLOR[data.x], COLOR_ON[data.x]);
      if (chart = this.$node.find('#candlestick_chart').highcharts()) {
        for (type in COLOR) {
          colors = COLOR[type];
          _ref = chart.series;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            s = _ref[_i];
            if ((s.userOptions.algorithm == null) && (s.userOptions.id === type)) {
              s.update(colors, false);
            }
          }
        }
        return this.trigger("switch::main_indicator_switch::init");
      }
    };
    this.switchMainIndicator = function(event, data) {
      var chart, indicator, key, s, val, visible, _i, _j, _len, _len1, _ref, _ref1;
      for (key in INDICATOR) {
        val = INDICATOR[key];
        INDICATOR[key] = false;
      }
      INDICATOR[data.x] = true;
      if (chart = this.$node.find('#candlestick_chart').highcharts()) {
        _ref = chart.series;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          s = _ref[_i];
          if (s.userOptions.innerGroup === 'main') {
            s.setVisible(true, false);
          }
        }
        for (indicator in INDICATOR) {
          visible = INDICATOR[indicator];
          _ref1 = chart.series;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            s = _ref1[_j];
            if ((s.userOptions.algorithm != null) && (s.userOptions.algorithm === indicator)) {
              s.setVisible(visible, false);
            }
          }
        }
        return chart.redraw();
      }
    };
    this.adjustChart = function() {
      var chart;
      if (chart = this.$node.find('#candlestick_chart').highcharts()) {
        if (MACD_INDICATOR['MACD']) {
          chart.yAxis[2].update({
            height: "15%",
            top: "85%"
          });
          chart.yAxis[1].update({
            height: "15%",
            top: "70%"
          });
          chart.yAxis[0].update({
            height: "70%"
          });
        } else {
          chart.yAxis[2].update({
            height: "0%"
          });
          chart.yAxis[1].update({
            height: "15%",
            top: "85%"
          });
          chart.yAxis[0].update({
            height: "85%"
          });
        }
        return chart.redraw();
      }
    };
    this.switchMACDIndicator = function(event, data) {
      var chart, key, s, val, _i, _len, _ref, _results;
      for (key in MACD_INDICATOR) {
        val = MACD_INDICATOR[key];
        MACD_INDICATOR[key] = false;
      }
      MACD_INDICATOR[data.x] = true;
      if (chart = this.$node.find('#candlestick_chart').highcharts()) {
        _ref = chart.series;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          s = _ref[_i];
          if (s.userOptions.innerGroup === 'macd') {
            s.setVisible(MACD_INDICATOR['MACD'], false);
            _results.push(this.adjustChart());
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }
    };
    this.switchLegendIndicator = function(event, data) {
      var key, val;
      for (key in LEGEND_INDICATOR) {
        val = LEGEND_INDICATOR[key];
        LEGEND_INDICATOR[key] = false;
      }
      return LEGEND_INDICATOR[data.x] = true;
    };
    this.default_range = function(unit) {
      return 1000 * 60 * unit * 100;
    };
    this.initHighStock = function(data, tooltipEnabled) {
      var component, dataGrouping, range, timeUnits, title, tooltipTemplate, unit;
      component = this;
      range = this.default_range(data['minutes']);
      unit = $("[data-unit=" + data['minutes'] + "]").text();
      title = "" + (gon.market.base_unit.toUpperCase()) + "/" + (gon.market.quote_unit.toUpperCase()) + " - " + unit;
      timeUnits = {
        millisecond: 1,
        second: 1000,
        minute: 60000,
        hour: 3600000,
        day: 24 * 3600000,
        week: 7 * 24 * 3600000,
        month: 31 * 24 * 3600000,
        year: 31556952000
      };
      dataGrouping = {
        enabled: false
      };
      tooltipTemplate = JST["templates/tooltip"];
      if (DATETIME_LABEL_FORMAT_FOR_TOOLTIP) {
        dataGrouping['dateTimeLabelFormats'] = DATETIME_LABEL_FORMAT_FOR_TOOLTIP;
      }
      return this.$node.find('#candlestick_chart').highcharts("StockChart", {
        chart: {
          events: {
            load: (function(_this) {
              return function() {
                return _this.unmask();
              };
            })(this)
          },
          animation: true,
          marginTop: 95,
          backgroundColor: 'rgba(0,0,0, 0.0)'
        },
        mapNavigation: {
          enableMouseWheelZoom: true
        },
        credits: {
          enabled: false
        },
        tooltip: {
          enabled: true,
          valueDecimals: gon.market.bid.fixed,
          borderWidth: 0,
          backgroundColor: 'rgba(0,0,0,0)',
          borderRadius: 2,
          shadow: false,
          shared: true,
          split: false,
          positioner: function(w, h, point) {
            var chart_h, chart_w, grid_h, x, y;
            chart_w = $(this.chart.renderTo).width();
            chart_h = $(this.chart.renderTo).height();
            grid_h = Math.min(20, Math.ceil(chart_h / 10));
            if (LEGEND_INDICATOR['Legend'] === true) {
              x = 5;
            } else {
              x = -800;
              this.hide();
            }
            y = 5;
            return {
              x: x,
              y: y
            };
          },
          useHTML: true,
          formatter: function() {
            var chart, dateFormat, dateTimeLabelFormats, fun, index, k, key, series, v;
            chart = this.points[0].series.chart;
            series = this.points[0].series;
            index = this.points[0].point.index;
            key = this.points[0].key;
            for (k in timeUnits) {
              v = timeUnits[k];
              if (v >= series.xAxis.closestPointRange || (v <= timeUnits.day && key % v > 0)) {
                dateFormat = dateTimeLabelFormats = series.options.dataGrouping.dateTimeLabelFormats[k][0];
                title = Highcharts.dateFormat(dateFormat, key);
                break;
              }
            }
            fun = function(h, s) {
              h[s.options.id] = s.data[index];
              return h;
            };
            return tooltipTemplate({
              title: title,
              indicator: INDICATOR,
              macd_indicator: MACD_INDICATOR,
              format: function(v, fixed) {
                if (fixed == null) {
                  fixed = 3;
                }
                return formatter.fixPriceGroup(parseFloat(v));
              },
              format4: function(v, fixed) {
                if (fixed == null) {
                  fixed = 4;
                }
                if (fixed > 4) {
                  return formatter.round(v, 4);
                } else {
                  return formatter.round(v, fixed);
                }
              },
              points: _.reduce(chart.series, fun, {})
            });
          }
        },
        plotOptions: {
          candlestick: {
            turboThreshold: 0,
            followPointer: true,
            color: '#990f0f',
            upColor: '#000000',
            lineColor: '#cc1414',
            upLineColor: '#49c043',
            dataGrouping: dataGrouping
          },
          column: {
            turboThreshold: 0,
            dataGrouping: dataGrouping
          },
          trendline: {
            lineWidth: 1
          },
          histogram: {
            lineWidth: 1,
            tooltip: {
              pointFormat: "<li><span style='color: {series.color};'>{series.name}: <b>{point.y}</b></span></li>"
            }
          }
        },
        scrollbar: {
          buttonArrowColor: '#333',
          barBackgroundColor: '#202020',
          buttonBackgroundColor: '#202020',
          trackBackgroundColor: '#202020',
          barBorderColor: '#2a2a2a',
          buttonBorderColor: '#2a2a2a',
          trackBorderColor: '#2a2a2a'
        },
        rangeSelector: {
          enabled: false
        },
        navigator: {
          maskFill: 'rgba(32, 32, 32, 0.6)',
          outlineColor: '#333',
          outlineWidth: 1,
          baseSeries: 'candlestick',
          series: {
            color: '#306196'
          },
          xAxis: {
            dateTimeLabelFormats: DATETIME_LABEL_FORMAT
          }
        },
        xAxis: {
          type: 'datetime',
          dateTimeLabelFormats: DATETIME_LABEL_FORMAT,
          lineColor: '#333',
          tickColor: '#333',
          tickWidth: 2,
          range: range,
          maxPadding: 1,
          crosshair: {
            snap: false,
            width: 0.5,
            dashStyle: 'solid',
            color: '#777',
            interpolate: true,
            label: {
              enabled: true,
              formatter: function(val) {
                return Highcharts.dateFormat('%a %d %b %H:%M:%S', val);
              },
              backgroundColor: '#2b3434',
              style: {
                color: '#aaa'
              }
            }
          },
          events: {
            afterSetExtremes: function(e) {
              if (e.trigger === 'navigator' && e.triggerOp === 'navigator-drag') {
                if (component.liveRange(this.chart) && !component.running) {
                  return component.trigger("switch::range_switch::init");
                }
              }
            }
          }
        },
        yAxis: [
          {
            labels: {
              enabled: true,
              align: 'left',
              reserveSpace: true,
              formatter: function() {
                return formatter.fixPriceGroup(this.value);
              },
              x: 2,
              y: -5
            },
            gridLineColor: '#222',
            gridLineDashStyle: 'ShortDot',
            top: "0%",
            height: "85%",
            lineColor: '#fff',
            min: null,
            tickPositioner: function() {
              var currentTick, dataMax, dataMin, i, maxDeviation, prevTick, step, threshold, tickArray, ticks, _i;
              maxDeviation = this.dataMax - this.dataMin;
              dataMin = this.dataMin;
              dataMax = this.dataMax;
              ticks = 10.0;
              threshold = 0.000000010;
              if (maxDeviation <= threshold) {
                maxDeviation = threshold;
                if (dataMin - maxDeviation / 2.0 < 0.000000000) {
                  dataMin = 0.000000000;
                } else {
                  if (dataMin + threshold > dataMax) {
                    dataMin -= ((dataMin + threshold) - dataMax) / 2.0;
                  }
                }
              }
              step = maxDeviation / ticks;
              tickArray = [];
              prevTick = 0.000000000;
              currentTick = dataMin;
              for (i = _i = 0; 0 <= ticks ? _i <= ticks : _i >= ticks; i = 0 <= ticks ? ++_i : --_i) {
                if (currentTick - prevTick >= 0.0000000005) {
                  tickArray.push(currentTick);
                  prevTick = currentTick;
                }
                currentTick += step;
              }
              return tickArray;
            },
            crosshair: {
              snap: false,
              interpolate: true,
              width: 0.5,
              dashStyle: 'solid',
              color: '#777',
              label: {
                enabled: true,
                formatter: function(v) {
                  return formatter.fixPriceGroup(parseFloat(v));
                },
                backgroundColor: '#2b3434',
                style: {
                  color: '#aaa'
                }
              }
            }
          }, {
            labels: {
              enabled: true,
              align: 'left',
              x: -73,
              y: -5
            },
            top: "85%",
            gridLineColor: '#222',
            gridLineDashStyle: 'ShortDot',
            height: "15%",
            crosshair: {
              snap: false,
              width: 0.5,
              dashStyle: 'solid',
              color: '#777',
              label: {
                enabled: true,
                format: '{value:.4f}',
                backgroundColor: '#2b3434',
                style: {
                  color: '#aaa'
                }
              }
            }
          }, {
            labels: {
              enabled: false
            },
            top: "85%",
            gridLineColor: '#000',
            height: "0%"
          }
        ],
        series: [
          {
            id: 'volume',
            name: gon.i18n.chart.volume,
            yAxis: 1,
            type: "column",
            data: data['volume'],
            color: '#777',
            showInLegend: false
          }, {
            id: 'ma5',
            name: 'MA5',
            linkedTo: 'close',
            innerGroup: 'main',
            showInLegend: true,
            type: 'trendline',
            algorithm: 'MA',
            periods: 5,
            color: '#7c9aaa',
            visible: INDICATOR['MA'],
            zIndex: 1,
            marker: {
              radius: 0
            }
          }, {
            id: 'ma10',
            name: 'MA10',
            linkedTo: 'close',
            innerGroup: 'main',
            showInLegend: true,
            type: 'trendline',
            algorithm: 'MA',
            periods: 10,
            color: '#be8f53',
            visible: INDICATOR['MA'],
            zIndex: 2,
            marker: {
              radius: 0
            }
          }, {
            id: 'ema7',
            name: 'EMA7',
            linkedTo: 'close',
            innerGroup: 'main',
            showInLegend: true,
            type: 'trendline',
            algorithm: 'EMA',
            periods: 7,
            color: '#7c9aaa',
            visible: INDICATOR['EMA'],
            zIndex: 3,
            marker: {
              radius: 0
            }
          }, {
            id: 'ema30',
            name: 'EMA30',
            linkedTo: 'close',
            innerGroup: 'main',
            showInLegend: true,
            type: 'trendline',
            algorithm: 'EMA',
            periods: 30,
            color: '#be8f53',
            visible: INDICATOR['EMA'],
            zIndex: 4,
            marker: {
              radius: 0
            }
          }, {
            id: 'macd',
            name: 'MACD',
            linkedTo: 'close',
            innerGroup: 'macd',
            yAxis: 2,
            showInLegend: true,
            type: 'trendline',
            algorithm: 'MACD',
            color: '#7c9aaa',
            visible: MACD_INDICATOR['MACD'],
            zIndex: 5,
            marker: {
              radius: 0
            }
          }, {
            id: 'sig',
            name: 'SIG',
            linkedTo: 'close',
            innerGroup: 'macd',
            yAxis: 2,
            showInLegend: true,
            type: 'trendline',
            algorithm: 'signalLine',
            color: '#be8f53',
            visible: MACD_INDICATOR['MACD'],
            zIndex: 6,
            marker: {
              radius: 0
            }
          }, {
            id: 'hist',
            name: 'HIST',
            linkedTo: 'close',
            innerGroup: 'macd',
            yAxis: 2,
            showInLegend: true,
            type: 'histogram',
            visible: MACD_INDICATOR['MACD'],
            zIndex: 7,
            color: '#990f0f'
          }, _.extend({
            id: 'candlestick',
            name: gon.i18n.chart.candlestick,
            type: "candlestick",
            data: data['candlestick'],
            showInLegend: false,
            zIndex: 0
          }, COLOR['candlestick']), _.extend({
            id: 'close',
            type: 'spline',
            data: data['close'],
            showInLegend: false,
            marker: {
              radius: 0
            }
          }, COLOR['close'])
        ]
      });
    };
    this.formatPointArray = function(point) {
      return {
        x: point[0],
        open: point[1],
        high: point[2],
        low: point[3],
        close: point[4]
      };
    };
    this.createPointOnSeries = function(chart, i, px, point) {
      return chart.series[i].addPoint(point, false, true);
    };
    this.createPoint = function(chart, data, i) {
      this.createPointOnSeries(chart, CANDLESTICK_IDX, data.candlestick[i][0], data.candlestick[i]);
      this.createPointOnSeries(chart, CLOSE_IDX, data.close[i][0], data.close[i]);
      this.createPointOnSeries(chart, VOLUME_IDX, data.volume[i].x, data.volume[i]);
      return chart.redraw(true);
    };
    this.updatePointOnSeries = function(chart, i, px, point) {
      var last;
      if (chart.series[i].points) {
        last = chart.series[i].points[chart.series[i].points.length - 1];
        if (px === last.x) {
          return last.update(point, true);
        } else {
          return console.log("Error update on series " + i + ": px=" + px + " lastx=" + last.x);
        }
      }
    };
    this.updatePoint = function(chart, data, i) {
      this.updatePointOnSeries(chart, CANDLESTICK_IDX, data.candlestick[i][0], data.candlestick[i]);
      this.updatePointOnSeries(chart, CLOSE_IDX, data.close[i][0], data.close[i][1]);
      this.updatePointOnSeries(chart, VOLUME_IDX, data.volume[i].x, data.volume[i]);
      return chart.redraw(true);
    };
    this.process = function(chart, data) {
      var current, current_point, i, _i, _ref, _results;
      _results = [];
      for (i = _i = 0, _ref = data.candlestick.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        current = chart.series[CANDLESTICK_IDX].points.length - 1;
        current_point = chart.series[CANDLESTICK_IDX].points[current];
        if (data.candlestick[i][0] > current_point.x) {
          _results.push(this.createPoint(chart, data, i));
        } else {
          _results.push(this.updatePoint(chart, data, i));
        }
      }
      return _results;
    };
    this.updateByTrades = function(event, data) {
      var chart;
      chart = this.$node.find('#candlestick_chart').highcharts();
      if (this.liveRange(chart)) {
        return this.process(chart, data);
      } else {
        return this.running = false;
      }
    };
    this.liveRange = function(chart) {
      return true;
    };
    return this.after('initialize', function() {
      this.on(document, 'market::candlestick::request', this.request);
      this.on(document, 'market::candlestick::response', this.init);
      this.on(document, 'market::candlestick::trades', this.updateByTrades);
      this.on(document, 'switch::legend_indicator_switch', this.switchLegendIndicator);
      this.on(document, 'switch::main_indicator_switch', this.switchMainIndicator);
      this.on(document, 'switch::indicator_switch', this.switchMACDIndicator);
      return this.on(document, 'switch::type_switch', this.switchType);
    });
  });

}).call(this);
(function() {
  this.DepthUI = flight.component(function() {
    this.attributes({
      chart: '#depths'
    });
    this.refresh = function(event, data) {
      var chart;
      chart = this.select('chart').highcharts();
      chart.series[0].setData(data.bids, false);
      chart.series[1].setData(data.asks, false);
      return chart.redraw();
    };
    this.initChart = function(data) {
      return this.select('chart').highcharts({
        chart: {
          margin: 0,
          height: 148,
          backgroundColor: 'rgba(0,0,0,0)',
          type: 'area'
        },
        title: {
          text: ''
        },
        credits: {
          enabled: false
        },
        legend: {
          enabled: false
        },
        rangeSelector: {
          enabled: false
        },
        xAxis: [
          {
            type: 'logarithmic',
            width: '50%',
            labels: {
              enabled: false
            }
          }, {
            type: 'logarithmic',
            offset: 0,
            left: '50%',
            labels: {
              enabled: false
            },
            width: '50%'
          }
        ],
        yAxis: {
          min: 0,
          gridLineColor: '#333',
          gridLineDashStyle: 'ShortDot',
          title: {
            text: ''
          },
          labels: {
            enabled: false
          }
        },
        plotOptions: {
          area: {
            softThreshold: true,
            threshold: 0
          }
        },
        tooltip: {
          valueDecimals: 4,
          headerFormat: "<table class=depths-table><tr>\n  <th><span>{series.name}</span> " + gon.i18n.chart.price + "</th><th>" + gon.i18n.chart.depth + "</th>\n</tr>",
          pointFormatter: function() {
            return '<tr><td>' + this.x.toFixed(9) + '</td><td>' + this.y.toFixed(1) + '</td></tr>';
          },
          footerFormat: '</table>',
          borderWidth: 0,
          backgroundColor: 'rgba(0,0,0,0)',
          borderRadius: 0,
          shadow: false,
          useHTML: true,
          shared: true,
          positioner: function() {
            return {
              x: 200,
              y: 3
            };
          }
        },
        series: [
          {
            name: gon.i18n.bid,
            fillColor: 'rgba(77, 215, 16, 0.5)',
            lineColor: 'rgb(77, 215, 16)',
            color: 'transparent',
            xAxis: 0,
            animation: {
              duration: 1000
            }
          }, {
            name: gon.i18n.ask,
            animation: {
              duration: 1000
            },
            fillColor: 'rgba(208, 0, 23, 0.3)',
            lineColor: 'rgb(208, 0, 23)',
            color: 'transparent',
            xAxis: 1
          }
        ]
      });
    };
    return this.after('initialize', function() {
      this.initChart();
      this.on(document, 'market::depth::response', this.refresh);
      this.on(document, 'market::depth::fade_toggle', function() {
        return this.$node.fadeToggle();
      });
      return this.on(this.select('close'), 'click', (function(_this) {
        return function() {
          return _this.trigger('market::depth::fade_toggle');
        };
      })(this));
    });
  });

}).call(this);
(function() {
  this.FlashMessageUI = flight.component(function() {
    this.showMeg = function(data) {
      var template;
      this.$node.html("");
      template = JST['templates/flash_message'](data);
      return $(template).prependTo(this.$node);
    };
    this.info = function(event, data) {
      data.info = true;
      return this.showMeg(data);
    };
    this.notice = function(event, data) {
      data.notice = true;
      return this.showMeg(data);
    };
    this.alert = function(event, data) {
      data.alert = true;
      return this.showMeg(data);
    };
    return this.after('initialize', function() {
      this.on(document, 'flash:info', this.info);
      this.on(document, 'flash:notice', this.notice);
      return this.on(document, 'flash:alert', this.alert);
    });
  });

}).call(this);
(function() {
  this.FloatUI = flight.component(function() {
    this.attributes({
      action: 'ul.nav.nav-tabs > li',
      close: 'i.fa.fa-close'
    });
    return this.after('initialize', function() {
      this.select('action').click((function(_this) {
        return function(e) {
          if (_this.select('action').length > 1) {
            if (_this.$node.hasClass('hover') && $(e.currentTarget).hasClass('active')) {
              return _this.select('close').click();
            } else {
              return _this.$node.addClass('hover');
            }
          } else {
            if (!_this.$node.hasClass('hover')) {
              return _this.$node.addClass('hover');
            } else {
              return _this.select('close').click();
            }
          }
        };
      })(this));
      return this.select('close').click((function(_this) {
        return function() {
          _this.$node.removeClass('hover');
          return _this.select('action').removeClass('active');
        };
      })(this));
    });
  });

}).call(this);
(function() {
  this.HeaderUI = flight.component(function() {
    this.attributes({
      vol: 'span.vol',
      amount: 'span.amount',
      high: 'span.high',
      low: 'span.low',
      change: 'span.change',
      sound: 'input[name="sound-checkbox"]'
    });
    this.refresh = function(event, ticker) {
      var p1, p2, trend;
      this.select('vol').text("" + (formatter.round(ticker.volume, 1)) + " " + (gon.market.base_unit.toUpperCase()) + " / " + (formatter.round(ticker.volume2, 4)) + " " + (gon.market.quote_unit.toUpperCase()));
      this.select('high').text(ticker.high);
      this.select('low').text(ticker.low);
      p1 = parseFloat(ticker.open);
      p2 = parseFloat(ticker.last);
      trend = formatter.trend(p1 <= p2);
      return this.select('change').html("<span class='" + trend + "'>" + (formatter.price_change(p1, p2)) + "%</span>");
    };
    return this.after('initialize', function() {
      var state, _ref;
      this.on(document, 'market::ticker', this.refresh);
      if (Cookies.get('sound') === void 0) {
        Cookies.set('sound', true, 30);
      }
      state = (_ref = Cookies.get('sound') === 'true') != null ? _ref : {
        "true": false
      };
      this.select('sound').bootstrapSwitch({
        labelText: gon.i18n["switch"].sound,
        state: state,
        handleWidth: 40,
        labelWidth: 40,
        onSwitchChange: function(event, state) {
          return Cookies.set('sound', state, 30);
        }
      });
      return $('header .dropdown-menu').click(function(e) {
        return e.stopPropagation();
      });
    });
  });

}).call(this);
(function() {
  var ESC;

  ESC = 27;

  this.KeyBindUI = flight.component(function() {
    return this.after('initialize', function() {
      var entry;
      entry = '#ask_entry';
      return this.$node.on('keyup', function(e) {
        if (e.keyCode === ESC) {
          if (entry === '#bid_entry') {
            entry = '#ask_entry';
          } else {
            entry = '#bid_entry';
          }
          return $(entry).trigger('place_order::clear');
        }
      });
    });
  });

}).call(this);
(function() {
  window.MarketSwitchUI = flight.component(function() {
    this.attributes({
      table: 'tbody',
      marketGroupName: '.panel-body-head thead a.name',
      marketGroupItem: '.dropdown-wrapper .dropdown-menu li a',
      marketGroups: '.dropdown-wrapper .dropdown-menu',
      marketsTable: '.table.markets',
      marketsFilter: 'input',
      marketsList: 'tr.market',
      switchUnit: 'a.switch_unit',
      sortName: 'a.sort_name',
      sortUnit: 'a.sort_change',
      sortPrice: 'a.sort_price',
      sortNameDirection: 'span.name_sort_direction',
      sortUnitDirection: 'span.change_sort_direction',
      sortPriceDirection: 'span.price_sort_direction'
    });
    this.setPinned = function(pinned) {
      if (pinned === 'true') {
        $("[data-name='pin-unpin-markets']").find(".fa").removeClass('fa-flip-vertical');
        return $("[data-name='pin-unpin-markets']").find(".info").text("Unpin markets");
      } else {
        if (!$("[data-name='pin-unpin-markets']").find(".fa").hasClass('fa-flip-vertical')) {
          $("[data-name='pin-unpin-markets']").find(".fa").addClass('fa-flip-vertical');
        }
        return $("[data-name='pin-unpin-markets']").find(".info").text("Pin markets");
      }
    };
    this.switchMarketGroup = function(event, item) {
      var name;
      item = $(event.target).closest('a');
      name = item.data('name');
      if (name === 'pin-unpin-markets') {
        if (this.markets_trades_pinned === 'true') {
          this.markets_trades_pinned = 'false';
        } else {
          this.markets_trades_pinned = 'true';
        }
        this.setPinned(this.markets_trades_pinned);
        return this.switchMarketByMarket($('.highlight').data('market'));
      } else {
        this.markets_filter = name;
        this.select('marketGroupItem').removeClass('active');
        item.addClass('active');
        this.select('marketGroupName').text(item.find('span').text());
        this.select('marketsTable').attr("class", "table table-hover markets " + name);
        return this.select('marketsTable').attr("style", "font-size: 12px");
      }
    };
    this.setMarketGroup = function(market_filter) {
      var marketGroup;
      this.select('marketGroupItem').removeClass('active');
      marketGroup = this.select('marketGroups').find("a[data-name='" + market_filter + "']");
      marketGroup.addClass('active');
      this.select('marketGroupName').text(marketGroup.find('span').text());
      this.select('marketsTable').attr("class", "table table-hover markets " + market_filter);
      return this.select('marketsTable').attr("style", "font-size: 12px");
    };
    this.updateMarket = function(select, ticker) {
      var curren_market, p1, p2, trend;
      trend = formatter.trend(ticker.last_trend);
      curren_market = select[0];
      curren_market.attributes['class'].value = "market quote-" + ticker.quote_unit;
      curren_market.attributes['data-market'].value = ticker.base_unit + ticker.quote_unit;
      curren_market.attributes['id'].value = "market-list-" + ticker.base_unit + ticker.quote_unit;
      if (this.markets_name_filter.length) {
        if (curren_market.attributes['data-market'].value.indexOf(this.markets_name_filter.toLowerCase()) >= 0) {
          curren_market.attributes['class'].value += " visible";
        } else {
          curren_market.attributes['class'].value += " hide";
        }
      }
      select.find('td.name').html("<span class=''>" + ticker.name + "</span>");
      select.find('td.price').attr('title', ticker.last).html("<span class='" + trend + "'>" + (formatter.ticker_price(ticker.last)) + "</span>");
      if (this.current_unit === 'volume') {
        p1 = parseFloat(ticker.open);
        p2 = parseFloat(ticker.last);
        trend = formatter.trend(p1 <= p2);
        return select.find('td.change').html("<span class='" + trend + "'>" + (formatter.price_change(p1, p2)) + "%</span>");
      } else {
        return select.find('td.change').html("<span class='" + trend + "'>" + (formatter.round(ticker.volume2, 4)) + "</span>");
      }
    };
    this.refresh = function(event, data) {
      var local_index, records, recordsFound, table, ticker, _i, _j, _len, _len1, _ref, _ref1;
      table = this.select('table');
      records = this.select('table').find("tr.market");
      recordsFound = [];
      local_index = 0;
      _ref = data.tickers;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        ticker = _ref[_i];
        recordsFound.push(table.find("tr#" + records[local_index++].attributes['id'].value));
      }
      local_index = 0;
      _ref1 = data.tickers;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        ticker = _ref1[_j];
        this.updateMarket(recordsFound[local_index++], ticker.data);
      }
      return this.select('table').find("tr#market-list-" + gon.market.id).addClass('highlight');
    };
    this.filterMarkets = function(filter) {
      var local_markets, market, market_class, _i, _len, _results;
      this.markets_name_filter = filter;
      local_markets = this.select('marketsList');
      _results = [];
      for (_i = 0, _len = local_markets.length; _i < _len; _i++) {
        market = local_markets[_i];
        market_class = market.attributes['class'].value;
        if (market.attributes['data-market'].value.indexOf(filter.toLowerCase()) >= 0 || !filter.length) {
          if (market_class.indexOf('hide') >= 0) {
            market.attributes['class'].value = market_class.substr(0, market_class.indexOf('hide') - 1);
          }
          if (market_class.indexOf('visible') === -1) {
            _results.push(market.attributes['class'].value += " visible");
          } else {
            _results.push(void 0);
          }
        } else {
          if (market_class.indexOf('visible') >= 0) {
            market.attributes['class'].value = market_class.substr(0, market_class.indexOf('visible') - 1);
          }
          if (market_class.indexOf('hide') === -1) {
            _results.push(market.attributes['class'].value += " hide");
          } else {
            _results.push(void 0);
          }
        }
      }
      return _results;
    };
    this.filterEditing = function(e) {
      var char, filter;
      char = e.key;
      filter = e.currentTarget.value;
      if (char.length === 1) {
        filter += char;
      } else if (char === 'Backspace') {
        filter = filter.substring(0, filter.length - 1);
      } else if (char !== 'Enter') {
        e.currentTarget.value = '';
        filter = '';
      }
      return this.filterMarkets(filter);
    };
    this.setUnit = function(unit_name) {
      this.unit = this.select('switchUnit');
      this.selected = this.unit[0];
      if (this.unit.hasClass('fa-percent') && unit_name === 'volume2') {
        return this.updateColumnTransation(this.selected, 'fa-percent', 'fa-btc');
      } else if (this.unit.hasClass('fa-btc') && unit_name === 'volume') {
        return this.updateColumnTransation(this.selected, 'fa-btc', 'fa-percent');
      }
    };
    this.switchUnit = function(e) {
      var column, current_column, current_column_sort;
      this.unit = this.select('switchUnit');
      this.selected = this.unit[0];
      if (this.unit.hasClass('fa-percent')) {
        this.updateColumnTransation(this.selected, 'fa-percent', 'fa-btc');
      } else {
        this.updateColumnTransation(this.selected, 'fa-btc', 'fa-percent');
      }
      current_column = this.getCurrentUnit();
      if (this.current_column === 'volume2' || this.current_column === 'volume') {
        current_column_sort = 'unsorted';
        column = this.select('sortUnit');
        if (column.hasClass('desc')) {
          current_column_sort = 'desc';
        } else {
          if (column.hasClass('asc')) {
            current_column_sort = 'asc';
          }
        }
      } else {
        current_column_sort = this.columnOrder(this.current_column);
        current_column = this.current_column;
      }
      return this.trigger('market::tickers::sort', {
        unit: current_column,
        order: current_column_sort
      });
    };
    this.getCurrentUnit = function() {
      var selected, unit;
      unit = this.select('switchUnit');
      selected = unit[0];
      if (unit.hasClass('fa-percent')) {
        this.current_unit = 'volume';
      } else {
        this.current_unit = 'volume2';
      }
      return this.current_unit;
    };
    this.getColumn = function(column_name) {
      var column;
      if (column_name === 'volume' || column_name === 'volume2') {
        column = this.select('sortUnit');
      } else if (column_name === 'last') {
        column = this.select('sortPrice');
      } else if (column_name === 'name') {
        column = this.select('sortName');
      }
      return column;
    };
    this.getColumnDirection = function(column_name) {
      var direction;
      direction = null;
      if (column_name === 'volume' || column_name === 'volume2') {
        direction = this.select('sortUnitDirection')[0];
      } else if (column_name === 'last') {
        direction = this.select('sortPriceDirection')[0];
      } else if (column_name === 'name') {
        direction = this.select('sortNameDirection')[0];
      }
      return direction;
    };
    this.columnOrder = function(column_name) {
      var column;
      column = this.getColumn(column_name);
      if (column_name === 'none') {
        return 'unsorted';
      }
      if (column.hasClass('desc')) {
        return 'desc';
      } else {
        if (column.hasClass('asc')) {
          return 'asc';
        }
      }
      return 'unsorted';
    };
    this.resetSort = function(column_name) {
      var column, direction;
      direction = this.getColumnDirection(column_name);
      column = this.getColumn(column_name);
      if (column_name === 'none') {
        return;
      }
      if (column.hasClass('desc')) {
        this.updateColumnTransation(column[0], 'desc', 'unsorted');
        return this.updateColumnTransation(direction, 'fa-sort-desc', 'fa-unsorted');
      } else {
        if (column.hasClass('asc')) {
          this.updateColumnTransation(column[0], 'asc', 'unsorted');
          return this.updateColumnTransation(direction, 'fa-sort-asc', 'fa-unsorted');
        }
      }
    };
    this.sortColumn = function(column_name, column_order) {
      var column, current_column_sort, direction, prev_column_sort;
      if (column_name === 'none') {
        return;
      }
      if (column_name !== this.current_column) {
        this.resetSort(this.current_column);
      }
      direction = this.getColumnDirection(column_name);
      column = this.getColumn(column_name);
      prev_column_sort = 'unsorted';
      current_column_sort = 'unsorted';
      if (column_order !== 'none') {
        this.resetSort(column_name);
        this.updateColumnTransation(column[0], 'unsorted', column_order);
        current_column_sort = column_order;
      } else {
        if (column.hasClass('unsorted')) {
          this.updateColumnTransation(column[0], 'unsorted', 'desc');
          current_column_sort = 'desc';
        } else {
          if (column.hasClass('desc')) {
            this.updateColumnTransation(column[0], 'desc', 'asc');
            current_column_sort = 'asc';
            prev_column_sort = 'desc';
          } else {
            if (column.hasClass('asc')) {
              this.updateColumnTransation(column[0], 'asc', 'desc');
              current_column_sort = 'desc';
              prev_column_sort = 'asc';
            }
          }
        }
      }
      if (prev_column_sort === 'unsorted' && current_column_sort === 'desc') {
        this.updateColumnTransation(direction, 'fa-unsorted', 'fa-sort-desc');
      } else if (prev_column_sort === 'unsorted' && current_column_sort === 'asc') {
        this.updateColumnTransation(direction, 'fa-unsorted', 'fa fa-sort-asc');
      } else if (prev_column_sort === 'desc' && current_column_sort === 'asc') {
        this.updateColumnTransation(direction, 'fa-sort-desc', 'fa-sort-asc');
      } else if (prev_column_sort === 'asc' && current_column_sort === 'desc') {
        this.updateColumnTransation(direction, 'fa-sort-asc', 'fa-sort-desc');
      }
      this.current_column = column_name;
      return this.trigger('market::tickers::sort', {
        unit: this.current_column,
        order: current_column_sort
      });
    };
    this.sortUnit = function(e) {
      return this.sortColumn(this.getCurrentUnit(), 'none');
    };
    this.sortPrice = function(e) {
      return this.sortColumn('last', 'none');
    };
    this.sortName = function(e) {
      return this.sortColumn('name', 'none');
    };
    this.updateColumnTransation = function(selected, from, to) {
      if (selected.attributes['class'].value.indexOf(from) > 0) {
        selected.attributes['class'].value = selected.attributes['class'].value.substr(0, selected.attributes['class'].value.indexOf(from) - 1);
        return selected.attributes['class'].value += " " + to;
      }
    };
    this.switchMarketByMarket = function(market) {
      var parameters;
      parameters = '?' + 'markets=' + this.markets_filter + '&column=' + this.current_column + '&order=' + this.columnOrder(this.current_column) + '&unit=' + this.current_unit + '&pinned=' + this.markets_trades_pinned;
      return window.location.href = window.formatter.market_url(market + parameters);
    };
    this.switchMarket = function(e) {
      if (e.target.nodeName !== 'I') {
        return this.switchMarketByMarket($(e.target).closest('tr').data('market'));
      }
    };
    return this.after('initialize', function() {
      this.on(document, 'market::tickers', this.refresh);
      this.on(this.select('marketGroupItem'), 'click', this.switchMarketGroup);
      this.on(this.select('marketsFilter'), 'keydown', this.filterEditing);
      this.on(this.select('switchUnit'), 'click', this.switchUnit);
      this.on(this.select('sortUnit'), 'click', this.sortUnit);
      this.on(this.select('sortPrice'), 'click', this.sortPrice);
      this.on(this.select('sortName'), 'click', this.sortName);
      this.on(this.select('table'), 'click', this.switchMarket);
      this.markets_filter = gon.markets_filter;
      this.current_column = gon.markets_column;
      this.current_unit = gon.markets_unit;
      this.markets_trades_pinned = gon.markets_pinned;
      this.markets_name_filter = '';
      this.setPinned(this.markets_trades_pinned);
      this.resetSort('name');
      this.setMarketGroup(this.markets_filter);
      this.sortColumn(this.current_column, gon.markets_column_order);
      this.setUnit(this.current_unit);
      this.hide_accounts = $('tr.hide');
      return $('.view_all_accounts').on('click', (function(_this) {
        return function(e) {
          var $el, acc, _i, _j, _len, _len1, _ref, _ref1, _results, _results1;
          $el = $(e.currentTarget);
          if (_this.hide_accounts.hasClass('show1')) {
            $el.text($el.data('show-text'));
            _ref = _this.hide_accounts;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              acc = _ref[_i];
              if (acc.lastChild.firstChild.textContent !== '0.0000') {
                if (acc.attributes['class'].value.indexOf('show1') > 0) {
                  acc.attributes['class'].value = acc.attributes['class'].value.substr(0, acc.attributes['class'].value.indexOf('show1') - 1);
                  _results.push(acc.attributes['class'].value += " hide");
                } else {
                  _results.push(void 0);
                }
              } else {
                _results.push(void 0);
              }
            }
            return _results;
          } else if (_this.hide_accounts.hasClass('hide')) {
            $el.text($el.data('hide-text'));
            _ref1 = _this.hide_accounts;
            _results1 = [];
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              acc = _ref1[_j];
              if (acc.lastChild.firstChild.textContent !== '0.0000') {
                if (acc.attributes['class'].value.indexOf('hide') > 0) {
                  acc.attributes['class'].value = acc.attributes['class'].value.substr(0, acc.attributes['class'].value.indexOf('hide') - 1);
                  _results1.push(acc.attributes['class'].value += " show1");
                } else {
                  _results1.push(void 0);
                }
              } else {
                _results1.push(void 0);
              }
            }
            return _results1;
          }
        };
      })(this));
    });
  });

}).call(this);
(function() {
  window.MarketTickerUI = flight.component(function() {
    this.attributes({
      askSelector: '.ask .price',
      bidSelector: '.bid .price',
      lastSelector: '.last .price',
      priceSelector: '.price'
    });
    this.updatePrice = function(selector, price, trend) {
      selector.removeClass('text-up').removeClass('text-down').addClass(formatter.trend(trend));
      return selector.html(formatter.fixBid(price));
    };
    this.refresh = function(event, ticker) {
      this.updatePrice(this.select('askSelector'), ticker.sell, ticker.sell_trend);
      this.updatePrice(this.select('bidSelector'), ticker.buy, ticker.buy_trend);
      return this.updatePrice(this.select('lastSelector'), ticker.last, ticker.last_trend);
    };
    return this.after('initialize', function() {
      return this.on(document, 'market::ticker', this.refresh);
    });
  });

}).call(this);
(function() {
  window.MarketTradesUI = flight.component(function() {
    flight.compose.mixin(this, [NotificationMixin]);
    this.attributes({
      defaultHeight: 156,
      tradeSelector: 'tr',
      newTradeSelector: 'tr.new',
      allSelector: 'a.all',
      mySelector: 'a.my',
      allTableSelector: 'table.all-trades tbody',
      myTableSelector: 'table.my-trades tbody',
      newMarketTradeContent: 'table.all-trades tr.new div',
      newMyTradeContent: 'table.my-trades tr.new div',
      tradesLimit: 80
    });
    this.showAllTrades = function(event) {
      this.select('mySelector').removeClass('active');
      this.select('allSelector').addClass('active');
      this.select('myTableSelector').hide();
      return this.select('allTableSelector').show();
    };
    this.showMyTrades = function(event) {
      this.select('allSelector').removeClass('active');
      this.select('mySelector').addClass('active');
      this.select('allTableSelector').hide();
      return this.select('myTableSelector').show();
    };
    this.bufferMarketTrades = function(event, data) {
      return this.marketTrades = this.marketTrades.concat(data.trades);
    };
    this.clearMarkers = function(table) {
      table.find('tr.new').removeClass('new');
      return table.find('tr').slice(this.attr.tradesLimit).remove();
    };
    this.notifyMyTrade = function(trade) {
      var market, message;
      market = gon.markets[trade.market];
      message = gon.i18n.notification.new_trade.replace(/%{kind}/g, gon.i18n[trade.kind]).replace(/%{id}/g, trade.id).replace(/%{price}/g, trade.price).replace(/%{volume}/g, trade.volume).replace(/%{base_unit}/g, market.base_unit.toUpperCase()).replace(/%{quote_unit}/g, market.quote_unit.toUpperCase());
      return this.notify(message);
    };
    this.isMine = function(trade) {
      var t, _i, _len, _ref;
      if (this.myTrades.length === 0) {
        return false;
      }
      _ref = this.myTrades;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        t = _ref[_i];
        if (trade.tid === t.id) {
          return true;
        }
        if (trade.tid > t.id) {
          return false;
        }
      }
    };
    this.handleMarketTrades = function(event, data) {
      var el, trade, _i, _len, _ref;
      _ref = data.trades;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        trade = _ref[_i];
        this.marketTrades.unshift(trade);
        trade.classes = 'new';
        if (this.isMine(trade)) {
          trade.classes += ' mine';
        }
        el = this.select('allTableSelector').prepend(JST['templates/market_trade'](trade));
      }
      this.marketTrades = this.marketTrades.slice(0, this.attr.tradesLimit);
      this.select('newMarketTradeContent').slideDown('slow');
      return setTimeout((function(_this) {
        return function() {
          return _this.clearMarkers(_this.select('allTableSelector'));
        };
      })(this), 900);
    };
    this.handleMyTrades = function(event, data, notify) {
      var el, trade, _i, _len, _ref;
      if (notify == null) {
        notify = true;
      }
      _ref = data.trades;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        trade = _ref[_i];
        if (trade.market === gon.market.id) {
          this.myTrades.unshift(trade);
          trade.classes = 'new';
          el = this.select('myTableSelector').prepend(JST['templates/my_trade'](trade));
          this.select('allTableSelector').find("tr#market-trade-" + trade.id).addClass('mine');
        }
        if (notify) {
          this.notifyMyTrade(trade);
        }
      }
      if (this.myTrades.length > this.attr.tradesLimit) {
        this.myTrades = this.myTrades.slice(0, this.attr.tradesLimit);
      }
      this.select('newMyTradeContent').slideDown('slow');
      return setTimeout((function(_this) {
        return function() {
          return _this.clearMarkers(_this.select('myTableSelector'));
        };
      })(this), 900);
    };
    return this.after('initialize', function() {
      this.marketTrades = [];
      this.myTrades = [];
      this.on(document, 'trade::populate', (function(_this) {
        return function(event, data) {
          return _this.handleMyTrades(event, {
            trades: data.trades.reverse()
          }, false);
        };
      })(this));
      this.on(document, 'trade', (function(_this) {
        return function(event, trade) {
          return _this.handleMyTrades(event, {
            trades: [trade]
          });
        };
      })(this));
      this.on(document, 'market::trades', this.handleMarketTrades);
      this.on(this.select('allSelector'), 'click', this.showAllTrades);
      return this.on(this.select('mySelector'), 'click', this.showMyTrades);
    });
  });

}).call(this);
(function() {
  this.MyOrdersUI = flight.component(function() {
    flight.compose.mixin(this, [ItemListMixin]);
    this.getTemplate = function(order) {
      return $(JST["templates/order_active"](order));
    };
    this.orderHandler = function(event, order) {
      if (order.market !== gon.market.id) {
        return;
      }
      switch (order.state) {
        case 'wait':
          return this.addOrUpdateItem(order);
        case 'cancel':
          return this.removeItem(order.id);
        case 'done':
          return this.removeItem(order.id);
      }
    };
    this.cancelOrder = function(event) {
      var tr;
      tr = $(event.target).parents('tr');
      if (confirm(formatter.t('place_order')['confirm_cancel'])) {
        return $.ajax({
          url: formatter.market_url(gon.market.id, tr.data('id')),
          method: 'delete'
        });
      }
    };
    return this.after('initialize', function() {
      this.on(document, 'order::wait::populate', this.populate);
      this.on(document, 'order::wait order::cancel order::done', this.orderHandler);
      return this.on(this.select('tbody'), 'click', this.cancelOrder);
    });
  });

}).call(this);
(function() {
  this.OrderBookUI = flight.component(function() {
    this.attributes({
      bookLimit: 30,
      askBookSel: 'table.asks',
      bidBookSel: 'table.bids',
      seperatorSelector: 'table.seperator',
      fade_toggle_depth: '#fade_toggle_depth'
    });
    this.update = function(event, data) {
      this.updateOrders(this.select('bidBookSel'), _.first(data.bids, this.attr.bookLimit), 'bid');
      return this.updateOrders(this.select('askBookSel'), _.first(data.asks, this.attr.bookLimit), 'ask');
    };
    this.appendRow = function(book, template, data) {
      data.classes = 'new';
      return book.append(template(data));
    };
    this.insertRow = function(book, row, template, data) {
      data.classes = 'new';
      return row.before(template(data));
    };
    this.updateRow = function(row, order, index, v1, v2) {
      row.data('order', index);
      if (v1.equals(v2)) {
        return;
      }
      if (v2.greaterThan(v1)) {
        row.addClass('text-up');
      } else {
        row.addClass('text-down');
      }
      row.data('volume', order[1]);
      row.find('td.volume').html(formatter.mask_fixed_volume(order[1]));
      return row.find('td.amount').html(formatter.amount(order[1], order[0]));
    };
    this.mergeUpdate = function(bid_or_ask, book, orders, template) {
      var $row, i, j, order, p1, p2, row, rows, v1, v2, _results;
      rows = book.find('tr');
      i = j = 0;
      _results = [];
      while (true) {
        row = rows[i];
        order = orders[j];
        $row = $(row);
        if (row && order) {
          p1 = new BigNumber($row.data('price'));
          v1 = new BigNumber($row.data('volume'));
          p2 = new BigNumber(order[0]);
          v2 = new BigNumber(order[1]);
          if ((bid_or_ask === 'ask' && p2.lessThan(p1)) || (bid_or_ask === 'bid' && p2.greaterThan(p1))) {
            this.insertRow(book, $row, template, {
              price: order[0],
              volume: order[1],
              index: j
            });
            _results.push(j += 1);
          } else if (p1.equals(p2)) {
            this.updateRow($row, order, j, v1, v2);
            i += 1;
            _results.push(j += 1);
          } else {
            $row.addClass('obsolete');
            _results.push(i += 1);
          }
        } else if (row) {
          $row.addClass('obsolete');
          _results.push(i += 1);
        } else if (order) {
          this.appendRow(book, template, {
            price: order[0],
            volume: order[1],
            index: j
          });
          _results.push(j += 1);
        } else {
          break;
        }
      }
      return _results;
    };
    this.clearMarkers = function(book) {
      var obsolete, obsolete_divs;
      book.find('tr.new').removeClass('new');
      book.find('tr.text-up').removeClass('text-up');
      book.find('tr.text-down').removeClass('text-down');
      obsolete = book.find('tr.obsolete');
      obsolete_divs = book.find('tr.obsolete div');
      return obsolete_divs.slideUp('slow', function() {
        return obsolete.remove();
      });
    };
    this.updateOrders = function(table, orders, bid_or_ask) {
      var book;
      book = this.select("" + bid_or_ask + "BookSel");
      this.mergeUpdate(bid_or_ask, book, orders, JST["templates/order_book_" + bid_or_ask]);
      book.find("tr.new div").slideDown('slow');
      return setTimeout((function(_this) {
        return function() {
          return _this.clearMarkers(_this.select("" + bid_or_ask + "BookSel"));
        };
      })(this), 900);
    };
    this.computeDeep = function(event, orders, type) {
      var balance, done, index, origVolume, price, subamount, total, total_fun, volume, volume_fun;
      balance = BigNumber(this.getBalance(type));
      index = Number($(event.currentTarget).data('order'));
      orders = _.take(orders, index + 1);
      volume_fun = function(memo, num) {
        return memo.plus(BigNumber(num[1]));
      };
      volume = _.reduce(orders, volume_fun, BigNumber(0));
      if (type === 'bid') {
        done = false;
        total_fun = function(memo, num) {
          var diff, part, subtotal;
          if (done) {
            return memo;
          }
          part = BigNumber(num[0]).times(BigNumber(num[1]));
          subtotal = memo.plus(part);
          if (subtotal.greaterThan(balance)) {
            diff = subtotal.minus(balance).dividedBy(BigNumber(num[1]));
            volume = volume.minus(diff);
            subtotal = memo.plus(BigNumber(num[0]).minus(diff).times(BigNumber(num[1])));
            done = true;
          }
          return subtotal;
        };
      }
      if (type === 'ask') {
        done = false;
        subamount = BigNumber(0);
        total_fun = function(memo, num) {
          var diff, part, subtotal;
          if (done) {
            return memo;
          }
          subamount = subamount.plus(BigNumber(num[1]));
          part = BigNumber(num[0]).times(BigNumber(num[1]));
          subtotal = memo.plus(part);
          if (subamount.greaterThan(balance)) {
            diff = subamount.minus(balance);
            volume = subamount.minus(diff);
            subtotal = memo.plus(BigNumber(num[1]).minus(diff).times(BigNumber(num[0])));
            done = true;
          }
          return subtotal;
        };
      }
      total = _.reduce(orders, total_fun, BigNumber(0));
      price = BigNumber(_.last(orders)[0]);
      origVolume = _.last(orders)[1];
      return {
        price: price,
        volume: volume,
        origVolume: origVolume,
        total: total
      };
    };
    this.placeOrder = function(target, data) {
      return this.trigger(target, 'place_order::order::total', data);
    };
    this.placeOtherOrder = function(target, data) {
      this.trigger(target, 'place_order::input::price', data);
      return this.trigger(target, 'place_order::input::volume', data);
    };
    this.getBalance = function(type) {
      if (type === 'bid') {
        return this.balance_bid;
      }
      return this.balance_ask;
    };
    this.onBidBalanceChange = function(e, data) {
      return this.balance_bid = data.balance;
    };
    this.onAskBalanceChange = function(e, data) {
      return this.balance_ask = data.balance;
    };
    return this.after('initialize', function() {
      var _ref, _ref1;
      this.on(document, 'market::order_book::update', this.update);
      this.on(document, 'place_order::balance::change::bid', this.onBidBalanceChange);
      this.on(document, 'place_order::balance::change::ask', this.onAskBalanceChange);
      if (gon.accounts !== void 0 && gon.market.ask !== void 0 && gon.market.bid !== void 0) {
        this.balance_ask = ((_ref = gon.accounts[gon.market.ask.currency]) != null ? _ref.balance : void 0) || 0;
        this.balance_bid = ((_ref1 = gon.accounts[gon.market.bid.currency]) != null ? _ref1.balance : void 0) || 0;
      } else {
        this.balance_ask = 0;
        this.balance_bid = 0;
      }
      this.on(this.select('fade_toggle_depth'), 'click', (function(_this) {
        return function() {
          return _this.trigger('market::depth::fade_toggle');
        };
      })(this));
      $('.asks').on('click', 'tr', (function(_this) {
        return function(e) {
          var i;
          i = $(e.target).closest('tr').data('order');
          _this.placeOrder($('#bid_entry'), _.extend(_this.computeDeep(e, gon.asks, 'bid'), {
            type: 'ask'
          }));
          return _this.placeOtherOrder($('#ask_entry'), {
            price: BigNumber(gon.asks[i][0]),
            volume: BigNumber(gon.asks[i][1]),
            total: BigNumber(gon.asks[i][0]).times(BigNumber(gon.asks[i][1]))
          });
        };
      })(this));
      return $('.bids').on('click', 'tr', (function(_this) {
        return function(e) {
          var i;
          i = $(e.target).closest('tr').data('order');
          _this.placeOrder($('#ask_entry'), _.extend(_this.computeDeep(e, gon.bids, 'ask'), {
            type: 'bid'
          }));
          return _this.placeOtherOrder($('#bid_entry'), {
            price: BigNumber(gon.bids[i][0]),
            volume: BigNumber(gon.bids[i][1]),
            total: BigNumber(gon.bids[i][0]).times(BigNumber(gon.bids[i][1]))
          });
        };
      })(this));
    });
  });

}).call(this);
(function() {
  this.OrderPriceUI = flight.component(function() {
    flight.compose.mixin(this, [OrderInputMixin]);
    this.attributes({
      precision: gon.market.bid.fixed,
      variables: {
        input: 'price',
        known: 'volume',
        output: 'total'
      }
    });
    this.getLastPrice = function() {
      return Number(gon.ticker.last);
    };
    this.toggleAlert = function(event) {
      var lastPrice;
      lastPrice = this.getLastPrice();
      switch (false) {
        case !!this.value:
          return this.trigger('place_order::price_alert::hide');
        case !(this.value > (lastPrice * 1.1)):
          return this.trigger('place_order::price_alert::show', {
            label: 'price_high'
          });
        case !(this.value < (lastPrice * 0.9)):
          return this.trigger('place_order::price_alert::show', {
            label: 'price_low'
          });
        default:
          return this.trigger('place_order::price_alert::hide');
      }
    };
    this.onOutput = function(event, order) {
      var price;
      price = order.total.div(order.volume);
      return this.$node.val(price);
    };
    return this.after('initialize', function() {
      return this.on('focusout', this.toggleAlert);
    });
  });

}).call(this);
(function() {
  this.OrderTotalUI = flight.component(function() {
    flight.compose.mixin(this, [OrderInputMixin]);
    this.attributes({
      precision: gon.market.bid.fixed,
      variables: {
        input: 'total',
        known: 'price',
        output: 'volume'
      }
    });
    return this.onOutput = function(event, order) {
      var total;
      total = order.price.times(order.volume);
      if (!this.validateRange(total)) {
        this.changeOrder(this.value);
      }
      this.setInputValue(this.value);
      order.total = this.value;
      return this.trigger('place_order::order::updated', order);
    };
  });

}).call(this);
(function() {
  this.OrderVolumeUI = flight.component(function() {
    flight.compose.mixin(this, [OrderInputMixin]);
    this.attributes({
      precision: gon.market.ask.fixed,
      variables: {
        input: 'volume',
        known: 'price',
        output: 'total'
      }
    });
    return this.onOutput = function(event, order) {
      var volume;
      if (order.price.equals(0)) {
        return;
      }
      volume = order.total.div(order.price);
      if (!this.validateRange(volume)) {
        this.changeOrder(this.value);
      }
      this.setInputValue(this.value);
      order.volume = this.value;
      return this.trigger('place_order::order::updated', order);
    };
  });

}).call(this);
(function() {
  this.PlaceOrderUI = flight.component(function() {
    this.attributes({
      formSel: 'form',
      successSel: '.status-success',
      infoSel: '.status-info',
      feeSel: '.status-fee',
      dangerSel: '.status-danger',
      priceAlertSel: '.hint-price-disadvantage',
      positionsLabelSel: '.hint-positions',
      feeLabelSel: '.hint-fee',
      feeLabelInfo: '.fee-info',
      feeLabelDiscountInfo: '.fee-discount-info',
      priceSel: 'input[id$=price]',
      volumeSel: 'input[id$=volume]',
      totalSel: 'input[id$=total]',
      bidSel: "input[id='calculate_bid']",
      askSel: "input[id='calculate_ask']",
      currentBalanceSel: 'span.current-balance',
      submitButton: ':submit'
    });
    this.panelType = function() {
      switch (this.$node.attr('id')) {
        case 'bid_entry':
          return 'bid';
        case 'ask_entry':
          return 'ask';
      }
    };
    this.cleanMsg = function() {
      this.select('successSel').text('');
      this.select('infoSel').text('');
      this.select('dangerSel').text('');
      return this.select('feeSel').text('');
    };
    this.resetForm = function(event) {
      this.trigger('place_order::reset::price');
      this.trigger('place_order::reset::volume');
      this.trigger('place_order::reset::total');
      return this.priceAlertHide();
    };
    this.disableSubmit = function() {
      return this.select('submitButton').addClass('disabled').attr('disabled', 'disabled');
    };
    this.enableSubmit = function() {
      return this.select('submitButton').removeClass('disabled').removeAttr('disabled');
    };
    this.confirmDialogMsg = function() {
      var confirmType, price, sum, volume;
      confirmType = this.select('submitButton').text();
      price = this.select('priceSel').val();
      volume = this.select('volumeSel').val();
      sum = this.select('totalSel').val();
      return "" + gon.i18n.place_order.confirm_submit + " \"" + confirmType + "\"?\n\n" + gon.i18n.place_order.price + ": " + price + "\n" + gon.i18n.place_order.volume + ": " + volume + "\n" + gon.i18n.place_order.sum + ": " + sum;
    };
    this.beforeSend = function(event, jqXHR) {
      if (true) {
        return this.disableSubmit();
      } else {
        return jqXHR.abort();
      }
    };
    this.handleSuccess = function(event, data) {
      this.cleanMsg();
      this.select('successSel').append(JST["templates/hint_order_success"]({
        msg: data.message
      })).show();
      this.resetForm(event);
      window.sfx_success();
      return this.enableSubmit();
    };
    this.handleError = function(event, data) {
      var ef_class, json;
      this.cleanMsg();
      ef_class = 'shake shake-constant hover-stop';
      json = JSON.parse(data.responseText);
      console.log(json);
      this.select('dangerSel').append(JST["templates/hint_order_warning"]({
        msg: json.message
      })).show().addClass(ef_class).wait(500).removeClass(ef_class);
      window.sfx_warning();
      return this.enableSubmit();
    };
    this.getBalance = function() {
      return BigNumber(this.select('currentBalanceSel').data('balance'));
    };
    this.getLastPrice = function() {
      return BigNumber(gon.ticker.last);
    };
    this.allIn = function(event) {
      switch (this.panelType()) {
        case 'ask':
          return this.trigger('place_order::input::volume', {
            volume: this.getBalance()
          });
        case 'bid':
          return this.trigger('place_order::input::total', {
            total: this.getBalance()
          });
      }
    };
    this.refreshBalance = function(event, data) {
      var balance, currency, type, _ref;
      type = this.panelType();
      currency = gon.market[type].currency;
      balance = ((_ref = gon.accounts[currency]) != null ? _ref.balance : void 0) || 0;
      this.select('currentBalanceSel').data('balance', balance);
      this.select('currentBalanceSel').text(formatter.fix(type, balance));
      this.trigger("place_order::balance::change", {
        balance: BigNumber(balance)
      });
      this.trigger("place_order::max::" + this.usedInput, {
        max: BigNumber(balance)
      });
      return this.trigger("place_order::balance::change::" + type, {
        balance: BigNumber(balance)
      });
    };
    this.roundValueToText = function(v, precision) {
      return v.round(precision, BigNumber.ROUND_DOWN).toF(precision);
    };
    this.updateOrder = function(event, data) {
      this.select('priceSel').val(BigNumber(data.price).round(gon.market.bid.fixed, BigNumber.ROUND_DOWN).toF(gon.market.bid.fixed));
      this.select('volumeSel').val(BigNumber(data.volume).round(gon.market.ask.fixed, BigNumber.ROUND_DOWN).toF(gon.market.ask.fixed));
      this.select('totalSel').val(BigNumber(data.total).round(gon.market.bid.fixed, BigNumber.ROUND_DOWN).toF(gon.market.bid.fixed));
      return this.updateAvailable(event, data);
    };
    this.updateAvailable = function(event, order) {
      var available, fee, fee_actual_percent, gio_account, gio_discount_flag, node, type;
      this.current_order = order;
      type = this.panelType();
      node = this.select('currentBalanceSel');
      if (!order[this.usedInput]) {
        order[this.usedInput] = 0;
      }
      available = formatter.fix(type, this.getBalance().minus(order[this.usedInput]));
      fee = 0.0;
      fee_actual_percent = 0.0;
      if (type === 'ask') {
        fee = gon.market.ask.fee;
      } else {
        fee = gon.market.bid.fee;
      }
      gio_discount_flag = -1;
      if (gon.accounts !== void 0) {
        gio_account = gon.accounts['gio'];
        if (gio_account.hasOwnProperty('gio_discount')) {
          if (gio_account.gio_discount === true) {
            gio_discount_flag = 1;
          }
          if (gio_account.gio_discount === false) {
            gio_discount_flag = 0;
          }
        }
      }
      fee_actual_percent = fee;
      if (gio_discount_flag === 1) {
        fee_actual_percent = fee / 2.0;
      }
      if (order.hasOwnProperty('total')) {
        order.fee = order.total * fee;
      } else {
        order.fee = order[this.usedInput] * fee;
      }
      order.fee_percent = fee * 100.0;
      order.fee_actual_percent = fee_actual_percent * 100.0;
      order.gio_discount_flag = gio_discount_flag;
      if (this.select('priceSel').val() !== 0.0 && this.select('priceSel').val() !== '') {
        this.select('feeLabelSel').hide().text(formatter.fixPriceGroup(order.fee)).fadeIn();
        this.select('feeLabelInfo').hide().text(formatter.round(order.fee_actual_percent, 2) + "%").fadeIn();
      } else {
        this.select('feeLabelSel').fadeOut().text('');
        this.select('feeLabelInfo').fadeOut().text('');
      }
      if (order.gio_discount_flag === 1) {
        this.select('feeLabelDiscountInfo').fadeOut().text('');
      } else {
        this.select('feeLabelDiscountInfo').hide().text('how to get 50% market fee discount').fadeIn();
      }
      if (BigNumber(available).lessThan(0.000000001)) {
        this.select('positionsLabelSel').hide().text(gon.i18n.place_order["full_" + type]).fadeIn();
      } else {
        this.select('positionsLabelSel').fadeOut().text('');
      }
      return node.text(available);
    };
    this.priceAlertHide = function(event) {
      return this.select('priceAlertSel').fadeOut(function() {
        return $(this).text('');
      });
    };
    this.priceAlertShow = function(event, data) {
      return this.select('priceAlertSel').hide().text(gon.i18n.place_order[data.label]).fadeIn();
    };
    this.clear = function(e) {
      if (e.currentTarget.checked) {
        this.disableSubmit();
        this.refreshBalance(null, null);
        this.trigger("place_order::max::" + this.usedInput, {
          max: BigNumber("1000000000000.0")
        });
        this.trigger("place_order::balance::change::" + (this.panelType()), {
          balance: BigNumber("1000000000000.0")
        });
      } else {
        this.enableSubmit();
        this.refreshBalance(null, null);
      }
      this.resetForm(e);
      this.select('feeLabelSel').fadeOut().text('');
      this.select('feeLabelInfo').fadeOut().text('');
      return this.trigger('place_order::focus::price');
    };
    this.calculatorClick = function(e) {
      return this.clear(e);
    };
    return this.after('initialize', function() {
      var type;
      type = this.panelType();
      if (type === 'ask') {
        this.usedInput = 'volume';
      } else {
        this.usedInput = 'total';
      }
      this.current_order = null;
      PlaceOrderData.attachTo(this.$node);
      OrderPriceUI.attachTo(this.select('priceSel'), {
        form: this.$node,
        type: type
      });
      OrderVolumeUI.attachTo(this.select('volumeSel'), {
        form: this.$node,
        type: type
      });
      OrderTotalUI.attachTo(this.select('totalSel'), {
        form: this.$node,
        type: type
      });
      this.on('place_order::price_alert::hide', this.priceAlertHide);
      this.on('place_order::price_alert::show', this.priceAlertShow);
      this.on('place_order::order::updated', this.updateAvailable);
      this.on('place_order::clear', this.clear);
      this.on('place_order::order::total', this.updateOrder);
      this.on(document, 'account::update', this.refreshBalance);
      this.on(this.select('formSel'), 'ajax:beforeSend', this.beforeSend);
      this.on(this.select('formSel'), 'ajax:success', this.handleSuccess);
      this.on(this.select('formSel'), 'ajax:error', this.handleError);
      this.on(this.select('currentBalanceSel'), 'click', this.allIn);
      if (this.panelType() === 'bid') {
        return this.on(this.select('bidSel'), 'click', this.calculatorClick);
      } else {
        return this.on(this.select('askSel'), 'click', this.calculatorClick);
      }
    });
  });

}).call(this);
(function() {
  this.PushButton = flight.component(function() {
    this.attributes({
      buttons: '.type-toggle button'
    });
    this.setActiveButton = function(event) {
      this.select('buttons').removeClass('active');
      return $(event.target).closest('button').addClass('active');
    };
    return this.after('initialize', function() {
      return this.on(this.select('buttons'), 'click', this.setActiveButton);
    });
  });

}).call(this);
(function() {


}).call(this);
(function() {
  this.SettingsUI = flight.component(function() {
    this.attributes({
      gio_discount_mark: '#gio_discount_mark'
    });
    this.updateDiscounts = function() {
      var account, currency, gio_discount_flag, gio_discount_mark_node, _ref;
      gio_discount_flag = -1;
      _ref = this.accounts;
      for (currency in _ref) {
        account = _ref[currency];
        if (account.currency === 'gio' && account.hasOwnProperty('gio_discount')) {
          if (account.gio_discount === true) {
            gio_discount_flag = 1;
          }
          if (account.gio_discount === false) {
            gio_discount_flag = 0;
          }
        }
      }
      gio_discount_mark_node = this.select('gio_discount_mark');
      if (gio_discount_flag === 1) {
        gio_discount_mark_node.attr('class', 'fa fa-star');
        return gio_discount_mark_node.attr('style', 'color: #e6b800');
      } else if (gio_discount_flag === 0) {
        gio_discount_mark_node.attr('class', '_empty');
        return gio_discount_mark_node.attr('style', '_empty');
      }
    };
    return this.after('initialize', function() {
      this.accounts = gon.accounts;
      this.on(document, 'account::update', (function(_this) {
        return function(event, data) {
          _this.accounts = data;
          return _this.updateDiscounts();
        };
      })(this));
      return this.on(document, 'market::tickers', (function(_this) {
        return function(event, data) {
          _this.tickers = data.raw;
          return _this.updateDiscounts();
        };
      })(this));
    });
  });

}).call(this);
(function() {
  this.SmsAuthVerifyUI = flight.component(function() {
    this.countDown = 0;
    this.attributes({
      phoneNumberInput: '#token_sms_token_phone_number',
      verifyCodeInput: '#token_sms_token_verify_code',
      sendCodeButton: 'button[value=send_code]'
    });
    this.verifyPhoneNumber = function(event, data) {
      this.select('phoneNumberInput').parent().removeClass('has-error');
      if (this.select('phoneNumberInput').val() === "") {
        this.select('phoneNumberInput').parent().addClass('has-error');
        return event.preventDefault();
      } else {
        return setTimeout((function(_this) {
          return function() {
            return _this.countDownSendCodeButton();
          };
        })(this), 0);
      }
    };
    this.countDownSendCodeButton = function() {
      var altName, countDownTimer, origName;
      origName = this.select('sendCodeButton').data('orig-name');
      altName = this.select('sendCodeButton').data('alt-name');
      this.countDown = 30;
      this.select('sendCodeButton').attr('disabled', 'disabled').addClass('disabled');
      countDownTimer = (function(_this) {
        return function() {
          return setTimeout(function() {
            if (_this.countDown !== 0) {
              _this.countDown--;
              _this.select('sendCodeButton').text(altName.replace('COUNT', _this.countDown));
              return countDownTimer();
            } else {
              return _this.select('sendCodeButton').removeAttr('disabled').removeClass('disabled').text(origName);
            }
          }, 1000);
        };
      })(this);
      return countDownTimer();
    };
    this.beforeSend = function(event, jqXHR, settings) {
      var input;
      if (settings.data.match('send_code')) {
        return;
      }
      input = this.select('verifyCodeInput');
      input.parent().removeClass('has-error');
      if (input.val() === "") {
        input.parent().addClass('has-error');
        return jqXHR.abort();
      }
    };
    this.handleSuccess = function(event, text, status, jqXHR) {
      var data;
      data = JSON.parse(text);
      if (data.reload) {
        window.location.reload();
      }
      return this.trigger('flash:notice', {
        msg: data.text
      });
    };
    this.handleError = function(event, jqXHR, status, error) {
      var data;
      data = JSON.parse(jqXHR.responseText);
      this.countDown = 0;
      return this.trigger('flash:alert', {
        msg: data.text
      });
    };
    return this.after('initialize', function() {
      this.on(this.select('sendCodeButton'), 'click', this.verifyPhoneNumber);
      this.on('ajax:beforeSend', this.beforeSend);
      this.on('ajax:success', this.handleSuccess);
      return this.on('ajax:error', this.handleError);
    });
  });

}).call(this);
(function() {
  this.SwitchUI = flight.component(function() {
    this.attributes({
      "switch": 'li > a'
    });
    this.getX = function() {
      if (Cookies.get(this.name())) {
        return Cookies.get(this.name());
      } else {
        return this.setX(this.defaultX());
      }
    };
    this.setX = function(x) {
      Cookies.set(this.name(), x);
      return x;
    };
    this.name = function() {
      return this.$node.attr('id');
    };
    this.defaultX = function() {
      return this.$node.data('x');
    };
    this.init = function(event, data) {
      return this.$node.find("[data-x=" + (this.getX()) + "]").click();
    };
    return this.after('initialize', function() {
      this.on(this.select('switch'), 'click', (function(_this) {
        return function(e) {
          var x;
          _this.select('switch').removeClass('active');
          $(e.currentTarget).addClass('active');
          x = $(e.currentTarget).data('x');
          _this.setX(x);
          return _this.trigger("switch::" + (_this.name()), {
            x: x
          });
        };
      })(this));
      this.on(document, "switch::" + (this.name()) + "::init", this.init);
      return this.init();
    });
  });

}).call(this);
(function() {
  this.TwoFactorAuth = flight.component(function() {
    this.attributes({
      switchName: 'span.switch-name',
      switchItem: '.dropdown-menu a',
      switchItemApp: '.dropdown-menu a[data-type="app"]',
      switchItemSms: '.dropdown-menu a[data-type="sms"]',
      sendCodeButtonContainer: '.send-code-button',
      sendCodeButton: 'button[value=send_code]',
      authType: '.two_factor_auth_type',
      appHint: 'span.hint.app',
      smsHint: 'span.hint.sms',
      chapterWrap: '.captcha-wrap'
    });
    this.setActiveItem = function(event) {
      switch ($(event.target).data('type')) {
        case 'app':
          return this.switchToApp();
        case 'sms':
          return this.switchToSms();
      }
    };
    this.switchToApp = function() {
      this.select('switchName').text(this.select('switchItemApp').text());
      this.select('sendCodeButtonContainer').addClass('hide');
      this.select('authType').val('app');
      this.select('smsHint').addClass('hide');
      return this.select('appHint').removeClass('hide');
    };
    this.switchToSms = function() {
      this.select('switchName').text(this.select('switchItemSms').text());
      this.select('sendCodeButtonContainer').removeClass('hide');
      this.select('authType').val('sms');
      this.select('smsHint').removeClass('hide');
      return this.select('appHint').addClass('hide');
    };
    this.countDownSendCodeButton = function() {
      var altName, countDown, countDownTimer, origName;
      origName = this.select('sendCodeButton').data('orig-name');
      altName = this.select('sendCodeButton').data('alt-name');
      countDown = 30;
      this.select('sendCodeButton').attr('disabled', 'disabled').addClass('disabled');
      countDownTimer = (function(_this) {
        return function() {
          return setTimeout(function() {
            if (countDown !== 0) {
              countDown--;
              _this.select('sendCodeButton').text(altName.replace('COUNT', countDown));
              return countDownTimer();
            } else {
              return _this.select('sendCodeButton').removeAttr('disabled').removeClass('disabled').text(origName);
            }
          }, 1000);
        };
      })(this);
      return countDownTimer();
    };
    this.sendCode = function(event) {
      event.preventDefault();
      this.countDownSendCodeButton();
      return $.get('/two_factors/sms?refresh=true');
    };
    this.checkCaptchaRequired = function() {
      return this.select('chapterWrap').load('/two_factors/app', function(html) {
        return $(this).html(html);
      });
    };
    return this.after('initialize', function() {
      this.checkCaptchaRequired();
      $.subscribe('withdraw:form:submitted', (function(_this) {
        return function() {
          return _this.checkCaptchaRequired();
        };
      })(this));
      this.on(this.select('switchItem'), 'click', this.setActiveItem);
      return this.on(this.select('sendCodeButton'), 'click', this.sendCode);
    });
  });

}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["templates/flash_message"] = function(__obj) {
    if (!__obj) __obj = {};
    var __out = [], __capture = function(callback) {
      var out = __out, result;
      __out = [];
      callback.call(this);
      result = __out.join('');
      __out = out;
      return __safe(result);
    }, __sanitize = function(value) {
      if (value && value.ecoSafe) {
        return value;
      } else if (typeof value !== 'undefined' && value != null) {
        return __escape(value);
      } else {
        return '';
      }
    }, __safe, __objSafe = __obj.safe, __escape = __obj.escape;
    __safe = __obj.safe = function(value) {
      if (value && value.ecoSafe) {
        return value;
      } else {
        if (!(typeof value !== 'undefined' && value != null)) value = '';
        var result = new String(value);
        result.ecoSafe = true;
        return result;
      }
    };
    if (!__escape) {
      __escape = __obj.escape = function(value) {
        return ('' + value)
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;');
      };
    }
    (function() {
      (function() {
        if (this.notice) {
          __out.push('\n<div class="alert alert-dismissable alert-success" id="notice">\n  <button aria-hidden="true" class="close" data-dismiss="alert" type="button"></button>\n  <h5><i class="fa fa-bullhorn"></i><span>');
          __out.push(__sanitize(this.msg));
          __out.push('</span></h5>\n</div>\n');
        }
      
        __out.push('\n');
      
        if (this.alert) {
          __out.push('\n<div class="alert alert-dismissable alert-warning" id="alert">\n  <button aria-hidden="true" class="close" data-dismiss="alert" type="button"></button>\n  <h5><i class="fa fa-info-circle"></i><span>');
          __out.push(__sanitize(this.msg));
          __out.push('</span></h5>\n</div>\n');
        }
      
        __out.push('\n');
      
        if (this.info) {
          __out.push('\n<div class="alert alert-dismissable alert-info" id="info">\n  <button aria-hidden="true" class="close" data-dismiss="alert" type="button"></button>\n  <h5><i class="fa fa-info-circle"></i><span>');
          __out.push(__sanitize(this.msg));
          __out.push('</span></h5>\n</div>\n');
        }
      
        __out.push('\n');
      
      }).call(this);
      
    }).call(__obj);
    __obj.safe = __objSafe, __obj.escape = __escape;
    return __out.join('');
  };
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["templates/hint_order_success"] = function(__obj) {
    if (!__obj) __obj = {};
    var __out = [], __capture = function(callback) {
      var out = __out, result;
      __out = [];
      callback.call(this);
      result = __out.join('');
      __out = out;
      return __safe(result);
    }, __sanitize = function(value) {
      if (value && value.ecoSafe) {
        return value;
      } else if (typeof value !== 'undefined' && value != null) {
        return __escape(value);
      } else {
        return '';
      }
    }, __safe, __objSafe = __obj.safe, __escape = __obj.escape;
    __safe = __obj.safe = function(value) {
      if (value && value.ecoSafe) {
        return value;
      } else {
        if (!(typeof value !== 'undefined' && value != null)) value = '';
        var result = new String(value);
        result.ecoSafe = true;
        return result;
      }
    };
    if (!__escape) {
      __escape = __obj.escape = function(value) {
        return ('' + value)
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;');
      };
    }
    (function() {
      (function() {
        __out.push('<i class="fa fa-check text-default">\n  ');
      
        __out.push(__sanitize(this.msg));
      
        __out.push('\n</i>\n');
      
      }).call(this);
      
    }).call(__obj);
    __obj.safe = __objSafe, __obj.escape = __escape;
    return __out.join('');
  };
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["templates/hint_order_warning"] = function(__obj) {
    if (!__obj) __obj = {};
    var __out = [], __capture = function(callback) {
      var out = __out, result;
      __out = [];
      callback.call(this);
      result = __out.join('');
      __out = out;
      return __safe(result);
    }, __sanitize = function(value) {
      if (value && value.ecoSafe) {
        return value;
      } else if (typeof value !== 'undefined' && value != null) {
        return __escape(value);
      } else {
        return '';
      }
    }, __safe, __objSafe = __obj.safe, __escape = __obj.escape;
    __safe = __obj.safe = function(value) {
      if (value && value.ecoSafe) {
        return value;
      } else {
        if (!(typeof value !== 'undefined' && value != null)) value = '';
        var result = new String(value);
        result.ecoSafe = true;
        return result;
      }
    };
    if (!__escape) {
      __escape = __obj.escape = function(value) {
        return ('' + value)
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;');
      };
    }
    (function() {
      (function() {
        __out.push('<i class="fa fa-times text-default">\n  ');
      
        __out.push(__sanitize(this.msg));
      
        __out.push('\n</i>\n');
      
      }).call(this);
      
    }).call(__obj);
    __obj.safe = __objSafe, __obj.escape = __escape;
    return __out.join('');
  };
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["templates/market_trade"] = function(__obj) {
    if (!__obj) __obj = {};
    var __out = [], __capture = function(callback) {
      var out = __out, result;
      __out = [];
      callback.call(this);
      result = __out.join('');
      __out = out;
      return __safe(result);
    }, __sanitize = function(value) {
      if (value && value.ecoSafe) {
        return value;
      } else if (typeof value !== 'undefined' && value != null) {
        return __escape(value);
      } else {
        return '';
      }
    }, __safe, __objSafe = __obj.safe, __escape = __obj.escape;
    __safe = __obj.safe = function(value) {
      if (value && value.ecoSafe) {
        return value;
      } else {
        if (!(typeof value !== 'undefined' && value != null)) value = '';
        var result = new String(value);
        result.ecoSafe = true;
        return result;
      }
    };
    if (!__escape) {
      __escape = __obj.escape = function(value) {
        return ('' + value)
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;');
      };
    }
    (function() {
      (function() {
        var trend;
      
        trend = formatter.trend(this.type);
      
        __out.push('\n\n<tr id=\'market-trade-');
      
        __out.push(__sanitize(this.tid));
      
        __out.push('\' class=\'');
      
        __out.push(__sanitize(this.classes));
      
        __out.push('\'>\n  <td class="time text-left col-xs-4" style="font-size: 12px"><div>\n    ');
      
        __out.push(formatter.trade_time(this.date));
      
        __out.push('\n  </div></td>\n  <td class="my text-left col-xs-1" style="font-size: 12px; padding: 0 20px 0 0"><div>\n    <i class=\'fa fa-star\'></i>\n  </div></td>\n  <td class=\'price text-right col-xs-5 ');
      
        __out.push(__sanitize(trend));
      
        __out.push('\' style=\'font-size: 12px; padding: 0 0 0 0; font-weight: bold\'><div>\n    ');
      
        __out.push(formatter.ticker_price(this.price));
      
        __out.push('\n  </div></td>\n  <td class=\'volume text-right col-xs-7\' title=\'');
      
        __out.push(__sanitize(formatter.fix_bid(this.price * this.amount)));
      
        __out.push('\' style=\'font-size: 12px; font-weight: bold\'><div>\n    ');
      
        __out.push(formatter.mask_fixed_volume(this.amount));
      
        __out.push('\n  </div></td>\n</tr>\n');
      
      }).call(this);
      
    }).call(__obj);
    __obj.safe = __objSafe, __obj.escape = __escape;
    return __out.join('');
  };
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["templates/my_trade"] = function(__obj) {
    if (!__obj) __obj = {};
    var __out = [], __capture = function(callback) {
      var out = __out, result;
      __out = [];
      callback.call(this);
      result = __out.join('');
      __out = out;
      return __safe(result);
    }, __sanitize = function(value) {
      if (value && value.ecoSafe) {
        return value;
      } else if (typeof value !== 'undefined' && value != null) {
        return __escape(value);
      } else {
        return '';
      }
    }, __safe, __objSafe = __obj.safe, __escape = __obj.escape;
    __safe = __obj.safe = function(value) {
      if (value && value.ecoSafe) {
        return value;
      } else {
        if (!(typeof value !== 'undefined' && value != null)) value = '';
        var result = new String(value);
        result.ecoSafe = true;
        return result;
      }
    };
    if (!__escape) {
      __escape = __obj.escape = function(value) {
        return ('' + value)
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;');
      };
    }
    (function() {
      (function() {
        var trend;
      
        trend = formatter.trend(this.kind);
      
        __out.push('\n\n<tr class=\'');
      
        __out.push(__sanitize(this.classes));
      
        __out.push('\'>\n  <td colspan=2 class="time text-left col-xs-8" style="font-size: 12px"><div>\n    ');
      
        __out.push(formatter.fulltime(this.at));
      
        __out.push('\n  </div></td>\n  <td class=\'price text-right col-xs-6 ');
      
        __out.push(__sanitize(trend));
      
        __out.push('\' style=\'font-size: 12px; font-weight: bold\'><div>\n    ');
      
        __out.push(formatter.mask_fixed_price(this.price));
      
        __out.push('\n  </div></td>\n  <td class=\'volume text-right col-xs-6\' style=\'font-size: 12px; font-weight: bold\'><div>\n    ');
      
        __out.push(formatter.mask_fixed_volume(this.volume));
      
        __out.push('\n  </div></td>\n</tr>\n');
      
      }).call(this);
      
    }).call(__obj);
    __obj.safe = __objSafe, __obj.escape = __escape;
    return __out.join('');
  };
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["templates/order_active"] = function(__obj) {
    if (!__obj) __obj = {};
    var __out = [], __capture = function(callback) {
      var out = __out, result;
      __out = [];
      callback.call(this);
      result = __out.join('');
      __out = out;
      return __safe(result);
    }, __sanitize = function(value) {
      if (value && value.ecoSafe) {
        return value;
      } else if (typeof value !== 'undefined' && value != null) {
        return __escape(value);
      } else {
        return '';
      }
    }, __safe, __objSafe = __obj.safe, __escape = __obj.escape;
    __safe = __obj.safe = function(value) {
      if (value && value.ecoSafe) {
        return value;
      } else {
        if (!(typeof value !== 'undefined' && value != null)) value = '';
        var result = new String(value);
        result.ecoSafe = true;
        return result;
      }
    };
    if (!__escape) {
      __escape = __obj.escape = function(value) {
        return ('' + value)
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;');
      };
    }
    (function() {
      (function() {
        var trade_state;
      
        trade_state = this.origin_volume === this.volume ? 'new' : 'partial';
      
        __out.push('\n\n<tr data-id="');
      
        __out.push(__sanitize(this.id));
      
        __out.push('" data-kind="');
      
        __out.push(__sanitize(this.kind));
      
        __out.push('" class="order ');
      
        __out.push(__sanitize(this.kind));
      
        __out.push('">\n  <td class=\'time text-left col-xs-6\'>\n    <span>');
      
        __out.push(formatter.fulltime(this.at));
      
        __out.push('</span>\n  </td>\n  <td class=\'kind text-left col-xs-6\' style=\'padding: 0 50px 0 0\'>\n    <span class=\'label label-');
      
        __out.push(__sanitize(this.kind));
      
        __out.push('\'>');
      
        __out.push(__sanitize(formatter.short_trade(this.kind)));
      
        __out.push('</span><span class=\'label label-');
      
        __out.push(__sanitize(trade_state));
      
        __out.push('\'>');
      
        __out.push(__sanitize(gon.i18n.trade_state[trade_state]));
      
        __out.push('</span>\n  </td>\n  <td class=\'price text-right col-xs-4 ');
      
        __out.push(__sanitize(formatter.trend(this.kind)));
      
        __out.push('\' style=\'padding: 0 30px 0 0\' >\n    <span>');
      
        __out.push(formatter.mask_fixed_price(this.price));
      
        __out.push('</span>\n  </td>\n  <td class=\'volume text-right col-xs-4\' style=\'padding: 0 70px 0 0\' >\n    <span>');
      
        __out.push(formatter.mask_fixed_volume(this.volume));
      
        __out.push('</span>\n  </td>\n  <td class=\'amount text-right col-xs-5\' style=\'padding: 0 70px 0 0\' >\n    <span>');
      
        __out.push(formatter.amount(this.volume, this.price));
      
        __out.push('</span>\n  </td>\n</tr>\n');
      
      }).call(this);
      
    }).call(__obj);
    __obj.safe = __objSafe, __obj.escape = __escape;
    return __out.join('');
  };
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["templates/order_book_ask"] = function(__obj) {
    if (!__obj) __obj = {};
    var __out = [], __capture = function(callback) {
      var out = __out, result;
      __out = [];
      callback.call(this);
      result = __out.join('');
      __out = out;
      return __safe(result);
    }, __sanitize = function(value) {
      if (value && value.ecoSafe) {
        return value;
      } else if (typeof value !== 'undefined' && value != null) {
        return __escape(value);
      } else {
        return '';
      }
    }, __safe, __objSafe = __obj.safe, __escape = __obj.escape;
    __safe = __obj.safe = function(value) {
      if (value && value.ecoSafe) {
        return value;
      } else {
        if (!(typeof value !== 'undefined' && value != null)) value = '';
        var result = new String(value);
        result.ecoSafe = true;
        return result;
      }
    };
    if (!__escape) {
      __escape = __obj.escape = function(value) {
        return ('' + value)
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;');
      };
    }
    (function() {
      (function() {
        __out.push('<tr data-order=\'');
      
        __out.push(__sanitize(this.index));
      
        __out.push('\' data-price=\'');
      
        __out.push(__sanitize(this.price));
      
        __out.push('\' data-volume=\'');
      
        __out.push(__sanitize(this.volume));
      
        __out.push('\' class=\'');
      
        __out.push(__sanitize(this.classes));
      
        __out.push('\'>\n  <td class=\'price col-xs-7 text-down\'><div>\n    ');
      
        __out.push(formatter.ticker_price(this.price));
      
        __out.push('\n  </div></td>\n  <td class=\'volume col-xs-8\'><div>\n    ');
      
        __out.push(formatter.mask_fixed_volume(this.volume));
      
        __out.push('\n  </div></td>\n  <td class=\'amount col-xs-10\'><div>\n    ');
      
        __out.push(formatter.amount(this.volume, this.price));
      
        __out.push('\n  </div></td>\n</tr>\n');
      
      }).call(this);
      
    }).call(__obj);
    __obj.safe = __objSafe, __obj.escape = __escape;
    return __out.join('');
  };
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["templates/order_book_bid"] = function(__obj) {
    if (!__obj) __obj = {};
    var __out = [], __capture = function(callback) {
      var out = __out, result;
      __out = [];
      callback.call(this);
      result = __out.join('');
      __out = out;
      return __safe(result);
    }, __sanitize = function(value) {
      if (value && value.ecoSafe) {
        return value;
      } else if (typeof value !== 'undefined' && value != null) {
        return __escape(value);
      } else {
        return '';
      }
    }, __safe, __objSafe = __obj.safe, __escape = __obj.escape;
    __safe = __obj.safe = function(value) {
      if (value && value.ecoSafe) {
        return value;
      } else {
        if (!(typeof value !== 'undefined' && value != null)) value = '';
        var result = new String(value);
        result.ecoSafe = true;
        return result;
      }
    };
    if (!__escape) {
      __escape = __obj.escape = function(value) {
        return ('' + value)
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;');
      };
    }
    (function() {
      (function() {
        __out.push('<tr data-order=\'');
      
        __out.push(__sanitize(this.index));
      
        __out.push('\' data-price=\'');
      
        __out.push(__sanitize(this.price));
      
        __out.push('\' data-volume=\'');
      
        __out.push(__sanitize(this.volume));
      
        __out.push('\' class=\'');
      
        __out.push(__sanitize(this.classes));
      
        __out.push('\'>\n  <td class=\'amount col-xs-10\' style=\'padding: 0 30px 0 0\' ><div>\n    ');
      
        __out.push(formatter.amount(this.volume, this.price));
      
        __out.push('\n  </div></td>\n  <td class=\'volume col-xs-8\' style=\'padding: 0 30px 0 0\' ><div>\n    ');
      
        __out.push(formatter.mask_fixed_volume(this.volume));
      
        __out.push('\n  </div></td>\n  <td class=\'price col-xs-7 text-up\'><div>\n    ');
      
        __out.push(formatter.ticker_price(this.price));
      
        __out.push('\n  </div></td>\n</tr>\n');
      
      }).call(this);
      
    }).call(__obj);
    __obj.safe = __objSafe, __obj.escape = __escape;
    return __out.join('');
  };
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["templates/order_done"] = function(__obj) {
    if (!__obj) __obj = {};
    var __out = [], __capture = function(callback) {
      var out = __out, result;
      __out = [];
      callback.call(this);
      result = __out.join('');
      __out = out;
      return __safe(result);
    }, __sanitize = function(value) {
      if (value && value.ecoSafe) {
        return value;
      } else if (typeof value !== 'undefined' && value != null) {
        return __escape(value);
      } else {
        return '';
      }
    }, __safe, __objSafe = __obj.safe, __escape = __obj.escape;
    __safe = __obj.safe = function(value) {
      if (value && value.ecoSafe) {
        return value;
      } else {
        if (!(typeof value !== 'undefined' && value != null)) value = '';
        var result = new String(value);
        result.ecoSafe = true;
        return result;
      }
    };
    if (!__escape) {
      __escape = __obj.escape = function(value) {
        return ('' + value)
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;');
      };
    }
    (function() {
      (function() {
        __out.push('<tr data-id=\'');
      
        __out.push(__sanitize(this.id));
      
        __out.push('\' data-kind=\'');
      
        __out.push(__sanitize(this.kind));
      
        __out.push('\' class=\'order ');
      
        __out.push(__sanitize(this.kind));
      
        __out.push('\'>\n  <td class=\'time text-left col-xs-6\'>\n    ');
      
        __out.push(formatter.fulltime(this.at));
      
        __out.push('\n  </td>\n  <td class=\'kind text-left col-xs-6 ');
      
        __out.push(formatter.trend(this.kind));
      
        __out.push('\' style=\'padding: 0 50px 0 0\'>\n    ');
      
        __out.push(formatter.short_trade(this.kind));
      
        __out.push('\n  </td>\n  <td class=\'price text-right col-xs-4\' style=\'padding: 0 30px 0 0\'>\n    ');
      
        __out.push(__sanitize(formatter.fix_bid(this.price)));
      
        __out.push('\n  </td>\n  <td class=\'volume text-right col-xs-4\' style=\'padding: 0 70px 0 0\'>\n    ');
      
        __out.push(__sanitize(formatter.fix_ask(this.volume)));
      
        __out.push('\n  </td>\n  <td class=\'amount text-right col-xs-5\' style=\'padding: 0 70px 0 0\'>\n    ');
      
        __out.push(formatter.amount(this.volume, this.price));
      
        __out.push('\n  </td>\n  <td class=\'col-xs-3\'></td>\n</tr>\n');
      
      }).call(this);
      
    }).call(__obj);
    __obj.safe = __objSafe, __obj.escape = __escape;
    return __out.join('');
  };
}).call(this);
(function() { this.JST || (this.JST = {}); this.JST["templates/tooltip"] = function(__obj) {
    if (!__obj) __obj = {};
    var __out = [], __capture = function(callback) {
      var out = __out, result;
      __out = [];
      callback.call(this);
      result = __out.join('');
      __out = out;
      return __safe(result);
    }, __sanitize = function(value) {
      if (value && value.ecoSafe) {
        return value;
      } else if (typeof value !== 'undefined' && value != null) {
        return __escape(value);
      } else {
        return '';
      }
    }, __safe, __objSafe = __obj.safe, __escape = __obj.escape;
    __safe = __obj.safe = function(value) {
      if (value && value.ecoSafe) {
        return value;
      } else {
        if (!(typeof value !== 'undefined' && value != null)) value = '';
        var result = new String(value);
        result.ecoSafe = true;
        return result;
      }
    };
    if (!__escape) {
      __escape = __obj.escape = function(value) {
        return ('' + value)
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;');
      };
    }
    (function() {
      (function() {
        __out.push('<div class=\'chart-ticker\'>\n  <span class=\'tooltip-title\'>');
      
        __out.push(__sanitize(this.title));
      
        __out.push('</span>\n\n  <br />\n\n  <div class=\'tooltip-ticker\'>\n    <span class=t-title>');
      
        __out.push(__sanitize(gon.i18n.chart.open));
      
        __out.push('</span>\n    <span class=t-value>');
      
        __out.push(__sanitize(this.format(this.points.candlestick.open, gon.market.bid.fixed)));
      
        __out.push('</span>\n  </div>\n  <div class=\'tooltip-ticker\'>\n    <span class=t-title>');
      
        __out.push(__sanitize(gon.i18n.chart.close));
      
        __out.push('</span>\n    <span class=t-value>');
      
        __out.push(__sanitize(this.format(this.points.candlestick.close, gon.market.bid.fixed)));
      
        __out.push('</span>\n  </div>\n  <div class=\'tooltip-ticker\'>\n    <span class=t-title>');
      
        __out.push(__sanitize(gon.i18n.chart.high));
      
        __out.push('</span>\n    <span class=t-value>');
      
        __out.push(__sanitize(this.format(this.points.candlestick.high, gon.market.bid.fixed)));
      
        __out.push('</span>\n  </div>\n  <div class=\'tooltip-ticker\'>\n    <span class=t-title>');
      
        __out.push(__sanitize(gon.i18n.chart.low));
      
        __out.push('</span>\n    <span class=t-value>');
      
        __out.push(__sanitize(this.format(this.points.candlestick.low, gon.market.bid.fixed)));
      
        __out.push('</span>\n  </div>\n  <div class=\'tooltip-ticker\'>\n    <span class=t-title>');
      
        __out.push(__sanitize(gon.i18n.chart.volume));
      
        __out.push('</span>\n    <span class=t-value>');
      
        __out.push(__sanitize(this.format4(this.points.volume.y, 4)));
      
        __out.push('</span>\n  </div>\n\n  <ul class=\'list-inline\'>\n    ');
      
        if (this.indicator['MA']) {
          __out.push('\n      <li>\n        <span style=\'color: ');
          __out.push(__sanitize(this.points.ma5.series.color));
          __out.push(';\'>');
          __out.push(__sanitize(this.points.ma5.series.name));
          __out.push(': <b>');
          __out.push(__sanitize(this.format(this.points.ma5.y, gon.market.bid.fixed)));
          __out.push('</b></span>\n      </li>\n      <li>\n        <span style=\'color: ');
          __out.push(__sanitize(this.points.ma10.series.color));
          __out.push(';\'>');
          __out.push(__sanitize(this.points.ma10.series.name));
          __out.push(': <b>');
          __out.push(__sanitize(this.format(this.points.ma10.y, gon.market.bid.fixed)));
          __out.push('</b></span>\n      </li>\n    ');
        }
      
        __out.push('\n    ');
      
        if (this.indicator['EMA']) {
          __out.push('\n      <li>\n        <span style=\'color: ');
          __out.push(__sanitize(this.points.ema7.series.color));
          __out.push(';\'>');
          __out.push(__sanitize(this.points.ema7.series.name));
          __out.push(': <b>');
          __out.push(__sanitize(this.format(this.points.ema7.y, gon.market.bid.fixed)));
          __out.push('</b></span>\n      </li>\n      <li>\n        <span style=\'color: ');
          __out.push(__sanitize(this.points.ema30.series.color));
          __out.push(';\'>');
          __out.push(__sanitize(this.points.ema30.series.name));
          __out.push(': <b>');
          __out.push(__sanitize(this.format(this.points.ema30.y, gon.market.bid.fixed)));
          __out.push('</b></span>\n      </li>\n    ');
        }
      
        __out.push('\n  </ul>\n  <ul class=\'list-inline\'>\n    ');
      
        if (this.macd_indicator['MACD']) {
          __out.push('\n      <li>\n        <span style=\'color: ');
          __out.push(__sanitize(this.points.macd.series.color));
          __out.push(';\'>');
          __out.push(__sanitize(this.points.macd.series.name));
          __out.push(': <b>');
          __out.push(__sanitize(this.format(this.points.macd.y)));
          __out.push('</b></span>\n      </li>\n      <li>\n        <span style=\'color: ');
          __out.push(__sanitize(this.points.sig.series.color));
          __out.push(';\'>');
          __out.push(__sanitize(this.points.sig.series.name));
          __out.push(': <b>');
          __out.push(__sanitize(this.format(this.points.sig.y)));
          __out.push('</b></span>\n      </li>\n      <li>\n        <span style=\'color: ');
          __out.push(__sanitize(this.points.hist.series.color));
          __out.push(';\'>');
          __out.push(__sanitize(this.points.hist.series.name));
          __out.push(': <b>');
          __out.push(__sanitize(this.format(this.points.hist.y)));
          __out.push('</b></span>\n      </li>\n    ');
        }
      
        __out.push('\n  </ul>\n\n</div>\n');
      
      }).call(this);
      
    }).call(__obj);
    __obj.safe = __objSafe, __obj.escape = __escape;
    return __out.join('');
  };
}).call(this);
(function() {
  $(function() {
    BigNumber.config({
      ERRORS: false
    });
    if ($('#assets-index').length) {
      $.scrollIt({
        topOffset: -180,
        activeClass: 'active'
      });
      $('a.go-verify').on('click', function(e) {
        var partial_tree, root, uri;
        e.preventDefault();
        root = $('.tab-pane.active .root.json pre').text();
        partial_tree = $('.tab-pane.active .partial-tree.json pre').text();
        if (partial_tree) {
          uri = 'http://syskall.com/proof-of-liabilities/#verify?partial_tree=' + partial_tree + '&expected_root=' + root;
          return window.open(encodeURI(uri), '_blank');
        }
      });
    }
    $('[data-clipboard-text], [data-clipboard-target]').each(function() {
      var placement, zero;
      zero = new ZeroClipboard($(this), {
        forceHandCursor: true
      });
      zero.on('complete', function() {
        return $(zero.htmlBridge).attr('title', gon.clipboard.done).tooltip('fixTitle').tooltip('show');
      });
      zero.on('mouseout', function() {
        return $(zero.htmlBridge).attr('title', gon.clipboard.click).tooltip('fixTitle');
      });
      placement = $(this).data('placement') || 'bottom';
      return $(zero.htmlBridge).tooltip({
        title: gon.clipboard.click,
        placement: placement
      });
    });
    $('.qrcode-container').each(function(index, el) {
      var $el;
      $el = $(el);
      return new QRCode(el, {
        text: $el.data('text'),
        width: $el.data('width'),
        height: $el.data('height')
      });
    });
    FlashMessageUI.attachTo('.flash-message');
    SmsAuthVerifyUI.attachTo('#edit_sms_auth');
    return TwoFactorAuth.attachTo('.two-factor-auth-container');
  });

}).call(this);
